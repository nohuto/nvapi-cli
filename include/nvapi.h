#ifndef _NVAPI_H
#define _NVAPI_H
#pragma pack(push, 8)
#ifdef __cplusplus
extern "C" {
#endif
#ifndef _WIN32
#define __cdecl
#endif
#ifndef __ecount
#define __nvapi_undef__ecount
#define __ecount(size)
#endif
#ifndef __bcount
#define __nvapi_undef__bcount
#define __bcount(size)
#endif
#ifndef __in
#define __nvapi_undef__in
#define __in
#endif
#ifndef __in_ecount
#define __nvapi_undef__in_ecount
#define __in_ecount(size)
#endif
#ifndef __in_bcount
#define __nvapi_undef__in_bcount
#define __in_bcount(size)
#endif
#ifndef __in_z
#define __nvapi_undef__in_z
#define __in_z
#endif
#ifndef __in_ecount_z
#define __nvapi_undef__in_ecount_z
#define __in_ecount_z(size)
#endif
#ifndef __in_bcount_z
#define __nvapi_undef__in_bcount_z
#define __in_bcount_z(size)
#endif
#ifndef __in_nz
#define __nvapi_undef__in_nz
#define __in_nz
#endif
#ifndef __in_ecount_nz
#define __nvapi_undef__in_ecount_nz
#define __in_ecount_nz(size)
#endif
#ifndef __in_bcount_nz
#define __nvapi_undef__in_bcount_nz
#define __in_bcount_nz(size)
#endif
#ifndef __out
#define __nvapi_undef__out
#define __out
#endif
#ifndef __out_ecount
#define __nvapi_undef__out_ecount
#define __out_ecount(size)
#endif
#ifndef __out_bcount
#define __nvapi_undef__out_bcount
#define __out_bcount(size)
#endif
#ifndef __out_ecount_part
#define __nvapi_undef__out_ecount_part
#define __out_ecount_part(size, length)
#endif
#ifndef __out_bcount_part
#define __nvapi_undef__out_bcount_part
#define __out_bcount_part(size, length)
#endif
#ifndef __out_ecount_full
#define __nvapi_undef__out_ecount_full
#define __out_ecount_full(size)
#endif
#ifndef __out_bcount_full
#define __nvapi_undef__out_bcount_full
#define __out_bcount_full(size)
#endif
#ifndef __out_z
#define __nvapi_undef__out_z
#define __out_z
#endif
#ifndef __out_z_opt
#define __nvapi_undef__out_z_opt
#define __out_z_opt
#endif
#ifndef __out_ecount_z
#define __nvapi_undef__out_ecount_z
#define __out_ecount_z(size)
#endif
#ifndef __out_bcount_z
#define __nvapi_undef__out_bcount_z
#define __out_bcount_z(size)
#endif
#ifndef __out_ecount_part_z
#define __nvapi_undef__out_ecount_part_z
#define __out_ecount_part_z(size, length)
#endif
#ifndef __out_bcount_part_z
#define __nvapi_undef__out_bcount_part_z
#define __out_bcount_part_z(size, length)
#endif
#ifndef __out_ecount_full_z
#define __nvapi_undef__out_ecount_full_z
#define __out_ecount_full_z(size)
#endif
#ifndef __out_bcount_full_z
#define __nvapi_undef__out_bcount_full_z
#define __out_bcount_full_z(size)
#endif
#ifndef __out_nz
#define __nvapi_undef__out_nz
#define __out_nz
#endif
#ifndef __out_nz_opt
#define __nvapi_undef__out_nz_opt
#define __out_nz_opt
#endif
#ifndef __out_ecount_nz
#define __nvapi_undef__out_ecount_nz
#define __out_ecount_nz(size)
#endif
#ifndef __out_bcount_nz
#define __nvapi_undef__out_bcount_nz
#define __out_bcount_nz(size)
#endif
#ifndef __inout
#define __nvapi_undef__inout
#define __inout
#endif
#ifndef __inout_ecount
#define __nvapi_undef__inout_ecount
#define __inout_ecount(size)
#endif
#ifndef __inout_bcount
#define __nvapi_undef__inout_bcount
#define __inout_bcount(size)
#endif
#ifndef __inout_ecount_part
#define __nvapi_undef__inout_ecount_part
#define __inout_ecount_part(size, length)
#endif
#ifndef __inout_bcount_part
#define __nvapi_undef__inout_bcount_part
#define __inout_bcount_part(size, length)
#endif
#ifndef __inout_ecount_full
#define __nvapi_undef__inout_ecount_full
#define __inout_ecount_full(size)
#endif
#ifndef __inout_bcount_full
#define __nvapi_undef__inout_bcount_full
#define __inout_bcount_full(size)
#endif
#ifndef __inout_z
#define __nvapi_undef__inout_z
#define __inout_z
#endif
#ifndef __inout_ecount_z
#define __nvapi_undef__inout_ecount_z
#define __inout_ecount_z(size)
#endif
#ifndef __inout_bcount_z
#define __nvapi_undef__inout_bcount_z
#define __inout_bcount_z(size)
#endif
#ifndef __inout_nz
#define __nvapi_undef__inout_nz
#define __inout_nz
#endif
#ifndef __inout_ecount_nz
#define __nvapi_undef__inout_ecount_nz
#define __inout_ecount_nz(size)
#endif
#ifndef __inout_bcount_nz
#define __nvapi_undef__inout_bcount_nz
#define __inout_bcount_nz(size)
#endif
#ifndef __ecount_opt
#define __nvapi_undef__ecount_opt
#define __ecount_opt(size)
#endif
#ifndef __bcount_opt
#define __nvapi_undef__bcount_opt
#define __bcount_opt(size)
#endif
#ifndef __in_opt
#define __nvapi_undef__in_opt
#define __in_opt
#endif
#ifndef __in_ecount_opt
#define __nvapi_undef__in_ecount_opt
#define __in_ecount_opt(size)
#endif
#ifndef __in_bcount_opt
#define __nvapi_undef__in_bcount_opt
#define __in_bcount_opt(size)
#endif
#ifndef __in_z_opt
#define __nvapi_undef__in_z_opt
#define __in_z_opt
#endif
#ifndef __in_ecount_z_opt
#define __nvapi_undef__in_ecount_z_opt
#define __in_ecount_z_opt(size)
#endif
#ifndef __in_bcount_z_opt
#define __nvapi_undef__in_bcount_z_opt
#define __in_bcount_z_opt(size)
#endif
#ifndef __in_nz_opt
#define __nvapi_undef__in_nz_opt
#define __in_nz_opt
#endif
#ifndef __in_ecount_nz_opt
#define __nvapi_undef__in_ecount_nz_opt
#define __in_ecount_nz_opt(size)
#endif
#ifndef __in_bcount_nz_opt
#define __nvapi_undef__in_bcount_nz_opt
#define __in_bcount_nz_opt(size)
#endif
#ifndef __out_opt
#define __nvapi_undef__out_opt
#define __out_opt
#endif
#ifndef __out_ecount_opt
#define __nvapi_undef__out_ecount_opt
#define __out_ecount_opt(size)
#endif
#ifndef __out_bcount_opt
#define __nvapi_undef__out_bcount_opt
#define __out_bcount_opt(size)
#endif
#ifndef __out_ecount_part_opt
#define __nvapi_undef__out_ecount_part_opt
#define __out_ecount_part_opt(size, length)
#endif
#ifndef __out_bcount_part_opt
#define __nvapi_undef__out_bcount_part_opt
#define __out_bcount_part_opt(size, length)
#endif
#ifndef __out_ecount_full_opt
#define __nvapi_undef__out_ecount_full_opt
#define __out_ecount_full_opt(size)
#endif
#ifndef __out_bcount_full_opt
#define __nvapi_undef__out_bcount_full_opt
#define __out_bcount_full_opt(size)
#endif
#ifndef __out_ecount_z_opt
#define __nvapi_undef__out_ecount_z_opt
#define __out_ecount_z_opt(size)
#endif
#ifndef __out_bcount_z_opt
#define __nvapi_undef__out_bcount_z_opt
#define __out_bcount_z_opt(size)
#endif
#ifndef __out_ecount_part_z_opt
#define __nvapi_undef__out_ecount_part_z_opt
#define __out_ecount_part_z_opt(size, length)
#endif
#ifndef __out_bcount_part_z_opt
#define __nvapi_undef__out_bcount_part_z_opt
#define __out_bcount_part_z_opt(size, length)
#endif
#ifndef __out_ecount_full_z_opt
#define __nvapi_undef__out_ecount_full_z_opt
#define __out_ecount_full_z_opt(size)
#endif
#ifndef __out_bcount_full_z_opt
#define __nvapi_undef__out_bcount_full_z_opt
#define __out_bcount_full_z_opt(size)
#endif
#ifndef __out_ecount_nz_opt
#define __nvapi_undef__out_ecount_nz_opt
#define __out_ecount_nz_opt(size)
#endif
#ifndef __out_bcount_nz_opt
#define __nvapi_undef__out_bcount_nz_opt
#define __out_bcount_nz_opt(size)
#endif
#ifndef __inout_opt
#define __nvapi_undef__inout_opt
#define __inout_opt
#endif
#ifndef __inout_ecount_opt
#define __nvapi_undef__inout_ecount_opt
#define __inout_ecount_opt(size)
#endif
#ifndef __inout_bcount_opt
#define __nvapi_undef__inout_bcount_opt
#define __inout_bcount_opt(size)
#endif
#ifndef __inout_ecount_part_opt
#define __nvapi_undef__inout_ecount_part_opt
#define __inout_ecount_part_opt(size, length)
#endif
#ifndef __inout_bcount_part_opt
#define __nvapi_undef__inout_bcount_part_opt
#define __inout_bcount_part_opt(size, length)
#endif
#ifndef __inout_ecount_full_opt
#define __nvapi_undef__inout_ecount_full_opt
#define __inout_ecount_full_opt(size)
#endif
#ifndef __inout_bcount_full_opt
#define __nvapi_undef__inout_bcount_full_opt
#define __inout_bcount_full_opt(size)
#endif
#ifndef __inout_z_opt
#define __nvapi_undef__inout_z_opt
#define __inout_z_opt
#endif
#ifndef __inout_ecount_z_opt
#define __nvapi_undef__inout_ecount_z_opt
#define __inout_ecount_z_opt(size)
#endif
#ifndef __inout_ecount_z_opt
#define __nvapi_undef__inout_ecount_z_opt
#define __inout_ecount_z_opt(size)
#endif
#ifndef __inout_bcount_z_opt
#define __nvapi_undef__inout_bcount_z_opt
#define __inout_bcount_z_opt(size)
#endif
#ifndef __inout_nz_opt
#define __nvapi_undef__inout_nz_opt
#define __inout_nz_opt
#endif
#ifndef __inout_ecount_nz_opt
#define __nvapi_undef__inout_ecount_nz_opt
#define __inout_ecount_nz_opt(size)
#endif
#ifndef __inout_bcount_nz_opt
#define __nvapi_undef__inout_bcount_nz_opt
#define __inout_bcount_nz_opt(size)
#endif
#ifndef __deref_ecount
#define __nvapi_undef__deref_ecount
#define __deref_ecount(size)
#endif
#ifndef __deref_bcount
#define __nvapi_undef__deref_bcount
#define __deref_bcount(size)
#endif
#ifndef __deref_out
#define __nvapi_undef__deref_out
#define __deref_out
#endif
#ifndef __deref_out_ecount
#define __nvapi_undef__deref_out_ecount
#define __deref_out_ecount(size)
#endif
#ifndef __deref_out_bcount
#define __nvapi_undef__deref_out_bcount
#define __deref_out_bcount(size)
#endif
#ifndef __deref_out_ecount_part
#define __nvapi_undef__deref_out_ecount_part
#define __deref_out_ecount_part(size, length)
#endif
#ifndef __deref_out_bcount_part
#define __nvapi_undef__deref_out_bcount_part
#define __deref_out_bcount_part(size, length)
#endif
#ifndef __deref_out_ecount_full
#define __nvapi_undef__deref_out_ecount_full
#define __deref_out_ecount_full(size)
#endif
#ifndef __deref_out_bcount_full
#define __nvapi_undef__deref_out_bcount_full
#define __deref_out_bcount_full(size)
#endif
#ifndef __deref_out_z
#define __nvapi_undef__deref_out_z
#define __deref_out_z
#endif
#ifndef __deref_out_ecount_z
#define __nvapi_undef__deref_out_ecount_z
#define __deref_out_ecount_z(size)
#endif
#ifndef __deref_out_bcount_z
#define __nvapi_undef__deref_out_bcount_z
#define __deref_out_bcount_z(size)
#endif
#ifndef __deref_out_nz
#define __nvapi_undef__deref_out_nz
#define __deref_out_nz
#endif
#ifndef __deref_out_ecount_nz
#define __nvapi_undef__deref_out_ecount_nz
#define __deref_out_ecount_nz(size)
#endif
#ifndef __deref_out_bcount_nz
#define __nvapi_undef__deref_out_bcount_nz
#define __deref_out_bcount_nz(size)
#endif
#ifndef __deref_inout
#define __nvapi_undef__deref_inout
#define __deref_inout
#endif
#ifndef __deref_inout_z
#define __nvapi_undef__deref_inout_z
#define __deref_inout_z
#endif
#ifndef __deref_inout_ecount
#define __nvapi_undef__deref_inout_ecount
#define __deref_inout_ecount(size)
#endif
#ifndef __deref_inout_bcount
#define __nvapi_undef__deref_inout_bcount
#define __deref_inout_bcount(size)
#endif
#ifndef __deref_inout_ecount_part
#define __nvapi_undef__deref_inout_ecount_part
#define __deref_inout_ecount_part(size, length)
#endif
#ifndef __deref_inout_bcount_part
#define __nvapi_undef__deref_inout_bcount_part
#define __deref_inout_bcount_part(size, length)
#endif
#ifndef __deref_inout_ecount_full
#define __nvapi_undef__deref_inout_ecount_full
#define __deref_inout_ecount_full(size)
#endif
#ifndef __deref_inout_bcount_full
#define __nvapi_undef__deref_inout_bcount_full
#define __deref_inout_bcount_full(size)
#endif
#ifndef __deref_inout_z
#define __nvapi_undef__deref_inout_z
#define __deref_inout_z
#endif
#ifndef __deref_inout_ecount_z
#define __nvapi_undef__deref_inout_ecount_z
#define __deref_inout_ecount_z(size)
#endif
#ifndef __deref_inout_bcount_z
#define __nvapi_undef__deref_inout_bcount_z
#define __deref_inout_bcount_z(size)
#endif
#ifndef __deref_inout_nz
#define __nvapi_undef__deref_inout_nz
#define __deref_inout_nz
#endif
#ifndef __deref_inout_ecount_nz
#define __nvapi_undef__deref_inout_ecount_nz
#define __deref_inout_ecount_nz(size)
#endif
#ifndef __deref_inout_bcount_nz
#define __nvapi_undef__deref_inout_bcount_nz
#define __deref_inout_bcount_nz(size)
#endif
#ifndef __deref_ecount_opt
#define __nvapi_undef__deref_ecount_opt
#define __deref_ecount_opt(size)
#endif
#ifndef __deref_bcount_opt
#define __nvapi_undef__deref_bcount_opt
#define __deref_bcount_opt(size)
#endif
#ifndef __deref_out_opt
#define __nvapi_undef__deref_out_opt
#define __deref_out_opt
#endif
#ifndef __deref_out_ecount_opt
#define __nvapi_undef__deref_out_ecount_opt
#define __deref_out_ecount_opt(size)
#endif
#ifndef __deref_out_bcount_opt
#define __nvapi_undef__deref_out_bcount_opt
#define __deref_out_bcount_opt(size)
#endif
#ifndef __deref_out_ecount_part_opt
#define __nvapi_undef__deref_out_ecount_part_opt
#define __deref_out_ecount_part_opt(size, length)
#endif
#ifndef __deref_out_bcount_part_opt
#define __nvapi_undef__deref_out_bcount_part_opt
#define __deref_out_bcount_part_opt(size, length)
#endif
#ifndef __deref_out_ecount_full_opt
#define __nvapi_undef__deref_out_ecount_full_opt
#define __deref_out_ecount_full_opt(size)
#endif
#ifndef __deref_out_bcount_full_opt
#define __nvapi_undef__deref_out_bcount_full_opt
#define __deref_out_bcount_full_opt(size)
#endif
#ifndef __deref_out_z_opt
#define __nvapi_undef__deref_out_z_opt
#define __deref_out_z_opt
#endif
#ifndef __deref_out_ecount_z_opt
#define __nvapi_undef__deref_out_ecount_z_opt
#define __deref_out_ecount_z_opt(size)
#endif
#ifndef __deref_out_bcount_z_opt
#define __nvapi_undef__deref_out_bcount_z_opt
#define __deref_out_bcount_z_opt(size)
#endif
#ifndef __deref_out_nz_opt
#define __nvapi_undef__deref_out_nz_opt
#define __deref_out_nz_opt
#endif
#ifndef __deref_out_ecount_nz_opt
#define __nvapi_undef__deref_out_ecount_nz_opt
#define __deref_out_ecount_nz_opt(size)
#endif
#ifndef __deref_out_bcount_nz_opt
#define __nvapi_undef__deref_out_bcount_nz_opt
#define __deref_out_bcount_nz_opt(size)
#endif
#ifndef __deref_inout_opt
#define __nvapi_undef__deref_inout_opt
#define __deref_inout_opt
#endif
#ifndef __deref_inout_ecount_opt
#define __nvapi_undef__deref_inout_ecount_opt
#define __deref_inout_ecount_opt(size)
#endif
#ifndef __deref_inout_bcount_opt
#define __nvapi_undef__deref_inout_bcount_opt
#define __deref_inout_bcount_opt(size)
#endif
#ifndef __deref_inout_ecount_part_opt
#define __nvapi_undef__deref_inout_ecount_part_opt
#define __deref_inout_ecount_part_opt(size, length)
#endif
#ifndef __deref_inout_bcount_part_opt
#define __nvapi_undef__deref_inout_bcount_part_opt
#define __deref_inout_bcount_part_opt(size, length)
#endif
#ifndef __deref_inout_ecount_full_opt
#define __nvapi_undef__deref_inout_ecount_full_opt
#define __deref_inout_ecount_full_opt(size)
#endif
#ifndef __deref_inout_bcount_full_opt
#define __nvapi_undef__deref_inout_bcount_full_opt
#define __deref_inout_bcount_full_opt(size)
#endif
#ifndef __deref_inout_z_opt
#define __nvapi_undef__deref_inout_z_opt
#define __deref_inout_z_opt
#endif
#ifndef __deref_inout_ecount_z_opt
#define __nvapi_undef__deref_inout_ecount_z_opt
#define __deref_inout_ecount_z_opt(size)
#endif
#ifndef __deref_inout_bcount_z_opt
#define __nvapi_undef__deref_inout_bcount_z_opt
#define __deref_inout_bcount_z_opt(size)
#endif
#ifndef __deref_inout_nz_opt
#define __nvapi_undef__deref_inout_nz_opt
#define __deref_inout_nz_opt
#endif
#ifndef __deref_inout_ecount_nz_opt
#define __nvapi_undef__deref_inout_ecount_nz_opt
#define __deref_inout_ecount_nz_opt(size)
#endif
#ifndef __deref_inout_bcount_nz_opt
#define __nvapi_undef__deref_inout_bcount_nz_opt
#define __deref_inout_bcount_nz_opt(size)
#endif
#ifndef __deref_opt_ecount
#define __nvapi_undef__deref_opt_ecount
#define __deref_opt_ecount(size)
#endif
#ifndef __deref_opt_bcount
#define __nvapi_undef__deref_opt_bcount
#define __deref_opt_bcount(size)
#endif
#ifndef __deref_opt_out
#define __nvapi_undef__deref_opt_out
#define __deref_opt_out
#endif
#ifndef __deref_opt_out_z
#define __nvapi_undef__deref_opt_out_z
#define __deref_opt_out_z
#endif
#ifndef __deref_opt_out_ecount
#define __nvapi_undef__deref_opt_out_ecount
#define __deref_opt_out_ecount(size)
#endif
#ifndef __deref_opt_out_bcount
#define __nvapi_undef__deref_opt_out_bcount
#define __deref_opt_out_bcount(size)
#endif
#ifndef __deref_opt_out_ecount_part
#define __nvapi_undef__deref_opt_out_ecount_part
#define __deref_opt_out_ecount_part(size, length)
#endif
#ifndef __deref_opt_out_bcount_part
#define __nvapi_undef__deref_opt_out_bcount_part
#define __deref_opt_out_bcount_part(size, length)
#endif
#ifndef __deref_opt_out_ecount_full
#define __nvapi_undef__deref_opt_out_ecount_full
#define __deref_opt_out_ecount_full(size)
#endif
#ifndef __deref_opt_out_bcount_full
#define __nvapi_undef__deref_opt_out_bcount_full
#define __deref_opt_out_bcount_full(size)
#endif
#ifndef __deref_opt_inout
#define __nvapi_undef__deref_opt_inout
#define __deref_opt_inout
#endif
#ifndef __deref_opt_inout_ecount
#define __nvapi_undef__deref_opt_inout_ecount
#define __deref_opt_inout_ecount(size)
#endif
#ifndef __deref_opt_inout_bcount
#define __nvapi_undef__deref_opt_inout_bcount
#define __deref_opt_inout_bcount(size)
#endif
#ifndef __deref_opt_inout_ecount_part
#define __nvapi_undef__deref_opt_inout_ecount_part
#define __deref_opt_inout_ecount_part(size, length)
#endif
#ifndef __deref_opt_inout_bcount_part
#define __nvapi_undef__deref_opt_inout_bcount_part
#define __deref_opt_inout_bcount_part(size, length)
#endif
#ifndef __deref_opt_inout_ecount_full
#define __nvapi_undef__deref_opt_inout_ecount_full
#define __deref_opt_inout_ecount_full(size)
#endif
#ifndef __deref_opt_inout_bcount_full
#define __nvapi_undef__deref_opt_inout_bcount_full
#define __deref_opt_inout_bcount_full(size)
#endif
#ifndef __deref_opt_inout_z
#define __nvapi_undef__deref_opt_inout_z
#define __deref_opt_inout_z
#endif
#ifndef __deref_opt_inout_ecount_z
#define __nvapi_undef__deref_opt_inout_ecount_z
#define __deref_opt_inout_ecount_z(size)
#endif
#ifndef __deref_opt_inout_bcount_z
#define __nvapi_undef__deref_opt_inout_bcount_z
#define __deref_opt_inout_bcount_z(size)
#endif
#ifndef __deref_opt_inout_nz
#define __nvapi_undef__deref_opt_inout_nz
#define __deref_opt_inout_nz
#endif
#ifndef __deref_opt_inout_ecount_nz
#define __nvapi_undef__deref_opt_inout_ecount_nz
#define __deref_opt_inout_ecount_nz(size)
#endif
#ifndef __deref_opt_inout_bcount_nz
#define __nvapi_undef__deref_opt_inout_bcount_nz
#define __deref_opt_inout_bcount_nz(size)
#endif
#ifndef __deref_opt_ecount_opt
#define __nvapi_undef__deref_opt_ecount_opt
#define __deref_opt_ecount_opt(size)
#endif
#ifndef __deref_opt_bcount_opt
#define __nvapi_undef__deref_opt_bcount_opt
#define __deref_opt_bcount_opt(size)
#endif
#ifndef __deref_opt_out_opt
#define __nvapi_undef__deref_opt_out_opt
#define __deref_opt_out_opt
#endif
#ifndef __deref_opt_out_ecount_opt
#define __nvapi_undef__deref_opt_out_ecount_opt
#define __deref_opt_out_ecount_opt(size)
#endif
#ifndef __deref_opt_out_bcount_opt
#define __nvapi_undef__deref_opt_out_bcount_opt
#define __deref_opt_out_bcount_opt(size)
#endif
#ifndef __deref_opt_out_ecount_part_opt
#define __nvapi_undef__deref_opt_out_ecount_part_opt
#define __deref_opt_out_ecount_part_opt(size, length)
#endif
#ifndef __deref_opt_out_bcount_part_opt
#define __nvapi_undef__deref_opt_out_bcount_part_opt
#define __deref_opt_out_bcount_part_opt(size, length)
#endif
#ifndef __deref_opt_out_ecount_full_opt
#define __nvapi_undef__deref_opt_out_ecount_full_opt
#define __deref_opt_out_ecount_full_opt(size)
#endif
#ifndef __deref_opt_out_bcount_full_opt
#define __nvapi_undef__deref_opt_out_bcount_full_opt
#define __deref_opt_out_bcount_full_opt(size)
#endif
#ifndef __deref_opt_out_z_opt
#define __nvapi_undef__deref_opt_out_z_opt
#define __deref_opt_out_z_opt
#endif
#ifndef __deref_opt_out_ecount_z_opt
#define __nvapi_undef__deref_opt_out_ecount_z_opt
#define __deref_opt_out_ecount_z_opt(size)
#endif
#ifndef __deref_opt_out_bcount_z_opt
#define __nvapi_undef__deref_opt_out_bcount_z_opt
#define __deref_opt_out_bcount_z_opt(size)
#endif
#ifndef __deref_opt_out_nz_opt
#define __nvapi_undef__deref_opt_out_nz_opt
#define __deref_opt_out_nz_opt
#endif
#ifndef __deref_opt_out_ecount_nz_opt
#define __nvapi_undef__deref_opt_out_ecount_nz_opt
#define __deref_opt_out_ecount_nz_opt(size)
#endif
#ifndef __deref_opt_out_bcount_nz_opt
#define __nvapi_undef__deref_opt_out_bcount_nz_opt
#define __deref_opt_out_bcount_nz_opt(size)
#endif
#ifndef __deref_opt_inout_opt
#define __nvapi_undef__deref_opt_inout_opt
#define __deref_opt_inout_opt
#endif
#ifndef __deref_opt_inout_ecount_opt
#define __nvapi_undef__deref_opt_inout_ecount_opt
#define __deref_opt_inout_ecount_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_opt
#define __nvapi_undef__deref_opt_inout_bcount_opt
#define __deref_opt_inout_bcount_opt(size)
#endif
#ifndef __deref_opt_inout_ecount_part_opt
#define __nvapi_undef__deref_opt_inout_ecount_part_opt
#define __deref_opt_inout_ecount_part_opt(size, length)
#endif
#ifndef __deref_opt_inout_bcount_part_opt
#define __nvapi_undef__deref_opt_inout_bcount_part_opt
#define __deref_opt_inout_bcount_part_opt(size, length)
#endif
#ifndef __deref_opt_inout_ecount_full_opt
#define __nvapi_undef__deref_opt_inout_ecount_full_opt
#define __deref_opt_inout_ecount_full_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_full_opt
#define __nvapi_undef__deref_opt_inout_bcount_full_opt
#define __deref_opt_inout_bcount_full_opt(size)
#endif
#ifndef __deref_opt_inout_z_opt
#define __nvapi_undef__deref_opt_inout_z_opt
#define __deref_opt_inout_z_opt
#endif
#ifndef __deref_opt_inout_ecount_z_opt
#define __nvapi_undef__deref_opt_inout_ecount_z_opt
#define __deref_opt_inout_ecount_z_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_z_opt
#define __nvapi_undef__deref_opt_inout_bcount_z_opt
#define __deref_opt_inout_bcount_z_opt(size)
#endif
#ifndef __deref_opt_inout_nz_opt
#define __nvapi_undef__deref_opt_inout_nz_opt
#define __deref_opt_inout_nz_opt
#endif
#ifndef __deref_opt_inout_ecount_nz_opt
#define __nvapi_undef__deref_opt_inout_ecount_nz_opt
#define __deref_opt_inout_ecount_nz_opt(size)
#endif
#ifndef __deref_opt_inout_bcount_nz_opt
#define __nvapi_undef__deref_opt_inout_bcount_nz_opt
#define __deref_opt_inout_bcount_nz_opt(size)
#endif
#ifndef __success
#define __nvapi_success
#define __success(epxr)
#endif
#ifndef _Ret_notnull_
#define __nvapi__Ret_notnull_
#define _Ret_notnull_
#endif
#ifndef _Post_writable_byte_size_
#define __nvapi__Post_writable_byte_size_
#define _Post_writable_byte_size_(n)
#endif
#ifndef _Outptr_
#define __nvapi_Outptr_
#define _Outptr_
#endif
#define NVAPI_INTERFACE extern __success(return == NVAPI_OK) NvAPI_Status __cdecl
#if (defined(WIN32) || defined(_WIN32)) && defined(_MSC_VER) && (_MSC_VER > 1399) && !defined(NVAPI_INTERNAL) &&       \
    !defined(NVAPI_DEPRECATED_OLD)
#ifndef __nvapi_deprecated_function
#define __nvapi_deprecated_function(message) __declspec(deprecated(message))
#endif
#ifndef __nvapi_deprecated_datatype
#define __nvapi_deprecated_datatype(FirstRelease)                                                                      \
  __declspec(deprecated("Do not use this data type - it is deprecated in release " #FirstRelease "."))
#endif
#else
#ifndef __nvapi_deprecated_function
#define __nvapi_deprecated_function(message)
#endif
#ifndef __nvapi_deprecated_datatype
#define __nvapi_deprecated_datatype(FirstRelease)
#endif
#endif
#if defined(__GNUC__) || defined(__arm) || defined(__IAR_SYSTEMS_ICC__) || defined(__ghs__) || defined(_WIN64)
typedef unsigned long long NvU64;
typedef long long NvS64;
#else
typedef unsigned __int64 NvU64;
typedef __int64 NvS64;
#endif
#if (defined(macintosh) || defined(__APPLE__)) && !defined(__LP64__)
typedef signed long NvS32;
#else
typedef signed int NvS32;
#endif
#ifndef __unix
#if ((defined(macintosh) && defined(__LP64__) && (__NVAPI_RESERVED0__)) ||                                             \
     (!defined(macintosh) && defined(__NVAPI_RESERVED0__)))
typedef unsigned int NvU32;
#else
typedef unsigned long NvU32;
#endif
#else
typedef unsigned int NvU32;
#endif
typedef unsigned long temp_NvU32;
typedef signed short NvS16;
typedef unsigned short NvU16;
typedef unsigned char NvU8;
typedef signed char NvS8;
typedef float NvF32;
#define NvU32TONvF32(_pData) *(NvF32 *)(_pData)
#define NvF32TONvU32(_pData) *(NvU32 *)(_pData)
typedef NvU8 NvBool;
#define NV_TRUE ((NvBool)(0 == 0))
#define NV_FALSE ((NvBool)(0 != 0))
typedef struct _NV_RECT {
  NvU32 left;
  NvU32 top;
  NvU32 right;
  NvU32 bottom;
} NV_RECT;
#define NV_DECLARE_HANDLE(name)                                                                                        \
  struct name##__ {                                                                                                    \
    int unused;                                                                                                        \
  };                                                                                                                   \
  typedef struct name##__ *name
NV_DECLARE_HANDLE(NvLogicalGpuHandle);
NV_DECLARE_HANDLE(NvPhysicalGpuHandle);
NV_DECLARE_HANDLE(NvDisplayHandle);
NV_DECLARE_HANDLE(NvMonitorHandle);
NV_DECLARE_HANDLE(NvUnAttachedDisplayHandle);
NV_DECLARE_HANDLE(NvVisualComputingDeviceHandle);
NV_DECLARE_HANDLE(NvEventHandle);
NV_DECLARE_HANDLE(NvHICHandle);
NV_DECLARE_HANDLE(NvGSyncDeviceHandle);
NV_DECLARE_HANDLE(NvVioHandle);
NV_DECLARE_HANDLE(NvTransitionHandle);
NV_DECLARE_HANDLE(NvAudioHandle);
NV_DECLARE_HANDLE(Nv3DVPContextHandle);
NV_DECLARE_HANDLE(Nv3DVPTransceiverHandle);
NV_DECLARE_HANDLE(Nv3DVPGlassesHandle);
typedef void *StereoHandle;
NV_DECLARE_HANDLE(NvSourceHandle);
NV_DECLARE_HANDLE(NvTargetHandle);
NV_DECLARE_HANDLE(NVDX_SwapChainHandle);
static const NVDX_SwapChainHandle NVDX_SWAPCHAIN_NONE = 0;
NV_DECLARE_HANDLE(NvPresentBarrierClientHandle);
#define NVAPI_DEFAULT_HANDLE 0
#define NV_BIT(x) (1 << (x))
#define NVAPI_COPROC_DISPLAY_HANDLE ((NvDisplayHandle)(uintptr_t)0xde800001)
#define NVAPI_GENERIC_STRING_MAX 4096
#define NVAPI_LONG_STRING_MAX 256
#define NVAPI_SHORT_STRING_MAX 64
typedef struct {
  NvS32 sX;
  NvS32 sY;
  NvS32 sWidth;
  NvS32 sHeight;
} NvSBox;
#ifndef NvGUID_Defined
#define NvGUID_Defined
typedef struct {
  NvU32 data1;
  NvU16 data2;
  NvU16 data3;
  NvU8 data4[8];
} NvGUID, NvLUID;
#endif
#define NVAPI_MAX_PHYSICAL_GPUS 64
#define NVAPI_MAX_PHYSICAL_BRIDGES 100
#define NVAPI_PHYSICAL_GPUS 32
#define NVAPI_MAX_LOGICAL_GPUS 64
#define NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES 256
#define NVAPI_MAX_AVAILABLE_SLI_GROUPS 256
#define NVAPI_MAX_GPU_TOPOLOGIES NVAPI_MAX_PHYSICAL_GPUS
#define NVAPI_MAX_GPU_PER_TOPOLOGY 8
#define NVAPI_MAX_DISPLAY_HEADS 2
#define NVAPI_ADVANCED_DISPLAY_HEADS 4
#define NVAPI_MAX_DISPLAYS NVAPI_PHYSICAL_GPUS *NVAPI_ADVANCED_DISPLAY_HEADS
#define NVAPI_MAX_ACPI_IDS 16
#define NVAPI_MAX_VIEW_MODES 8
#define NVAPI_SYSTEM_MAX_HWBCS 128
#define NVAPI_SYSTEM_HWBC_INVALID_ID 0xffffffff
#define NVAPI_SYSTEM_MAX_DISPLAYS NVAPI_MAX_PHYSICAL_GPUS *NV_MAX_HEADS
#define NV_MAX_HEADS 4
#define NVAPI_MAX_HEADS_PER_GPU 32
#define NV_MAX_VID_STREAMS 4
#define NV_MAX_VID_STREAMS_EX 20
#define NV_MAX_VID_PROFILES 4
#define NVAPI_MAX_AUDIO_DEVICES 16
typedef char NvAPI_String[NVAPI_GENERIC_STRING_MAX];
typedef char NvAPI_LongString[NVAPI_LONG_STRING_MAX];
typedef char NvAPI_ShortString[NVAPI_SHORT_STRING_MAX];
typedef NvU16 NvAPI_UnicodeShortString[NVAPI_SHORT_STRING_MAX];
#define MAKE_NVAPI_VERSION(typeName, ver) (NvU32)(sizeof(typeName) | ((ver) << 16))
#define GET_NVAPI_VERSION(ver) (NvU32)((ver) >> 16)
#define GET_NVAPI_SIZE(ver) (NvU32)((ver) & 0xffff)
typedef enum _NvAPI_Status {
  NVAPI_OK = 0,
  NVAPI_ERROR = -1,
  NVAPI_LIBRARY_NOT_FOUND = -2,
  NVAPI_NO_IMPLEMENTATION = -3,
  NVAPI_API_NOT_INITIALIZED = -4,
  NVAPI_INVALID_ARGUMENT = -5,
  NVAPI_NVIDIA_DEVICE_NOT_FOUND = -6,
  NVAPI_END_ENUMERATION = -7,
  NVAPI_INVALID_HANDLE = -8,
  NVAPI_INCOMPATIBLE_STRUCT_VERSION = -9,
  NVAPI_HANDLE_INVALIDATED = -10,
  NVAPI_OPENGL_CONTEXT_NOT_CURRENT = -11,
  NVAPI_INVALID_POINTER = -14,
  NVAPI_NO_GL_EXPERT = -12,
  NVAPI_INSTRUMENTATION_DISABLED = -13,
  NVAPI_NO_GL_NSIGHT = -15,
  NVAPI_EXPECTED_LOGICAL_GPU_HANDLE = -100,
  NVAPI_EXPECTED_PHYSICAL_GPU_HANDLE = -101,
  NVAPI_EXPECTED_DISPLAY_HANDLE = -102,
  NVAPI_INVALID_COMBINATION = -103,
  NVAPI_NOT_SUPPORTED = -104,
  NVAPI_PORTID_NOT_FOUND = -105,
  NVAPI_EXPECTED_UNATTACHED_DISPLAY_HANDLE = -106,
  NVAPI_INVALID_PERF_LEVEL = -107,
  NVAPI_DEVICE_BUSY = -108,
  NVAPI_NV_PERSIST_FILE_NOT_FOUND = -109,
  NVAPI_PERSIST_DATA_NOT_FOUND = -110,
  NVAPI_EXPECTED_TV_DISPLAY = -111,
  NVAPI_EXPECTED_TV_DISPLAY_ON_DCONNECTOR = -112,
  NVAPI_NO_ACTIVE_SLI_TOPOLOGY = -113,
  NVAPI_SLI_RENDERING_MODE_NOTALLOWED = -114,
  NVAPI_EXPECTED_DIGITAL_FLAT_PANEL = -115,
  NVAPI_ARGUMENT_EXCEED_MAX_SIZE = -116,
  NVAPI_DEVICE_SWITCHING_NOT_ALLOWED = -117,
  NVAPI_TESTING_CLOCKS_NOT_SUPPORTED = -118,
  NVAPI_UNKNOWN_UNDERSCAN_CONFIG = -119,
  NVAPI_TIMEOUT_RECONFIGURING_GPU_TOPO = -120,
  NVAPI_DATA_NOT_FOUND = -121,
  NVAPI_EXPECTED_ANALOG_DISPLAY = -122,
  NVAPI_NO_VIDLINK = -123,
  NVAPI_REQUIRES_REBOOT = -124,
  NVAPI_INVALID_HYBRID_MODE = -125,
  NVAPI_MIXED_TARGET_TYPES = -126,
  NVAPI_SYSWOW64_NOT_SUPPORTED = -127,
  NVAPI_IMPLICIT_SET_GPU_TOPOLOGY_CHANGE_NOT_ALLOWED = -128,
  NVAPI_REQUEST_USER_TO_CLOSE_NON_MIGRATABLE_APPS = -129,
  NVAPI_OUT_OF_MEMORY = -130,
  NVAPI_WAS_STILL_DRAWING = -131,
  NVAPI_FILE_NOT_FOUND = -132,
  NVAPI_TOO_MANY_UNIQUE_STATE_OBJECTS = -133,
  NVAPI_INVALID_CALL = -134,
  NVAPI_D3D10_1_LIBRARY_NOT_FOUND = -135,
  NVAPI_FUNCTION_NOT_FOUND = -136,
  NVAPI_INVALID_USER_PRIVILEGE = -137,
  NVAPI_EXPECTED_NON_PRIMARY_DISPLAY_HANDLE = -138,
  NVAPI_EXPECTED_COMPUTE_GPU_HANDLE = -139,
  NVAPI_STEREO_NOT_INITIALIZED = -140,
  NVAPI_STEREO_REGISTRY_ACCESS_FAILED = -141,
  NVAPI_STEREO_REGISTRY_PROFILE_TYPE_NOT_SUPPORTED = -142,
  NVAPI_STEREO_REGISTRY_VALUE_NOT_SUPPORTED = -143,
  NVAPI_STEREO_NOT_ENABLED = -144,
  NVAPI_STEREO_NOT_TURNED_ON = -145,
  NVAPI_STEREO_INVALID_DEVICE_INTERFACE = -146,
  NVAPI_STEREO_PARAMETER_OUT_OF_RANGE = -147,
  NVAPI_STEREO_FRUSTUM_ADJUST_MODE_NOT_SUPPORTED = -148,
  NVAPI_TOPO_NOT_POSSIBLE = -149,
  NVAPI_MODE_CHANGE_FAILED = -150,
  NVAPI_D3D11_LIBRARY_NOT_FOUND = -151,
  NVAPI_INVALID_ADDRESS = -152,
  NVAPI_STRING_TOO_SMALL = -153,
  NVAPI_MATCHING_DEVICE_NOT_FOUND = -154,
  NVAPI_DRIVER_RUNNING = -155,
  NVAPI_DRIVER_NOTRUNNING = -156,
  NVAPI_ERROR_DRIVER_RELOAD_REQUIRED = -157,
  NVAPI_SET_NOT_ALLOWED = -158,
  NVAPI_ADVANCED_DISPLAY_TOPOLOGY_REQUIRED = -159,
  NVAPI_SETTING_NOT_FOUND = -160,
  NVAPI_SETTING_SIZE_TOO_LARGE = -161,
  NVAPI_TOO_MANY_SETTINGS_IN_PROFILE = -162,
  NVAPI_PROFILE_NOT_FOUND = -163,
  NVAPI_PROFILE_NAME_IN_USE = -164,
  NVAPI_PROFILE_NAME_EMPTY = -165,
  NVAPI_EXECUTABLE_NOT_FOUND = -166,
  NVAPI_EXECUTABLE_ALREADY_IN_USE = -167,
  NVAPI_DATATYPE_MISMATCH = -168,
  NVAPI_PROFILE_REMOVED = -169,
  NVAPI_UNREGISTERED_RESOURCE = -170,
  NVAPI_ID_OUT_OF_RANGE = -171,
  NVAPI_DISPLAYCONFIG_VALIDATION_FAILED = -172,
  NVAPI_DPMST_CHANGED = -173,
  NVAPI_INSUFFICIENT_BUFFER = -174,
  NVAPI_ACCESS_DENIED = -175,
  NVAPI_MOSAIC_NOT_ACTIVE = -176,
  NVAPI_SHARE_RESOURCE_RELOCATED = -177,
  NVAPI_REQUEST_USER_TO_DISABLE_DWM = -178,
  NVAPI_D3D_DEVICE_LOST = -179,
  NVAPI_INVALID_CONFIGURATION = -180,
  NVAPI_STEREO_HANDSHAKE_NOT_DONE = -181,
  NVAPI_EXECUTABLE_PATH_IS_AMBIGUOUS = -182,
  NVAPI_DEFAULT_STEREO_PROFILE_IS_NOT_DEFINED = -183,
  NVAPI_DEFAULT_STEREO_PROFILE_DOES_NOT_EXIST = -184,
  NVAPI_CLUSTER_ALREADY_EXISTS = -185,
  NVAPI_DPMST_DISPLAY_ID_EXPECTED = -186,
  NVAPI_INVALID_DISPLAY_ID = -187,
  NVAPI_STREAM_IS_OUT_OF_SYNC = -188,
  NVAPI_INCOMPATIBLE_AUDIO_DRIVER = -189,
  NVAPI_VALUE_ALREADY_SET = -190,
  NVAPI_TIMEOUT = -191,
  NVAPI_GPU_WORKSTATION_FEATURE_INCOMPLETE = -192,
  NVAPI_STEREO_INIT_ACTIVATION_NOT_DONE = -193,
  NVAPI_SYNC_NOT_ACTIVE = -194,
  NVAPI_SYNC_MASTER_NOT_FOUND = -195,
  NVAPI_INVALID_SYNC_TOPOLOGY = -196,
  NVAPI_ECID_SIGN_ALGO_UNSUPPORTED = -197,
  NVAPI_ECID_KEY_VERIFICATION_FAILED = -198,
  NVAPI_FIRMWARE_OUT_OF_DATE = -199,
  NVAPI_FIRMWARE_REVISION_NOT_SUPPORTED = -200,
  NVAPI_LICENSE_CALLER_AUTHENTICATION_FAILED = -201,
  NVAPI_D3D_DEVICE_NOT_REGISTERED = -202,
  NVAPI_RESOURCE_NOT_ACQUIRED = -203,
  NVAPI_TIMING_NOT_SUPPORTED = -204,
  NVAPI_HDCP_ENCRYPTION_FAILED = -205,
  NVAPI_PCLK_LIMITATION_FAILED = -206,
  NVAPI_NO_CONNECTOR_FOUND = -207,
  NVAPI_HDCP_DISABLED = -208,
  NVAPI_API_IN_USE = -209,
  NVAPI_NVIDIA_DISPLAY_NOT_FOUND = -210,
  NVAPI_PRIV_SEC_VIOLATION = -211,
  NVAPI_INCORRECT_VENDOR = -212,
  NVAPI_DISPLAY_IN_USE = -213,
  NVAPI_UNSUPPORTED_CONFIG_NON_HDCP_HMD = -214,
  NVAPI_MAX_DISPLAY_LIMIT_REACHED = -215,
  NVAPI_INVALID_DIRECT_MODE_DISPLAY = -216,
  NVAPI_GPU_IN_DEBUG_MODE = -217,
  NVAPI_D3D_CONTEXT_NOT_FOUND = -218,
  NVAPI_STEREO_VERSION_MISMATCH = -219,
  NVAPI_GPU_NOT_POWERED = -220,
  NVAPI_ERROR_DRIVER_RELOAD_IN_PROGRESS = -221,
  NVAPI_WAIT_FOR_HW_RESOURCE = -222,
  NVAPI_REQUIRE_FURTHER_HDCP_ACTION = -223,
  NVAPI_DISPLAY_MUX_TRANSITION_FAILED = -224,
  NVAPI_INVALID_DSC_VERSION = -225,
  NVAPI_INVALID_DSC_SLICECOUNT = -226,
  NVAPI_INVALID_DSC_OUTPUT_BPP = -227,
  NVAPI_FAILED_TO_LOAD_FROM_DRIVER_STORE = -228,
  NVAPI_NO_VULKAN = -229,
  NVAPI_REQUEST_PENDING = -230,
  NVAPI_RESOURCE_IN_USE = -231,
} NvAPI_Status;
#define NVAPI_API_NOT_INTIALIZED NVAPI_API_NOT_INITIALIZED
NVAPI_INTERFACE NvAPI_Initialize();
NVAPI_INTERFACE NvAPI_Unload();
#ifndef NV_DRIVER_TYPE_ENUM
#define NV_DRIVER_TYPE_ENUM
typedef enum _NV_DRIVER_TYPE {
  NV_DISPLAY_DRIVER = 0x00000000,
  NV_PLATFORM_DRIVER = 0x00000001,
} NV_DRIVER_TYPE;
#endif
NVAPI_INTERFACE NvAPI_InitializeEx(NV_DRIVER_TYPE drvType);
NVAPI_INTERFACE NvAPI_UnloadEx(NV_DRIVER_TYPE drvType);
NVAPI_INTERFACE NvAPI_GetErrorMessage(NvAPI_Status nr, NvAPI_ShortString szDesc);
NVAPI_INTERFACE NvAPI_GetInterfaceVersionString(NvAPI_ShortString szDesc);
NVAPI_INTERFACE NvAPI_GetInterfaceVersionStringEx(NvAPI_ShortString szDesc);
#ifndef DISPLAYPORT_STRUCTS_DEFINED
#define DISPLAYPORT_STRUCTS_DEFINED
typedef enum _NV_DP_LINK_RATE {
  NV_DP_1_62GBPS = 6,
  NV_DP_2_70GBPS = 0xA,
  NV_DP_5_40GBPS = 0x14,
  NV_DP_8_10GBPS = 0x1E,
  NV_EDP_2_16GBPS = 8,
  NV_EDP_2_43GBPS = 9,
  NV_EDP_3_24GBPS = 0xC,
  NV_EDP_4_32GBPS = 0x10
} NV_DP_LINK_RATE;
typedef enum _NV_DP_LANE_COUNT {
  NV_DP_1_LANE = 1,
  NV_DP_2_LANE = 2,
  NV_DP_4_LANE = 4,
} NV_DP_LANE_COUNT;
typedef enum _NV_DP_COLOR_FORMAT {
  NV_DP_COLOR_FORMAT_RGB = 0,
  NV_DP_COLOR_FORMAT_YCbCr422,
  NV_DP_COLOR_FORMAT_YCbCr444,
} NV_DP_COLOR_FORMAT;
typedef enum _NV_DP_COLORIMETRY {
  NV_DP_COLORIMETRY_RGB = 0,
  NV_DP_COLORIMETRY_YCbCr_ITU601,
  NV_DP_COLORIMETRY_YCbCr_ITU709,
} NV_DP_COLORIMETRY;
typedef enum _NV_DP_DYNAMIC_RANGE {
  NV_DP_DYNAMIC_RANGE_VESA = 0,
  NV_DP_DYNAMIC_RANGE_CEA,
} NV_DP_DYNAMIC_RANGE;
typedef enum _NV_DP_BPC {
  NV_DP_BPC_DEFAULT = 0,
  NV_DP_BPC_6,
  NV_DP_BPC_8,
  NV_DP_BPC_10,
  NV_DP_BPC_12,
  NV_DP_BPC_16,
} NV_DP_BPC;
#define NV_DP_MAX_TOPOLOGY_NODES 128
#define NV_DP_MAX_HDCP_ADDRESS_HOPS 7
#define NV_DP_MAX_ADDRESS_HOPS 15
typedef struct _NV_DP_ADDRESS {
  NvU32 hopCount;
  NvU32 hop[NV_DP_MAX_ADDRESS_HOPS];
} NV_DP_ADDRESS;
typedef enum _NV_DP_NODE_TYPE {
  NV_DP_NODE_TYPE_UNKNOWN = -1,
  NV_DP_NODE_TYPE_DP = 0,
  NV_DP_NODE_TYPE_HDMI = 1,
  NV_DP_NODE_TYPE_DVI = 2,
  NV_DP_NODE_TYPE_VGA = 3,
} NV_DP_NODE_TYPE;
typedef struct {
  NvU64 isOsVisible : 1;
  NvU64 isStreamCloned : 1;
  NvU64 reservedDD : 30;
  NvU64 isMultistream : 1;
  NvU64 isVideoSink : 1;
  NvU64 isAudioSink : 1;
  NvU64 isLoop : 1;
  NvU64 isRedundant : 1;
  NvU64 isMustDisconnect : 1;
  NvU64 isZombie : 1;
  NvU64 isCableOk : 1;
  NvU64 isPowerSuspended : 1;
  NvU64 isActive : 1;
  NvU64 isHdcpCapable : 1;
  NvU64 isPathHdcpCapable : 1;
  NvU64 isHdcpActive : 1;
  NvU64 isRevoked : 1;
  NvU64 reservedLibrary : 18;
} NV_DP_NODE_FLAGS;
typedef struct _NV_DP_BRANCH_DEVICE_PORTS_INFO {
  NvU16 validPortsMask;
  NvU16 inputPortsMask;
  NvU16 internalPortsMask;
} NV_DP_BRANCH_DEVICE_PORTS_INFO;
typedef struct _NV_DP_NODE_INFO {
  NvU32 version;
  NvU32 displayId;
  NV_DP_BRANCH_DEVICE_PORTS_INFO branchDevicePortsInfo;
  NV_DP_ADDRESS auxAddress;
  NvGUID guid;
  NV_DP_NODE_FLAGS flags;
  NV_DP_NODE_TYPE nodeType;
} NV_DP_NODE_INFO;
#define NV_DP_NODE_INFO_VER MAKE_NVAPI_VERSION(NV_DP_NODE_INFO, 1)
#endif
#define NV_EDID_V1_DATA_SIZE 256
#define NV_EDID_DATA_SIZE NV_EDID_V1_DATA_SIZE
typedef struct {
  NvU32 version;
  NvU8 EDID_Data[NV_EDID_DATA_SIZE];
} NV_EDID_V1;
typedef struct {
  NvU32 version;
  NvU8 EDID_Data[NV_EDID_DATA_SIZE];
  NvU32 sizeofEDID;
} NV_EDID_V2;
typedef struct {
  NvU32 version;
  NvU8 EDID_Data[NV_EDID_DATA_SIZE];
  NvU32 sizeofEDID;
  NvU32 edidId;
  NvU32 offset;
} NV_EDID_V3;
typedef NV_EDID_V3 NV_EDID;
#define NV_EDID_VER1 MAKE_NVAPI_VERSION(NV_EDID_V1, 1)
#define NV_EDID_VER2 MAKE_NVAPI_VERSION(NV_EDID_V2, 2)
#define NV_EDID_VER3 MAKE_NVAPI_VERSION(NV_EDID_V3, 3)
#define NV_EDID_VER NV_EDID_VER3
NVAPI_INTERFACE NvAPI_GPU_GetEDID(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayOutputId, NV_EDID *pEDID);
#define NV_EDID_DATA_SIZE_MAX 1024
typedef enum {
  NV_EDID_FLAG_DEFAULT = 0,
  NV_EDID_FLAG_RAW = 1,
  NV_EDID_FLAG_COOKED = 2,
  NV_EDID_FLAG_FORCED = 3,
  NV_EDID_FLAG_INF = 4,
  NV_EDID_FLAG_HW = 5,
  NV_EDID_FLAG_TILES = 6,
} NV_EDID_FLAG;
#define NV_EDID_OK 0
#define NV_EDID_BAD_CHECKSUM 0x1
#define NV_EDID_INCOMPATIBLE_CONNECTOR 0x2
#define NV_EDID_UNSUPPORTED_PIXEL_CLOCK 0x4
#define NV_EDID_INCOMPATIBLE_VESA_SPEC 0x8
typedef enum _NV_GPU_CONNECTOR_TYPE {
  NVAPI_GPU_CONNECTOR_VGA_15_PIN = 0x00000000,
  NVAPI_GPU_CONNECTOR_TV_COMPOSITE = 0x00000010,
  NVAPI_GPU_CONNECTOR_TV_SVIDEO = 0x00000011,
  NVAPI_GPU_CONNECTOR_TV_HDTV_COMPONENT = 0x00000013,
  NVAPI_GPU_CONNECTOR_TV_SCART = 0x00000014,
  NVAPI_GPU_CONNECTOR_TV_COMPOSITE_SCART_ON_EIAJ4120 = 0x00000016,
  NVAPI_GPU_CONNECTOR_TV_HDTV_EIAJ4120 = 0x00000017,
  NVAPI_GPU_CONNECTOR_PC_POD_HDTV_YPRPB = 0x00000018,
  NVAPI_GPU_CONNECTOR_PC_POD_SVIDEO = 0x00000019,
  NVAPI_GPU_CONNECTOR_PC_POD_COMPOSITE = 0x0000001A,
  NVAPI_GPU_CONNECTOR_DVI_I_TV_SVIDEO = 0x00000020,
  NVAPI_GPU_CONNECTOR_DVI_I_TV_COMPOSITE = 0x00000021,
  NVAPI_GPU_CONNECTOR_DVI_I = 0x00000030,
  NVAPI_GPU_CONNECTOR_DVI_D = 0x00000031,
  NVAPI_GPU_CONNECTOR_ADC = 0x00000032,
  NVAPI_GPU_CONNECTOR_LFH_DVI_I_1 = 0x00000038,
  NVAPI_GPU_CONNECTOR_LFH_DVI_I_2 = 0x00000039,
  NVAPI_GPU_CONNECTOR_SPWG = 0x00000040,
  NVAPI_GPU_CONNECTOR_OEM = 0x00000041,
  NVAPI_GPU_CONNECTOR_DISPLAYPORT_EXTERNAL = 0x00000046,
  NVAPI_GPU_CONNECTOR_DISPLAYPORT_INTERNAL = 0x00000047,
  NVAPI_GPU_CONNECTOR_DISPLAYPORT_MINI_EXT = 0x00000048,
  NVAPI_GPU_CONNECTOR_HDMI_A = 0x00000061,
  NVAPI_GPU_CONNECTOR_HDMI_C_MINI = 0x00000063,
  NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_1 = 0x00000064,
  NVAPI_GPU_CONNECTOR_LFH_DISPLAYPORT_2 = 0x00000065,
  NVAPI_GPU_CONNECTOR_VIRTUAL_WFD = 0x00000070,
  NVAPI_GPU_CONNECTOR_USB_C = 0x00000071,
  NVAPI_GPU_CONNECTOR_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CONNECTOR_TYPE;
typedef enum _NV_GPU_CONNECTOR_PLATFORM {
  NVAPI_GPU_CONNECTOR_PLATFORM_DEFAULT_ADD_IN_CARD = 0x00000000,
  NVAPI_GPU_CONNECTOR_PLATFORM_TWO_PLATE_ADD_IN_CARD = 0x00000001,
  NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_ADD_IN_CARD = 0x00000008,
  NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK = 0x00000010,
  NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK_LEFT = 0x00000011,
  NVAPI_GPU_CONNECTOR_PLATFORM_MOBILE_BACK_DOCK = 0x00000018,
  NVAPI_GPU_CONNECTOR_PLATFORM_MAINBOARD_DEFAULT = 0x00000020,
  NVAPI_GPU_CONNECTOR_PLATFORM_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CONNECTOR_PLATFORM;
typedef struct {
  NV_GPU_CONNECTOR_TYPE type;
  NvU32 locationIndex;
} NV_GPU_CONNECTOR_DATA;
#define NV_API_MAX_CONNECTOR_PER_OUTPUT 4
typedef struct _NV_GPU_CONNECTOR_INFO_V1 {
  NvU32 version;
  NV_GPU_CONNECTOR_PLATFORM connectorPlatform;
  NvU32 connectorCount;
  NV_GPU_CONNECTOR_DATA connector[NV_API_MAX_CONNECTOR_PER_OUTPUT];
} NV_GPU_CONNECTOR_INFO_V1;
typedef NV_GPU_CONNECTOR_INFO_V1 NV_GPU_CONNECTOR_INFO;
#define NV_GPU_CONNECTOR_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CONNECTOR_INFO_V1, 1)
#define NV_GPU_CONNECTOR_INFO_VER NV_GPU_CONNECTOR_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetConnectorInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId,
                                           NV_GPU_CONNECTOR_INFO *pConnectorInfo);
typedef struct _NV_CONNECTOR_CAPS {
  NvU32 maxDisplaysVisibleToOS;
  NvU32 maxNodesInMultiStreamTopology;
  NvU32 maxAddressHopsInMultiStreamTopology;
  NvU32 maxHdcpHopsSupported;
  NvU64 isMultiStreamCapable : 1;
  NvU64 isStreamCloneCapable : 1;
  NvU64 reserved : 62;
} NV_CONNECTOR_CAPS;
typedef struct {
  NvU32 version;
  NV_GPU_CONNECTOR_PLATFORM connectorPlatform;
  NvU32 connectorDataCount;
  NV_GPU_CONNECTOR_DATA *connectorData;
  NV_CONNECTOR_CAPS connectorCaps;
} NV_GPU_CONNECTOR_INFO_EX_V1;
typedef enum _NV_GPU_CONNECTOR_DONGLE_TYPE {
  NV_GPU_CONNECTOR_DONGLE_TYPE_OTHER = 0,
  NV_GPU_CONNECTOR_DONGLE_TYPE_DP2DVI = 1,
  NV_GPU_CONNECTOR_DONGLE_TYPE_DP2HDMI = 2,
  NV_GPU_CONNECTOR_DONGLE_TYPE_DMS592DVI = 3,
  NV_GPU_CONNECTOR_DONGLE_TYPE_DMS592VGA = 4,
  NV_GPU_CONNECTOR_DONGLE_TYPE_DP2VGA = 5,
  NV_GPU_CONNECTOR_DONGLE_TYPE_ACTIVE_DP2DVI = 6,
  NV_GPU_CONNECTOR_DONGLE_TYPE_ACTIVE_DP2HDMI = 7,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2VGA = 20,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2SVIDEO = 21,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2COMPOSITE = 22,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2COMPONENT = 23,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2DVI = 24,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2HDMI = 25,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2WFD = 26,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2EIAJRC5237 = 27,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2SDI = 28,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2DP = 29,
  NV_GPU_CONNECTOR_DONGLE_TYPE_WFD2UDI = 30,
} NV_GPU_CONNECTOR_DONGLE_TYPE;
typedef struct {
  NvU32 version;
  NV_GPU_CONNECTOR_PLATFORM connectorPlatform;
  NvU32 connectorDataCount;
  NV_GPU_CONNECTOR_DATA *connectorData;
  NV_CONNECTOR_CAPS connectorCaps;
  NV_GPU_CONNECTOR_DONGLE_TYPE dongleType;
} NV_GPU_CONNECTOR_INFO_EX_V2;
typedef NV_GPU_CONNECTOR_INFO_EX_V2 NV_GPU_CONNECTOR_INFO_EX;
#define NV_GPU_CONNECTOR_INFO_EX_VER1 MAKE_NVAPI_VERSION(NV_GPU_CONNECTOR_INFO_EX_V1, 1)
#define NV_GPU_CONNECTOR_INFO_EX_VER2 MAKE_NVAPI_VERSION(NV_GPU_CONNECTOR_INFO_EX_V2, 2)
#define NV_GPU_CONNECTOR_INFO_EX_VER NV_GPU_CONNECTOR_INFO_EX_VER2
NVAPI_INTERFACE NvAPI_GPU_GetConnectorInfoEx(__in NvU32 displayId, __inout NV_GPU_CONNECTOR_INFO_EX *pConnectorInfo);
typedef enum _NV_TV_ENCODER_TYPE {
  NV_ENCODER_TYPE_UNKNOWN = 0,
  NV_ENCODER_TYPE_BROOKTREE_868 = 1,
  NV_ENCODER_TYPE_BROOKTREE_869 = 2,
  NV_ENCODER_TYPE_BROOKTREE_871 = 3,
  NV_ENCODER_TYPE_BROOKTREE_870 = 4,
  NV_ENCODER_TYPE_BROOKTREE_872 = 5,
  NV_ENCODER_TYPE_BROOKTREE_873 = 6,
  NV_ENCODER_TYPE_BROOKTREE_874 = 7,
  NV_ENCODER_TYPE_BROOKTREE_875 = 8,
  NV_ENCODER_TYPE_BROOKTREE_890 = 9,
  NV_ENCODER_TYPE_BROOKTREE_891 = 10,
  NV_ENCODER_TYPE_BROOKTREE_892 = 11,
  NV_ENCODER_TYPE_CHRONTEL_7003 = 12,
  NV_ENCODER_TYPE_CHRONTEL_7004 = 13,
  NV_ENCODER_TYPE_CHRONTEL_7005 = 14,
  NV_ENCODER_TYPE_CHRONTEL_7006 = 15,
  NV_ENCODER_TYPE_CHRONTEL_7007 = 16,
  NV_ENCODER_TYPE_CHRONTEL_7008 = 17,
  NV_ENCODER_TYPE_CHRONTEL_7009 = 18,
  NV_ENCODER_TYPE_CHRONTEL_7010 = 19,
  NV_ENCODER_TYPE_CHRONTEL_7011 = 20,
  NV_ENCODER_TYPE_CHRONTEL_7012 = 21,
  NV_ENCODER_TYPE_CHRONTEL_7019 = 22,
  NV_ENCODER_TYPE_CHRONTEL_7021 = 23,
  NV_ENCODER_TYPE_CHRONTEL_7301 = 24,
  NV_ENCODER_TYPE_PHILIPS_7102 = 25,
  NV_ENCODER_TYPE_PHILIPS_7103 = 26,
  NV_ENCODER_TYPE_PHILIPS_7108 = 27,
  NV_ENCODER_TYPE_PHILIPS_7109 = 28,
  NV_ENCODER_TYPE_PHILIPS_7108B = 29,
  NV_ENCODER_TYPE_PHILIPS_7108A = 30,
  NV_ENCODER_TYPE_PHILIPS_7109A = 31,
  NV_ENCODER_TYPE_PHILIPS_7104 = 32,
  NV_ENCODER_TYPE_PHILIPS_7105 = 33,
  NV_ENCODER_TYPE_NVIDIA_TV17 = 34,
  NV_ENCODER_TYPE_NVIDIA_MV17 = 35,
  NV_ENCODER_TYPE_NVIDIA_MV36 = 36,
  NV_ENCODER_TYPE_NVIDIA_G80 = 37,
} NV_TV_ENCODER_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetTvEncoderType(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId,
                                           NV_TV_ENCODER_TYPE *pEncoderType);
typedef enum _NV_DISPLAY_TV_FORMAT {
  NV_DISPLAY_TV_FORMAT_NONE = 0,
  NV_DISPLAY_TV_FORMAT_SD_NTSCM = 0x00000001,
  NV_DISPLAY_TV_FORMAT_SD_NTSCJ = 0x00000002,
  NV_DISPLAY_TV_FORMAT_SD_PALM = 0x00000004,
  NV_DISPLAY_TV_FORMAT_SD_PALBDGH = 0x00000008,
  NV_DISPLAY_TV_FORMAT_SD_PALN = 0x00000010,
  NV_DISPLAY_TV_FORMAT_SD_PALNC = 0x00000020,
  NV_DISPLAY_TV_FORMAT_SD_576i = 0x00000100,
  NV_DISPLAY_TV_FORMAT_SD_480i = 0x00000200,
  NV_DISPLAY_TV_FORMAT_ED_480p = 0x00000400,
  NV_DISPLAY_TV_FORMAT_ED_576p = 0x00000800,
  NV_DISPLAY_TV_FORMAT_HD_720p = 0x00001000,
  NV_DISPLAY_TV_FORMAT_HD_1080i = 0x00002000,
  NV_DISPLAY_TV_FORMAT_HD_1080p = 0x00004000,
  NV_DISPLAY_TV_FORMAT_HD_720p50 = 0x00008000,
  NV_DISPLAY_TV_FORMAT_HD_1080p24 = 0x00010000,
  NV_DISPLAY_TV_FORMAT_HD_1080i50 = 0x00020000,
  NV_DISPLAY_TV_FORMAT_HD_1080p50 = 0x00040000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp30 = 0x00080000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp30_3840 = NV_DISPLAY_TV_FORMAT_UHD_4Kp30,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp25 = 0x00100000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp25_3840 = NV_DISPLAY_TV_FORMAT_UHD_4Kp25,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp24 = 0x00200000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp24_3840 = NV_DISPLAY_TV_FORMAT_UHD_4Kp24,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp24_SMPTE = 0x00400000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp50_3840 = 0x00800000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp60_3840 = 0x00900000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp30_4096 = 0x00A00000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp25_4096 = 0x00B00000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp24_4096 = 0x00C00000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp50_4096 = 0x00D00000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp60_4096 = 0x00E00000,
  NV_DISPLAY_TV_FORMAT_UHD_8Kp24_7680 = 0x01000000,
  NV_DISPLAY_TV_FORMAT_UHD_8Kp25_7680 = 0x02000000,
  NV_DISPLAY_TV_FORMAT_UHD_8Kp30_7680 = 0x04000000,
  NV_DISPLAY_TV_FORMAT_UHD_8Kp48_7680 = 0x08000000,
  NV_DISPLAY_TV_FORMAT_UHD_8Kp50_7680 = 0x09000000,
  NV_DISPLAY_TV_FORMAT_UHD_8Kp60_7680 = 0x0A000000,
  NV_DISPLAY_TV_FORMAT_UHD_8Kp100_7680 = 0x0B000000,
  NV_DISPLAY_TV_FORMAT_UHD_8Kp120_7680 = 0x0C000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp48_3840 = 0x0D000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp48_4096 = 0x0E000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp100_4096 = 0x0F000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp100_3840 = 0x10000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp120_4096 = 0x11000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp120_3840 = 0x12000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp100_5120 = 0x13000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp120_5120 = 0x14000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp24_5120 = 0x15000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp25_5120 = 0x16000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp30_5120 = 0x17000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp48_5120 = 0x18000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp50_5120 = 0x19000000,
  NV_DISPLAY_TV_FORMAT_UHD_4Kp60_5120 = 0x20000000,
  NV_DISPLAY_TV_FORMAT_UHD_10Kp24_10240 = 0x21000000,
  NV_DISPLAY_TV_FORMAT_UHD_10Kp25_10240 = 0x22000000,
  NV_DISPLAY_TV_FORMAT_UHD_10Kp30_10240 = 0x23000000,
  NV_DISPLAY_TV_FORMAT_UHD_10Kp48_10240 = 0x24000000,
  NV_DISPLAY_TV_FORMAT_UHD_10Kp50_10240 = 0x25000000,
  NV_DISPLAY_TV_FORMAT_UHD_10Kp60_10240 = 0x26000000,
  NV_DISPLAY_TV_FORMAT_UHD_10Kp100_10240 = 0x27000000,
  NV_DISPLAY_TV_FORMAT_UHD_10Kp120_10240 = 0x28000000,
  NV_DISPLAY_TV_FORMAT_SD_OTHER = 0x30000000,
  NV_DISPLAY_TV_FORMAT_ED_OTHER = 0x40000000,
  NV_DISPLAY_TV_FORMAT_HD_OTHER = 0x50000000,
  NV_DISPLAY_TV_FORMAT_ANY = 0x80000000,
} NV_DISPLAY_TV_FORMAT;
typedef struct {
  NvU32 version;
  NvU32 supportedFormats;
  NV_DISPLAY_TV_FORMAT currentFormat;
  NV_GPU_CONNECTOR_TYPE currentConnector;
} NV_DISPLAY_TV_OUTPUT_INFO;
#define NV_DISPLAY_TV_OUTPUT_INFO_VER MAKE_NVAPI_VERSION(NV_DISPLAY_TV_OUTPUT_INFO, 1)
NVAPI_INTERFACE NvAPI_GetTVOutputInfo(NvDisplayHandle hNvDisplay, NvU32 outputId,
                                      NV_DISPLAY_TV_OUTPUT_INFO *pTVOutInfo);
#define NVAPI_MAX_VIEW_TARGET 2
#define NVAPI_ADVANCED_MAX_VIEW_TARGET 4
#ifndef _NV_TARGET_VIEW_MODE_
#define _NV_TARGET_VIEW_MODE_
typedef enum _NV_TARGET_VIEW_MODE {
  NV_VIEW_MODE_STANDARD = 0,
  NV_VIEW_MODE_CLONE = 1,
  NV_VIEW_MODE_HSPAN = 2,
  NV_VIEW_MODE_VSPAN = 3,
  NV_VIEW_MODE_DUALVIEW = 4,
  NV_VIEW_MODE_MULTIVIEW = 5,
} NV_TARGET_VIEW_MODE;
#endif
typedef enum _NV_SCALING {
  NV_SCALING_DEFAULT = 0,
  NV_SCALING_GPU_SCALING_TO_CLOSEST = 1,
  NV_SCALING_GPU_SCALING_TO_NATIVE = 2,
  NV_SCALING_GPU_SCANOUT_TO_NATIVE = 3,
  NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_NATIVE = 5,
  NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_CLOSEST = 6,
  NV_SCALING_GPU_SCANOUT_TO_CLOSEST = 7,
  NV_SCALING_GPU_INTEGER_ASPECT_SCALING = 8,
  NV_SCALING_MONITOR_SCALING = NV_SCALING_GPU_SCALING_TO_CLOSEST,
  NV_SCALING_ADAPTER_SCALING = NV_SCALING_GPU_SCALING_TO_NATIVE,
  NV_SCALING_CENTERED = NV_SCALING_GPU_SCANOUT_TO_NATIVE,
  NV_SCALING_ASPECT_SCALING = NV_SCALING_GPU_SCALING_TO_ASPECT_SCANOUT_TO_NATIVE,
  NV_SCALING_CUSTOMIZED = 255
} NV_SCALING;
typedef enum _NV_ROTATE {
  NV_ROTATE_0 = 0,
  NV_ROTATE_90 = 1,
  NV_ROTATE_180 = 2,
  NV_ROTATE_270 = 3,
  NV_ROTATE_IGNORED = 4,
} NV_ROTATE;
#define NVFORMAT_MAKEFOURCC(ch0, ch1, ch2, ch3)                                                                        \
  ((NvU32)(NvU8)(ch0) | ((NvU32)(NvU8)(ch1) << 8) | ((NvU32)(NvU8)(ch2) << 16) | ((NvU32)(NvU8)(ch3) << 24))
typedef enum _NV_FORMAT {
  NV_FORMAT_UNKNOWN = 0,
  NV_FORMAT_P8 = 41,
  NV_FORMAT_R5G6B5 = 23,
  NV_FORMAT_A8R8G8B8 = 21,
  NV_FORMAT_A16B16G16R16F = 113,
  NV_FORMAT_R8G8B8 = 20,
  NV_FORMAT_X8R8G8B8 = 22,
  NV_FORMAT_X1R5G5B5 = 24,
  NV_FORMAT_A1R5G5B5 = 25,
  NV_FORMAT_A4R4G4B4 = 26,
  NV_FORMAT_R3G3B2 = 27,
  NV_FORMAT_A8 = 28,
  NV_FORMAT_A8R3G3B2 = 29,
  NV_FORMAT_X4R4G4B4 = 30,
  NV_FORMAT_A2B10G10R10 = 31,
  NV_FORMAT_A8B8G8R8 = 32,
  NV_FORMAT_X8B8G8R8 = 33,
  NV_FORMAT_G16R16 = 34,
  NV_FORMAT_A2R10G10B10 = 35,
  NV_FORMAT_A16B16G16R16 = 36,
  NV_FORMAT_A8P8 = 40,
  NV_FORMAT_L8 = 50,
  NV_FORMAT_A8L8 = 51,
  NV_FORMAT_A4L4 = 52,
  NV_FORMAT_V8U8 = 60,
  NV_FORMAT_L6V5U5 = 61,
  NV_FORMAT_X8L8V8U8 = 62,
  NV_FORMAT_Q8W8V8U8 = 63,
  NV_FORMAT_V16U16 = 64,
  NV_FORMAT_W11V11U10 = 65,
  NV_FORMAT_A2W10V10U10 = 67,
  NV_FORMAT_UYVY = NVFORMAT_MAKEFOURCC('U', 'Y', 'V', 'Y'),
  NV_FORMAT_R8G8_B8G8 = NVFORMAT_MAKEFOURCC('R', 'G', 'B', 'G'),
  NV_FORMAT_YUY2 = NVFORMAT_MAKEFOURCC('Y', 'U', 'Y', '2'),
  NV_FORMAT_G8R8_G8B8 = NVFORMAT_MAKEFOURCC('G', 'R', 'G', 'B'),
  NV_FORMAT_DXT1 = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '1'),
  NV_FORMAT_DXT2 = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '2'),
  NV_FORMAT_DXT3 = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '3'),
  NV_FORMAT_DXT4 = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '4'),
  NV_FORMAT_DXT5 = NVFORMAT_MAKEFOURCC('D', 'X', 'T', '5'),
  NV_FORMAT_D16_LOCKABLE = 70,
  NV_FORMAT_D32 = 71,
  NV_FORMAT_D15S1 = 73,
  NV_FORMAT_D24S8 = 75,
  NV_FORMAT_D24X8 = 77,
  NV_FORMAT_D24X4S4 = 79,
  NV_FORMAT_D16 = 80,
  NV_FORMAT_D32F_LOCKABLE = 82,
  NV_FORMAT_D24FS8 = 83,
  NV_FORMAT_D32_LOCKABLE = 84,
  NV_FORMAT_S8_LOCKABLE = 85,
  NV_FORMAT_S1D15 = 72,
  NV_FORMAT_S8D24 = 74,
  NV_FORMAT_X8D24 = 76,
  NV_FORMAT_X4S4D24 = 78,
  NV_FORMAT_L16 = 81,
  NV_FORMAT_VERTEXDATA = 100,
  NV_FORMAT_INDEX16 = 101,
  NV_FORMAT_INDEX32 = 102,
  NV_FORMAT_Q16W16V16U16 = 110,
  NV_FORMAT_R16F = 111,
  NV_FORMAT_G16R16F = 112,
  NV_FORMAT_R32F = 114,
  NV_FORMAT_G32R32F = 115,
  NV_FORMAT_A32B32G32R32F = 116,
  NV_FORMAT_CxV8U8 = 117,
  NV_FORMAT_A1 = 118,
} NV_FORMAT;
typedef enum _NV_CONNECTOR {
  NV_CONN_AUTO = 0,
} NV_CONNECTOR;
typedef struct {
  float x;
  float y;
  float w;
  float h;
} NV_VIEWPORTF;
typedef enum _NV_TIMING_OVERRIDE {
  NV_TIMING_OVERRIDE_CURRENT = 0,
  NV_TIMING_OVERRIDE_AUTO,
  NV_TIMING_OVERRIDE_EDID,
  NV_TIMING_OVERRIDE_DMT,
  NV_TIMING_OVERRIDE_DMT_RB,
  NV_TIMING_OVERRIDE_CVT,
  NV_TIMING_OVERRIDE_CVT_RB,
  NV_TIMING_OVERRIDE_GTF,
  NV_TIMING_OVERRIDE_EIA861,
  NV_TIMING_OVERRIDE_ANALOG_TV,
  NV_TIMING_OVERRIDE_CUST,
  NV_TIMING_OVERRIDE_NV_PREDEFINED,
  NV_TIMING_OVERRIDE_NV_PSF = NV_TIMING_OVERRIDE_NV_PREDEFINED,
  NV_TIMING_OVERRIDE_NV_ASPR,
  NV_TIMING_OVERRIDE_SDI,
  NV_TIMING_OVRRIDE_MAX,
} NV_TIMING_OVERRIDE;
#ifndef NV_TIMING_STRUCTS_DEFINED
#define NV_TIMING_STRUCTS_DEFINED
typedef struct tagNV_TIMINGEXT {
  NvU32 flag;
  NvU16 rr;
  NvU32 rrx1k;
  NvU32 aspect;
  NvU16 rep;
  NvU32 status;
  NvU8 name[40];
} NV_TIMINGEXT;
typedef struct _NV_TIMING {
  NvU16 HVisible;
  NvU16 HBorder;
  NvU16 HFrontPorch;
  NvU16 HSyncWidth;
  NvU16 HTotal;
  NvU8 HSyncPol;
  NvU16 VVisible;
  NvU16 VBorder;
  NvU16 VFrontPorch;
  NvU16 VSyncWidth;
  NvU16 VTotal;
  NvU8 VSyncPol;
  NvU16 interlaced;
  NvU32 pclk;
  NV_TIMINGEXT etc;
} NV_TIMING;
#endif
#define NV_TIMING_H_SYNC_POSITIVE 0
#define NV_TIMING_H_SYNC_NEGATIVE 1
#define NV_TIMING_H_SYNC_DEFAULT NV_TIMING_H_SYNC_NEGATIVE
#define NV_TIMING_V_SYNC_POSITIVE 0
#define NV_TIMING_V_SYNC_NEGATIVE 1
#define NV_TIMING_V_SYNC_DEFAULT NV_TIMING_V_SYNC_POSITIVE
#define NV_TIMING_PROGRESSIVE 0
#define NV_TIMING_INTERLACED 1
#define NV_TIMING_INTERLACED_EXTRA_VBLANK_ON_FIELD2 1
#define NV_TIMING_INTERLACED_NO_EXTRA_VBLANK_ON_FIELD2 2
typedef enum _NVAPI_TIMING_TYPE {
  NV_TIMING_TYPE_DMT = 1,
  NV_TIMING_TYPE_GTF,
  NV_TIMING_TYPE_ASPR,
  NV_TIMING_TYPE_NTSC_TV,
  NV_TIMING_TYPE_PAL_TV,
  NV_TIMING_TYPE_CVT,
  NV_TIMING_TYPE_CVT_RB,
  NV_TIMING_TYPE_CUST,
  NV_TIMING_TYPE_EDID_DTD,
  NV_TIMING_TYPE_EDID_STD,
  NV_TIMING_TYPE_EDID_EST,
  NV_TIMING_TYPE_EDID_CVT,
  NV_TIMING_TYPE_EDID_861ST,
  NV_TIMING_TYPE_NV_PREDEFINED,
  NV_TIMING_TYPE_DMT_RB,
  NV_TIMING_TYPE_EDID_EXT_DTD,
  NV_TIMING_TYPE_SDTV,
  NV_TIMING_TYPE_HDTV,
} NVAPI_TIMING_TYPE;
#define NV_DISP_INDEX_AUTO 0
typedef struct {
  NvU32 version;
  NvU32 device;
  NV_GPU_CONNECTOR_TYPE connector;
  NvU32 srcID;
  NvU32 srcImportance;
  NvU32 width;
  NvU32 height;
  NvU32 depth;
  NV_ROTATE rotation;
  NV_FORMAT colorFormat;
  NV_VIEWPORTF srcPartition;
  NV_VIEWPORTF viewportIn;
  NV_SCALING scaling;
  NV_VIEWPORTF viewportOut;
  NV_TIMING_OVERRIDE timingOverride;
  NvU32 refreshRate;
  NvU32 interlaced : 1;
  NvU32 hwModeSetOnly : 1;
  NvU32 SelectCustomTiming : 1;
  NvU32 needNullModeset : 1;
  NvU32 need6x4Modeset : 1;
  NvU32 forceModeSet : 1;
  NvU32 gpuId : 24;
  NvU32 isSliFocusDisplay : 1;
  NvU32 forceModeEnum : 1;
  NV_DISPLAY_TV_FORMAT tvFormat;
  NV_TIMING timing;
} NV_DISP_PATH_V1;
typedef struct {
  NvU32 version;
  NvU32 device;
  NV_GPU_CONNECTOR_TYPE connector;
  NvU32 srcID;
  NvU32 srcImportance;
  NvU32 width;
  NvU32 height;
  NvU32 depth;
  NV_ROTATE rotation;
  NV_FORMAT colorFormat;
  NV_VIEWPORTF srcPartition;
  NV_VIEWPORTF viewportIn;
  NV_SCALING scaling;
  NV_VIEWPORTF viewportOut;
  NV_TIMING_OVERRIDE timingOverride;
  NvU32 refreshRate;
  NvU32 interlaced : 1;
  NvU32 hwModeSetOnly : 1;
  NvU32 SelectCustomTiming : 1;
  NvU32 needNullModeset : 1;
  NvU32 need6x4Modeset : 1;
  NvU32 forceModeSet : 1;
  NvU32 gpuId : 24;
  NvU32 isSliFocusDisplay : 1;
  NvU32 forceModeEnum : 1;
  NV_DISPLAY_TV_FORMAT tvFormat;
  NV_TIMING timing;
  NvU32 refreshRate1K;
} NV_DISP_PATH_V2;
typedef struct {
  NvU32 version;
  NvU32 device;
  NV_GPU_CONNECTOR_TYPE connector;
  NvU32 srcID;
  NvU32 srcImportance;
  NvU32 width;
  NvU32 height;
  NvU32 depth;
  NV_ROTATE rotation;
  NV_FORMAT colorFormat;
  NV_VIEWPORTF srcPartition;
  NV_VIEWPORTF viewportIn;
  NV_SCALING scaling;
  NV_VIEWPORTF viewportOut;
  NV_TIMING_OVERRIDE timingOverride;
  NvU32 refreshRate;
  NvU32 interlaced : 1;
  NvU32 hwModeSetOnly : 1;
  NvU32 SelectCustomTiming : 1;
  NvU32 needNullModeset : 1;
  NvU32 need6x4Modeset : 1;
  NvU32 forceModeSet : 1;
  NvU32 gpuId : 32;
  NvU32 isSliFocusDisplay : 1;
  NvU32 forceModeEnum : 1;
  NV_DISPLAY_TV_FORMAT tvFormat;
  NV_TIMING timing;
  NvU32 refreshRate1K;
} NV_DISP_PATH_V3;
typedef NV_DISP_PATH_V3 NV_DISP_PATH;
#define NV_DISP_PATH_VER3 MAKE_NVAPI_VERSION(NV_DISP_PATH_V1, 3)
#define NV_DISP_PATH_VER2 MAKE_NVAPI_VERSION(NV_DISP_PATH_V1, 2)
#define NV_DISP_PATH_VER1 MAKE_NVAPI_VERSION(NV_DISP_PATH_V1, 1)
#define NV_DISP_PATH_VER4 MAKE_NVAPI_VERSION(NV_DISP_PATH_V2, 4)
#define NV_DISP_PATH_VER5 MAKE_NVAPI_VERSION(NV_DISP_PATH_V3, 5)
#define NV_DISP_PATH_VER NV_DISP_PATH_VER5
NVAPI_INTERFACE NvAPI_SetDisplaySettings(NvDisplayHandle hNvDisplay, NV_DISP_PATH *paths, NvU32 pathCount);
typedef struct {
  NvU32 version;
  NvU32 count;
  struct {
    NvU32 deviceMask;
    NvU32 sourceId;
    NvU32 bPrimary : 1;
    NvU32 bInterlaced : 1;
    NvU32 bGDIPrimary : 1;
    NvU32 bForceModeSet : 1;
  } target[NVAPI_MAX_VIEW_TARGET];
} NV_VIEW_TARGET_INFO;
#define NV_VIEW_TARGET_INFO_VER MAKE_NVAPI_VERSION(NV_VIEW_TARGET_INFO, 2)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_SetDisplayConfig.")
    NVAPI_INTERFACE
    NvAPI_SetView(NvDisplayHandle hNvDisplay, NV_VIEW_TARGET_INFO *pTargetInfo, NV_TARGET_VIEW_MODE targetView);
#define NVAPI_MAX_DISPLAY_PATH NVAPI_MAX_VIEW_TARGET
#define NVAPI_ADVANCED_MAX_DISPLAY_PATH NVAPI_ADVANCED_MAX_VIEW_TARGET
typedef struct {
  NvU32 deviceMask;
  NvU32 sourceId;
  NvU32 bPrimary : 1;
  NV_GPU_CONNECTOR_TYPE connector;
  NvU32 width;
  NvU32 height;
  NvU32 depth;
  NV_FORMAT colorFormat;
  NV_ROTATE rotation;
  NV_SCALING scaling;
  NvU32 refreshRate;
  NvU32 interlaced : 1;
  NV_DISPLAY_TV_FORMAT tvFormat;
  NvU32 posx;
  NvU32 posy;
  NvU32 bGDIPrimary : 1;
  NvU32 bForceModeSet : 1;
  NvU32 bFocusDisplay : 1;
  NvU32 gpuId : 24;
} NV_DISPLAY_PATH;
typedef struct {
  NvU32 version;
  NvU32 count;
  NV_DISPLAY_PATH path[NVAPI_MAX_DISPLAY_PATH];
} NV_DISPLAY_PATH_INFO_V3;
typedef struct {
  NvU32 version;
  NvU32 count;
  NV_DISPLAY_PATH path[NVAPI_ADVANCED_MAX_DISPLAY_PATH];
} NV_DISPLAY_PATH_INFO;
#define NV_DISPLAY_PATH_INFO_VER NV_DISPLAY_PATH_INFO_VER4
#define NV_DISPLAY_PATH_INFO_VER4 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO, 4)
#define NV_DISPLAY_PATH_INFO_VER3 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO, 3)
#define NV_DISPLAY_PATH_INFO_VER2 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO, 2)
#define NV_DISPLAY_PATH_INFO_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_PATH_INFO, 1)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_SetDisplayConfig.")
    NVAPI_INTERFACE
    NvAPI_SetViewEx(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo, NV_TARGET_VIEW_MODE displayView);
#define NVAPI_MAX_NUM_AP 16
#define NVAPI_MAX_DEVICES 127
typedef struct {
  union {
    NvU32 data1;
    struct {
      NvU8 revMin;
      NvU8 revMaj;
      NvU8 verMin;
      NvU8 verMaj;
    } ver;
  };
  NvU16 data2;
  NvU16 data3;
  NvU8 data4[8];
} NV_UID;
typedef struct {
#pragma pack(1)
  NvU64 uSessionID : 37;
  NvU64 uDisplay : 3;
  NvU64 uReserved : 24;
#pragma pack()
} NV_HDCP_CN;
typedef struct {
  union {
    NvU64 quadWord;
    struct {
      NvU64 hugePart : 40;
      NvU64 unusedPart : 24;
    } parts;
  };
} NV_U40;
typedef struct {
  union {
    NvU64 quadWord;
    struct {
      NvU64 hugePart : 56;
      NvU64 unusedPart : 8;
    } parts;
  };
} NV_U56;
typedef struct {
#pragma pack(1)
  NvU32 ucDeviceCount : 7;
  NvU32 bMaxDevicesExceeded : 1;
  NvU32 bRepeaterDepth : 3;
  NvU32 bMaxCascadeExceeded : 1;
  NvU32 bHDMImode : 1;
  NvU32 bReserved : 19;
#pragma pack()
} NV_HDCP_BSTATUS;
typedef struct {
#pragma pack(1)
  NvU64 uAttachPoints : 16;
  NvU64 bNonHDCP : 1;
  NvU64 uHeadIndex : 4;
  NvU64 uRFUPlanes : 8;
  NvU64 uNumberOfActiveHeads : 1;
  NvU64 bHDCP22Encrypting : 1;
  NvU64 uStreamIdType : 1;
  NvU64 uReserved2 : 8;
  NvU64 uAttachedPlanes : 8;
  NvU64 bCloneMode : 1;
  NvU64 bSpanMode : 1;
  NvU64 reserved : 14;
#pragma pack()
} NV_HDCP_CS;
typedef struct {
#pragma pack(1)
  NvU64 bEncrypting : 1;
  NvU64 bRepeater : 1;
  NvU64 bUserAccessible : 1;
  NvU64 bExtUnprotected : 1;
  NvU64 uPortIndex : 4;
  NvU64 uNumPorts : 4;
  NvU64 bInternalPanel : 1;
  NvU64 bWideScope : 1;
  NvU64 bHasCs : 1;
  NvU64 bReadZ : 1;
  NvU64 uReserved : 24;
  NvU64 bDualLinkEven : 1;
  NvU64 bDualLinkOdd : 1;
  NvU64 bDualLinkCapable : 1;
  NvU64 reserved : 21;
  NvU32 DisplayId;
#pragma pack()
} NV_HDCP_STATUS;
typedef struct {
#pragma pack(1)
  NvU32 BCaps : 15;
  NvU32 HDCPMode : 1;
  NvU32 HDCPVersion : 8;
  NvU32 bReserved : 8;
#pragma pack()
} NV_HDCP_BCAPS;
typedef enum {
  NV_HDCP_FLAGS_NULL = 0x00000000,
  NV_HDCP_FLAGS_APINDEX = 0x00000001,
  NV_HDCP_FLAGS_AN = 0x00000010,
  NV_HDCP_FLAGS_AKSV = 0x00000020,
  NV_HDCP_FLAGS_BKSV = 0x00000040,
  NV_HDCP_FLAGS_BSTATUS = 0x00000080,
  NV_HDCP_FLAGS_CN = 0x00000100,
  NV_HDCP_FLAGS_CKSV = 0x00000200,
  NV_HDCP_FLAGS_DKSV = 0x00000400,
  NV_HDCP_FLAGS_KP = 0x00001000,
  NV_HDCP_FLAGS_S = 0x00002000,
  NV_HDCP_FLAGS_CS = 0x00004000,
  NV_HDCP_FLAGS_V = 0x00010000,
  NV_HDCP_FLAGS_MP = 0x00020000,
  NV_HDCP_FLAGS_BKSVLIST = 0x00040000,
  NV_HDCP_FLAGS_DUAL_LINK = 0x00100000,
  NV_HDCP_FLAGS_ALWAYS_AUTH = 0x00200000,
  NV_HDCP_FLAGS_ON_BY_DEMAND = 0x00000000,
  NV_HDCP_FLAGS_ABORT_UNTRUST = 0x00400000,
  NV_HDCP_FLAGS_ABORT_UNRELBL = 0x00800000,
  NV_HDCP_FLAGS_ABORT_KSV_LEN = 0x01000000,
  NV_HDCP_FLAGS_ABORT_KSV_SIG = 0x02000000,
  NV_HDCP_FLAGS_ABORT_SRM_SIG = 0x04000000,
  NV_HDCP_FLAGS_ABORT_SRM_REV = 0x08000000,
  NV_HDCP_FLAGS_ABORT_NORDY = 0x10000000,
  NV_HDCP_FLAGS_ABORT_KSVTOP = 0x20000000,
  NV_HDCP_FLAGS_ABORT_BADBKSV = 0x40000000,
} NV_HDCP_FLAGS;
typedef enum {
  NV_HDCP_CMD_NULL = 0x00,
  NV_HDCP_CMD_QUERY_HEAD_CONFIG = 0x01,
  NV_HDCP_CMD_READ_LINK_STATUS = 0x02,
  NV_HDCP_CMD_VALIDATE_LINK = 0x03,
  NV_HDCP_CMD_RENEGOTIATE = 0x04,
  NV_HDCP_CMD_ABORTAUTHENTICATION = 0x05,
  NV_HDCP_CMD_SETLINKPOLICY = 0x06,
} NV_HDCP_COMMANDS;
typedef enum {
  NV_HDCP_STATUS_SUCCESS = (0x00000000L),
  NV_HDCP_STATUS_UNSUCCESSFUL = (0xC0000001L),
  NV_HDCP_STATUS_PENDING = (0x00000103L),
  NV_HDCP_STATUS_LINK_FAILED = (0xC000013EL),
  NV_HDCP_STATUS_INVALID_PARAMETER = (0xC000000DL),
  NV_HDCP_STATUS_INVALID_PARAMETER_MIX = (0xC0000030L),
  NV_HDCP_STATUS_NO_MEMORY = (0xC0000017L),
  NV_HDCP_STATUS_BAD_TOKEN_TYPE = (0xC00000A8L),
} NV_HDCP_RET_STATUS;
typedef struct _NV_HDCP_PACKET_V1 {
#pragma pack(4)
  NV_UID uidHDCP;
  NvU32 packetSize;
  NvU32 hDisplayContext;
  NV_HDCP_COMMANDS cmdCommand;
  NV_HDCP_FLAGS flFlags;
  NV_HDCP_RET_STATUS hdcpPacketStatus;
  NvU32 apIndex;
  NV_HDCP_CN cN;
  NV_U40 cKsv;
  NV_HDCP_BSTATUS bStatus[NVAPI_MAX_NUM_AP];
  NV_HDCP_STATUS hdcpStatus[NVAPI_MAX_NUM_AP];
  NV_HDCP_CS cS;
  NV_U56 kP[2];
  NV_U40 aN[2];
  NV_U40 aKsv[2];
  NV_U40 dKsv[2];
  NvU8 vP[20];
  NvU64 mP;
  NvU32 numBKSVs;
  NV_U40 bKsvList[NVAPI_MAX_DEVICES];
#pragma pack()
} NV_HDCP_PACKET_V1;
typedef struct _NV_HDCP_PACKET {
#pragma pack(4)
  NV_UID uidHDCP;
  NvU32 packetSize;
  NvU32 hDisplayContext;
  NV_HDCP_COMMANDS cmdCommand;
  NV_HDCP_FLAGS flFlags;
  NV_HDCP_RET_STATUS hdcpPacketStatus;
  NvU32 apIndex;
  NV_HDCP_CN cN;
  NV_U40 cKsv;
  NV_HDCP_BSTATUS bStatus[NVAPI_MAX_NUM_AP];
  NV_HDCP_STATUS hdcpStatus[NVAPI_MAX_NUM_AP];
  NV_HDCP_CS cS;
  NV_U56 kP[2];
  NV_U40 aN[2];
  NV_U40 aKsv[2];
  NV_U40 dKsv[2];
  NvU8 vP[20];
  NvU64 mP;
  NvU32 numBKSVs;
  NV_U40 bKsvList[NVAPI_MAX_DEVICES];
  NV_HDCP_BCAPS hdcpBCaps[NVAPI_MAX_NUM_AP];
#pragma pack()
} NV_HDCP_PACKET;
typedef struct _NV_HDCP_INFO_V1 {
  NvU32 version;
  NV_HDCP_PACKET_V1 nvHdcpPacket;
} NV_HDCP_INFO_V1;
typedef struct _NV_HDCP_INFO_V2 {
  NvU32 version;
  NV_HDCP_PACKET nvHdcpPacket;
} NV_HDCP_INFO_V2;
typedef NV_HDCP_INFO_V2 NV_HDCP_INFO;
#define NV_HDCP_INFO_VER1 MAKE_NVAPI_VERSION(NV_HDCP_INFO_V1, 1)
#define NV_HDCP_INFO_VER2 MAKE_NVAPI_VERSION(NV_HDCP_INFO_V2, 2)
#define NV_HDCP_INFO_VER NV_HDCP_INFO_VER2
NVAPI_INTERFACE NvAPI_GetHDCPLinkParameters(__in NvDisplayHandle hNvDisplay, __out NV_HDCP_INFO *pNvHdcpInfo);
#define NVAPI_MAX_3D_Apps 128
typedef struct {
  NvU32 version;
  NvU32 processId;
  NvAPI_ShortString processName;
} NV_3D_APP_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 processId;
  NvAPI_LongString processName;
} NV_3D_APP_INFO_V2;
typedef NV_3D_APP_INFO_V2 NV_3D_APP_INFO;
#define NV_3D_APP_INFO_VER_1 MAKE_NVAPI_VERSION(NV_3D_APP_INFO_V1, 1)
#define NV_3D_APP_INFO_VER_2 MAKE_NVAPI_VERSION(NV_3D_APP_INFO_V2, 2)
#define NV_3D_APP_INFO_VER NV_3D_APP_INFO_VER_2
NVAPI_INTERFACE NvAPI_QueryNonMigratableApps(NV_3D_APP_INFO apps[NVAPI_MAX_3D_Apps], NvU32 *total);
#ifndef NV_PAN_AND_SCAN_DEFINED
#define NV_PAN_AND_SCAN_DEFINED
#endif
typedef struct {
  NvU32 numerator;
  NvU32 denominator;
} NV_DISPLAY_REFRESH_RATE;
typedef struct _NV_POSITION {
  NvS32 x;
  NvS32 y;
} NV_POSITION;
typedef struct _NV_RESOLUTION {
  NvU32 width;
  NvU32 height;
  NvU32 colorDepth;
} NV_RESOLUTION;
typedef struct _NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 {
  NvU32 version;
  NV_ROTATE rotation;
  NV_SCALING scaling;
  NvU32 refreshRate1K;
  NvU32 interlaced : 1;
  NvU32 primary : 1;
#ifdef NV_PAN_AND_SCAN_DEFINED
  NvU32 isPanAndScanTarget : 1;
#else
  NvU32 reservedBit1 : 1;
#endif
  NvU32 disableVirtualModeSupport : 1;
  NvU32 isPreferredUnscaledTarget : 1;
  NvU32 reserved : 27;
  NV_GPU_CONNECTOR_TYPE connector;
  NV_DISPLAY_TV_FORMAT tvFormat;
  NV_TIMING_OVERRIDE timingOverride;
  NV_TIMING timing;
} NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1;
typedef NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1 NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO;
#define NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER1                                                                \
  MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_V1, 1)
#define NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO_VER1
typedef struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1 {
  NvU32 displayId;
  NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO *details;
} NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1;
typedef struct _NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 {
  NvU32 displayId;
  NV_DISPLAYCONFIG_PATH_ADVANCED_TARGET_INFO *details;
  NvU32 targetId;
} NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2;
typedef NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 NV_DISPLAYCONFIG_PATH_TARGET_INFO;
typedef enum _NV_DISPLAYCONFIG_SPANNING_ORIENTATION {
  NV_DISPLAYCONFIG_SPAN_NONE = 0,
  NV_DISPLAYCONFIG_SPAN_HORIZONTAL = 1,
  NV_DISPLAYCONFIG_SPAN_VERTICAL = 2,
} NV_DISPLAYCONFIG_SPANNING_ORIENTATION;
typedef struct _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 {
  NV_RESOLUTION resolution;
  NV_FORMAT colorFormat;
  NV_POSITION position;
  NV_DISPLAYCONFIG_SPANNING_ORIENTATION spanningOrientation;
  NvU32 bGDIPrimary : 1;
  NvU32 bSLIFocus : 1;
  NvU32 reserved : 30;
} NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1;
typedef struct _NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V2 {
  NV_RESOLUTION resolution;
  NV_FORMAT colorFormat;
  NV_POSITION position;
  NV_DISPLAYCONFIG_SPANNING_ORIENTATION spanningOrientation;
  NvU32 bGDIPrimary : 1;
  NvU32 bSLIFocus : 1;
  NvU32 reserved : 30;
  NvU32 sourceId;
} NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V2;
typedef NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V2 NV_DISPLAYCONFIG_SOURCE_MODE_INFO;
typedef struct _NV_DISPLAYCONFIG_PATH_INFO_V1 {
  NvU32 version;
  NvU32 reserved_sourceId;
  NvU32 targetInfoCount;
  NV_DISPLAYCONFIG_PATH_TARGET_INFO_V1 *targetInfo;
  NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 *sourceModeInfo;
} NV_DISPLAYCONFIG_PATH_INFO_V1;
#define _NV_DISPLAYCONFIG_PATH_INFO_V2 _NV_DISPLAYCONFIG_PATH_INFO
typedef struct _NV_DISPLAYCONFIG_PATH_INFO_V2 {
  NvU32 version;
  union {
    NvU32 sourceId;
    NvU32 reserved_sourceId;
  };
  NvU32 targetInfoCount;
  NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 *targetInfo;
  NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 *sourceModeInfo;
  NvU32 IsNonNVIDIAAdapter : 1;
  NvU32 reserved : 31;
  void *pOSAdapterID;
} NV_DISPLAYCONFIG_PATH_INFO_V2;
#define NV_DISPLAYCONFIG_PATH_INFO_VER1 MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_INFO_V1, 1)
#define NV_DISPLAYCONFIG_PATH_INFO_VER2 MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_INFO_V2, 2)
typedef struct _NV_DISPLAYCONFIG_PATH_INFO_V3 {
  NvU32 version;
  union {
    NvU32 sourceId;
    NvU32 reserved_sourceId;
  };
  NvU32 targetInfoCount;
  NV_DISPLAYCONFIG_PATH_TARGET_INFO_V2 *targetInfo;
  NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V2 *sourceModeInfo;
  NvU32 IsNonNVIDIAAdapter : 1;
  NvU32 reserved : 31;
  void *pOSAdapterID;
  NvU32 sourceModeInfoCount;
} NV_DISPLAYCONFIG_PATH_INFO_V3;
#define NV_DISPLAYCONFIG_PATH_INFO_VER3 MAKE_NVAPI_VERSION(NV_DISPLAYCONFIG_PATH_INFO_V3, 3)
typedef NV_DISPLAYCONFIG_PATH_INFO_V3 NV_DISPLAYCONFIG_PATH_INFO;
#define NV_DISPLAYCONFIG_PATH_INFO_VER NV_DISPLAYCONFIG_PATH_INFO_VER3
#ifndef NV_DISPLAYCONFIG_PATH_INFO_VER
typedef NV_DISPLAYCONFIG_PATH_INFO_V2 NV_DISPLAYCONFIG_PATH_INFO;
#define NV_DISPLAYCONFIG_PATH_INFO_VER NV_DISPLAYCONFIG_PATH_INFO_VER2
typedef NV_DISPLAYCONFIG_SOURCE_MODE_INFO_V1 NV_DISPLAYCONFIG_SOURCE_MODE_INFO;
#endif
typedef enum _NV_DISPLAYCONFIG_FLAGS {
  NV_DISPLAYCONFIG_VALIDATE_ONLY = 0x00000001,
  NV_DISPLAYCONFIG_SAVE_TO_PERSISTENCE = 0x00000002,
  NV_DISPLAYCONFIG_DRIVER_RELOAD_ALLOWED = 0x00000004,
  NV_DISPLAYCONFIG_FORCE_MODE_ENUMERATION = 0x00000008,
  NV_FORCE_COMMIT_VIDPN = 0x00000010,
} NV_DISPLAYCONFIG_FLAGS;
#define NVAPI_UNICODE_STRING_MAX 2048
#define NVAPI_BINARY_DATA_MAX 4096
typedef NvU16 NvAPI_UnicodeString[NVAPI_UNICODE_STRING_MAX];
typedef const NvU16 *NvAPI_LPCWSTR;
#define NVAPI_MAX_GPU_CLOCKS 32
#define NVAPI_MAX_GPU_PUBLIC_CLOCKS 32
#define NVAPI_MAX_GPU_PERF_CLOCKS 32
#define NVAPI_MAX_GPU_PERF_VOLTAGES 16
#define NVAPI_MAX_GPU_PERF_PSTATES 16
typedef enum {
  NV_GPU_VOLT_VOLT_DOMAIN_INVALID = 0,
  NV_GPU_VOLT_VOLT_DOMAIN_LOGIC = 1,
  NV_GPU_VOLT_VOLT_DOMAIN_SRAM = 2,
  NV_GPU_VOLT_VOLT_DOMAIN_MSVDD = 3,
} NV_GPU_VOLT_VOLT_DOMAIN_TYPE;
typedef enum _NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID {
  NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_CORE = 0,
  NVAPI_GPU_PERF_VOLTAGE_INFO_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_PERF_VOLTAGES,
} NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID;
typedef enum _NV_GPU_CLIENT_VOLT_DOMAIN_ID {
  NV_GPU_CLIENT_VOLT_DOMAIN_CORE = 0,
  NV_GPU_CLIENT_VOLT_DOMAIN_MAX_ENTRIES,
} NV_GPU_CLIENT_VOLT_DOMAIN_ID;
typedef enum _NV_GPU_PERF_VOLTAGE_DOMAIN_ID {
  NVAPI_GPU_PERF_VOLTAGE_DOMAIN_CORE = 0,
  NVAPI_GPU_PERF_VOLTAGE_DOMAIN_FB = 1,
  NVAPI_GPU_PERF_VOLTAGE_DOMAIN_COLD_CORE = 2,
  NVAPI_GPU_PERF_VOLTAGE_DOMAIN_CORE_NOMINAL = 3,
  NVAPI_GPU_PERF_VOLTAGE_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_PERF_VOLTAGES,
} NV_GPU_PERF_VOLTAGE_DOMAIN_ID;
#define NV_GPU_VOLT_VOLT_RAILS_MAX_V1 (32)
typedef enum _NV_GPU_PUBLIC_CLOCK_ID {
  NVAPI_GPU_PUBLIC_CLOCK_GRAPHICS = 0,
  NVAPI_GPU_PUBLIC_CLOCK_MEMORY = 4,
  NVAPI_GPU_PUBLIC_CLOCK_PROCESSOR = 7,
  NVAPI_GPU_PUBLIC_CLOCK_VIDEO = 8,
  NVAPI_GPU_PUBLIC_CLOCK_UNDEFINED = NVAPI_MAX_GPU_PUBLIC_CLOCKS,
} NV_GPU_PUBLIC_CLOCK_ID;
typedef enum _NV_GPU_CLOCK_DOMAIN_ID {
  NVAPI_GPU_CLOCK_DOMAIN_GPC = 0,
  NVAPI_GPU_CLOCK_DOMAIN_XBAR = 1,
  NVAPI_GPU_CLOCK_DOMAIN_SYS = 2,
  NVAPI_GPU_CLOCK_DOMAIN_HUB = 3,
  NVAPI_GPU_CLOCK_DOMAIN_NV = 0,
  NVAPI_GPU_CLOCK_DOMAIN_G = 1,
  NVAPI_GPU_CLOCK_DOMAIN_S = 2,
  NVAPI_GPU_CLOCK_DOMAIN_R = 3,
  NVAPI_GPU_CLOCK_DOMAIN_M = 4,
  NVAPI_GPU_CLOCK_DOMAIN_HOST = 5,
  NVAPI_GPU_CLOCK_DOMAIN_DISP = 6,
  NVAPI_GPU_CLOCK_DOMAIN_HOTCLK = 7,
  NVAPI_GPU_CLOCK_DOMAIN_PCLK0 = 8,
  NVAPI_GPU_CLOCK_DOMAIN_PCLK1 = 9,
  NVAPI_GPU_CLOCK_DOMAIN_BYPCLK = 10,
  NVAPI_GPU_CLOCK_DOMAIN_XCLK = 11,
  NVAPI_GPU_CLOCK_DOMAIN_VPV = 12,
  NVAPI_GPU_CLOCK_DOMAIN_VPS = 13,
  NVAPI_GPU_CLOCK_DOMAIN_GPUCACHECLK = 14,
  NVAPI_GPU_CLOCK_DOMAIN_GPC2 = 15,
  NVAPI_GPU_CLOCK_DOMAIN_XBAR2 = 16,
  NVAPI_GPU_CLOCK_DOMAIN_SYS2 = 17,
  NVAPI_GPU_CLOCK_DOMAIN_HUB2 = 18,
  NVAPI_GPU_CLOCK_DOMAIN_LEG = 19,
  NVAPI_GPU_CLOCK_DOMAIN_PWR = 20,
  NVAPI_GPU_CLOCK_DOMAIN_MSD = 21,
  NVAPI_GPU_CLOCK_DOMAIN_UTILS = 22,
  NVAPI_GPU_CLOCK_DOMAIN_COLD_NV = 23,
  NVAPI_GPU_CLOCK_DOMAIN_COLD_HOTCLK = 24,
  NVAPI_GPU_CLOCK_DOMAIN_LTC2 = 25,
  NVAPI_GPU_CLOCK_DOMAIN_2D = 26,
  NVAPI_GPU_CLOCK_DOMAIN_3D = 27,
  NVAPI_GPU_CLOCK_DOMAIN_HOST1X = 28,
  NVAPI_GPU_CLOCK_DOMAIN_DISP0 = 29,
  NVAPI_GPU_CLOCK_DOMAIN_DISP1 = 30,
  NVAPI_GPU_CLOCK_DOMAIN_PCIEGEN = 31,
  NVAPI_GPU_CLOCK_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_CLOCKS,
} NV_GPU_CLOCK_DOMAIN_ID;
typedef enum {
  NV_GPU_CLOCK_PSTATE_USAGE_FIXED = 0x0,
  NV_GPU_CLOCK_PSTATE_USAGE_PSTATE = 0x1,
  NV_GPU_CLOCK_PSTATE_USAGE_DECOUPLED = 0x2,
  NV_GPU_CLOCK_PSTATE_USAGE_RATIO = 0x3,
} NV_GPU_CLOCK_INFO_DOMAIN_PSTATE_USAGE;
typedef struct {
  NvU32 frequency;
  NvU32 bIsPresent : 1;
  NvU32 bDrivingDDR : 1;
  NvU32 bSetClock : 1;
  NvU32 pstateUsage : 2;
  NvU32 reserved : 27;
} NV_GPU_CLOCK_INFO_DOMAIN;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_INFO_DOMAIN domain[NVAPI_MAX_GPU_CLOCKS];
} NV_GPU_CLOCK_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_INFO_DOMAIN domain[NVAPI_MAX_GPU_CLOCKS];
  struct {
    NvU32 effectiveFrequency;
    NV_GPU_CLOCK_DOMAIN_ID ratioDomain;
    NvU32 ratio;
    NvU32 reserved[4];
  } extendedDomain[NVAPI_MAX_GPU_CLOCKS];
} NV_GPU_CLOCK_INFO_V2;
typedef NV_GPU_CLOCK_INFO_V2 NV_GPU_CLOCK_INFO;
#define NV_GPU_CLOCK_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_INFO_V1, 1)
#define NV_GPU_CLOCK_INFO_VER_2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_INFO_V2, 2)
#define NV_GPU_CLOCK_INFO_VER NV_GPU_CLOCK_INFO_VER_2
typedef enum _NV_GPU_PERF_PSTATE_ID {
  NVAPI_GPU_PERF_PSTATE_P0 = 0,
  NVAPI_GPU_PERF_PSTATE_P1,
  NVAPI_GPU_PERF_PSTATE_P2,
  NVAPI_GPU_PERF_PSTATE_P3,
  NVAPI_GPU_PERF_PSTATE_P4,
  NVAPI_GPU_PERF_PSTATE_P5,
  NVAPI_GPU_PERF_PSTATE_P6,
  NVAPI_GPU_PERF_PSTATE_P7,
  NVAPI_GPU_PERF_PSTATE_P8,
  NVAPI_GPU_PERF_PSTATE_P9,
  NVAPI_GPU_PERF_PSTATE_P10,
  NVAPI_GPU_PERF_PSTATE_P11,
  NVAPI_GPU_PERF_PSTATE_P12,
  NVAPI_GPU_PERF_PSTATE_P13,
  NVAPI_GPU_PERF_PSTATE_P14,
  NVAPI_GPU_PERF_PSTATE_P15,
  NVAPI_GPU_PERF_PSTATE_UNDEFINED = NVAPI_MAX_GPU_PERF_PSTATES,
  NVAPI_GPU_PERF_PSTATE_ALL,
} NV_GPU_PERF_PSTATE_ID;
#define NVAPI_MAX_GPU_PSTATE20_PSTATES 16
#define NVAPI_MAX_GPU_PSTATE20_CLOCKS 8
#define NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES 4
typedef enum {
  NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_SINGLE = 0,
  NVAPI_GPU_PERF_PSTATE20_CLOCK_TYPE_RANGE,
} NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID;
typedef struct {
  NvS32 value;
  struct {
    NvS32 min;
    NvS32 max;
  } valueRange;
} NV_GPU_PERF_PSTATES20_PARAM_DELTA;
typedef struct {
  NV_GPU_PUBLIC_CLOCK_ID domainId;
  NV_GPU_PERF_PSTATE20_CLOCK_TYPE_ID typeId;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NV_GPU_PERF_PSTATES20_PARAM_DELTA freqDelta_kHz;
  union {
    struct {
      NvU32 freq_kHz;
    } single;
    struct {
      NvU32 minFreq_kHz;
      NvU32 maxFreq_kHz;
      NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;
      NvU32 minVoltage_uV;
      NvU32 maxVoltage_uV;
    } range;
  } data;
} NV_GPU_PSTATE20_CLOCK_ENTRY_V1;
typedef struct {
  NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NvU32 volt_uV;
  NV_GPU_PERF_PSTATES20_PARAM_DELTA voltDelta_uV;
} NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1;
typedef struct {
  NvU32 version;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NvU32 numPstates;
  NvU32 numClocks;
  NvU32 numBaseVoltages;
  struct {
    NV_GPU_PERF_PSTATE_ID pstateId;
    NvU32 bIsEditable : 1;
    NvU32 reserved : 31;
    NV_GPU_PSTATE20_CLOCK_ENTRY_V1 clocks[NVAPI_MAX_GPU_PSTATE20_CLOCKS];
    NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 baseVoltages[NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES];
  } pstates[NVAPI_MAX_GPU_PSTATE20_PSTATES];
} NV_GPU_PERF_PSTATES20_INFO_V1;
typedef struct _NV_GPU_PERF_PSTATES20_INFO_V2 {
  NvU32 version;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NvU32 numPstates;
  NvU32 numClocks;
  NvU32 numBaseVoltages;
  struct {
    NV_GPU_PERF_PSTATE_ID pstateId;
    NvU32 bIsEditable : 1;
    NvU32 reserved : 31;
    NV_GPU_PSTATE20_CLOCK_ENTRY_V1 clocks[NVAPI_MAX_GPU_PSTATE20_CLOCKS];
    NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 baseVoltages[NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES];
  } pstates[NVAPI_MAX_GPU_PSTATE20_PSTATES];
  struct {
    NvU32 numVoltages;
    NV_GPU_PSTATE20_BASE_VOLTAGE_ENTRY_V1 voltages[NVAPI_MAX_GPU_PSTATE20_BASE_VOLTAGES];
  } ov;
} NV_GPU_PERF_PSTATES20_INFO_V2;
typedef NV_GPU_PERF_PSTATES20_INFO_V2 NV_GPU_PERF_PSTATES20_INFO;
#define NV_GPU_PERF_PSTATES20_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_INFO_V1, 1)
#define NV_GPU_PERF_PSTATES20_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_INFO_V2, 2)
#define NV_GPU_PERF_PSTATES20_INFO_VER3 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_INFO_V2, 3)
#define NV_GPU_PERF_PSTATES20_INFO_VER NV_GPU_PERF_PSTATES20_INFO_VER3
#define NVAPI_MAX_GPU_PSTATE20_CLOCKS_PRIVATE 16
#define NVAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE 8
typedef struct {
  NV_GPU_CLOCK_DOMAIN_ID domainId;
  NV_GPU_CLOCK_INFO_DOMAIN_PSTATE_USAGE usage;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NV_GPU_PERF_PSTATES20_PARAM_DELTA freqDelta_kHz;
  union {
    struct {
      NvU32 freq_kHz;
    } fixed;
    struct {
      NvU32 freq_kHz;
    } pstate;
    struct {
      NvU32 minFreq_kHz;
      NvU32 maxFreq_kHz;
      NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
      NvU32 minVoltage_uV;
      NvU32 maxVoltage_uV;
    } decoupled;
    struct {
      NvU32 minFreq_kHz;
      NvU32 maxFreq_kHz;
    } ratio;
  } data;
} NV_GPU_PSTATE20_PRIVATE_CLOCK_ENTRY_V1;
typedef enum {
  NV_GPU_CLK_CLK_VOLTAGE_TYPE_POR = 0,
  NV_GPU_CLK_CLK_VOLTAGE_TYPE_SOURCE = 1,
} NV_GPU_CLK_CLK_VOLTAGE_TYPE;
typedef enum _NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE {
  NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_LOGICAL = 0x0,
  NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_VDT = 0x1,
  NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_DELTA_ONLY = 0x2,
  NV_GPU_PSTATE30_VOLTAGE_ENTRY_TYPE_VFE = 0x3,
  NV_GPU_PSTATE30_VOLTAGE_ENTRY_TYPE_PSTATE = 0x4,
  NV_GPU_PSTATE30_VOLTAGE_ENTRY_TYPE_VPSTATE = 0x5,
  NV_GPU_PSTATE30_VOLTAGE_ENTRY_TYPE_FREQUENCY = 0x6,
  NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE_UNDEFINED = 0xFF,
} NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE;
typedef struct {
  NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
  NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE type;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NvU32 volt_uV;
  NV_GPU_PERF_PSTATES20_PARAM_DELTA voltDelta_uV;
  union {
    struct {
      NvU32 nominal_uV;
    } logical;
    struct {
      NvU8 vdtIndex;
    } vdt;
  } data;
} NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1;
typedef struct {
  NvU32 nominal_uV;
} NV_GPU_PERF_VOLT_DOM_INFO_DATA_LOGICAL;
typedef struct {
  NvU8 vfeEquIndex;
} NV_GPU_PERF_VOLT_DOM_INFO_DATA_VFE;
typedef struct {
  NvU8 vdtIndex;
} NV_GPU_PERF_VOLT_DOM_INFO_DATA_VDT;
typedef struct {
  NV_GPU_CLOCK_DOMAIN_ID clkDomainId;
  NvU32 freq_kHz;
} NV_GPU_PERF_VOLT_DOM_INFO_DATA_FREQ;
typedef enum {
  NV_GPU_PERF_VOLT_DOM_INFO_PSTATE_FREQ_TYPE_INVALID = 0,
  NV_GPU_PERF_VOLT_DOM_INFO_PSTATE_FREQ_TYPE_MIN,
  NV_GPU_PERF_VOLT_DOM_INFO_PSTATE_FREQ_TYPE_MAX,
  NV_GPU_PERF_VOLT_DOM_INFO_PSTATE_FREQ_TYPE_NOM,
} NV_GPU_PERF_VOLT_DOM_INFO_PSTATE_FREQ_TYPE;
typedef struct {
  NvU8 pstateIndex;
  NV_GPU_PERF_VOLT_DOM_INFO_PSTATE_FREQ_TYPE freqType;
} NV_GPU_PERF_VOLT_DOM_INFO_DATA_PSTATE;
typedef struct {
  NvU8 vpstateIndex;
} NV_GPU_PERF_VOLT_DOM_INFO_DATA_VPSTATE;
typedef union {
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_LOGICAL logical;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_VFE vfe;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_VDT vdt;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_PSTATE pstate;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_VPSTATE vpstate;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_FREQ freq;
  NvU32 rsvd[64];
} NV_GPU_PSTATE_VOLTAGE_ENTRY_DATA_V1;
typedef union {
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_LOGICAL logical;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_VFE vfe;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_VDT vdt;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_PSTATE pstate;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_VPSTATE vpstate;
  NV_GPU_PERF_VOLT_DOM_INFO_DATA_FREQ freq;
  NvU8 rsvd[32];
} NV_GPU_PSTATE_VOLTAGE_ENTRY_DATA_V2;
typedef struct {
  NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
  NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE type;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NV_GPU_VOLT_VOLT_DOMAIN_TYPE voltageDomain;
  NvU32 volt_uV;
  NV_GPU_PERF_PSTATES20_PARAM_DELTA voltDelta_uV;
  NvU32 rsvd[29];
  NV_GPU_PSTATE_VOLTAGE_ENTRY_DATA_V1 data;
} NV_GPU_PSTATE_VOLTAGE_ENTRY_V1;
typedef struct {
  NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
  NV_GPU_PSTATE20_VOLTAGE_ENTRY_TYPE type;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NV_GPU_VOLT_VOLT_DOMAIN_TYPE voltageDomain;
  NvU32 volt_uV;
  NV_GPU_PERF_PSTATES20_PARAM_DELTA voltDelta_uV;
  NvU8 rsvd[32];
  NV_GPU_PSTATE_VOLTAGE_ENTRY_DATA_V2 data;
} NV_GPU_PSTATE_VOLTAGE_ENTRY_V2;
typedef NV_GPU_PSTATE_VOLTAGE_ENTRY_V1 NV_GPU_PSTATE30_VOLTAGE_ENTRY_V1;
typedef NV_GPU_PSTATE_VOLTAGE_ENTRY_V2 NV_GPU_PSTATE30_VOLTAGE_ENTRY_V2;
typedef NV_GPU_PSTATE_VOLTAGE_ENTRY_DATA_V1 NV_GPU_PSTATE30_VOLTAGE_ENTRY_DATA_V1;
typedef NV_GPU_PSTATE_VOLTAGE_ENTRY_DATA_V2 NV_GPU_PSTATE30_VOLTAGE_ENTRY_DATA_V2;
typedef NV_GPU_PSTATE_VOLTAGE_ENTRY_V2 NV_GPU_PSTATE_VOLTAGE_ENTRY;
typedef NV_GPU_PSTATE_VOLTAGE_ENTRY_DATA_V2 NV_GPU_PSTATE_VOLTAGE_ENTRY_DATA;
typedef struct {
  NvU32 version;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NvU32 numPstates;
  NvU32 numClocks;
  NvU32 numVoltages;
  struct {
    NV_GPU_PERF_PSTATE_ID pstateId;
    NvU32 bIsEditable : 1;
    NvU32 reserved : 31;
    NV_GPU_PSTATE20_PRIVATE_CLOCK_ENTRY_V1 clocks[NVAPI_MAX_GPU_PSTATE20_CLOCKS_PRIVATE];
    NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1 voltages[NVAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE];
  } pstates[NVAPI_MAX_GPU_PSTATE20_PSTATES];
} NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V1;
typedef struct _NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V2 {
  NvU32 version;
  NvU32 bIsEditable : 1;
  NvU32 bSetPStates20InternalTestFlag : 1;
  NvU32 reserved : 30;
  NvU32 numPstates;
  NvU32 numClocks;
  NvU32 numVoltages;
  struct {
    NV_GPU_PERF_PSTATE_ID pstateId;
    NvU32 bIsEditable : 1;
    NvU32 reserved : 31;
    NV_GPU_PSTATE20_PRIVATE_CLOCK_ENTRY_V1 clocks[NVAPI_MAX_GPU_PSTATE20_CLOCKS_PRIVATE];
    NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1 voltages[NVAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE];
  } pstates[NVAPI_MAX_GPU_PSTATE20_PSTATES];
  struct {
    NvU32 numVoltages;
    NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1 voltages[NVAPI_MAX_GPU_PSTATE20_VOLTAGES_PRIVATE];
  } ov;
} NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V2;
typedef NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V2 NV_GPU_PERF_PSTATES20_PRIVATE_INFO;
#define NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V1, 1)
#define NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES20_PRIVATE_INFO_V2, 2)
#define NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER NV_GPU_PERF_PSTATES20_PRIVATE_INFO_VER2
#define NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1 32
#define NV_GPU_CLK_CLK_DELTA_MAX_VOLT_RAILS 04
typedef enum {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_2X = 0x0,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_3X = 0x1,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_3X_FIXED = 0x2,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_3X_PROG = 0x3,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_3X_MASTER = 0x4,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_3X_SLAVE = 0x5,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_30_PROG = 0x6,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_30_MASTER = 0x4,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_30_SLAVE = 0x5,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_35_PROG = 0x7,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_35_MASTER = 0x8,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_35_SLAVE = 0x9,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_40_PROG = 0xa,
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CLOCK_CLK_DOMAIN_TYPE;
typedef struct {
  NvU32 bMilliWattValid : 1;
  NvU32 reserved : 31;
  NvU32 mp;
  NvU32 mW;
} NV_GPU_CLIENT_POWER_READING_V1;
typedef enum {
  NV_GPU_CLIENT_PFF_CURVE_TUPLE_POWER,
  NV_GPU_CLIENT_PFF_CURVE_TUPLE_TEMPERATURE,
} NV_GPU_CLIENT_PFF_CURVE_TUPLE_TYPE;
typedef struct {
  NV_GPU_CLIENT_PFF_CURVE_TUPLE_TYPE type;
  NvU32 freqkHz;
  union {
    NV_GPU_CLIENT_POWER_READING_V1 power;
    NvS32 temperature;
  };
} NV_GPU_CLIENT_PFF_CURVE_TUPLE_V1;
typedef struct {
  NvU32 freqkHz;
} NV_GPU_CLIENT_PFF_CURVE_TUPLE_STATUS_V1;
#define NV_GPU_CLIENT_PFF_CURVE_NUM_TUPLES 3
typedef struct {
  NV_GPU_CLIENT_PFF_CURVE_TUPLE_V1
  tuples[NV_GPU_CLIENT_PFF_CURVE_NUM_TUPLES];
} NV_GPU_CLIENT_PFF_CURVE_V1;
typedef struct {
  NV_GPU_CLIENT_PFF_CURVE_TUPLE_STATUS_V1
  tuples[NV_GPU_CLIENT_PFF_CURVE_NUM_TUPLES];
} NV_GPU_CLIENT_PFF_CURVE_STATUS_V1;
typedef NvU16 NV_GPU_BOARDOBJ_IDX;
typedef NvU16 NvBoardObjIdx;
#define NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS (32)
#define NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS (255)
#define NV_GPU_BOARDOBJGRP_E512_MAX_OBJECTS (512)
#define NV_GPU_BOARDOBJGRP_E1024_MAX_OBJECTS (1024)
#define NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_BIT_SIZE 32
#define NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_INDEX(_bit) ((_bit) / NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_BIT_SIZE)
#define NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_OFFSET(_bit) ((_bit) % NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_BIT_SIZE)
#define NV_GPU_BOARDOBJGRP_MASK_DATA_SIZE(_bits) (NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_INDEX((_bits) - 1) + 1)
#define NV_GPU_BOARDOBJGRP_MASK_ARRAY_START_SIZE 1
#define NV_GPU_BOARDOBJGRP_MASK_ARRAY_EXTENSION_SIZE(_bits)                                                            \
  (NV_GPU_BOARDOBJGRP_MASK_DATA_SIZE(_bits) - NV_GPU_BOARDOBJGRP_MASK_ARRAY_START_SIZE)
#define NV_GPU_BOARDOBJGRP_MASK_FOR_EACH_INDEX(_maxObjects, _index, _pMask)                                            \
  {                                                                                                                    \
    for (_index = 0; _index < _maxObjects; _index++) {                                                                 \
      if (0 == (NV_BIT(NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_OFFSET(_index)) &                                          \
                ((const NvU32 *)(_pMask)->pData)[NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_INDEX(_index)])) {               \
        continue;                                                                                                      \
      }
#define NV_GPU_BOARDOBJGRP_MASK_FOR_EACH_INDEX_END                                                                     \
  }                                                                                                                    \
  }
#define NV_GPU_BOARDOBJGRP_MASK_BIT_IS_SET(_index, _pMask)                                                             \
  (0 != (NV_BIT(NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_OFFSET(_index)) &                                                 \
         ((const NvU32 *)(_pMask)->pData)[NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_INDEX(_index)]))
#define NV_GPU_BOARDOBJGRP_MASK_BIT_SET(_pMask, _bitIdx)                                                               \
  do {                                                                                                                 \
    (_pMask)->pData[NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_INDEX(_bitIdx)] |=                                            \
        NVBIT_TYPE(NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_OFFSET(_bitIdx), NvU32);                                       \
  } while (NV_FALSE)
#define NV_GPU_BOARDOBJGRP_MASK_BIT_CLR(_pMask, _bitIdx)                                                               \
  do {                                                                                                                 \
    (_pMask)->pData[NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_INDEX(_bitIdx)] &=                                            \
        ~NVBIT_TYPE(NV_GPU_BOARDOBJGRP_MASK_MASK_ELEMENT_OFFSET(_bitIdx), NvU32);                                      \
  } while (NV_FALSE)
#define NV_GPU_BOARDOBJGRP_MASK_E32_FOR_EACH_INDEX(_index, _pMask)                                                     \
  NV_GPU_BOARDOBJGRP_MASK_FOR_EACH_INDEX(NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS, _index, _pMask)
#define NV_GPU_BOARDOBJGRP_MASK_E255_FOR_EACH_INDEX(_index, _pMask)                                                    \
  NV_GPU_BOARDOBJGRP_MASK_FOR_EACH_INDEX(NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS, _index, _pMask)
#define NV_GPU_BOARDOBJGRP_MASK_E512_FOR_EACH_INDEX(_index, _pMask)                                                    \
  NV_GPU_BOARDOBJGRP_MASK_FOR_EACH_INDEX(NV_GPU_BOARDOBJGRP_E512_MAX_OBJECTS, _index, _pMask)
#define NV_GPU_BOARDOBJGRP_MASK_E1024_FOR_EACH_INDEX(_index, _pMask)                                                   \
  NV_GPU_BOARDOBJGRP_MASK_FOR_EACH_INDEX(NV_GPU_BOARDOBJGRP_E1024_MAX_OBJECTS, _index, _pMask)
#define NV_GPU_BOARDOBJGRP_MASK_INIT(_pMask, _bitSize)                                                                 \
  do {                                                                                                                 \
    NvU8 _dataCount = NV_GPU_BOARDOBJGRP_MASK_DATA_SIZE(_bitSize);                                                     \
    NvU8 _dataIndex;                                                                                                   \
    for (_dataIndex = 0; _dataIndex < _dataCount; _dataIndex++) { ((NvU32 *)(_pMask)->pData)[_dataIndex] = 0U; }       \
  } while (NV_FALSE)
#define NV_GPU_BOARDOBJGRP_MASK_COPY_E512_TO_E255(_pMaskE512, _pMaskE255)                                              \
  do {                                                                                                                 \
    NvU8 _dataCount = NV_GPU_BOARDOBJGRP_MASK_DATA_SIZE(NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS);                          \
    NvU8 _dataIndex;                                                                                                   \
    for (_dataIndex = 0; _dataIndex < _dataCount; _dataIndex++) {                                                      \
      ((NvU32 *)(_pMaskE255)->pData)[_dataIndex] = ((const NvU32 *)(_pMaskE512)->pData)[_dataIndex];                   \
    }                                                                                                                  \
  } while (NV_FALSE)
#define NV_GPU_BOARDOBJGRP_MASK_E32_INIT(_pMask)                                                                       \
  NV_GPU_BOARDOBJGRP_MASK_INIT(_pMask, NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS)
#define NV_GPU_BOARDOBJGRP_MASK_E255_INIT(_pMask)                                                                      \
  NV_GPU_BOARDOBJGRP_MASK_INIT(_pMask, NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS)
#define NV_GPU_BOARDOBJGRP_MASK_E512_INIT(_pMask)                                                                      \
  NV_GPU_BOARDOBJGRP_MASK_INIT(_pMask, NV_GPU_BOARDOBJGRP_E512_MAX_OBJECTS)
#define NV_GPU_BOARDOBJGRP_MASK_E1024_INIT(_pMask)                                                                     \
  NV_GPU_BOARDOBJGRP_MASK_INIT(_pMask, NV_GPU_BOARDOBJGRP_E1024_MAX_OBJECTS)
typedef struct {
  NvU32 pData[NV_GPU_BOARDOBJGRP_MASK_ARRAY_START_SIZE];
} NV_GPU_BOARDOBJGRP_MASK;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK super;
} NV_GPU_BOARDOBJGRP_MASK_E32;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK super;
  NvU32 pDataE255[NV_GPU_BOARDOBJGRP_MASK_ARRAY_EXTENSION_SIZE(NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS)];
} NV_GPU_BOARDOBJGRP_MASK_E255;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK super;
  NvU32 pDataE512[NV_GPU_BOARDOBJGRP_MASK_ARRAY_EXTENSION_SIZE(NV_GPU_BOARDOBJGRP_E512_MAX_OBJECTS)];
} NV_GPU_BOARDOBJGRP_MASK_E512;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK super;
  NvU32 pDataE1024[NV_GPU_BOARDOBJGRP_MASK_ARRAY_EXTENSION_SIZE(NV_GPU_BOARDOBJGRP_E1024_MAX_OBJECTS)];
} NV_GPU_BOARDOBJGRP_MASK_E1024;
#define NV_GPU_BOARDOBJ_IDX_INVALID_8BIT 255
#define NV_GPU_BOARDOBJ_GRP_IDX_TO_8BIT(grpIdx)                                                                        \
  ((grpIdx > NV_GPU_BOARDOBJ_IDX_INVALID_8BIT) ? (NvU8)NV_GPU_BOARDOBJ_IDX_INVALID_8BIT : (NvU8)grpIdx)
#define NV_GPU_VOLT_VOLT_RAIL_CLIENT_MAX_RAILS (0x04)
#define NV_GPU_CLOCK_CLK_DOMAIN_CLIENT_MAX_DOMAINS_V1 NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS
#define NV_GPU_MC_POWERGATING_ENGINE_ID_GRAPHICS (0x00000000)
#define NV_GPU_MC_POWERGATING_ENGINE_ID_VIDEO (0x00000001)
#define NV_GPU_MC_POWERGATING_ENGINE_ID_GR_PASSIVE (0x00000001)
#define NV_GPU_MC_POWERGATING_ENGINE_ID_GR_RG (0x00000002)
#define NV_GPU_MC_POWERGATING_ENGINE_ID_DI (0x00000003)
#define NV_GPU_MC_POWERGATING_ENGINE_ID_MS (0x00000004)
#define NV_GPU_MC_POWERGATING_ENGINE_ID_EI (0x00000005)
#define NV_GPU_MC_POWERGATING_ENGINE_ID_MAX (0x00000006)
typedef enum {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE_RPPM_1X = 0x0,
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE_WORKLOAD_SINGLE_1X,
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE_WORKLOAD_COMBINED_1X,
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE_DLPPM_1X,
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE_TGP_1X,
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE_UNUSED = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE,
    *PNV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE;
#define NV_GPU_VOLT_CLK_ADC_ACC_SAMPLE_MAX 13
typedef struct {
  NvU8 sampledCode;
  NvU32 actualVoltageuV;
  NvU32 correctedVoltageuV;
  NvU32 adcAccumulatorVal;
  NvU32 adcNumSamplesVal;
} NV_GPU_VOLT_ADC_ACC_SAMPLE, *PNV_GPU_VOLT_ADC_ACC_SAMPLE;
typedef enum {
  NV_GPU_VOLT_VOLT_RAIL_SENSED_VOLTAGE_MODE_MIN = 0x00U,
  NV_GPU_VOLT_VOLT_RAIL_SENSED_VOLTAGE_MODE_MAX,
  NV_GPU_VOLT_VOLT_RAIL_SENSED_VOLTAGE_MODE_AVG,
  NV_GPU_VOLT_VOLT_RAIL_SENSED_VOLTAGE_MODE_NUM,
} NV_GPU_VOLT_VOLT_RAIL_SENSED_VOLTAGE_MODE_ENUM;
typedef struct {
  NV_GPU_VOLT_ADC_ACC_SAMPLE
  clkAdcAccSample[NV_GPU_VOLT_CLK_ADC_ACC_SAMPLE_MAX];
  NvU8 numSamples;
  NvU8 mode;
  NvU32 voltageuV;
} NV_GPU_VOLT_RAIL_SENSED_VOLTAGE_DATA, *PNV_GPU_VOLT_RAIL_SENSED_VOLTAGE_DATA;
typedef struct {
  NvU64 tickCnt;
  NvU64 timens;
} NV_GPU_CLOCK_COUNTER_SAMPLE_V2;
typedef struct {
  NvU32 freqkHz;
  NvU32 voltuV;
  NvU8 rsvd[32];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_WORKLOAD_SINGLE_1X_INDEPENDENT_DOMAIN_VMIN_V1;
typedef struct {
  NvU32 voltFlooruV;
  NvU32 railVminuV;
  NV_GPU_BOARDOBJGRP_MASK_E32 independentClkDomainMask;
  NvU8 rsvd[64];
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_WORKLOAD_SINGLE_1X_INDEPENDENT_DOMAIN_VMIN_V1
      domains[NV_GPU_CLOCK_CLK_DOMAIN_CLIENT_MAX_DOMAINS_V1];
  NvU8 rsvd2[64];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_WORKLOAD_SINGLE_1X_INDEPENDENT_DOMAINS_VMIN_V1;
typedef struct {
  NvU32 freqMHz;
  NvU32 leakagemX;
  NvU32 voltmV;
  NvU32 voltFlooruV;
  NvU32 observedVal;
  NvU32 workload;
  NV_GPU_BOARDOBJGRP_MASK_E32 independentClkDomainMask;
  NV_GPU_CLOCK_COUNTER_SAMPLE_V2 clkCntrStart;
  NV_GPU_VOLT_RAIL_SENSED_VOLTAGE_DATA sensed;
  NvU32 lpwrResidency[NV_GPU_MC_POWERGATING_ENGINE_ID_MAX];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_SINGLE_1X_V1,
    *PNV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_SINGLE_1X_V1;
typedef struct {
  NvU32 freqMHz;
  NvU32 leakagemX;
  NvU32 voltmV;
  NvU32 voltFlooruV;
  NvU32 observedVal;
  NvU32 workload;
  NV_GPU_BOARDOBJGRP_MASK_E32 independentClkDomainMask;
  NV_GPU_CLOCK_COUNTER_SAMPLE_V2 clkCntrStart;
  NV_GPU_VOLT_RAIL_SENSED_VOLTAGE_DATA sensed;
  NvU8 rsvd[128];
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_WORKLOAD_SINGLE_1X_INDEPENDENT_DOMAINS_VMIN_V1 independentDomainsVmin;
  NvU32 lpwrResidency[NV_GPU_MC_POWERGATING_ENGINE_ID_MAX];
  NvU32 freqSoftFloorMHz;
  NvU32 freqFmaxVminMHz;
  NvU8 rsvd2[120];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_SINGLE_1X_V2,
    *PNV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_SINGLE_1X_V2;
typedef struct {
  NvU32 workload;
  NvU32 leakagemX;
  NvU32 voltmV;
  NvU32 freqMHz;
  NvU32 effectiveFreqMHz;
  NvU32 estimatedVal;
  NvU32 freqFloorMHz;
  NvU32 estimatedValFloor;
  NvU32 lpwrResidency[NV_GPU_MC_POWERGATING_ENGINE_ID_MAX];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_SINGLE_1X_V1,
    *PNV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_SINGLE_1X_V1;
typedef struct {
  NvU32 workload;
  NvU32 leakagemX;
  NvU32 voltmV;
  NvU32 freqMHz;
  NvU32 effectiveFreqMHz;
  NvU32 estimatedVal;
  NvU32 freqFloorMHz;
  NvU32 estimatedValFloor;
  NvU8 rsvd[128];
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_WORKLOAD_SINGLE_1X_INDEPENDENT_DOMAINS_VMIN_V1 independentDomainsVmin;
  NvU32 lpwrResidency[NV_GPU_MC_POWERGATING_ENGINE_ID_MAX];
  NvU8 rsvd2[128];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_SINGLE_1X_V2,
    *PNV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_SINGLE_1X_V2;
#define NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_MAX 2
typedef struct {
  NvU32 observedVal;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_SINGLE_1X_V1
  singles[NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_MAX];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_COMBINED_1X_V1,
    *PNV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_COMBINED_1X_V1;
typedef struct {
  NvU32 observedVal;
  NvU8 rsvd[1024];
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_SINGLE_1X_V2
  singles[NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_MAX];
  NvU8 rsvd2[256];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_COMBINED_1X_V2,
    *PNV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_COMBINED_1X_V2;
typedef struct {
  NvU32 estimatedVal;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_SINGLE_1X_V1
  singles[NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_MAX];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_COMBINED_1X_V1,
    *PNV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_COMBINED_1X_V1;
typedef struct {
  NvU32 estimatedVal;
  NvU8 rsvd[256];
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_SINGLE_1X_V2
  singles[NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_MAX];
  NvU8 rsvd2[256];
} NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_COMBINED_1X_V2,
    *PNV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_COMBINED_1X_V2;
typedef struct _NV_GPU_PMUMON_SAMPLE_SUPER_V1 {
  NvU64 gpuTimeStamp;
  NvU64 cpuTimeStamp;
  NvU8 rsvd[64];
} NV_GPU_PMUMON_SAMPLE_SUPER_V1;
typedef struct _NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 {
  NvU32 tailIndex;
  NvU32 sequenceId;
  NvU32 headIndex;
  NvU32 numSamples;
  NvU32 resetCount;
  NvU8 rsvd[60];
} NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1;
NVAPI_INTERFACE NvAPI_3DVP_CreateContext(Nv3DVPContextHandle *phContext);
NVAPI_INTERFACE NvAPI_3DVP_DestroyContext(Nv3DVPContextHandle hContext);
NVAPI_INTERFACE NvAPI_3DVP_EnumTransceiver(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle *phTransceiver);
typedef enum _NVAPI_3DVP_ACCESS {
  NVAPI_3DVP_ACC_NONE = 0,
  NVAPI_3DVP_ACC_READ,
  NVAPI_3DVP_ACC_READWRITE,
  NVAPI_3DVP_ACC_COUNT,
} NVAPI_3DVP_ACCESS;
NVAPI_INTERFACE NvAPI_3DVP_OpenTransceiver(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                           NVAPI_3DVP_ACCESS access);
NVAPI_INTERFACE NvAPI_3DVP_OpenTransceiverPriviledged(Nv3DVPContextHandle hContext,
                                                      Nv3DVPTransceiverHandle hTransceiver, NVAPI_3DVP_ACCESS access);
NVAPI_INTERFACE NvAPI_3DVP_CloseTransceiver(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver);
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverAccess(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                                NVAPI_3DVP_ACCESS *pAccess);
NVAPI_INTERFACE NvAPI_3DVP_ResetTransceiverToFactorySettings(Nv3DVPContextHandle hContext,
                                                             Nv3DVPTransceiverHandle hTransceiver);
typedef struct {
  NvU8 a0;
  NvU8 a1;
  NvU8 a2;
  NvU8 a3;
  NvU8 a4;
} NVAPI_3DVP_RF_ADDRESS;
#define NVAPI_3DVP_SERIAL_NUMBER_LENGTH 13
typedef NvU8 NVAPI_3DVP_SERIAL_NUMBER[NVAPI_3DVP_SERIAL_NUMBER_LENGTH];
typedef struct {
  NvU32 version;
  NvU32 hwFeatures;
  NvU32 fwRevA;
  NvU32 fwRevB;
  NvU32 fwRevC;
  NVAPI_3DVP_RF_ADDRESS rfAddress;
  NvU32 channelCount;
  NVAPI_3DVP_SERIAL_NUMBER serialNumber;
  NvU32 isEmbedded;
} NVAPI_3DVP_TRANSCEIVER_INFO;
#define NVAPI_3DVP_TRANSCEIVER_INFO_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_TRANSCEIVER_INFO, 2)
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverInfo(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                              NVAPI_3DVP_TRANSCEIVER_INFO *pInfo);
NVAPI_INTERFACE NvAPI_3DVP_IsAirplaneModeEnabled(__in Nv3DVPContextHandle hContext,
                                                 __in Nv3DVPTransceiverHandle hTransceiver, __out NvU32 *pEnabled);
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverSignalQuality(__in Nv3DVPContextHandle hContext,
                                                       __in Nv3DVPTransceiverHandle hTransceiver, __out NvU8 *pQuality);
typedef struct {
  NvU32 version;
  NvU32 frequency;
  NvU32 quality;
} NVAPI_3DVP_CHANNEL_INFO;
#define NVAPI_3DVP_CHANNEL_INFO_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_CHANNEL_INFO, 1)
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverChannelInfo(__in Nv3DVPContextHandle hContext,
                                                     __in Nv3DVPTransceiverHandle hTransceiver, __in NvU32 channelIndex,
                                                     __inout NVAPI_3DVP_CHANNEL_INFO *pInfo);
typedef struct {
  NvU8 c0;
  NvU8 c1;
  NvU8 c2;
  NvU8 c3;
} NVAPI_3DVP_CHANNELS;
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverChannels(__in Nv3DVPContextHandle hContext,
                                                  __in Nv3DVPTransceiverHandle hTransceiver,
                                                  __out NVAPI_3DVP_CHANNELS *pChannels);
NVAPI_INTERFACE NvAPI_3DVP_SetTransceiverChannels(__in Nv3DVPContextHandle hContext,
                                                  __in Nv3DVPTransceiverHandle hTransceiver,
                                                  __in_opt NVAPI_3DVP_CHANNELS *pChannels);
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverChannel(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                                 NvU32 *pChannelIndex);
NVAPI_INTERFACE NvAPI_3DVP_SetTransceiverChannel(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                                 NvU32 channelIndex);
typedef enum _NVAPI_3DVP_TRANSCEIVER_MODE {
  NVAPI_3DVP_TM_INVALID = 0,
  NVAPI_3DVP_TM_LOW_RANGE,
  NVAPI_3DVP_TM_MEDIUM_RANGE,
  NVAPI_3DVP_TM_HIGH_RANGE,
  NVAPI_3DVP_TM_COUNT,
} NVAPI_3DVP_TRANSCEIVER_MODE;
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverMode(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                              NVAPI_3DVP_TRANSCEIVER_MODE *pMode);
NVAPI_INTERFACE NvAPI_3DVP_SetTransceiverMode(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                              NVAPI_3DVP_TRANSCEIVER_MODE mode);
typedef struct {
  NvU32 version;
  NvU32 button;
  NvS32 wheel;
} NVAPI_3DVP_TRANSCEIVER_STATE;
#define NVAPI_3DVP_TRANSCEIVER_STATE_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_TRANSCEIVER_STATE, 1)
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiverState(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                               NVAPI_3DVP_TRANSCEIVER_STATE *pState);
typedef enum _NVAPI_3DVP_PAIRING_MODE {
  NVAPI_3DVP_PM_STOP_PAIRING = 0,
  NVAPI_3DVP_PM_START_PAIRING_BEACON = 0xFFFFFFFF,
} NVAPI_3DVP_PAIRING_MODE;
NVAPI_INTERFACE NvAPI_3DVP_PairGlasses(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                       NvU32 timeOut);
NVAPI_INTERFACE NvAPI_3DVP_UnpairGlasses(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                         Nv3DVPGlassesHandle hGlasses);
NVAPI_INTERFACE NvAPI_3DVP_DiscoverGlasses(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                           NvU32 timeOut);
NVAPI_INTERFACE NvAPI_3DVP_EnumGlasses(Nv3DVPContextHandle hContext, Nv3DVPTransceiverHandle hTransceiver,
                                       Nv3DVPGlassesHandle *phGlasses);
NVAPI_INTERFACE NvAPI_3DVP_GetTransceiver(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses,
                                          Nv3DVPTransceiverHandle *pTransceiver);
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesAccess(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses,
                                            NVAPI_3DVP_ACCESS *pAccess);
NVAPI_INTERFACE NvAPI_3DVP_IdentifyGlasses(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses);
NVAPI_INTERFACE NvAPI_3DVP_ResetGlassesToFactorySettings(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses);
typedef struct {
  NvU32 version;
  NvU32 hwFeatures;
  NvU32 fwRevA;
  NVAPI_3DVP_RF_ADDRESS rfAddress;
  NVAPI_3DVP_SERIAL_NUMBER serialNumber;
  NvU32 repairCount;
} NVAPI_3DVP_GLASSES_INFO;
#define NVAPI_3DVP_GLASSES_INFO_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_GLASSES_INFO, 2)
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesInfo(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses,
                                          NVAPI_3DVP_GLASSES_INFO *pInfo);
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesSyncCycle(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses,
                                               NvU32 *pSyncCycle);
NVAPI_INTERFACE NvAPI_3DVP_SetGlassesSyncCycle(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses,
                                               NvU32 syncCycle);
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesName(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses,
                                          NvAPI_UnicodeString *pName);
NVAPI_INTERFACE NvAPI_3DVP_SetGlassesName(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses,
                                          NvAPI_UnicodeString name);
typedef struct {
  NvU32 version;
  NvU32 missedCycles;
  NvU32 battery;
  NvU32 batteryVoltage;
  NvU32 batteryCharging;
} NVAPI_3DVP_GLASSES_STATE;
#define NVAPI_3DVP_GLASSES_STATE_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_GLASSES_STATE, 1)
NVAPI_INTERFACE NvAPI_3DVP_GetGlassesState(Nv3DVPContextHandle hContext, Nv3DVPGlassesHandle hGlasses,
                                           NVAPI_3DVP_GLASSES_STATE *pState);
typedef enum _NVAPI_3DVP_EVENT_TYPE {
  NVAPI_3DVP_ET_INVALID = 0,
  NVAPI_3DVP_ET_CONTEXT_DESTROYED,
  NVAPI_3DVP_ET_TRANSCEIVER_ENUM_DIRTY,
  NVAPI_3DVP_ET_TRANSCEIVER_STALLED,
  NVAPI_3DVP_ET_AIRPLANE_MODE_TOGGLED,
  NVAPI_3DVP_ET_SIGNAL_QUALITY_CHANGED,
  NVAPI_3DVP_ET_PAIRING_GLASSES_STARTED,
  NVAPI_3DVP_ET_PAIRING_GLASSES_COMPLETE,
  NVAPI_3DVP_ET_DISCOVERING_GLASSES_STARTED,
  NVAPI_3DVP_ET_DISCOVERING_GLASSES_COMPLETE,
  NVAPI_3DVP_ET_GLASSES_ENUM_DIRTY,
  NVAPI_3DVP_ET_GLASSES_NAMES_CHANGED,
  NVAPI_3DVP_ET_GLASSES_STATES_CHANGED,
  NVAPI_3DVP_ET_COUNT,
} NVAPI_3DVP_EVENT_TYPE;
typedef struct {
  NvU32 version;
  NVAPI_3DVP_EVENT_TYPE type;
  Nv3DVPTransceiverHandle hTransceiver;
} NVAPI_3DVP_EVENT;
#define NVAPI_3DVP_EVENT_VER MAKE_NVAPI_VERSION(NVAPI_3DVP_EVENT, 2)
NVAPI_INTERFACE NvAPI_3DVP_WaitEvent(__in Nv3DVPContextHandle hContext, __inout NVAPI_3DVP_EVENT *pEvent,
                                     __in NvU32 timeout);
typedef struct {
  NvU32 version;
  NvU32 drvVersion;
  NvU32 bldChangeListNum;
  NvAPI_ShortString szBuildBranchString;
  NvAPI_ShortString szAdapterString;
} NV_DISPLAY_DRIVER_VERSION;
#define NV_DISPLAY_DRIVER_VERSION_VER MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_VERSION, 1)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_SYS_GetDriverAndBranchVersion.")
    NVAPI_INTERFACE NvAPI_GetDisplayDriverVersion(NvDisplayHandle hNvDisplay, NV_DISPLAY_DRIVER_VERSION *pVersion);
NVAPI_INTERFACE NvAPI_GetDriverModuleLocation(__in NvAPI_LongString moduleName, __out NvAPI_LongString location);
NVAPI_INTERFACE NvAPI_SYS_GetDriverAndBranchVersion(NvU32 *pDriverVersion, NvAPI_ShortString szBuildBranchString);
typedef struct {
  NvU32 version;
  NvU32 dedicatedVideoMemory;
  NvU32 availableDedicatedVideoMemory;
  NvU32 systemVideoMemory;
  NvU32 sharedSystemMemory;
} NV_DISPLAY_DRIVER_MEMORY_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 dedicatedVideoMemory;
  NvU32 availableDedicatedVideoMemory;
  NvU32 systemVideoMemory;
  NvU32 sharedSystemMemory;
  NvU32 curAvailableDedicatedVideoMemory;
} NV_DISPLAY_DRIVER_MEMORY_INFO_V2;
typedef struct {
  NvU32 version;
  NvU32 dedicatedVideoMemory;
  NvU32 availableDedicatedVideoMemory;
  NvU32 systemVideoMemory;
  NvU32 sharedSystemMemory;
  NvU32 curAvailableDedicatedVideoMemory;
  NvU32 dedicatedVideoMemoryEvictionsSize;
  NvU32 dedicatedVideoMemoryEvictionCount;
} NV_DISPLAY_DRIVER_MEMORY_INFO_V3;
typedef NV_DISPLAY_DRIVER_MEMORY_INFO_V3 NV_DISPLAY_DRIVER_MEMORY_INFO;
#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER_1 MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_MEMORY_INFO_V1, 1)
#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER_2 MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_MEMORY_INFO_V2, 2)
#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER_3 MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_MEMORY_INFO_V3, 3)
#define NV_DISPLAY_DRIVER_MEMORY_INFO_VER NV_DISPLAY_DRIVER_MEMORY_INFO_VER_3
NVAPI_INTERFACE NvAPI_GPU_GetMemoryInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_DISPLAY_DRIVER_MEMORY_INFO *pMemoryInfo);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_GPU_GetMemoryInfo.") NVAPI_INTERFACE
    NvAPI_GetDisplayDriverMemoryInfo(NvDisplayHandle hNvDisplay, NV_DISPLAY_DRIVER_MEMORY_INFO *pMemoryInfo);
typedef struct {
  NvU32 version;
  NvU32 dedicatedVideoMemory;
  NvU32 systemVideoMemory;
  NvU32 sharedSystemMemory;
} NV_DRIVER_MEMORY_INFO;
#define NV_DRIVER_MEMORY_INFO_VER MAKE_NVAPI_VERSION(NV_DRIVER_MEMORY_INFO, 1)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_GPU_GetMemoryInfo.") NVAPI_INTERFACE
    NvAPI_GetDriverMemoryInfo(NvDisplayHandle hNvDisplay, NV_DRIVER_MEMORY_INFO *pMemoryInfo);
NVAPI_INTERFACE NvAPI_GetDisplayDriverBuildTitle(NvDisplayHandle hNvDisplay, NvAPI_String szTitle);
typedef enum {
  NVAPI_COMPILE_TYPE_UNKNONW = 0,
  NVAPI_COMPILE_TYPE_DEBUG = 1,
  NVAPI_COMPILE_TYPE_RELEASE = 2,
  NVAPI_COMPILE_TYPE_DEVELOP = 3
} NVAPI_COMPILE_TYPE;
NVAPI_INTERFACE NvAPI_GetDisplayDriverCompileType(NvDisplayHandle hNvDisplay, NvU32 *pCompileType);
NVAPI_INTERFACE NvAPI_GetDisplayDriverSecurityLevel(NvDisplayHandle hNvDisplay, NvU32 *pdrvSecurityLevel);
#define NV_MAX_NVCONFIG_BUFFER_SIZE (128 * 1024)
typedef struct {
  NvU32 version;
  NvU32 dataSize;
  NvU8 data[NV_MAX_NVCONFIG_BUFFER_SIZE];
} NV_DIAG_NVCONFIG_DATA;
#define NV_DIAG_NVCONFIG_DATA_VER MAKE_NVAPI_VERSION(NV_DIAG_NVCONFIG_DATA, 1)
NVAPI_INTERFACE NvAPI_Diag_GetNvConfigData(NV_DIAG_NVCONFIG_DATA *pNvConfigData);
typedef enum {
  NVAPI_REG_READ_DWORD,
  NVAPI_REG_WRITE_DWORD,
  NVAPI_REG_READ_BINARY,
  NVAPI_REG_WRITE_BINARY,
  NVAPI_REG_DELETE_VALUE,
} NVAPI_REG_ACCESS_TYPE;
#define NV_MAX_REGISTRY_KEY_NAME 1024
#define NV_MAX_REGISTRY_KEY_VALUE_SIZE 32768
typedef struct {
  NvU32 version;
  NVAPI_REG_ACCESS_TYPE iAccessType;
  char pszKeyName[NV_MAX_REGISTRY_KEY_NAME];
  NvU32 cbData;
  void *pvData;
} NV_REGISTRY_DATA;
#define NV_REGISTRY_DATA_VER MAKE_NVAPI_VERSION(NV_REGISTRY_DATA, 1)
NVAPI_INTERFACE NvAPI_AccessDisplayDriverRegistry(NvDisplayHandle hNvDisplay, NV_REGISTRY_DATA *pnvRegData);
NVAPI_INTERFACE NvAPI_GetDisplayDriverRegistryPath(NvDisplayHandle hNvDisplay, NvAPI_String szRegistryPath);
NVAPI_INTERFACE NvAPI_GetUnAttachedDisplayDriverRegistryPath(NvUnAttachedDisplayHandle hNvUnAttachedDisp,
                                                             NvAPI_String szRegistryPath);
#define NVAPI_OGLEXPERT_DETAIL_NONE 0x00000000
#define NVAPI_OGLEXPERT_DETAIL_ERROR 0x00000001
#define NVAPI_OGLEXPERT_DETAIL_SWFALLBACK 0x00000002
#define NVAPI_OGLEXPERT_DETAIL_BASIC_INFO 0x00000004
#define NVAPI_OGLEXPERT_DETAIL_DETAILED_INFO 0x00000008
#define NVAPI_OGLEXPERT_DETAIL_PERFORMANCE_WARNING 0x00000010
#define NVAPI_OGLEXPERT_DETAIL_QUALITY_WARNING 0x00000020
#define NVAPI_OGLEXPERT_DETAIL_USAGE_WARNING 0x00000040
#define NVAPI_OGLEXPERT_DETAIL_ALL 0xFFFFFFFF
#define NVAPI_OGLEXPERT_REPORT_NONE 0x00000000
#define NVAPI_OGLEXPERT_REPORT_ERROR 0x00000001
#define NVAPI_OGLEXPERT_REPORT_SWFALLBACK 0x00000002
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_VERTEX 0x00000004
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_GEOMETRY 0x00000008
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_XFB 0x00000010
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_RASTER 0x00000020
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAGMENT 0x00000040
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_ROP 0x00000080
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_FRAMEBUFFER 0x00000100
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_PIXEL 0x00000200
#define NVAPI_OGLEXPERT_REPORT_PIPELINE_TEXTURE 0x00000400
#define NVAPI_OGLEXPERT_REPORT_OBJECT_BUFFEROBJECT 0x00000800
#define NVAPI_OGLEXPERT_REPORT_OBJECT_TEXTURE 0x00001000
#define NVAPI_OGLEXPERT_REPORT_OBJECT_PROGRAM 0x00002000
#define NVAPI_OGLEXPERT_REPORT_OBJECT_FBO 0x00004000
#define NVAPI_OGLEXPERT_REPORT_FEATURE_SLI 0x00008000
#define NVAPI_OGLEXPERT_REPORT_ALL 0xFFFFFFFF
#define NVAPI_OGLEXPERT_OUTPUT_TO_NONE 0x00000000
#define NVAPI_OGLEXPERT_OUTPUT_TO_CONSOLE 0x00000001
#define NVAPI_OGLEXPERT_OUTPUT_TO_DEBUGGER 0x00000004
#define NVAPI_OGLEXPERT_OUTPUT_TO_CALLBACK 0x00000008
#define NVAPI_OGLEXPERT_OUTPUT_TO_ALL 0xFFFFFFFF
typedef void (*NVAPI_OGLEXPERT_CALLBACK)(unsigned int categoryId, unsigned int messageId, unsigned int detailLevel,
                                         int objectId, const char *messageStr);
NVAPI_INTERFACE NvAPI_OGL_ExpertModeSet(NvU32 expertDetailLevel, NvU32 expertReportMask, NvU32 expertOutputMask,
                                        NVAPI_OGLEXPERT_CALLBACK expertCallback);
NVAPI_INTERFACE NvAPI_OGL_ExpertModeGet(NvU32 *pExpertDetailLevel, NvU32 *pExpertReportMask, NvU32 *pExpertOutputMask,
                                        NVAPI_OGLEXPERT_CALLBACK *pExpertCallback);
NVAPI_INTERFACE NvAPI_OGL_ExpertModeDefaultsSet(NvU32 expertDetailLevel, NvU32 expertReportMask,
                                                NvU32 expertOutputMask);
NVAPI_INTERFACE NvAPI_OGL_ExpertModeDefaultsGet(NvU32 *pExpertDetailLevel, NvU32 *pExpertReportMask,
                                                NvU32 *pExpertOutputMask);
#define NV_PERSIST_FIND_LAST_MODE 0x00000001
#define NV_PERSIST_FIND_LAST_ACTIVE 0x00000002
#define NV_PERSIST_EDID_SUPPLIED 0x80000000
#define NV_PERSIST_FIND_CURRENT 0x00000003
#define MAX_PERSIST_DEVICES 8
typedef struct {
  NvU32 width;
  NvU32 height;
  NvU32 depth;
  NvU32 refresh;
  NvU32 interlaced;
  NvU32 primary : 1;
  NvU32 posx;
  NvU32 posy;
} NV_PERSIST_MODE;
typedef struct {
  NvU32 activeMask;
  NV_TARGET_VIEW_MODE state;
  NvU32 rotation;
  NvU32 scaling;
  NvU32 tvFormat;
  NV_PERSIST_MODE physicalMode;
  NV_PERSIST_MODE virtualMode;
} NV_PERSIST_DATA1;
typedef struct {
  NvU32 activeMask;
  NV_TARGET_VIEW_MODE state;
  NvU32 rotation;
  NvU32 scaling;
  NvU32 tvFormat;
  NV_PERSIST_MODE physicalMode;
  NV_PERSIST_MODE virtualMode;
  NvU32 connectedCRC32CommonEDIDs;
  NvU32 ulUnderscanX;
  NvU32 ulUnderscanY;
} NV_PERSIST_DATA2;
typedef NV_PERSIST_DATA2 NV_PERSIST_DATA;
#define NV_PERSIST_DATA_VER1 MAKE_NVAPI_VERSION(NV_PERSIST_DATA1, 1);
#define NV_PERSIST_DATA_VER2 MAKE_NVAPI_VERSION(NV_PERSIST_DATA2, 2);
#define NV_PERSIST_DATA_VER NV_PERSIST_DATA_VER2
typedef struct {
  NvU32 version;
  NvAPI_LongString lookupKey;
  NvU32 connectedMasks;
  NvU32 count;
  NV_PERSIST_DATA1 target[NVAPI_MAX_VIEW_TARGET];
} NV_PERSIST_DATA_INFO1;
typedef struct {
  NvU32 version;
  NvAPI_LongString lookupKey;
  NvU32 connectedMasks;
  NvU32 count;
  NV_PERSIST_DATA1 target[NVAPI_MAX_VIEW_TARGET];
  NV_EDID connectedEDIDs[NVAPI_MAX_HEADS_PER_GPU];
} NV_PERSIST_DATA_INFO2;
typedef struct {
  NvU32 version;
  NvAPI_LongString lookupKey;
  NvU32 connectedMasks;
  NvU32 count;
  NV_PERSIST_DATA1 target[NVAPI_ADVANCED_MAX_VIEW_TARGET];
  NV_EDID connectedEDIDs[NVAPI_MAX_HEADS_PER_GPU];
} NV_PERSIST_DATA_INFO3;
typedef struct {
  NvU32 version;
  NvAPI_LongString lookupKey;
  NvU32 connectedMasks;
  NvU32 count;
  NV_PERSIST_DATA target[NVAPI_ADVANCED_MAX_VIEW_TARGET];
  NV_EDID connectedEDIDs[NVAPI_MAX_HEADS_PER_GPU];
} NV_PERSIST_DATA_INFO4;
typedef NV_PERSIST_DATA_INFO4 NV_PERSIST_DATA_INFO;
#define NV_PERSIST_DATA_INFO_VER1 MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO1, 1)
#define NV_PERSIST_DATA_INFO_VER2 MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO2, 2)
#define NV_PERSIST_DATA_INFO_VER3 MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO3, 3)
#define NV_PERSIST_DATA_INFO_VER4 MAKE_NVAPI_VERSION(NV_PERSIST_DATA_INFO4, 4)
#define NV_PERSIST_DATA_INFO_VER NV_PERSIST_DATA_INFO_VER4
NVAPI_INTERFACE NvAPI_GetPersistenceData(NvPhysicalGpuHandle hPhysicalGpu, NV_PERSIST_DATA_INFO *pData, NvU32 flags);
NVAPI_INTERFACE NvAPI_SetPersistenceData(NvPhysicalGpuHandle hPhysicalGpu, NV_PERSIST_DATA_INFO *pData);
NVAPI_INTERFACE NvAPI_Diag_DP_ASSR(__in_opt NvPhysicalGpuHandle nvGPUHandle, __in NvU32 outputID, __in NvU32 disable,
                                   __out_opt NvU32 *enabled, __out NvU32 *err);
#define NV_APPENUMFLAG_READ 0x00000000
#define NV_APPENUMFLAG_READERASE 0x00000001
#define NV_APPENUMFLAG_READACTIVE 0x00000002
#define NV_APPENUMFLAG_READERASE_INACTIVE 0x00000003
#define NVAPI_MAX_CODEC_ENTRIES_PER_PROCESSID 32
typedef enum {
  NVAPI_API_UNKNOWN = -1,
  NVAPI_API_OPENGL = 0x1,
  NVAPI_API_DX9 = 0x2,
  NVAPI_API_DX10 = 0x3,
  NVAPI_API_DX9_CUDA = 0x4,
  NVAPI_API_DX10_CUDA = 0x5,
  NVAPI_API_OPENGL_CUDA = 0x6,
  NVAPI_API_DX9_VIDEO = 0x7,
  NVAPI_API_DX10_1 = 0x8,
  NVAPI_API_DX10_1_CUDA = 0x9,
  NVAPI_API_DX11 = 0xA,
  NVAPI_API_DX11_CUDA = 0xB,
  NVAPI_API_CUDA = 0xC,
  NVAPI_API_PHYSX = 0x20,
  NVAPI_API_OPENGL_PHYSX = 0x21,
  NVAPI_API_DX9_PHYSX = 0x22,
  NVAPI_API_DX10_PHYSX = 0x23,
  NVAPI_API_DX10_1_PHYSX = 0x28,
  NVAPI_API_DX11_PHYSX = 0x2A,
  NVAPI_API_OPENCL = 0x40,
  NVAPI_API_OPENGL_OPENCL = 0x41,
  NVAPI_API_DX9_OPENCL = 0x42,
  NVAPI_API_DX10_OPENCL = 0x43,
  NVAPI_API_DX10_1_OPENCL = 0x48,
  NVAPI_API_DX11_OPENCL = 0x4A,
  NVAPI_API_DX12 = 0x80,
  NVAPI_API_DX12_CUDA = 0x8C,
  NVAPI_API_DX12_OPENCL = 0xC0,
  NVAPI_API_DX12_PHYSX = 0xA0,
  NVAPI_API_VULKAN = 0X100,
  NVAPI_API_VULKAN_CUDA = 0x10C,
  NVAPI_API_VULKAN_OPENCL = 0x140,
  NVAPI_API_VULKAN_PHYSX = 0x120,
} NVAPI_API_TYPE;
typedef enum {
  NVAPI_VIDEO_CODEC_UNKNOWN = 0,
  NVAPI_VIDEO_CODEC_MPEG,
  NVAPI_VIDEO_CODEC_H264,
  NVAPI_VIDEO_CODEC_VC1,
  NVAPI_VIDEO_CODEC_MPEG4,
} NVAPI_VIDEO_CODEC_TYPE;
typedef struct {
  NVAPI_VIDEO_CODEC_TYPE codecTypes[NVAPI_MAX_CODEC_ENTRIES_PER_PROCESSID];
  NvU64 instanceCount;
} NVAPI_VIDEO_CODEC_INFO;
typedef enum {
  NVAPI_SLI_NOT_SUPPORTED = 0,
  NVAPI_SLI_DISABLED = 1,
  NVAPI_SLI_BRIDGED = 2,
  NVAPI_SLI_BRIDGELESS = 3
} NVAPI_SLI_STATUS;
typedef enum {
  NVAPI_SURROUND_DISABLED = 0,
  NVAPI_SURROUND_ENABLED_BRIDGED = 1,
  NVAPI_SURROUND_ENABLED_BRIDGELESS = 2
} NVAPI_SURROUND_INFO;
typedef enum _NVAPI_SLI_TOPOLOGY {
  NVAPI_SLI_TOPOLOGY_AUTOSELECT = 0,
  NVAPI_SLI_TOPOLOGY_AFR = 1,
  NVAPI_SLI_TOPOLOGY_SFR = 2,
  NVAPI_SLI_TOPOLOGY_SINGLE = 3,
  NVAPI_SLI_TOPOLOGY_AFR_OF_SFR = 4
} NVAPI_SLI_TOPOLOGY;
typedef struct {
  NVAPI_SLI_TOPOLOGY mode;
  NvU32 numSLIAA;
  NvU32 numSFR;
  NvU32 numAFR;
  NvU32 numActiveGpus;
} NVAPI_SLI_RUNTIME_INFO;
#define NVAPI_FPS_HISTOGRAM_NUM_BUCKETS 32
#define NVAPI_FPS_HIST_MIN 10
#define NVAPI_FPS_HIST_MAX 150
#define NVAPI_FPS_MIN_IN_MS (1000.0 / (NvF32)NVAPI_FPS_HIST_MIN)
#define NVAPI_FPS_MAX_IN_MS (1000.0 / (NvF32)NVAPI_FPS_HIST_MAX)
#define NVAPI_FPS_MS_RESOLUTION ((NVAPI_FPS_MIN_IN_MS - NVAPI_FPS_MAX_IN_MS) / NVAPI_FPS_HISTOGRAM_NUM_BUCKETS)
#define NVAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS 32
#define NVAPI_FPS_DELTA_MIN_RANGE -100.0
#define NVAPI_FPS_DELTA_MAX_RANGE 100.0
#define NVAPI_FPS_DELTA_RESOLUTION                                                                                     \
  ((NVAPI_FPS_DELTA_MAX_RANGE - NVAPI_FPS_DELTA_MIN_RANGE) / (NvF32)NVAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS)
#define NVAPI_FPS_HISTOGRAM_NUM_BUCKETS_EXTENDED 64
#define PSTATE_HISTOGRAM_NUM_BUCKETS 10
#define NVCLK_HISTOGRAM_NUM_BUCKETS 16
#define GPCCLK_HISTOGRAM_NUM_BUCKETS 16
typedef struct {
  NvU32 perFrameCreateTimeHistogram[NVAPI_FPS_HISTOGRAM_NUM_BUCKETS];
  NvU32 perFrameCreateTimeDerivativeHistogram[NVAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS];
  NvU32 pStateHistogram[PSTATE_HISTOGRAM_NUM_BUCKETS];
  float batteryPct;
  float cordedPct;
} NVAPI_GFE_INFO;
typedef struct {
  NvU32 perFrameCreateTimeHistogram[NVAPI_FPS_HISTOGRAM_NUM_BUCKETS_EXTENDED];
  NvU32 perFrameCreateTimeDerivativeHistogram[NVAPI_FRAME_RATE_DERIVATIVE_HISTOGRAM_NUM_BUCKETS];
  NvU32 pStateHistogram[PSTATE_HISTOGRAM_NUM_BUCKETS];
  float batteryPct;
  float cordedPct;
} NVAPI_GFE_INFO_V2;
typedef struct {
  NvU32 isStereoActivated : 1;
  NvU32 isStereoBlocked : 1;
  NvU32 isAnaglyph : 1;
  NvU32 isHDMIStereo : 1;
  NvU32 isHDMIAllowed : 1;
  NvU32 isHDMISupported : 1;
  NvU32 isHDMIProtected : 1;
  NvU32 isHDMIWindowed : 1;
  NvU32 isSliBroadcast : 1;
  NvU32 isClonedMode : 1;
  NvU32 isBulkLicense : 1;
  NvU32 isFullLicense : 1;
  NvU32 isUserLicense : 1;
  NvU32 isPanelReleased : 1;
  NvU32 isTestLicense : 1;
  NvU32 isDisplayIdentified : 1;
  NvU32 isDisplayReleased : 1;
  NvU32 isNB : 1;
  NvU32 isDisableHighVBIOverride : 1;
  NvU32 isDisableAuthentication : 1;
  NvU32 isBrowserStereoApp : 1;
  NvU32 isAeroEnabled : 1;
  NvU32 isGDIWindowModeEnabled : 1;
  NvU32 isGDIWindowModeActivated : 1;
  NvU32 isSandbox : 1;
  NvU32 isGameProfiled : 1;
  NvU32 isNBInternalPanel : 1;
  NvU32 isEnabledInRegistry : 1;
  NvU32 stereoHWType;
} NVAPI_STEREO_RUNTIME_INFO;
#define NVAPI_VRMODE_VALID 0x0001
#define NVAPI_DIRECTMODE_VALID 0x0002
#define NVAPI_VR_SLI_VALID 0x0004
#define NVAPI_MRS_VALID 0x0008
#define NVAPI_SPS_VALID 0x0010
#define NVAPI_LMS_VALID 0x0020
#define NVAPI_FEATURE_MASK 0x0000003F
#define NVAPI_VR_SESSION_TIME 0x8000000000000000
typedef struct {
  NvU64 validInfo;
  union {
    struct {
      NvU32 isVRMode : 1;
      NvU32 isVRDirectMode : 1;
      NvU32 isVRSli : 1;
      NvU32 isMRS : 1;
      NvU32 isSPS : 1;
      NvU32 isLMS : 1;
      NvU32 isReserved0 : 1;
      NvU32 isReserved1 : 1;
      NvU32 isReserved2 : 1;
      NvU32 isReserved3 : 1;
      NvU32 isReserved4 : 1;
      NvU32 isReserved5 : 1;
      NvU32 isReserved6 : 1;
      NvU32 isReserved7 : 1;
    } Bits;
    NvU64 Value;
  } Features;
  NvU64 VRSessionTime;
  NvU32 VRErrorCode;
  NvU32 VRMetaData[64];
  NvU32 Reserved[4];
} NVAPI_VR_RUNTIME_INFO;
typedef struct {
  NvU32 isDXRTActivated : 1;
} NVAPI_DXRT_INFO;
typedef struct {
  NvU32 bIsSystemMuxSwitchCapable : 1;
  NvU32 muxMode;
  NvU32 bIsProcessSwitchingMux : 1;
  NvU32 bIsProcessEarlyMuxSwitch : 1;
  double totalMuxSwitchTime;
  NvS32 muxSwitchResult;
  NvU32 Reserved[4];
} NVAPI_MUX_INFO_V1;
typedef enum _NVAPI_CONTAINER_TYPE {
  NVAPI_CONTAINER_UNINITIALIZED = -1,
  NVAPI_CONTAINER_NONE = 0x0,
  NVAPI_CONTAINER_NATIVE = 0x1,
  NVAPI_CONTAINER_SECURE = 0x2,
  NVAPI_CONTAINER_SESSION_ISOLATED = 0x4
} NVAPI_CONTAINER_TYPE;
typedef struct {
  NvU32 flags;
  NvGUID vmGuid;
} NVAPI_CV_INFO;
typedef struct {
  NVAPI_CONTAINER_TYPE containerType;
  NvGUID vmGuid;
} NVAPI_CV_INFO2;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
} NVAPI_PROCESS_POLL_INFO_V1;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
} NVAPI_PROCESS_POLL_INFO_V2;
#define NVAPI_PATH_MAX_LENGTH 260
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
} NVAPI_PROCESS_POLL_INFO_V3;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
} NVAPI_PROCESS_POLL_INFO_V4;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
} NVAPI_PROCESS_POLL_INFO_V5;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
} NVAPI_PROCESS_POLL_INFO_V6;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
} NVAPI_PROCESS_POLL_INFO_V7;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
  NvU64 activeSessionDuration;
} NVAPI_PROCESS_POLL_INFO_V8;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
  NvU64 activeSessionDuration;
  NVAPI_DXRT_INFO dxrtInfo;
} NVAPI_PROCESS_POLL_INFO_V9;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
  NvU64 activeSessionDuration;
  NVAPI_DXRT_INFO dxrtInfo;
  NVAPI_CV_INFO cvInfo;
  NVAPI_SLI_STATUS sliStatus;
  NVAPI_SURROUND_INFO surroundInfo;
  NvU32 bIsAnselTriggered : 1;
  NvU32 reserved : 31;
} NVAPI_PROCESS_POLL_INFO_V10;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
  NvU64 activeSessionDuration;
  NVAPI_DXRT_INFO dxrtInfo;
  NVAPI_CV_INFO cvInfo;
  NVAPI_SLI_STATUS sliStatus;
  NVAPI_SURROUND_INFO surroundInfo;
  NvU32 bIsAnselTriggered : 1;
  NvU32 reserved : 31;
  NvU32 videoStreamRefCount;
} NVAPI_PROCESS_POLL_INFO_V11;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
  NvU64 activeSessionDuration;
  NVAPI_DXRT_INFO dxrtInfo;
  NVAPI_CV_INFO cvInfo;
  NVAPI_SLI_STATUS sliStatus;
  NVAPI_SURROUND_INFO surroundInfo;
  NvU32 bIsAnselTriggered : 1;
  NvU32 reserved : 31;
  NvU32 videoStreamRefCount;
  NVAPI_CV_INFO2 cvInfo2;
} NVAPI_PROCESS_POLL_INFO_V12;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO_V2 gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
  NvU64 activeSessionDuration;
  NVAPI_DXRT_INFO dxrtInfo;
  NVAPI_CV_INFO cvInfo;
  NVAPI_SLI_STATUS sliStatus;
  NVAPI_SURROUND_INFO surroundInfo;
  NvU32 bIsAnselTriggered : 1;
  NvU32 reserved : 31;
  NvU32 videoStreamRefCount;
  NVAPI_CV_INFO2 cvInfo2;
} NVAPI_PROCESS_POLL_INFO_V13;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO_V2 gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
  NvU64 activeSessionDuration;
  NVAPI_DXRT_INFO dxrtInfo;
  NVAPI_CV_INFO cvInfo;
  NVAPI_SLI_STATUS sliStatus;
  NVAPI_SURROUND_INFO surroundInfo;
  NvU32 bIsAnselTriggered : 1;
  NvU32 reserved : 31;
  NvU32 videoStreamRefCount;
  NVAPI_CV_INFO2 cvInfo2;
  float averageQueuedFrames;
  float gpuBoundFramePct;
} NVAPI_PROCESS_POLL_INFO_V14;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO_V2 gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
  NvU64 activeSessionDuration;
  NVAPI_DXRT_INFO dxrtInfo;
  NVAPI_CV_INFO cvInfo;
  NVAPI_SLI_STATUS sliStatus;
  NVAPI_SURROUND_INFO surroundInfo;
  NvU32 bIsAnselTriggered : 1;
  NvU32 reserved : 31;
  NvU32 videoStreamRefCount;
  NVAPI_CV_INFO2 cvInfo2;
  float averageQueuedFrames;
  float gpuBoundFramePct;
  NVAPI_MUX_INFO_V1 muxInfo;
} NVAPI_PROCESS_POLL_INFO_V15;
typedef struct {
  NvU32 version;
  NVAPI_API_TYPE APIType;
  NvU32 processId;
  NvU64 openTime;
  NvU64 closeTime;
  NvU64 averageFrameRate;
  char exeName[NVAPI_LONG_STRING_MAX];
  NVAPI_VIDEO_CODEC_INFO videoCodecInfo;
  NVAPI_SLI_RUNTIME_INFO sliInfo;
  char pathName[NVAPI_PATH_MAX_LENGTH];
  float minFrameRate;
  float maxFrameRate;
  NVAPI_GFE_INFO_V2 gfeInfo;
  NVAPI_STEREO_RUNTIME_INFO stereoInfo;
  NvAPI_UnicodeString exeNameW;
  NvAPI_UnicodeString pathNameW;
  NvAPI_UnicodeString workingDirNameW;
  NvAPI_UnicodeString cmdLineArgsW;
  char sid[NVAPI_LONG_STRING_MAX];
  NvAPI_UnicodeString packageName;
  NVAPI_VR_RUNTIME_INFO vrInfo;
  NvU64 activeSessionDuration;
  NVAPI_DXRT_INFO dxrtInfo;
  NVAPI_CV_INFO cvInfo;
  NVAPI_SLI_STATUS sliStatus;
  NVAPI_SURROUND_INFO surroundInfo;
  NvU32 bIsAnselTriggered : 1;
  NvU32 reserved : 31;
  NvU32 videoStreamRefCount;
  NVAPI_CV_INFO2 cvInfo2;
  float averageQueuedFrames;
  float gpuBoundFramePct;
  NVAPI_MUX_INFO_V1 muxInfo;
  NvU32 pid;
} NVAPI_PROCESS_POLL_INFO_V16;
typedef NVAPI_PROCESS_POLL_INFO_V16 NVAPI_PROCESS_POLL_INFO;
#define NVAPI_PROCESS_POLL_INFO_VER_1 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V1, 1)
#define NVAPI_PROCESS_POLL_INFO_VER_2 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V2, 2)
#define NVAPI_PROCESS_POLL_INFO_VER_3 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V3, 3)
#define NVAPI_PROCESS_POLL_INFO_VER_4 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V4, 4)
#define NVAPI_PROCESS_POLL_INFO_VER_5 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V5, 5)
#define NVAPI_PROCESS_POLL_INFO_VER_6 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V6, 6)
#define NVAPI_PROCESS_POLL_INFO_VER_7 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V7, 7)
#define NVAPI_PROCESS_POLL_INFO_VER_8 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V8, 8)
#define NVAPI_PROCESS_POLL_INFO_VER_9 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V9, 9)
#define NVAPI_PROCESS_POLL_INFO_VER_10 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V10, 10)
#define NVAPI_PROCESS_POLL_INFO_VER_11 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V11, 11)
#define NVAPI_PROCESS_POLL_INFO_VER_12 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V12, 12)
#define NVAPI_PROCESS_POLL_INFO_VER_13 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V13, 13)
#define NVAPI_PROCESS_POLL_INFO_VER_14 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V14, 14)
#define NVAPI_PROCESS_POLL_INFO_VER_15 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V15, 15)
#define NVAPI_PROCESS_POLL_INFO_VER_16 MAKE_NVAPI_VERSION(NVAPI_PROCESS_POLL_INFO_V16, 16)
#define NVAPI_PROCESS_POLL_INFO_VER NVAPI_PROCESS_POLL_INFO_VER_16
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GetAppStatistics.") NVAPI_INTERFACE
    NvAPI_EnumAppStatistics(NvU32 enumIndex, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo);
#define NVAPI_MAX_PROCESS_INFO_ENTRIES 16
NVAPI_INTERFACE NvAPI_GetAppStatistics(NvU32 *pNum, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo);
NVAPI_INTERFACE NvAPI_GetAppStatisticsVm(NvU32 *pNum, NvU32 flags, NVAPI_PROCESS_POLL_INFO *pProcessInfo);
#define NV_3D_MAX_RANGE 25
typedef enum {
  NV_3D_PROPERTY_AS = 1,
  NV_3D_PROPERTY_AA = 2,
  NV_3D_PROPERTY_AF = 3,
  NV_3D_PROPERTY_MAX_FRAMES = 4,
  NV_3D_PROPERTY_TEX_FILTER = 5,
} NV_3D_PROPERTY;
typedef struct {
  NvU32 version;
  NV_3D_PROPERTY settingName;
  NvU32 flags;
  NvU32 defaultValue;
  NvU32 currentValue;
} NV_3D_SETTING;
typedef struct {
  NvU32 version;
  NV_3D_PROPERTY settingName;
  NvU32 value[NV_3D_MAX_RANGE];
  NvU32 validRangeCount;
} NV_3D_SETTING_RANGE;
#define NV_3D_PROFILE_VERSION MAKE_NVAPI_VERSION(NV_3D_SETTING, 1)
#define NV_3D_PROFILE_RANGE_VERSION MAKE_NVAPI_VERSION(NV_3D_SETTING_RANGE, 1)
NVAPI_INTERFACE NvAPI_3D_GetProperty(NvAPI_ShortString szProfileName, NV_3D_SETTING *p3dSetting);
NVAPI_INTERFACE NvAPI_3D_SetProperty(NvAPI_ShortString szProfileName, NV_3D_SETTING *p3dSetting);
NVAPI_INTERFACE NvAPI_3D_GetPropertyRange(NvAPI_ShortString szProfileName, NV_3D_SETTING_RANGE *p3dsettingRange);
NVAPI_INTERFACE NvAPI_GPU_GetAppStatistics(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pNum, NvU32 flags,
                                           NVAPI_PROCESS_POLL_INFO *pProcessInfo);
NVAPI_INTERFACE NvAPI_GPU_GetAppStatisticsVm(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pNum, NvU32 flags,
                                             NVAPI_PROCESS_POLL_INFO *pProcessInfo);
#define REGISTER_PROCESS_AS_GAME_ID 1
NVAPI_INTERFACE NvAPI_Mjolnir_SetupStreamingSession(__in NvU32 streamingProcessId, __in NvU32 flags);
#define MAX_GAME_IDS 4
#define MAX_PROCESS_IDS 16
typedef struct _NV_MJOLNIR_STREAMING_INFO {
  NvU32 version;
  NvU32 streamingSessionActive;
  NvU32 streamingSessionOwnerId;
  NvU32 fullScreen;
  NvU32 streamingSessionGameIds[MAX_GAME_IDS];
  NvU32 streamingSessionProcessIds[MAX_PROCESS_IDS];
} NV_MJOLNIR_STREAMING_INFO;
#define NV_MJOLNIR_STREAMING_INFO_VER_1 MAKE_NVAPI_VERSION(NV_MJOLNIR_STREAMING_INFO, 1)
NVAPI_INTERFACE NvAPI_Mjolnir_GetStreamingInfo(__inout NV_MJOLNIR_STREAMING_INFO *pStreamingInfo);
#define NV_GPU_POWER_DEVICE_MAX_DEVICES_V1 32
typedef enum _NV_GPU_POWER_DEVICE_TYPE {
  NV_GPU_POWER_DEVICE_TYPE_DISABLED = 0x0,
  NV_GPU_POWER_DEVICE_TYPE_INA219,
  NV_GPU_POWER_DEVICE_TYPE_VT1165,
  NV_GPU_POWER_DEVICE_TYPE_CHL8112,
  NV_GPU_POWER_DEVICE_TYPE_INA209,
  NV_GPU_POWER_DEVICE_TYPE_INA3221,
  NV_GPU_POWER_DEVICE_TYPE_BA00,
  NV_GPU_POWER_DEVICE_TYPE_BA10HW,
  NV_GPU_POWER_DEVICE_TYPE_BA10SW,
  NV_GPU_POWER_DEVICE_TYPE_BA11HW,
  NV_GPU_POWER_DEVICE_TYPE_BA11SW,
  NV_GPU_POWER_DEVICE_TYPE_BA12HW,
  NV_GPU_POWER_DEVICE_TYPE_BA13HW,
  NV_GPU_POWER_DEVICE_TYPE_BA14HW,
  NV_GPU_POWER_DEVICE_TYPE_NCT3933U,
  NV_GPU_POWER_DEVICE_TYPE_GPUADC10,
  NV_GPU_POWER_DEVICE_TYPE_GPUADC11,
  NV_GPU_POWER_DEVICE_TYPE_BA15HW,
  NV_GPU_POWER_DEVICE_TYPE_BA16HW,
  NV_GPU_POWER_DEVICE_TYPE_BA20,
  NV_GPU_POWER_DEVICE_TYPE_GPUADC13,
  NV_GPU_POWER_DEVICE_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_DEVICE_TYPE;
typedef enum _NV_GPU_POWER_DEVICE_POWER_RAIL {
  NV_GPU_POWER_DEVICE_POWER_RAIL_DISABLED = 0x00000000,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_NVVDD = 0x00000001,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_FBVDD = 0x00000002,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_FBVDDQ = 0x00000003,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_FBVDD_Q = 0x00000004,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_PEXVDD = 0x00000005,
  NV_GPU_POWER_DEVICE_POWER_RAIL_OUTPUT_A3V3 = 0x00000006,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_8PIN0 = 0x000000FA,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_8PIN1 = 0x000000FB,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_6PIN0 = 0x000000FC,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_EXT12V_6PIN1 = 0x000000FD,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_PEX3V3 = 0x000000FE,
  NV_GPU_POWER_DEVICE_POWER_RAIL_INPUT_PEX12V = 0x000000FF,
} NV_GPU_POWER_DEVICE_POWER_RAIL;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC10_IPC_SRC_TYPE_NONE = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC10_IPC_SRC_TYPE_ADC,
  NV_GPU_POWER_DEVICE_GPUADC10_IPC_SRC_TYPE_BA,
} NV_GPU_POWER_DEVICE_GPUADC10_IPC_SRC_TYPE,
    *PNV_GPU_POWER_DEVICE_GPUADC10_IPC_SRC_TYPE;
typedef enum {
  NV_GPU_POWER_VIOLATION_THERM_INDEX_TYPE_NONE = 0x00,
  NV_GPU_POWER_VIOLATION_THERM_INDEX_TYPE_EVENT,
  NV_GPU_POWER_VIOLATION_THERM_INDEX_TYPE_MONITOR,
} NV_GPU_POWER_VIOLATION_THERM_INDEX_TYPE,
    *PNV_GPU_POWER_VIOLATION_THERM_INDEX_TYPE;
typedef struct _NV_GPU_POWER_DEVICE_INFO_BA00 {
  NvU8 leakageIdx;
  NvU8 fitIdxFirst;
  NvU8 fitIdxLast;
  NvU8 fitIdxHiPwr;
  NvU32 threshmWHiPwr;
} NV_GPU_POWER_DEVICE_INFO_BA00;
typedef struct _NV_GPU_POWER_DEVICE_INFO_BA1XHW {
  NvU8 scalingEquIdx;
  NvU8 offsetEquIdx;
  NvU8 windowIdx;
  NvU8 sumShift;
  NvU8 winPeriod;
  NvU32 isMeasuringCurrent : 1;
  NvU32 isMonitoringNVVDD : 1;
  NvU32 isMonitoringFBVDDQ : 1;
  NvU32 reserved : 29;
} NV_GPU_POWER_DEVICE_INFO_BA1XHW;
typedef struct _NV_GPU_POWER_DEVICE_INFO_BA15HW {
  NV_GPU_POWER_DEVICE_INFO_BA1XHW super;
  NvU8 gpuAdcDevIdx;
} NV_GPU_POWER_DEVICE_INFO_BA15HW;
typedef struct _NV_GPU_POWER_DEVICE_INFO_BA16HW {
  NV_GPU_POWER_DEVICE_INFO_BA1XHW super;
  NvU8 gpuAdcDevIdx;
  NvBool bMonitorNV;
  NvBool bMonitorMS;
  NvBool bFactorALutEnableNV;
  NvBool bLeakageCLutEnableNV;
  NvBool bIsT1ModeADC;
  NvBool bIsT2ModeADC;
  NvU8 winSize;
  NvU8 stepSize;
  NvBool bFactorALutEnableMS;
  NvBool bLeakageCLutEnableMS;
  NvU8 leakageEquIdxMS;
  NvU8 scalingEquIdxMS;
  NvU8 adcSelNV;
  NvU8 adcSelMS;
  NvU8 pwrDomainGPC;
  NvU8 pwrDomainXBAR;
  NvU8 pwrDomainFBP;
} NV_GPU_POWER_DEVICE_INFO_BA16HW;
#define NV_GPU_POWER_DEVICE_BA20_MAX_CONFIGS 0x2
typedef struct {
  NvU8 voltRailIdx;
  NvBool bFactorALutEnable;
  NvBool bLeakageCLutEnable;
  NvU8 adcSel;
  NvU8 rsvd[40];
} NV_GPU_POWER_DEVICE_INFO_BA20_VOLT_RAIL_DATA;
typedef struct _NV_GPU_POWER_DEVICE_INFO_BA20 {
  NvBool bCurrent;
  NvU8 windowIdx;
  NvU8 gpuAdcDevIdx;
  NvBool bIsT1ModeADC;
  NvBool bIsT2ModeADC;
  NvU8 winSize;
  NvU8 stepSize;
  NvU8 pwrDomainGPC;
  NvU8 pwrDomainXBAR;
  NvU8 pwrDomainFBP;
  NvU16 scaleFactor;
  NV_GPU_POWER_DEVICE_INFO_BA20_VOLT_RAIL_DATA voltRailData[NV_GPU_POWER_DEVICE_BA20_MAX_CONFIGS];
  NvU8 rsvd[40];
} NV_GPU_POWER_DEVICE_INFO_BA20;
typedef struct _NV_GPU_POWER_DEVICE_INFO_BA1XSW {
  NvU8 pwrDeviceIdx;
  NvU32 minSamplingPeriodus;
} NV_GPU_POWER_DEVICE_INFO_BA1XSW;
typedef struct _NV_GPU_POWER_DEVICE_INFO_INA209 {
  NvU16 rShuntmOhm;
  NvU16 calibration;
  NvU16 configuration;
  NvU16 criticalDacPos;
  NvU16 criticalDacNeg;
} NV_GPU_POWER_DEVICE_INFO_INA209;
typedef struct _NV_GPU_POWER_DEVICE_INFO_INA219 {
  NvU16 rShuntmOhm;
  NvU16 calibration;
  NvU16 configuration;
} NV_GPU_POWER_DEVICE_INFO_INA219;
#define NV_GPU_POWER_DEVICE_INFO_INA3221_CH_NUM 0x03
typedef struct _NV_GPU_POWER_DEVICE_INFO_INA3221 {
  NvU16 rShuntmOhm[NV_GPU_POWER_DEVICE_INFO_INA3221_CH_NUM];
  NvU16 configuration;
  NvU16 maskEnable;
  NvU8 gpioFunction;
  NvU16 currCorrectM;
  NvS16 currCorrectB;
} NV_GPU_POWER_DEVICE_INFO_INA3221;
typedef struct _NV_GPU_POWER_DEVICE_INFO_NCT3933U {
  NvU32 defaultLimitmA;
  NvU8 reg04val;
  NvU8 reg05val;
  NvU16 stepSizemA;
} NV_GPU_POWER_DEVICE_INFO_NCT3933U;
#define NV_GPU_POWER_DEVICE_GPUADC10_PROV_UNIT_MV 0x00
#define NV_GPU_POWER_DEVICE_GPUADC10_PROV_UNIT_MA 0x01
#define NV_GPU_POWER_DEVICE_GPUADC10_PROV_UNIT_MW 0x02
#define NV_GPU_POWER_DEVICE_GPUADC10_PROV_UNIT_INVALID 0xFF
typedef struct {
  NV_GPU_POWER_DEVICE_GPUADC10_IPC_SRC_TYPE sourceType;
  union {
    NvU8 provider;
    NvU8 window;
  } index;
  NvU8 providerUnit;
  NvU8 iirGain;
  NvU8 iirLength;
  NvU8 iirDownshift;
  NvU8 propDownshift;
} NV_GPU_POWER_DEVICE_INFO_GPUADC10_IPC_INSTANCE;
#define NV_GPU_POWER_DEVICE_INFO_GPUADC10_IPC_NUM 0x04
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC10_IPC_INSTANCE instance[NV_GPU_POWER_DEVICE_INFO_GPUADC10_IPC_NUM];
  NvU16 compMaxOffset;
} NV_GPU_POWER_DEVICE_INFO_GPUADC10_IPC;
#define NV_GPU_POWER_DEVICE_INFO_GPUADC10_PHYSICAL_PROV_NUM 0x06
typedef struct {
  NvU16 pwmPeriod;
  NvU8 iirLength;
  NvU8 sampleDelay;
  NvU8 activeProvCount;
  NvU8 resetLength;
  NvU16 fullRangeVoltage;
  NvU16 fullRangeCurrent[NV_GPU_POWER_DEVICE_INFO_GPUADC10_PHYSICAL_PROV_NUM];
  NV_GPU_POWER_DEVICE_INFO_GPUADC10_IPC ipc;
} NV_GPU_POWER_DEVICE_INFO_GPUADC10;
#define NV_GPU_POWER_DEVICE_GPUADC11_PHYSICAL_PROV_NUM 0x09
#define NV_GPU_POWER_DEVICE_GPUADC11_OVRM_NUM 0x02
#define NV_GPU_POWER_DEVICE_GPUADC11_IPC_NUM 0x04
#define NV_GPU_POWER_DEVICE_GPUADC11_BEACON_NUM 0x02
#define NV_GPU_POWER_DEVICE_GPUADC11_OFFSET_NUM 0x02
#define NV_GPU_POWER_DEVICE_GPUADC11_SUM_NUM 0x02
#define NV_GPU_POWER_DEVICE_GPUADC11_SUM_INPUT_NUM 0x04
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_SRC_TYPE_NONE = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_SRC_TYPE_ADC,
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_SRC_TYPE_BA,
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_SRC_TYPE_ADC_SUM,
} NV_GPU_POWER_DEVICE_GPUADC11_IPC_SRC_TYPE,
    *PNV_GPU_POWER_DEVICE_GPUADC11_IPC_SRC_TYPE;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_PROV_UNIT_MV = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_PROV_UNIT_MA,
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_PROV_UNIT_MW,
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_PROV_UNIT_INVALID = 0xFF,
} NV_GPU_POWER_DEVICE_GPUADC11_IPC_PROV_UNIT,
    *PNV_GPU_POWER_DEVICE_GPUADC11_IPC_PROV_UNIT;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC11_SUM_PROV_UNIT_DISABLED = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC11_SUM_PROV_UNIT_MV,
  NV_GPU_POWER_DEVICE_GPUADC11_SUM_PROV_UNIT_MA,
  NV_GPU_POWER_DEVICE_GPUADC11_SUM_PROV_UNIT_MW,
} NV_GPU_POWER_DEVICE_GPUADC11_SUM_PROV_UNIT,
    *PNV_GPU_POWER_DEVICE_GPUADC11_SUM_PROV_UNIT;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC11_OPERATING_MODE_NON_ALT = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC11_OPERATING_MODE_ALT,
} NV_GPU_POWER_DEVICE_GPUADC11_OPERATING_MODE,
    *PNV_GPU_POWER_DEVICE_GPUADC11_OPERATING_MODE;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC11_BEACON_COMP_GT = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC11_BEACON_COMP_LT,
} NV_GPU_POWER_DEVICE_GPUADC11_BEACON_COMP,
    *PNV_GPU_POWER_DEVICE_GPUADC11_BEACON_COMP;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC11_OVRM_GEN_1 = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC11_OVRM_GEN_2 = 0x01,
  NV_GPU_POWER_DEVICE_GPUADC11_OVRM_GEN_INVALID = 0xFF,
} NV_GPU_POWER_DEVICE_GPUADC11_OVRM_GEN,
    *PNV_GPU_POWER_DEVICE_GPUADC11_OVRM_GEN;
typedef struct {
  NvBool bGround;
  NvU8 tupleProvNum;
  NvU8 imonNum;
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_OVRM_DATA_GEN2;
typedef struct {
  NvBool bEnabled;
  NV_GPU_POWER_DEVICE_GPUADC11_OVRM_GEN gen;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_DEVICE_INFO_GPUADC11_OVRM_DATA_GEN2 gen2;
    NvU8 rsvd[16];
  } data;
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_OVRM_DEVICE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_OVRM_DEVICE
  device[NV_GPU_POWER_DEVICE_GPUADC11_OVRM_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_OVRM;
typedef struct {
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_SRC_TYPE sourceType;
  union {
    NvU8 provider;
    NvU8 window;
    NvU8 sum;
    NvU8 rsvd[4];
  } index;
  NV_GPU_POWER_DEVICE_GPUADC11_IPC_PROV_UNIT providerUnit;
  NvU8 rsvd[16];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_IPC_INSTANCE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_IPC_INSTANCE
  instance[NV_GPU_POWER_DEVICE_GPUADC11_IPC_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_IPC;
typedef struct {
  NvU8 provIdx;
  NvU8 threshold;
  NV_GPU_POWER_DEVICE_GPUADC11_BEACON_COMP compFunc;
  NvU8 rsvd[16];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_BEACON_INSTANCE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_BEACON_INSTANCE
  instance[NV_GPU_POWER_DEVICE_GPUADC11_BEACON_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_BEACON;
typedef struct {
  NvU8 provIdx;
  NvU16 provMask;
  NvU8 rsvd[16];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_OFFSET_INSTANCE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_OFFSET_INSTANCE
  instance[NV_GPU_POWER_DEVICE_GPUADC11_OFFSET_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_OFFSET;
typedef struct {
  NvU8 provIdx;
  NvU8 scaleFactor;
  NvU8 rsvd[16];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_SUM_INPUT;
typedef struct {
  NV_GPU_POWER_DEVICE_GPUADC11_SUM_PROV_UNIT provUnit;
  NvU8 rsvd[16];
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_SUM_INPUT
  input[NV_GPU_POWER_DEVICE_GPUADC11_SUM_INPUT_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_SUM_INSTANCE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_SUM_INSTANCE
  instance[NV_GPU_POWER_DEVICE_GPUADC11_SUM_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC11_SUM;
typedef struct {
  NvU8 iirLength;
  NvU8 sampleDelay;
  NvU8 activeProvCount;
  NvU8 resetLength;
  NvU8 numSamples;
  NvU8 vcmOffsetVfeVarIdx;
  NvU8 diffOffsetVfeVarIdx;
  NvU8 diffGainVfeVarIdx;
  NvU8 vcmCoarseOffsetVfeVarIdx;
  NvU16 pwmPeriod;
  NvU16 imonProvMask;
  NvU16 fullRangeVoltage;
  NV_GPU_POWER_DEVICE_GPUADC11_OPERATING_MODE operatingMode;
  NvU32 fullRangeCurrent[NV_GPU_POWER_DEVICE_GPUADC11_PHYSICAL_PROV_NUM];
  NvU8 rsvd[32];
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_OVRM ovrm;
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_IPC ipc;
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_BEACON beacon;
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_OFFSET offset;
  NV_GPU_POWER_DEVICE_INFO_GPUADC11_SUM sum;
} NV_GPU_POWER_DEVICE_INFO_GPUADC11;
#define NV_GPU_POWER_DEVICE_GPUADC13_PHYSICAL_PROV_NUM 0x0E
#define NV_GPU_POWER_DEVICE_GPUADC13_OVRM_NUM 0x02
#define NV_GPU_POWER_DEVICE_GPUADC13_IPC_NUM 0x04
#define NV_GPU_POWER_DEVICE_GPUADC13_BEACON_NUM 0x02
#define NV_GPU_POWER_DEVICE_GPUADC13_OFFSET_NUM 0x02
#define NV_GPU_POWER_DEVICE_GPUADC13_SUM_NUM 0x02
#define NV_GPU_POWER_DEVICE_GPUADC13_SUM_INPUT_NUM 0x04
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_SRC_TYPE_NONE = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_SRC_TYPE_ADC,
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_SRC_TYPE_BA,
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_SRC_TYPE_ADC_SUM,
} NV_GPU_POWER_DEVICE_GPUADC13_IPC_SRC_TYPE,
    *PNV_GPU_POWER_DEVICE_GPUADC13_IPC_SRC_TYPE;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_PROV_UNIT_MV = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_PROV_UNIT_MA,
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_PROV_UNIT_MW,
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_PROV_UNIT_INVALID = 0xFF,
} NV_GPU_POWER_DEVICE_GPUADC13_IPC_PROV_UNIT,
    *PNV_GPU_POWER_DEVICE_GPUADC13_IPC_PROV_UNIT;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC13_SUM_PROV_UNIT_DISABLED = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC13_SUM_PROV_UNIT_MV,
  NV_GPU_POWER_DEVICE_GPUADC13_SUM_PROV_UNIT_MA,
  NV_GPU_POWER_DEVICE_GPUADC13_SUM_PROV_UNIT_MW,
} NV_GPU_POWER_DEVICE_GPUADC13_SUM_PROV_UNIT,
    *PNV_GPU_POWER_DEVICE_GPUADC13_SUM_PROV_UNIT;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC13_OPERATING_MODE_NON_ALT = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC13_OPERATING_MODE_ALT,
} NV_GPU_POWER_DEVICE_GPUADC13_OPERATING_MODE,
    *PNV_GPU_POWER_DEVICE_GPUADC13_OPERATING_MODE;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC13_BEACON_COMP_GT = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC13_BEACON_COMP_LT,
} NV_GPU_POWER_DEVICE_GPUADC13_BEACON_COMP,
    *PNV_GPU_POWER_DEVICE_GPUADC13_BEACON_COMP;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC13_OVRM_GEN_1 = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC13_OVRM_GEN_2 = 0x01,
  NV_GPU_POWER_DEVICE_GPUADC13_OVRM_GEN_INVALID = 0xFF,
} NV_GPU_POWER_DEVICE_GPUADC13_OVRM_GEN,
    *PNV_GPU_POWER_DEVICE_GPUADC13_OVRM_GEN;
typedef enum {
  NV_GPU_POWER_DEVICE_GPUADC13_ADC_PWM_MODE_PRI = 0x00,
  NV_GPU_POWER_DEVICE_GPUADC13_ADC_PWM_MODE_SEC,
} NV_GPU_POWER_DEVICE_GPUADC13_ADC_PWM_MODE,
    *PNV_GPU_POWER_DEVICE_GPUADC13_ADC_PWM_MODE;
typedef struct {
  NvBool bEnabled;
  NvU16 fullRangeVoltage;
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_OVRM_DATA_GEN2_IMON;
typedef struct {
  NvBool bGround;
  NvU8 tupleProvNum;
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_OVRM_DATA_GEN2_IMON imon;
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_OVRM_DATA_GEN2;
typedef struct {
  NvBool bEnabled;
  NV_GPU_POWER_DEVICE_GPUADC13_OVRM_GEN gen;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_DEVICE_INFO_GPUADC13_OVRM_DATA_GEN2 gen2;
    NvU8 rsvd[16];
  } data;
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_OVRM_DEVICE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_OVRM_DEVICE
  device[NV_GPU_POWER_DEVICE_GPUADC13_OVRM_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_OVRM;
typedef struct {
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_SRC_TYPE sourceType;
  union {
    NvU8 provider;
    NvU8 window;
    NvU8 sum;
    NvU8 rsvd[4];
  } index;
  NV_GPU_POWER_DEVICE_GPUADC13_IPC_PROV_UNIT providerUnit;
  NV_GPU_BOARDOBJ_IDX voltRailIdx;
  NvU16 floor;
  NvU16 ceil;
  NvU8 rsvd[16];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_IPC_INSTANCE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_IPC_INSTANCE
  instance[NV_GPU_POWER_DEVICE_GPUADC13_IPC_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_IPC;
typedef struct {
  NvU8 provIdx;
  NvU8 threshold;
  NV_GPU_POWER_DEVICE_GPUADC13_BEACON_COMP compFunc;
  NvU8 rsvd[16];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_BEACON_INSTANCE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_BEACON_INSTANCE
  instance[NV_GPU_POWER_DEVICE_GPUADC13_BEACON_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_BEACON;
typedef struct {
  NvU8 provIdx;
  NvU16 provMask;
  NvU8 rsvd[16];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_OFFSET_INSTANCE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_OFFSET_INSTANCE
  instance[NV_GPU_POWER_DEVICE_GPUADC13_OFFSET_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_OFFSET;
typedef struct {
  NvU8 provIdx;
  NvU8 scaleFactor;
  NvU8 rsvd[16];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_SUM_INPUT;
typedef struct {
  NV_GPU_POWER_DEVICE_GPUADC13_SUM_PROV_UNIT provUnit;
  NvU8 rsvd[16];
  union {
    NvU32 curr;
    NvU32 pwr;
    NvU8 rsvd[16];
  } convFactor;
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_SUM_INPUT
  input[NV_GPU_POWER_DEVICE_GPUADC13_SUM_INPUT_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_SUM_INSTANCE;
typedef struct {
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_SUM_INSTANCE
  instance[NV_GPU_POWER_DEVICE_GPUADC13_SUM_NUM];
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_SUM;
typedef struct {
  NvU16 hiLast;
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_ADC_PWM_PRI;
typedef struct {
  NvU16 syncThreshold;
  NvU16 resetThreshold;
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_ADC_PWM_SEC;
typedef struct {
  NV_GPU_POWER_DEVICE_GPUADC13_ADC_PWM_MODE mode;
  union {
    NV_GPU_POWER_DEVICE_INFO_GPUADC13_ADC_PWM_PRI pri;
    NV_GPU_POWER_DEVICE_INFO_GPUADC13_ADC_PWM_SEC sec;
  } data;
} NV_GPU_POWER_DEVICE_INFO_GPUADC13_ADC_PWM;
typedef struct {
  NvU8 iirLength;
  NvU8 sampleDelay;
  NvU8 activeProvCount;
  NvU8 resetLength;
  NvU8 numSamples;
  NvU8 vcmOffsetVfeVarIdx;
  NvU8 diffOffsetVfeVarIdx;
  NvU8 diffGainVfeVarIdx;
  NvU8 vcmCoarseOffsetVfeVarIdx;
  NvU8 diffCoarseGainVfeVarIdx;
  NvU16 pwmPeriod;
  NvU16 fullRangeVoltage;
  NV_GPU_POWER_DEVICE_GPUADC13_OPERATING_MODE operatingMode;
  NvU32 fullRangeCurrent[NV_GPU_POWER_DEVICE_GPUADC13_PHYSICAL_PROV_NUM];
  NvU8 rsvd[32];
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_OVRM ovrm;
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_IPC ipc;
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_BEACON beacon;
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_OFFSET offset;
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_SUM sum;
  NV_GPU_POWER_DEVICE_INFO_GPUADC13_ADC_PWM adcPwm;
} NV_GPU_POWER_DEVICE_INFO_GPUADC13;
typedef struct _NV_GPU_POWER_DEVICE_INFO_V1 {
  NvU8 type;
  NvU8 powerRail;
} NV_GPU_POWER_DEVICE_INFO_V1;
typedef struct _NV_GPU_POWER_DEVICE_INFO_V2 {
  NvU8 type;
  NvU8 powerRail;
  NvU8 rsvd[32];
  union {
    NV_GPU_POWER_DEVICE_INFO_BA00 ba00;
    NV_GPU_POWER_DEVICE_INFO_BA1XHW ba1xhw;
    NV_GPU_POWER_DEVICE_INFO_BA1XSW ba1xsw;
    NV_GPU_POWER_DEVICE_INFO_INA209 ina209;
    NV_GPU_POWER_DEVICE_INFO_INA219 ina219;
    NV_GPU_POWER_DEVICE_INFO_INA3221 ina3221;
    NV_GPU_POWER_DEVICE_INFO_NCT3933U nct3933u;
    NvU8 rsvd[48];
  } data;
} NV_GPU_POWER_DEVICE_INFO_V2;
typedef struct _NV_GPU_POWER_DEVICE_INFO_V3 {
  NvU8 type;
  NvU8 powerRail;
  union {
    NV_GPU_POWER_DEVICE_INFO_BA00 ba00;
    NV_GPU_POWER_DEVICE_INFO_BA1XSW ba1xsw;
    NV_GPU_POWER_DEVICE_INFO_BA1XHW ba1xhw;
    NV_GPU_POWER_DEVICE_INFO_BA15HW ba15hw;
    NV_GPU_POWER_DEVICE_INFO_INA209 ina209;
    NV_GPU_POWER_DEVICE_INFO_INA219 ina219;
    NV_GPU_POWER_DEVICE_INFO_INA3221 ina3221;
    NV_GPU_POWER_DEVICE_INFO_NCT3933U nct3933u;
    NV_GPU_POWER_DEVICE_INFO_GPUADC10 gpuadc10;
    NvU8 rsvd[72];
  } data;
  NvU8 rsvd[32];
} NV_GPU_POWER_DEVICE_INFO_V3;
typedef struct _NV_GPU_POWER_DEVICE_INFO_V4 {
  NvU8 type;
  NvU8 powerRail;
  NvU8 rsvd[32];
  union {
    NV_GPU_POWER_DEVICE_INFO_BA00 ba00;
    NV_GPU_POWER_DEVICE_INFO_BA1XSW ba1xsw;
    NV_GPU_POWER_DEVICE_INFO_BA1XHW ba1xhw;
    NV_GPU_POWER_DEVICE_INFO_BA15HW ba15hw;
    NV_GPU_POWER_DEVICE_INFO_BA16HW ba16hw;
    NV_GPU_POWER_DEVICE_INFO_BA20 ba20;
    NV_GPU_POWER_DEVICE_INFO_INA209 ina209;
    NV_GPU_POWER_DEVICE_INFO_INA219 ina219;
    NV_GPU_POWER_DEVICE_INFO_INA3221 ina3221;
    NV_GPU_POWER_DEVICE_INFO_NCT3933U nct3933u;
    NV_GPU_POWER_DEVICE_INFO_GPUADC10 gpuadc10;
    NV_GPU_POWER_DEVICE_INFO_GPUADC11 gpuadc11;
    NvU8 rsvd[600];
  } data;
} NV_GPU_POWER_DEVICE_INFO_V4;
typedef struct _NV_GPU_POWER_DEVICE_INFO_V5 {
  NvU8 type;
  NvU8 powerRail;
  NvU8 rsvd[32];
  union {
    NV_GPU_POWER_DEVICE_INFO_BA00 ba00;
    NV_GPU_POWER_DEVICE_INFO_BA1XSW ba1xsw;
    NV_GPU_POWER_DEVICE_INFO_BA1XHW ba1xhw;
    NV_GPU_POWER_DEVICE_INFO_BA15HW ba15hw;
    NV_GPU_POWER_DEVICE_INFO_BA16HW ba16hw;
    NV_GPU_POWER_DEVICE_INFO_BA20 ba20;
    NV_GPU_POWER_DEVICE_INFO_INA209 ina209;
    NV_GPU_POWER_DEVICE_INFO_INA219 ina219;
    NV_GPU_POWER_DEVICE_INFO_INA3221 ina3221;
    NV_GPU_POWER_DEVICE_INFO_NCT3933U nct3933u;
    NV_GPU_POWER_DEVICE_INFO_GPUADC10 gpuadc10;
    NV_GPU_POWER_DEVICE_INFO_GPUADC11 gpuadc11;
    NV_GPU_POWER_DEVICE_INFO_GPUADC13 gpuadc13;
    NvU8 rsvd[4096];
  } data;
} NV_GPU_POWER_DEVICE_INFO_V5;
typedef struct _NV_GPU_POWER_DEVICE_GET_INFO_V1 {
  NvU32 version;
  NvU32 pwrDeviceMask;
  NV_GPU_POWER_DEVICE_INFO_V1
  devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} NV_GPU_POWER_DEVICE_GET_INFO_V1;
typedef struct _NV_GPU_POWER_DEVICE_GET_INFO_V2 {
  NvU32 version;
  NvU32 pwrDeviceMask;
  NvU8 rsvd[32];
  NV_GPU_POWER_DEVICE_INFO_V2
  devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} NV_GPU_POWER_DEVICE_GET_INFO_V2;
typedef struct _NV_GPU_POWER_DEVICE_GET_INFO_V3 {
  NvU32 version;
  NvU32 pwrDeviceMask;
  NV_GPU_POWER_DEVICE_INFO_V3
  devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
  NvU8 rsvd[32];
} NV_GPU_POWER_DEVICE_GET_INFO_V3;
typedef struct _NV_GPU_POWER_DEVICE_GET_INFO_V4 {
  NvU32 version;
  NvU32 pwrDeviceMask;
  NV_GPU_POWER_DEVICE_INFO_V4
  devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
  NvU8 rsvd[32];
} NV_GPU_POWER_DEVICE_GET_INFO_V4;
typedef struct _NV_GPU_POWER_DEVICE_GET_INFO_V5 {
  NvU32 version;
  NvU32 pwrDeviceMask;
  NvU8 rsvd[32];
  NV_GPU_POWER_DEVICE_INFO_V5
  devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} NV_GPU_POWER_DEVICE_GET_INFO_V5;
#define NV_GPU_POWER_DEVICE_GET_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_INFO_V1, 1)
#define NV_GPU_POWER_DEVICE_GET_INFO_VER_2 MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_INFO_V2, 1)
#define NV_GPU_POWER_DEVICE_GET_INFO_VER_3 MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_INFO_V3, 3)
#define NV_GPU_POWER_DEVICE_GET_INFO_VER_4 MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_INFO_V4, 4)
#define NV_GPU_POWER_DEVICE_GET_INFO_VER_5 MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_INFO_V5, 5)
#define NV_GPU_POWER_DEVICE_GET_INFO_VER NV_GPU_POWER_DEVICE_GET_INFO_VER_5
typedef NV_GPU_POWER_DEVICE_GET_INFO_V5 NV_GPU_POWER_DEVICE_GET_INFO;
typedef NV_GPU_POWER_DEVICE_INFO_V5 NV_GPU_POWER_DEVICE_INFO;
NVAPI_INTERFACE NvAPI_GPU_PowerDeviceGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_POWER_DEVICE_GET_INFO *pPwrDevInfo);
#define NV_GPU_POWER_DEVICE_MAX_PROVIDERS_V2 5
#define NV_GPU_POWER_DEVICE_PROVIDER_MAX_THRESHOLDS_V2 4
typedef struct {
  NvU32 pwrmW;
  NvU32 currmA;
  NvU32 voltuV;
  NvU8 rsvd[32];
} NV_GPU_POWER_TUPLE_V2;
typedef struct {
  NV_GPU_POWER_TUPLE_V2 tuple;
  NvU8 numThresholds;
  NvU8 rsvd[32];
  NvU32 thresholds[NV_GPU_POWER_DEVICE_PROVIDER_MAX_THRESHOLDS_V2];
} NV_GPU_POWER_DEVICE_PROVIDER_STATUS_V2;
typedef struct {
  NV_GPU_POWER_DEVICE_TYPE type;
  NvU8 numProviders;
  NvU8 rsvd[32];
  NV_GPU_POWER_DEVICE_PROVIDER_STATUS_V2
  providers[NV_GPU_POWER_DEVICE_MAX_PROVIDERS_V2];
} NV_GPU_POWER_DEVICE_STATUS_V2;
#define NV_GPU_POWER_DEVICE_MAX_PROVIDERS_V3 32
typedef struct {
  NV_GPU_POWER_DEVICE_TYPE type;
  NvU8 numProviders;
  NvU8 rsvd[32];
  NV_GPU_POWER_DEVICE_PROVIDER_STATUS_V2
  providers[NV_GPU_POWER_DEVICE_MAX_PROVIDERS_V3];
} NV_GPU_POWER_DEVICE_STATUS_V3;
typedef struct {
  NvU32 version;
  NvU32 pwrDeviceMask;
  struct {
    NvU32 powermW;
    NvU32 voltageuV;
    NvU32 currentmA;
  } devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} NV_GPU_POWER_DEVICE_GET_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pwrDeviceMask;
  NvU8 rsvd[32];
  NV_GPU_POWER_DEVICE_STATUS_V2 devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} NV_GPU_POWER_DEVICE_GET_STATUS_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pwrDeviceMask;
  NvU8 rsvd[32];
  NV_GPU_POWER_DEVICE_STATUS_V3 devices[NV_GPU_POWER_DEVICE_MAX_DEVICES_V1];
} NV_GPU_POWER_DEVICE_GET_STATUS_V3;
#define NV_GPU_POWER_DEVICE_GET_STATUS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_STATUS_V1, 1)
#define NV_GPU_POWER_DEVICE_GET_STATUS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_STATUS_V2, 2)
#define NV_GPU_POWER_DEVICE_GET_STATUS_VER_3 MAKE_NVAPI_VERSION(NV_GPU_POWER_DEVICE_GET_STATUS_V3, 3)
#define NV_GPU_POWER_DEVICE_GET_STATUS_VER NV_GPU_POWER_DEVICE_GET_STATUS_VER_3
#define NV_GPU_POWER_DEVICE_GET_STATUS NV_GPU_POWER_DEVICE_GET_STATUS_V3
NVAPI_INTERFACE NvAPI_GPU_PowerDeviceGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_POWER_DEVICE_GET_STATUS *pPwrDevStatus);
#define NV_GPU_POWER_MONITOR_CHANNEL_INDEX_INVALID 0xFF
#define NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1 32
#define NV_GPU_POWER_MONITOR_MAX_CHANNELS_V2 32
#define NV_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2 32
#define NV_GPU_POWER_MONITOR_POWER_CHANNEL_PSTATE_ESTIMATION_LUT_MAX_ENTRIES 2
typedef enum {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_DEFAULT = 0x00000000,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SUMMATION,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_ESTIMATION,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SLOW,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_GEMINI_CORRECTION,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_1X,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SENSOR,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_PSTATE_ESTIMATION_LUT,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE_SENSOR_CLIENT_ALIGNED,
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE;
typedef enum {
  NV_GPU_POWER_CHANNEL_POWER_RAIL_UNKNOWN = 0x00000000,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_NVVDD = 0x00000001,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDD = 0x00000002,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDDQ = 0x00000003,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDD_Q = 0x00000004,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_PEXVDD = 0x00000005,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_A3V3 = 0x00000006,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_3V3NV = 0x00000007,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_TOTAL_GPU = 0x00000008,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDDQ_GPU = 0x00000009,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_FBVDDQ_MEM = 0x0000000A,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_OUTPUT_SRAM = 0x0000000B,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_PEX12V1 = 0x000000DE,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_TOTAL_BOARD2 = 0x000000DF,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_HIGH_VOLT0 = 0x000000E0,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_HIGH_VOLT1 = 0x000000E1,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_NVVDD1 = 0x000000E2,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_NVVDD2 = 0x000000E3,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN2 = 0x000000E4,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN3 = 0x000000E5,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN4 = 0x000000E6,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN5 = 0x000000E7,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_MISC0 = 0x000000E8,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_MISC1 = 0x000000E9,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_MISC2 = 0x000000EA,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_MISC3 = 0x000000EB,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_USBC0 = 0x000000EC,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_USBC1 = 0x000000ED,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FAN0 = 0x000000EE,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FAN1 = 0x000000EF,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_SRAM = 0x000000F0,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_PWR_SRC_PP = 0x000000F1,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_3V3_PP = 0x000000F2,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_3V3_MAIN = 0x000000F3,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_3V3_AON = 0x000000F4,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_TOTAL_BOARD = 0x000000F5,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_NVVDD = 0x000000F6,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FBVDD = 0x000000F7,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FBVDDQ = 0x000000F8,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_FBVDD_Q = 0x000000F9,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN0 = 0x000000FA,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_8PIN1 = 0x000000FB,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_6PIN0 = 0x000000FC,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_EXT12V_6PIN1 = 0x000000FD,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_PEX3V3 = 0x000000FE,
  NV_GPU_POWER_CHANNEL_POWER_RAIL_INPUT_PEX12V = 0x000000FF,
} NV_GPU_POWER_CHANNEL_POWER_RAIL;
typedef enum _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_WEIGHT = 0x00000000,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCED_PHASE_EST,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_BALANCING_PWM_WEIGHT,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_REGULATOR_LOSS_EST,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_REGULATOR_LOSS_DYN,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_REGULATOR_EFF_EST_V1,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE;
typedef struct {
  NvU32 pwrDeviceMask;
  NvS32 pwrOffsetmW;
  NvU32 pwrLimitmW;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V1;
typedef struct {
  NvU32 version;
  NvU8 bSupported;
  NvU32 samplingPeriodms;
  NvU32 sampleCount;
  NvU32 channelMask;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V1 channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
} NV_GPU_POWER_MONITOR_GET_INFO_V1;
typedef struct {
  NvU32 pwrDeviceMask;
  NvU32 pwrLimitmW;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_1X_INFO;
typedef struct {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_1X_INFO super;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_SLOW_INFO;
typedef struct {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_SLOW_INFO super;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_GEMINI_CORRECTION_INFO;
typedef struct {
  NvU8 pwrDevIdx;
  NvU8 pwrDevProvIdx;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO;
typedef struct {
  NvU8 relIdxFirst;
  NvU8 relIdxLast;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_INFO;
typedef struct {
  NV_GPU_PERF_PSTATE_ID pstateId;
  NvU32 powerOffset;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_PSTATE_ESTIMATION_LUT_ENTRY_INFO;
typedef struct {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_PSTATE_ESTIMATION_LUT_ENTRY_INFO
  lutEntry[NV_GPU_POWER_MONITOR_POWER_CHANNEL_PSTATE_ESTIMATION_LUT_MAX_ENTRIES];
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_PSTATE_ESTIMATION_LUT_INFO;
typedef struct {
  NvU32 pwrDeviceMask;
  NvS32 pwrOffsetmW;
  NvU32 pwrLimitmW;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE type;
  NvU8 pwrRail;
  NvU32 voltFixeduV;
  NvU32 pwrCorrSlope;
  NvU32 currCorrSlope;
  NvS32 currCorrOffsetmA;
  NvU8 rsvd[8];
  union {
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_1X_INFO c1x;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_GEMINI_CORRECTION_INFO gemmCorr;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_INFO sensor;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_SLOW_INFO slow;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_SUMMATION_INFO sum;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_PSTATE_ESTIMATION_LUT_INFO pstateEstLUT;
    NvU8 rsvd[16];
  } data;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2;
#define NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2
typedef struct {
  NvS32 weight;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_WEIGHT_INFO;
typedef struct {
  NvU8 numTotalPhases;
  NvU8 numStaticPhases;
  NvU8 balancedPhasePolicyRelIdxFirst;
  NvU8 balancedPhasePolicyRelIdxLast;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCED_PHASE_EST_INFO;
typedef struct {
  NvU8 balancingRelIdx;
  NvU8 bPrimary;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCING_PWM_WEIGHT_INFO;
typedef struct {
  NV_GPU_BOARDOBJ_IDX policyRelStart;
  NV_GPU_BOARDOBJ_IDX policyRelEnd;
} NV_GPU_POWER_POWER_POLICY_RELATIONSHIP_SET;
typedef enum _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_TYPE {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_TYPE_NVVDD = 0x00000000,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_TYPE_FBVDD,
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_TYPE;
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_EST_INFO {
  NvU8 regulatorType;
  NvS32 coefficient0;
  NvS32 coefficient1;
  NvS32 coefficient2;
  NvS32 coefficient3;
  NvS32 coefficient4;
  NvS32 coefficient5;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_EST_INFO;
typedef enum _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_PRIMARY_UNIT {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_PRIMARY_UNIT_POWER_MW = 0x0,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_PRIMARY_UNIT_CURRENT_MA = 0x1
} NV_GPU_POWER_MONITOR_REGULATOR_EFF_EST_V1_CHANNEL_UNIT_TYPE;
typedef enum _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_DIRECTION {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_DIRECTION_INPUT_TO_OUTPUT = 0x0,
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_DIRECTION_OUTPUT_TO_INPUT = 0x1,
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_DIRECTION;
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_INFO {
  NvU8 chIdxSecondary;
  NvU8 unitPrimary;
  NvU8 direction;
  NvS32 coefficient0;
  NvS32 coefficient1;
  NvS32 coefficient2;
  NvS32 coefficient3;
  NvS32 coefficient4;
  NvS32 coefficient5;
  NvS32 coefficient6;
  NvS32 coefficient7;
  NvS32 coefficient8;
  NvS32 coefficient9;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_INFO;
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_DYN_INFO {
  NvU8 thermMonIdx;
  NvU8 voltDomain;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_DYN_INFO;
typedef struct {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE type;
  NvU8 chIdx;
  union {
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_WEIGHT_INFO
    weight;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCED_PHASE_EST_INFO
    balancedPhaseEst;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCING_PWM_WEIGHT_INFO
    balancingPwmWeight;
    NvU8 rsvd[16];
  } data;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2;
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V3 {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE type;
  NvU8 chIdx;
  union {
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_WEIGHT_INFO
    weight;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCED_PHASE_EST_INFO
    balancedPhaseEst;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCING_PWM_WEIGHT_INFO
    balancingPwmWeight;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_EST_INFO
    regulatorLossEst;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_DYN_INFO
    regulatorLossDyn;
    NvU8 rsvd[32];
  } data;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V3;
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V4 {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE type;
  NvU8 chIdx;
  union {
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_WEIGHT_INFO
    weight;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCED_PHASE_EST_INFO
    balancedPhaseEst;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_BALANCING_PWM_WEIGHT_INFO
    balancingPwmWeight;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_EST_INFO
    regulatorLossEst;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_DYN_INFO
    regulatorLossDyn;
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_EFF_EST_V1_INFO
    regulatorEffEstV1;
    NvU8 rsvd[128];
  } data;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V4;
#define NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V4
typedef struct {
  NvU32 version;
  NvU8 bSupported;
  NvU32 samplingPeriodms;
  NvU32 sampleCount;
  NvU32 channelMask;
  NvU32 chRelMask;
  NvU32 totalGpuPowerChannelMask;
  NvU8 totalGpuChannelIdx;
  NvU8 rsvd[11];
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2 channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V2];
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V2 chRels[NV_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2];
} NV_GPU_POWER_MONITOR_GET_INFO_V2;
typedef struct _NV_GPU_POWER_MONITOR_GET_INFO_V3 {
  NvU32 version;
  NvU8 bSupported;
  NvU32 samplingPeriodms;
  NvU32 sampleCount;
  NvU32 channelMask;
  NvU32 chRelMask;
  NvU32 totalGpuPowerChannelMask;
  NvU8 totalGpuChannelIdx;
  NvU8 rsvd[11];
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2 channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V2];
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V3 chRels[NV_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2];
} NV_GPU_POWER_MONITOR_GET_INFO_V3;
typedef struct _NV_GPU_POWER_MONITOR_GET_INFO_V4 {
  NvU32 version;
  NvU8 bSupported;
  NvU32 samplingPeriodms;
  NvU32 sampleCount;
  NvU32 channelMask;
  NvU32 chRelMask;
  NvU32 totalGpuPowerChannelMask;
  NvU8 totalGpuChannelIdx;
  NvU8 rsvd[11];
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_INFO_V2 channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V2];
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_INFO_V4 chRels[NV_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2];
} NV_GPU_POWER_MONITOR_GET_INFO_V4;
#define NV_GPU_POWER_MONITOR_GET_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_INFO_V1, 1)
#define NV_GPU_POWER_MONITOR_GET_INFO_VER_2 MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_INFO_V2, 1)
#define NV_GPU_POWER_MONITOR_GET_INFO_VER_3 MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_INFO_V3, 3)
#define NV_GPU_POWER_MONITOR_GET_INFO_VER_4 MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_INFO_V4, 4)
#define NV_GPU_POWER_MONITOR_GET_INFO_VER NV_GPU_POWER_MONITOR_GET_INFO_VER_4
#define NV_GPU_POWER_MONITOR_GET_INFO NV_GPU_POWER_MONITOR_GET_INFO_V4
NVAPI_INTERFACE NvAPI_GPU_PowerMonitorGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                              NV_GPU_POWER_MONITOR_GET_INFO *pPwrMonInfo);
typedef struct {
  NvU32 pwrAvgmW;
  NvU32 pwrMinmW;
  NvU32 pwrMaxmW;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 channelMask;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V1
  channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
} NV_GPU_POWER_MONITOR_GET_STATUS_V1;
#pragma pack(push, 4)
typedef struct {
  NvU32 pwrAvgmW;
  NvU32 pwrMinmW;
  NvU32 pwrMaxmW;
  NvU32 currmA;
  NvU32 voltuV;
  NvU64 energymJ;
  NvU8 rsvd[16];
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V2;
#pragma pack(pop)
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE {
  NvU32 pwrmW;
  NvU32 currmA;
  NvU32 voltuV;
  NvU64 energymJ;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE;
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE_ACC {
  NvU64 pwrAccnJ;
  NvU64 currAccnC;
  NvU64 voltAccmVus;
  NvU32 seqId;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE_ACC;
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_CLIENT_ALIGNED_STATUS {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE_ACC lastTupleAcc;
  NvU64 lastTimens;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_CLIENT_ALIGNED_STATUS;
typedef struct {
  NvU32 pwrAvgmW;
  NvU32 pwrMinmW;
  NvU32 pwrMaxmW;
  NvU32 currmA;
  NvU32 voltuV;
  NvU64 energymJ;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TYPE type;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE tuple;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE tuplePolled;
  NvU8 rsvd[64];
  union {
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_SENSOR_CLIENT_ALIGNED_STATUS
    sensorClientAligned;
    NvU8 rsvd[64];
  } data;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V3;
typedef struct {
  NvU32 version;
  NvU32 channelMask;
  NvU32 totalGpuPowermW;
  NvU8 rsvd[16];
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V2
  channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
} NV_GPU_POWER_MONITOR_GET_STATUS_V2;
typedef struct _NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_DYN_STATUS {
  NvU32 dutyCycle;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_DYN_STATUS;
typedef struct {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_TYPE type;
  NvU8 rsvd[40];
  union {
    NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_REGULATOR_LOSS_DYN_STATUS
    regulatorLossDyn;
    NvU8 rsvd[32];
  } data;
} NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 channelMask;
  NvU32 totalGpuPowermW;
  NvU8 rsvd[16];
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V2
  channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
  NV_GPU_BOARDOBJGRP_MASK_E32 chRelMask;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_STATUS_V1
  channelRels[NV_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2];
} NV_GPU_POWER_MONITOR_GET_STATUS_V3;
typedef struct {
  NvU32 version;
  NvU32 channelMask;
  NvU32 totalGpuPowermW;
  NvU8 rsvd[64];
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_STATUS_V3
  channels[NV_GPU_POWER_MONITOR_MAX_CHANNELS_V1];
  NV_GPU_BOARDOBJGRP_MASK_E32 chRelMask;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_RELATIONSHIP_STATUS_V1
  channelRels[NV_GPU_POWER_MONITOR_MAX_CHANNEL_RELATIONSHIPS_V2];
} NV_GPU_POWER_MONITOR_GET_STATUS_V4;
#define NV_GPU_POWER_MONITOR_GET_STATUS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_STATUS_V1, 1)
#define NV_GPU_POWER_MONITOR_GET_STATUS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_STATUS_V2, 1)
#define NV_GPU_POWER_MONITOR_GET_STATUS_VER_3 MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_STATUS_V3, 1)
#define NV_GPU_POWER_MONITOR_GET_STATUS_VER_4 MAKE_NVAPI_VERSION(NV_GPU_POWER_MONITOR_GET_STATUS_V4, 1)
#define NV_GPU_POWER_MONITOR_GET_STATUS_VER NV_GPU_POWER_MONITOR_GET_STATUS_VER_4
#define NV_GPU_POWER_MONITOR_GET_STATUS NV_GPU_POWER_MONITOR_GET_STATUS_V4
NVAPI_INTERFACE NvAPI_GPU_PowerMonitorGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_POWER_MONITOR_GET_STATUS *pPwrMonStatus);
#define NV_GPU_POWER_CAPPING_ALG_DISABLED 0x00000000
#define NV_GPU_POWER_CAPPING_ALG_TEMPERATURE_SLOWDOWN 0x00000001
#define NV_GPU_POWER_CAPPING_ALG_PSTATE_CAP 0x00000002
typedef struct {
  NvU32 version;
  NvU8 alg;
  NvU32 channelMask;
} NV_GPU_POWER_CAPPING_GET_INFO_V1;
#define NV_GPU_POWER_CAPPING_GET_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_CAPPING_GET_INFO_V1, 1)
#define NV_GPU_POWER_CAPPING_GET_INFO_VER NV_GPU_POWER_CAPPING_GET_INFO_VER_1
#define NV_GPU_POWER_CAPPING_GET_INFO NV_GPU_POWER_CAPPING_GET_INFO_V1
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 400.") NVAPI_INTERFACE
    NvAPI_GPU_PowerCappingGetInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_POWER_CAPPING_GET_INFO *pPwrCapInfo);
#define NV_GPU_POWER_CAPPING_SLOWDOWN_MAX_CHANNELS_V1 8
typedef struct {
  NvU32 version;
  NvU8 bEnabled;
  NvU8 factorIndex;
  NvU8 factorCount;
  NvU32 capRatio;
  struct {
    NvU8 numerator;
    NvU8 denominator;
  } factors[NV_GPU_POWER_CAPPING_SLOWDOWN_MAX_CHANNELS_V1];
} NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_V1;
#define NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_VER_1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_V1, 1)
#define NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_VER NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_VER_1
#define NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS_V1
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 400.") NVAPI_INTERFACE
    NvAPI_GPU_PowerCappingSlowdownGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                            NV_GPU_POWER_CAPPING_SLOWDOWN_GET_STATUS *pPwrCapSlowStatus);
#define NV_GPU_POWER_EQUATION_MAX_EQUATIONS_V1 32
#define NV_GPU_POWER_EQUATION_INDEX_INVALID 0xFF
typedef enum _NV_GPU_POWER_EQUATION_TYPE {
  NV_GPU_POWER_EQUATION_TYPE_LEAKAGE_DTCS11 = 0x00000000,
  NV_GPU_POWER_EQUATION_TYPE_BA1X_SCALE = 0x00000001,
  NV_GPU_POWER_EQUATION_TYPE_BA00_FIT = 0x00000002,
  NV_GPU_POWER_EQUATION_TYPE_LEAKAGE_DTCS12 = 0x00000003,
  NV_GPU_POWER_EQUATION_TYPE_LEAKAGE_DTCS13 = 0x00000004,
  NV_GPU_POWER_EQUATION_TYPE_LEAKAGE = 0xFFFFFFFE,
  NV_GPU_POWER_EQUATION_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_EQUATION_TYPE;
typedef struct _NV_GPU_POWER_EQUATION_LEAKAGE_INFO {
  NvU16 fsEff;
  NvU16 pgEff;
} NV_GPU_POWER_EQUATION_LEAKAGE_INFO;
typedef struct _NV_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO {
  NV_GPU_POWER_EQUATION_LEAKAGE_INFO leakage;
  NvU32 k0;
  NvU32 k1;
  NvU32 k2;
  NvS32 k3;
} NV_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO;
typedef struct _NV_GPU_POWER_EQUATION_LEAKAGE_DTCS12_INFO {
  NV_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO super;
  NvU8 iddqVfeIdx;
  NvU8 tjThermChIdx;
} NV_GPU_POWER_EQUATION_LEAKAGE_DTCS12_INFO;
typedef struct _NV_GPU_POWER_EQUATION_LEAKAGE_DTCS13_INFO {
  NV_GPU_POWER_EQUATION_LEAKAGE_DTCS12_INFO super;
  NvU16 gpcrgEff;
  NvU16 grrpgEff;
} NV_GPU_POWER_EQUATION_LEAKAGE_DTCS13_INFO;
typedef struct _NV_GPU_POWER_EQUATION_BA00_FIT_INFO {
  NvU32 expBASlope;
  NvU32 expBAIntercept;
  NvU32 expDynPwrSlope;
  NvU32 expDynPwrIntercept;
} NV_GPU_POWER_EQUATION_BA00_FIT_INFO;
typedef struct _NV_GPU_POWER_EQUATION_BA1X_SCALE_INFO {
  NvU32 refVoltageuV;
  NvU32 ba2mW;
  NvU32 gpcClkMHz;
  NvU32 utilsClkMHz;
} NV_GPU_POWER_EQUATION_BA1X_SCALE_INFO;
typedef struct _NV_GPU_POWER_EQUATION_INFO_V1 {
  NV_GPU_POWER_EQUATION_TYPE type;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_EQUATION_LEAKAGE_INFO leakage;
    NV_GPU_POWER_EQUATION_LEAKAGE_DTCS11_INFO dtcs11;
    NV_GPU_POWER_EQUATION_BA00_FIT_INFO ba00Fit;
    NV_GPU_POWER_EQUATION_BA1X_SCALE_INFO ba1xScale;
    NV_GPU_POWER_EQUATION_LEAKAGE_DTCS12_INFO dtcs12;
    NV_GPU_POWER_EQUATION_LEAKAGE_DTCS13_INFO dtcs13;
    NvU8 rsvd[32];
  } data;
} NV_GPU_POWER_EQUATION_INFO_V1;
typedef struct _NV_GPU_POWER_EQUATION_INFO_PARAMS_V1 {
  NvU32 version;
  struct {
    NvU32 versionHw;
    NvU32 version;
    NvU32 valuemA;
  } iddq;
  NvU32 equationMask;
  NvU8 rsvd[16];
  NV_GPU_POWER_EQUATION_INFO_V1 equations[NV_GPU_POWER_EQUATION_MAX_EQUATIONS_V1];
} NV_GPU_POWER_EQUATION_INFO_PARAMS_V1;
#define NV_GPU_POWER_EQUATION_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_EQUATION_INFO_PARAMS_V1, 1)
#define NV_GPU_POWER_EQUATION_INFO_PARAMS_VER NV_GPU_POWER_EQUATION_INFO_PARAMS_VER_1
typedef NV_GPU_POWER_EQUATION_INFO_PARAMS_V1 NV_GPU_POWER_EQUATION_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_PowerEquationGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_GPU_POWER_EQUATION_INFO_PARAMS *pEquationInfo);
#define NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1 4
#define NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V2 32
#define NV_GPU_POWER_EQUATION_INDEX_INVALID 0xFF
typedef enum {
  NV_GPU_POWER_LEAKAGE_TYPE_DTCS10 = 0x00000000,
  NV_GPU_POWER_LEAKAGE_TYPE_DTCS11 = 0x00000001,
  NV_GPU_POWER_LEAKAGE_TYPE_BA00_FIT = 0x00000002,
  NV_GPU_POWER_LEAKAGE_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_LEAKAGE_TYPE;
typedef struct {
  float k0;
  float k1;
  float k2;
  NvS32 k3;
} NV_GPU_POWER_LEAKAGE_DTCS10_INFO;
typedef struct {
  NvU32 k0;
  NvU32 k1;
  NvU32 k2;
  NvS32 k3;
} NV_GPU_POWER_LEAKAGE_DTCS11_INFO;
typedef struct {
  NV_GPU_POWER_LEAKAGE_TYPE type;
  NvU16 fsEff;
  NvU16 pgEff;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_LEAKAGE_DTCS10_INFO dtcs10;
    NV_GPU_POWER_LEAKAGE_DTCS11_INFO dtcs11;
    NV_GPU_POWER_EQUATION_BA00_FIT_INFO ba00Fit;
    NvU8 rsvd[32];
  } data;
} NV_GPU_POWER_LEAKAGE_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 hwIddqVersion;
  NvU32 iddqVersion;
  NvU32 iddqmA;
  NvU32 leakageMask;
  NvU8 rsvd[16];
  NV_GPU_POWER_LEAKAGE_INFO_V1 leakages[NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1];
} NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V1;
typedef struct {
  NvU32 version;
  NvU32 hwIddqVersion;
  NvU32 iddqVersion;
  NvU32 iddqmA;
  NvU32 leakageMask;
  NvU8 rsvd[16];
  NV_GPU_POWER_LEAKAGE_INFO_V1 leakages[NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V2];
} NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V2;
#define NV_GPU_POWER_LEAKAGE_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V1, 1)
#define NV_GPU_POWER_LEAKAGE_INFO_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V2, 1)
#define NV_GPU_POWER_LEAKAGE_INFO_PARAMS_VER NV_GPU_POWER_LEAKAGE_INFO_PARAMS_VER_2
#define NV_GPU_POWER_LEAKAGE_INFO_PARAMS NV_GPU_POWER_LEAKAGE_INFO_PARAMS_V2
NVAPI_INTERFACE NvAPI_GPU_PowerLeakageGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                              NV_GPU_POWER_LEAKAGE_INFO_PARAMS *pLeakageInfo);
#define NV_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V1 32
#define NV_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V2 64
typedef struct {
  NvU32 voltageuV;
  NvU32 pwrLeakagemW;
} NV_GPU_POWER_LEAKAGE_STATUS_VOLTAGE_ENTRY;
typedef struct {
  NvU8 numVoltEntries;
  NvU8 rsvd[16];
  NV_GPU_POWER_LEAKAGE_STATUS_VOLTAGE_ENTRY
  voltEntries[NV_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V1];
} NV_GPU_POWER_LEAKAGE_STATUS_V1;
typedef struct {
  NvU32 version;
  NvS32 tj;
  NvU32 leakageMask;
  NvU8 rsvd[16];
  NV_GPU_POWER_LEAKAGE_STATUS_V1 leakages[NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1];
} NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V1;
typedef struct {
  NvU8 numVoltEntries;
  NvU8 rsvd[16];
  NV_GPU_POWER_LEAKAGE_STATUS_VOLTAGE_ENTRY
  voltEntries[NV_GPU_POWER_LEAKAGE_MAX_VOLTAGE_ENTRIES_V2];
} NV_GPU_POWER_LEAKAGE_STATUS_V2;
typedef struct {
  NvU32 version;
  NvS32 tj;
  NvU32 leakageMask;
  NvU8 rsvd[16];
  NV_GPU_POWER_LEAKAGE_STATUS_V2 leakages[NV_GPU_POWER_LEAKAGE_MAX_LEAKAGES_V1];
} NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2;
#define NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V1, 1)
#define NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2, 1)
#define NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_VER_2
#define NV_GPU_POWER_LEAKAGE_STATUS_PARAMS NV_GPU_POWER_LEAKAGE_STATUS_PARAMS_V2
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 295. Instead, use NvAPI_GPU_PowerLeakageGetStatus.")
    NVAPI_INTERFACE NvAPI_GPU_PowerLeakageGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                    NV_GPU_POWER_LEAKAGE_STATUS_PARAMS *pLeakageStatus);
#define NV_GPU_POWER_POLICY_MAX_POLICIES_V1 16
#define NV_GPU_POWER_POLICY_MAX_POLICIES_V2 32
#define NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1 16
#define NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V2 32
#define NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V1 6
#define NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V2 32
typedef enum {
  NV_GPU_POWER_POLICY_TYPE_TOTAL_GPU = 0x00000000,
  NV_GPU_POWER_POLICY_TYPE_WORKLOAD,
  NV_GPU_POWER_POLICY_TYPE_BANG_BANG_VF,
  NV_GPU_POWER_POLICY_TYPE_PROP_LIMIT,
  NV_GPU_POWER_POLICY_TYPE_HW_THRESHOLD,
  NV_GPU_POWER_POLICY_TYPE_MARCH_N,
  NV_GPU_POWER_POLICY_TYPE_WORKLOAD_MULTIRAIL,
  NV_GPU_POWER_POLICY_TYPE_MARCH_N_BA00,
  NV_GPU_POWER_POLICY_TYPE_MARCH_VF,
  NV_GPU_POWER_POLICY_TYPE_MARCH_VF_BA00,
  NV_GPU_POWER_POLICY_TYPE_VIOLATION_CONTROL,
  NV_GPU_POWER_POLICY_TYPE_BALANCE,
  NV_GPU_POWER_POLICY_TYPE_GEMINI,
  NV_GPU_POWER_POLICY_TYPE_WORKLOAD_SINGLE_1X,
  NV_GPU_POWER_POLICY_TYPE_WORKLOAD_COMBINED_1X,
  NV_GPU_POWER_POLICY_TYPE_MARCH_BA00 = 0xFFFFFFFA,
  NV_GPU_POWER_POLICY_TYPE_MARCH = 0xFFFFFFFB,
  NV_GPU_POWER_POLICY_TYPE_NDIV = 0xFFFFFFFC,
  NV_GPU_POWER_POLICY_TYPE_DOMGRP = 0xFFFFFFFD,
  NV_GPU_POWER_POLICY_TYPE_LIMIT = 0xFFFFFFFE,
  NV_GPU_POWER_POLICY_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_POLICY_TYPE;
typedef enum {
  NV_GPU_POWER_POLICY_LIMIT_UNIT_POWER_MW = 0x00000000,
  NV_GPU_POWER_POLICY_LIMIT_UNIT_CURRENT_MA,
} NV_GPU_POWER_POLICY_LIMIT_UNIT;
typedef enum {
  NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_WEIGHT = 0x00000000,
  NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_BALANCE,
  NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE;
typedef enum {
  NV_GPU_POWER_VIOLATION_TYPE_PROPGAIN = 0x00000000,
  NV_GPU_POWER_VIOLATION_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_VIOLATION_TYPE;
typedef enum {
  NV_GPU_POWER_POLICY_3X_FILTER_TYPE_NONE = 0x00000000,
  NV_GPU_POWER_POLICY_3X_FILTER_TYPE_BLOCK,
  NV_GPU_POWER_POLICY_3X_FILTER_TYPE_MOVING,
  NV_GPU_POWER_POLICY_3X_FILTER_TYPE_IIR,
  NV_GPU_POWER_POLICY_3X_FILTER_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_POWER_POLICY_3X_FILTER_TYPE;
typedef struct _NV_GPU_POWER_POLICY_DOMGRP_INFO {
  NvU8 b3DBoostVpstateFloor;
  NvU32 limitInflection;
} NV_GPU_POWER_POLICY_DOMGRP_INFO;
typedef struct _NV_GPU_POWER_POLICY_NDIV_INFO {
  NvU8 ndivCoeffMax;
} NV_GPU_POWER_POLICY_NDIV_INFO;
typedef struct _NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO {
  NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
  NvU16 uncapLimitRatio;
} NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO;
#define NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_RATIO 0x00
#define NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_TYPE_STATIC_VALUE 0x01
typedef union _NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_DATA {
  NvU16 ratio;
  NvU16 staticValue;
} NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_DATA;
typedef struct _NV_GPU_POWER_POLICY_MARCH_HYSTERESIS {
  NvU8 type;
  NV_GPU_POWER_POLICY_MARCH_HYSTERESIS_DATA data;
} NV_GPU_POWER_POLICY_MARCH_HYSTERESIS;
typedef struct _NV_GPU_POWER_POLICY_MARCH_BA00_PLANE_FIT {
  NvS32 coeffBA;
  NvS32 coeffCF;
  NvS32 coeffF;
  NvS32 intercept;
} NV_GPU_POWER_POLICY_MARCH_BA00_PLANE_FIT;
typedef struct _NV_GPU_POWER_POLICY_MARCH_BA00_INFO {
  NvU8 leakageIdx;
  NV_GPU_POWER_POLICY_MARCH_BA00_PLANE_FIT planeFit;
} NV_GPU_POWER_POLICY_MARCH_BA00_INFO;
typedef struct _NV_GPU_POWER_POLICY_MARCH_INFO {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU8 stepSize;
  NV_GPU_POWER_POLICY_MARCH_HYSTERESIS hysteresis;
  union {
    NV_GPU_POWER_POLICY_MARCH_BA00_INFO ba00;
  } data;
} NV_GPU_POWER_POLICY_MARCH_INFO;
typedef struct _NV_GPU_POWER_POLICY_MARCH_N_INFO {
  NV_GPU_POWER_POLICY_NDIV_INFO ndiv;
  NV_GPU_POWER_POLICY_MARCH_INFO march;
} NV_GPU_POWER_POLICY_MARCH_N_INFO;
typedef NV_GPU_POWER_POLICY_MARCH_N_INFO NV_GPU_POWER_POLICY_MARCH_N_BA00_INFO;
typedef struct _NV_GPU_POWER_POLICY_MARCH_VF_INFO {
  NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
  NV_GPU_POWER_POLICY_MARCH_INFO march;
} NV_GPU_POWER_POLICY_MARCH_VF_INFO;
typedef NV_GPU_POWER_POLICY_MARCH_VF_INFO NV_GPU_POWER_POLICY_MARCH_VF_BA00_INFO;
typedef struct _NV_GPU_POWER_POLICY_PROP_LIMIT_INFO {
  NvU8 policyRelIdxFirst;
  NvU8 policyRelIdxLast;
  NvU8 bDummy;
} NV_GPU_POWER_POLICY_PROP_LIMIT_INFO;
typedef struct _NV_GPU_POWER_POLICY_TOTAL_GPU_INFO_V1 {
  NvU8 fbPolicyRelIdx;
  NvU8 corePolicyRelIdx;
  NvU32 staticValue;
  NvU32 limitInflection;
  NvU8 bAdjEnabled;
  NvU8 adjRelIdxFirst;
  NvU8 adjRelIdxLast;
  NvU8 pwrChannelIdx;
} NV_GPU_POWER_POLICY_TOTAL_GPU_INFO_V1;
typedef struct _NV_GPU_POWER_POLICY_TOTAL_GPU_INFO_V2 {
  NvU8 fbPolicyRelIdx;
  NvU8 corePolicyRelIdx;
  NvU32 staticValue;
  NvU32 limitInflection0;
  NvU8 bAdjEnabled;
  NvU8 adjRelIdxFirst;
  NvU8 adjRelIdxLast;
  NvU8 pwrChannelIdx;
  NvU32 limitInflection1;
  NvU32 limitInflection2;
  NvBool bAdjBidirectionalEnabled;
} NV_GPU_POWER_POLICY_TOTAL_GPU_INFO_V2;
typedef struct _NV_GPU_POWER_POLICY_WORKLOAD_INFO {
  NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
  NvU8 leakageIdx;
  NvU8 medianFilterSize;
} NV_GPU_POWER_POLICY_WORKLOAD_INFO;
#define NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL_IDX0 0x00
#define NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL_IDX1 0x01
#define NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL_IDX_MAX 0x02
typedef struct {
  NvU8 chIdx;
  NvU8 voltRailIdx;
} NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL;
typedef struct _NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_INFO {
  NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
  NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL
  rail[NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL_IDX_MAX];
  NvU8 medianFilterSize;
} NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_INFO;
typedef struct {
  NvBool bSoftFloor;
  NvU32 clkPropTopIdx;
  NvU32 perfCfControllerClkIdx;
  NvU32 perfCfControllerIdx;
} NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_SOFT_FLOOR, *PNV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_SOFT_FLOOR;
typedef struct _NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_INFO {
  NvU32 voltRailIdx;
  NvU32 clkDomainIdx;
  NvBool bClkGatingAware;
  NvU8 medianFilterSize;
  NvU8 sensedVoltageMode;
  NvBool bDummy;
  NvU32 ignoreClkDomainIdx;
  NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_SOFT_FLOOR softFloor;
} NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_INFO;
typedef struct _NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_INFO {
  NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
  NvU32 singleRelIdxFirst;
  NvU32 singleRelIdxLast;
  NvU32 capMultiplier;
} NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_INFO;
typedef struct _NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO_POWER_TO_CURR_CONV {
  NvBool bUseCurrentConversion;
  NvU8 currentChannelIdx;
} NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO_POWER_TO_CURR_CONV;
typedef struct _NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO {
  NvU8 thresholdIdx;
  NvU8 lowThresholdIdx;
  NvU8 isUsingLowThreshold;
  NvU16 lowThresholdValue;
  NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO_POWER_TO_CURR_CONV pcc;
} NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO;
typedef struct _NV_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO {
  NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO hwThreshold;
  NvU32 limitDropRate;
  NvU32 limitRaiseRate;
  NvU32 limitDropValuemW;
  NvU32 limitRaiseValuemW;
  NvU8 policyRelIdx;
} NV_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO;
typedef struct _NV_GPU_POWER_POLICY_BALANCE_INFO {
  NvU8 policyRelIdxFirst;
  NvU8 policyRelIdxLast;
} NV_GPU_POWER_POLICY_BALANCE_INFO;
typedef enum {
  NV_GPU_POWER_POLICY_GEMINI_GPU_SLAVE = 0x0,
  NV_GPU_POWER_POLICY_GEMINI_GPU_MASTER,
  NV_GPU_POWER_POLICY_GEMINI_MAX_GPUS,
} NV_GPU_POWER_POLICY_GEMINI_GPU;
typedef struct {
  NvU16 samplePeriodms;
  NvU32 deltaStepSize;
  NvU32 deltaMax;
  NvU32 diffMax;
} NV_GPU_POWER_POLICY_GEMINI_CONTROLLER_PARAMS;
typedef struct {
  NvU8 geminiIdx;
  NvU32 boardId;
  NV_GPU_POWER_POLICY_GEMINI_CONTROLLER_PARAMS params;
} NV_GPU_POWER_POLICY_GEMINI_INFO_CONTROLLER;
typedef struct _NV_GPU_POWER_POLICY_GEMINI_INFO {
  NV_GPU_POWER_POLICY_GEMINI_GPU gpu;
  NvU8 policyRelIdxFirst;
  NvU8 policyRelIdxLast;
  NV_GPU_POWER_POLICY_GEMINI_INFO_CONTROLLER controller;
} NV_GPU_POWER_POLICY_GEMINI_INFO;
typedef struct _NV_GPU_POWER_POLICY_3X_FILTER_INFO_BLOCK {
  NvU8 blockSize;
} NV_GPU_POWER_POLICY_3X_FILTER_INFO_BLOCK;
typedef struct _NV_GPU_POWER_POLICY_3X_FILTER_INFO_MOVING {
  NvU8 windowSize;
} NV_GPU_POWER_POLICY_3X_FILTER_INFO_MOVING;
typedef struct _NV_GPU_POWER_POLICY_3X_FILTER_INFO_IIR {
  NvU8 divisor;
} NV_GPU_POWER_POLICY_3X_FILTER_INFO_IIR;
typedef struct _NV_GPU_POWER_POLICY_3X_FILTER_INFO_V3 {
  NV_GPU_POWER_POLICY_3X_FILTER_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_POWER_POLICY_3X_FILTER_INFO_BLOCK block;
    NV_GPU_POWER_POLICY_3X_FILTER_INFO_MOVING moving;
    NV_GPU_POWER_POLICY_3X_FILTER_INFO_IIR iir;
    NvU8 rsvd[32];
  } data;
} NV_GPU_POWER_POLICY_3X_FILTER_INFO_V3;
typedef struct _NV_GPU_POWER_POLICY_INFO_V1 {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU8 chIdx;
  NV_GPU_POWER_POLICY_LIMIT_UNIT limitUnit;
  NvU32 limitMin;
  NvU32 limitRated;
  NvU32 limitMax;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
    NV_GPU_POWER_POLICY_NDIV_INFO ndiv;
    NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO bangBangVf;
    NV_GPU_POWER_POLICY_PROP_LIMIT_INFO propLimit;
    NV_GPU_POWER_POLICY_TOTAL_GPU_INFO_V1 totalGpu;
    NV_GPU_POWER_POLICY_WORKLOAD_INFO workload;
    NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO hwThreshold;
    NvU8 rsvd[16];
  } data;
} NV_GPU_POWER_POLICY_INFO_V1;
typedef struct _NV_GPU_POWER_POLICY_INFO_V2 {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU8 chIdx;
  NV_GPU_POWER_POLICY_LIMIT_UNIT limitUnit;
  NvU32 limitMin;
  NvU32 limitRated;
  NvU32 limitMax;
  NvU32 limitBatt;
  NvU8 pastSampleCount;
  NvU8 nextSampleCount;
  NvU16 ratioLimitMin;
  NvU16 ratioLimitMax;
  NvU8 sampleMult;
  NvU8 rsvd[5];
  union {
    NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
    NV_GPU_POWER_POLICY_NDIV_INFO ndiv;
    NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO bangBangVf;
    NV_GPU_POWER_POLICY_MARCH_N_INFO marchN;
    NV_GPU_POWER_POLICY_MARCH_N_BA00_INFO marchNBA00;
    NV_GPU_POWER_POLICY_MARCH_VF_INFO marchVF;
    NV_GPU_POWER_POLICY_MARCH_VF_BA00_INFO marchVFBA00;
    NV_GPU_POWER_POLICY_PROP_LIMIT_INFO propLimit;
    NV_GPU_POWER_POLICY_TOTAL_GPU_INFO_V1 totalGpu;
    NV_GPU_POWER_POLICY_WORKLOAD_INFO workload;
    NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_INFO workloadMulRail;
    NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO hwThreshold;
    NV_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO vControl;
    NV_GPU_POWER_POLICY_BALANCE_INFO balance;
    NV_GPU_POWER_POLICY_GEMINI_INFO gemini;
    NvU8 rsvd[48];
  } data;
} NV_GPU_POWER_POLICY_INFO_V2;
typedef struct _NV_GPU_POWER_POLICY_INFO_V3 {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU8 chIdx;
  NV_GPU_POWER_POLICY_LIMIT_UNIT limitUnit;
  NvU32 limitMin;
  NvU32 limitRated;
  NvU32 limitMax;
  NvU32 limitBatt;
  NvU8 pastSampleCount;
  NvU8 nextSampleCount;
  NvU16 ratioLimitMin;
  NvU16 ratioLimitMax;
  NvU8 sampleMult;
  NV_GPU_POWER_POLICY_3X_FILTER_INFO_V3 filterInfo;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
    NV_GPU_POWER_POLICY_NDIV_INFO ndiv;
    NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO bangBangVf;
    NV_GPU_POWER_POLICY_MARCH_N_INFO marchN;
    NV_GPU_POWER_POLICY_MARCH_N_BA00_INFO marchNBA00;
    NV_GPU_POWER_POLICY_MARCH_VF_INFO marchVF;
    NV_GPU_POWER_POLICY_MARCH_VF_BA00_INFO marchVFBA00;
    NV_GPU_POWER_POLICY_PROP_LIMIT_INFO propLimit;
    NV_GPU_POWER_POLICY_TOTAL_GPU_INFO_V1 totalGpu;
    NV_GPU_POWER_POLICY_WORKLOAD_INFO workload;
    NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_INFO workloadMulRail;
    NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO hwThreshold;
    NV_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO vControl;
    NV_GPU_POWER_POLICY_BALANCE_INFO balance;
    NV_GPU_POWER_POLICY_GEMINI_INFO gemini;
    NvU8 rsvd[48];
  } data;
} NV_GPU_POWER_POLICY_INFO_V3;
typedef struct _NV_GPU_POWER_POLICY_INFO_V4 {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU8 chIdx;
  NV_GPU_POWER_POLICY_LIMIT_UNIT limitUnit;
  NvU32 limitMin;
  NvU32 limitRated;
  NvU32 limitMax;
  NvU32 limitBatt;
  NvU8 pastSampleCount;
  NvU8 nextSampleCount;
  NvU16 ratioLimitMin;
  NvU16 ratioLimitMax;
  NvU8 sampleMult;
  NV_GPU_POWER_POLICY_3X_FILTER_INFO_V3 filterInfo;
  NvU32 limitBattMax;
  NvU8 rsvd[12];
  union {
    NV_GPU_POWER_POLICY_DOMGRP_INFO domGrp;
    NV_GPU_POWER_POLICY_NDIV_INFO ndiv;
    NV_GPU_POWER_POLICY_BANG_BANG_VF_INFO bangBangVf;
    NV_GPU_POWER_POLICY_MARCH_N_INFO marchN;
    NV_GPU_POWER_POLICY_MARCH_N_BA00_INFO marchNBA00;
    NV_GPU_POWER_POLICY_MARCH_VF_INFO marchVF;
    NV_GPU_POWER_POLICY_MARCH_VF_BA00_INFO marchVFBA00;
    NV_GPU_POWER_POLICY_PROP_LIMIT_INFO propLimit;
    NV_GPU_POWER_POLICY_TOTAL_GPU_INFO_V2 totalGpu;
    NV_GPU_POWER_POLICY_WORKLOAD_INFO workload;
    NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_INFO workloadMulRail;
    NV_GPU_POWER_POLICY_WORKLOAD_SINGLE_1X_INFO single1x;
    NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_INFO
    combined1x;
    NV_GPU_POWER_POLICY_HW_THRESHOLD_INFO hwThreshold;
    NV_GPU_POWER_POLICY_VIOLATION_CONTROL_INFO vControl;
    NV_GPU_POWER_POLICY_BALANCE_INFO balance;
    NV_GPU_POWER_POLICY_GEMINI_INFO gemini;
    NvU8 rsvd[48];
  } data;
} NV_GPU_POWER_POLICY_INFO_V4;
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO {
  NvU16 weight;
} NV_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO;
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_BALANCE_INFO {
  NvU8 secPolicyIdx;
  NvU32 gpioFunc;
  NvU8 pwmSource;
  NvU32 pwmFreqHz;
  NvU32 pwmPeriod;
  NvU32 pwmDutyCycleInitial;
  NvU32 pwmDutyCycleStepSize;
  NvU8 phaseEstimateChIdx;
  NvU8 phaseCountMultiplier;
} NV_GPU_POWER_POLICY_RELATIONSHIP_BALANCE_INFO;
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1 {
  NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;
  NvU8 policyIdx;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO weight;
    NvU8 rsvd[16];
  } data;
} NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1;
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2 {
  NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;
  NvU8 policyIdx;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_POLICY_RELATIONSHIP_WEIGHT_INFO weight;
    NV_GPU_POWER_POLICY_RELATIONSHIP_BALANCE_INFO balance;
    NvU8 rsvd[48];
  } data;
} NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2;
typedef struct _NV_GPU_POWER_VIOLATION_PROPGAIN_INFO {
  NvU8 policyRelIdxFirst;
  NvU8 policyRelIdxLast;
} NV_GPU_POWER_VIOLATION_PROPGAIN_INFO_V1;
typedef struct {
  NV_GPU_POWER_VIOLATION_THERM_INDEX_TYPE thrmIdxType;
  union {
    NvU8 thrmEvent;
    NvU8 thrmMon;
  } index;
} NV_GPU_POWER_VIOLATION_THERM_INDEX, *PNV_GPU_POWER_VIOLATION_THERM_INDEX;
typedef struct _NV_GPU_POWER_VIOLATION_INFO_V1 {
  NV_GPU_POWER_VIOLATION_TYPE type;
  NvU8 thrmEventIdx;
  NvU8 sampleMult;
  NV_GPU_POWER_VIOLATION_THERM_INDEX thrmIdx;
  NvU8 rsvd[56];
  union {
    NV_GPU_POWER_VIOLATION_PROPGAIN_INFO_V1 propGain;
    NvU8 rsvd[64];
  } data;
} NV_GPU_POWER_VIOLATION_INFO_V1;
typedef struct {
  NvU32 version;
  NvU8 policyTableIdx;
  NvU32 limit;
} NV_GPU_PWR_POLICY_EXT_LIMIT_V1;
#define NV_GPU_PWR_POLICY_EXT_LIMIT_VER_1 MAKE_NVAPI_VERSION(NV_GPU_PWR_POLICY_EXT_LIMIT_V1, 1)
#define NV_GPU_PWR_POLICY_EXT_LIMIT_VER NV_GPU_PWR_POLICY_EXT_LIMIT_VER_1
#define NV_GPU_PWR_POLICY_EXT_LIMIT NV_GPU_PWR_POLICY_EXT_LIMIT_V1
typedef enum {
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D2 = 0x00000000,
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D3,
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D4,
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D5,
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_COUNT,
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_D1 = 0xFFFFFFFF,
} NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID;
NVAPI_INTERFACE NvAPI_GPU_SetExternPowerState(NvPhysicalGpuHandle hPhysicalGpu,
                                              NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID powerState);
#define NV_GPU_POWER_POLICY_TABLE_VERSION_2X 0x20
#define NV_GPU_POWER_POLICY_TABLE_VERSION_3X 0x30
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 domGrpPolicyMask;
  NvU32 limitPolicyMask;
  NvU32 policyRelMask;
  NvU8 tgpPolicyIdx;
  NvU8 rtpPolicyIdx;
  NvU8 rsvd[16];
  NV_GPU_POWER_POLICY_INFO_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V1;
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V2 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 domGrpPolicyMask;
  NvU32 limitPolicyMask;
  NvU32 policyRelMask;
  NvU8 tgpPolicyIdx;
  NvU8 rtpPolicyIdx;
  NvU8 rsvd[16];
  NV_GPU_POWER_POLICY_INFO_V2 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V2;
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V3 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 domGrpPolicyMask;
  NvU32 limitPolicyMask;
  NvU32 policyRelMask;
  NvU8 tgpPolicyIdx;
  NvU8 rtpPolicyIdx;
  NvU32 balancePolicyMask;
  NvU16 baseSamplePeriod;
  NvU8 policyVersion;
  NvU8 rsvd[29];
  NV_GPU_POWER_POLICY_INFO_V2 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V3;
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V4 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 domGrpPolicyMask;
  NvU32 limitPolicyMask;
  NvU32 policyRelMask;
  NvU8 tgpPolicyIdx;
  NvU8 rtpPolicyIdx;
  NvU32 balancePolicyMask;
  NvU16 baseSamplePeriod;
  NvU8 policyVersion;
  NvU16 minClientSamplePeriod;
  NvU8 lowSamplingMult;
  NvU8 pwrTgtPolicyIdx;
  NvU8 pwrTgtFloorPolicyIdx;
  NvU8 rsvd[23];
  NV_GPU_POWER_POLICY_INFO_V2 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
  NV_GPU_PWR_POLICY_EXT_LIMIT extLimits[NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_COUNT];
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID extPowerState;
} NV_GPU_POWER_POLICY_INFO_PARAMS_V4;
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V5 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 domGrpPolicyMask;
  NvU32 limitPolicyMask;
  NvU32 policyRelMask;
  NvU8 tgpPolicyIdx;
  NvU8 rtpPolicyIdx;
  NvU32 balancePolicyMask;
  NvU16 baseSamplePeriod;
  NvU8 policyVersion;
  NvU16 minClientSamplePeriod;
  NvU8 lowSamplingMult;
  NvU8 pwrTgtPolicyIdx;
  NvU8 pwrTgtFloorPolicyIdx;
  NvU32 pwrViolMask;
  NvU8 rsvd[19];
  NV_GPU_POWER_POLICY_INFO_V2 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
  NV_GPU_PWR_POLICY_EXT_LIMIT extLimits[NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_COUNT];
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID extPowerState;
  NV_GPU_POWER_VIOLATION_INFO_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V1];
  NvU8 rsvd1[64];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V5;
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V6 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 domGrpPolicyMask;
  NvU32 limitPolicyMask;
  NvU32 policyRelMask;
  NvU8 tgpPolicyIdx;
  NvU8 rtpPolicyIdx;
  NvU32 balancePolicyMask;
  NvU16 baseSamplePeriod;
  NvU8 policyVersion;
  NvU16 minClientSamplePeriod;
  NvU8 lowSamplingMult;
  NvU8 pwrTgtPolicyIdx;
  NvU8 pwrTgtFloorPolicyIdx;
  NvU32 pwrViolMask;
  NvBool bHideTgpReading;
  NvU8 rsvd[18];
  NV_GPU_POWER_POLICY_INFO_V3 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
  NV_GPU_PWR_POLICY_EXT_LIMIT extLimits[NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_COUNT];
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID extPowerState;
  NV_GPU_POWER_VIOLATION_INFO_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V1];
  NvU8 rsvd1[64];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V6;
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V7 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 domGrpPolicyMask;
  NvU32 limitPolicyMask;
  NvU32 policyRelMask;
  NvU8 tgpPolicyIdx;
  NvU8 rtpPolicyIdx;
  NvU32 balancePolicyMask;
  NvU16 baseSamplePeriod;
  NvU8 policyVersion;
  NvU16 minClientSamplePeriod;
  NvU8 lowSamplingMult;
  NvU8 pwrTgtPolicyIdx;
  NvU8 pwrTgtFloorPolicyIdx;
  NvU32 pwrViolMask;
  NvBool bHideTgpReading;
  NvU32 edppLimit;
  NvU8 rsvd[14];
  NV_GPU_POWER_POLICY_INFO_V4 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
  NV_GPU_PWR_POLICY_EXT_LIMIT extLimits[NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_COUNT];
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID extPowerState;
  NV_GPU_POWER_VIOLATION_INFO_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V1];
  NvU8 rsvd1[64];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V7;
typedef struct _NV_GPU_POWER_POLICY_INFO_PARAMS_V8 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 domGrpPolicyMask;
  NvU32 limitPolicyMask;
  NvU32 policyRelMask;
  NvU8 tgpPolicyIdx;
  NvU8 rtpPolicyIdx;
  NvU32 balancePolicyMask;
  NvU16 baseSamplePeriod;
  NvU8 policyVersion;
  NvU16 minClientSamplePeriod;
  NvU8 lowSamplingMult;
  NvU8 pwrTgtPolicyIdx;
  NvU8 pwrTgtFloorPolicyIdx;
  NvU32 pwrViolMask;
  NvBool bHideTgpReading;
  NvU32 edppLimit;
  NvBool bInflectionPointsDisableSupported;
  NvBool bInflectionPointsDisableReasonsSupported;
  NvBool bPPOlimitCurrBroadcast;
  NvU8 rsvd[61];
  NV_GPU_POWER_POLICY_INFO_V4 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V2];
  NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V2];
  NV_GPU_PWR_POLICY_EXT_LIMIT extLimits[NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID_COUNT];
  NV_GPU_PWR_POLICY_EXT_POWER_STATE_ID extPowerState;
  NV_GPU_POWER_VIOLATION_INFO_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V2];
  NvU8 rsvd1[64];
} NV_GPU_POWER_POLICY_INFO_PARAMS_V8;
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V1, 1)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V2, 1)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_3 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V3, 1)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_4 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V4, 4)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_5 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V5, 5)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_6 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V6, 6)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_7 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V7, 7)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER_8 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_INFO_PARAMS_V8, 8)
#define NV_GPU_POWER_POLICY_INFO_PARAMS_VER NV_GPU_POWER_POLICY_INFO_PARAMS_VER_8
#define NV_GPU_POWER_POLICY_INFO_PARAMS NV_GPU_POWER_POLICY_INFO_PARAMS_V8
#define NV_GPU_POWER_POLICY_INFO NV_GPU_POWER_POLICY_INFO_V4
#define NV_GPU_POWER_POLICY_RELATIONSHIP_INFO NV_GPU_POWER_POLICY_RELATIONSHIP_INFO_V2
#define NV_GPU_POWER_VIOLATION_INFO NV_GPU_POWER_VIOLATION_INFO_V1
NVAPI_INTERFACE NvAPI_GPU_PowerPolicyGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                             NV_GPU_POWER_POLICY_INFO_PARAMS *pPolicyInfo);
#define NV_GPU_POWER_POLICY_DOMAIN_GROUPS_LIMTS_MAX_DOMAIN_GROUPS 2
#define NV_GPU_POWER_POLICY_DOMAIN_GROUPS_LIMTS_MAX_DOMAIN_GROUPS_V2 8
#define NV_GPU_POWER_POLICY_DOMAIN_GROUP_LIMIT_VALUE_DISABLED 0xFFFFFFFF
typedef struct {
  NvU32 values[NV_GPU_POWER_POLICY_DOMAIN_GROUPS_LIMTS_MAX_DOMAIN_GROUPS];
} NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS;
typedef struct {
  NvU32 values[NV_GPU_POWER_POLICY_DOMAIN_GROUPS_LIMTS_MAX_DOMAIN_GROUPS_V2];
} NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS_V2;
typedef struct {
  NvU8 ndivCoeff;
} NV_GPU_POWER_POLICY_STATUS_NDIV;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
} NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpCeiling;
  NvU8 rsvd[16];
} NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS_V2 domGrpLimits;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS_V2 domGrpCeiling;
  NvU8 rsvd1[32];
} NV_GPU_POWER_POLICY_STATUS_DOMGRP_V3;
#define NV_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_NONE 0x00000000
#define NV_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_CAP 0x00000001
#define NV_GPU_POWER_POLICY_BANG_BANG_VF_ACTION_UNCAP 0x00000002
typedef struct {
  NvU8 pstateIdx;
  NvU8 vfIdx;
} NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1 domGrp;
  NvU8 action;
  NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
  input;
  NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
  output;
} NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
  NvU8 action;
  NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
  input;
  NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
  output;
} NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V3 domGrp;
  NvU8 action;
  NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
  input;
  NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_INDEXES
  output;
} NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V3;
#define NV_GPU_POWER_POLICY_MARCH_ACTION_NONE 0x00
#define NV_GPU_POWER_POLICY_MARCH_ACTION_CAP 0x01
#define NV_GPU_POWER_POLICY_MARCH_ACTION_UNCAP 0x02
typedef struct {
  NvU32 voltageuV;
  NvU32 freqMHz;
  NvU32 pwrLeakagemW;
  NvU32 limitCurrBA;
} NV_GPU_POWER_POLICY_STATUS_MARCH_BA00;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 uncapLimit;
  NvU8 action;
  union {
    NV_GPU_POWER_POLICY_STATUS_MARCH_BA00 ba00;
  } data;
} NV_GPU_POWER_POLICY_STATUS_MARCH;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_NDIV ndiv;
  NV_GPU_POWER_POLICY_STATUS_MARCH march;
} NV_GPU_POWER_POLICY_STATUS_MARCH_N;
typedef NV_GPU_POWER_POLICY_STATUS_MARCH_N NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1 domGrp;
  NV_GPU_POWER_POLICY_STATUS_MARCH march;
} NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V1;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
  NV_GPU_POWER_POLICY_STATUS_MARCH march;
} NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V2;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V3 domGrp;
  NV_GPU_POWER_POLICY_STATUS_MARCH march;
} NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V3;
typedef NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V1 NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00;
typedef struct {
  NvU32 pwrLeakagemW;
  NvU32 freqMHz;
  NvU32 voltmV2;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT;
typedef struct {
  NvU32 workloadmWperMHzmV2;
  NvU32 pwrLeakagemW;
  NvU32 freqMaxMHz;
  NvU32 voltmV2;
  NvU8 vfEntryIdx;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1 domGrp;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT work;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT freq;
  NvU32 workloadmWperMHzmV2;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V1;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT work;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT freq;
  NvU32 workloadmWperMHzmV2;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V2;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V3 domGrp;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_WORK_INPUT work;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_FREQ_INPUT freq;
  NvU32 workloadmWperMHzmV2;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V3;
typedef struct {
  NvU32 leakagemX;
  NvU32 voltmV;
  NvU32 observedVal;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_VOLT_RAIL_WORK_INPUT;
typedef struct {
  NvU32 freqMHz;
  NvU32 mscgResidency;
  NvU32 pgResidency;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_VOLT_RAIL_WORK_INPUT
  rail[NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL_IDX_MAX];
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_WORK_INPUT;
typedef struct {
  NvU32 workload;
  NvU32 leakagemX;
  NvU32 voltmV;
  NvU32 estimatedVal;
  NvU32 voltFlooruV;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_VOLT_RAIL_FREQ_INPUT;
typedef struct {
  NvU32 freqMaxMHz;
  NvU32 mscgResidency;
  NvU32 pgResidency;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_VOLT_RAIL_FREQ_INPUT
  rail[NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL_IDX_MAX];
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_FREQ_INPUT;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_WORK_INPUT work;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_FREQ_INPUT freq;
  NvU32 workloadmWperMHzmV2[NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL_IDX_MAX];
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_V1;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V3 domGrp;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_WORK_INPUT work;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_FREQ_INPUT freq;
  NvU32 workloadmWperMHzmV2[NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_VOLT_RAIL_IDX_MAX];
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_V2;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_COMBINED_1X_V1 obsMet;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_COMBINED_1X_V1 estMet;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_COMBINED_1X_V1;
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SINGLE_1X_IDX_PRI 0x0
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SINGLE_1X_IDX_SEC 0x1
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SINGLE_1X_IDX_MAX 0x2
typedef struct {
  NvU32 freqMHz[NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SINGLE_1X_IDX_MAX];
} NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIME_SINGLES_FREQ_TUPLE;
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_DEFAULT_RATIO 0x0
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_SEC_VMIN_FLOOR 0x1
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_SEC_SOFT_FLOOR 0x2
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_PRI_VMIN_FLOOR 0x3
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_MAX_RATIO 0x4
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_MIN_RATIO 0x5
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_MAX 0x5
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_MAX_V2 0x5
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_MAX_V3 0x8
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_INVALID 0xFF
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_DEFAULT_RATIO                                           \
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_DEFAULT_RATIO
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_SEC_VMIN_FLOOR                                          \
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_SEC_VMIN_FLOOR
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_SEC_SOFT_FLOOR                                          \
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_SEC_SOFT_FLOOR
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_PRI_VMIN_FLOOR                                          \
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_PRI_VMIN_FLOOR
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_MAX_RATIO                                               \
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_MAX_RATIO
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_MAX                                                     \
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_MAX
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_INVALID                                                 \
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_INVALID
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_TUPLE_IDX_START 0x0
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_TUPLE_IDX_END 0x1
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_TUPLE_IDX_MAX 0x2
typedef struct {
  NvU16 tupleStartIdx;
  NvU16 tupleEndIdx;
  NvU16 clkFreqStartIdx;
  NvU16 clkFreqEndIdx;
  NvU8 regimeId;
  NvU8 pad[3];
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIME_SINGLES_FREQ_TUPLE
  freqTuples[NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_TUPLE_IDX_MAX];
  NvU8 rsvd[52];
} NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME, *PNV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME;
typedef struct {
  NvU8 searchRegimeIdx;
  NvU16 tupleIdx;
} NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIMES_STATUS_TUPLE;
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIMES_STATUS_TUPLE_IDX_SEARCH 0x0
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIMES_STATUS_TUPLE_IDX_SCALING 0x1
#define NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIMES_STATUS_TUPLE_IDX_MAX 0x2
typedef struct {
  NvU8 numRegimes;
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIMES_STATUS_TUPLE
  tuples[NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIMES_STATUS_TUPLE_IDX_MAX];
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME
  searchRegimes[NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_MAX_V3];
  NvU8 rsvd[512];
} NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIMES_STATUS;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V3 domGrp;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_COMBINED_1X_V2 obsMet;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_COMBINED_1X_V2 estMet;
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME
  searchRegimes[NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_SEARCH_REGIME_ID_MAX_V2];
  NvU8 numRegimes;
  NvU8 rsvd[64];
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_COMBINED_1X_V2;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_DOMGRP_V3 domGrp;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_COMBINED_1X_V2 obsMet;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_COMBINED_1X_V2 estMet;
  NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_REGIMES_STATUS regimesStatus;
  NvU8 rsvd[1024];
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_COMBINED_1X_V3;
#define NV_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS 0x4
#define NV_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS_EXTRA 0x2
#define NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT_POLICY_IDX_RM 0xFF
typedef struct {
  NvU8 pwrPolicyIdx;
  NvU32 limitValue;
} NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT;
typedef struct {
  NvU8 numInputs;
  NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT
  inputs[NV_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS];
} NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT
  inputs[NV_GPU_POWER_POLICY_STATUS_MAX_LIMIT_INPUTS_EXTRA];
} NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS_EXTRA;
typedef struct _NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD {
  NvU32 violationCnt;
} NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD;
typedef struct _NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL {
  NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
  NvU32 violationRate;
  NvU32 targetPLimitmW;
} NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL;
#define NV_GPU_POWER_POLICY_STATUS_BALANCE_MAX_RELATIONSHIP_ENTRIES 4
typedef struct _NV_GPU_POWER_POLICY_STATUS_BALANCE_RELATIONSHIP_ENTRY {
  NvU8 relIdx;
  NvU32 limitLower;
  NvU32 limitDiff;
} NV_GPU_POWER_POLICY_STATUS_BALANCE_RELATIONSHIP_ENTRY;
typedef struct _NV_GPU_POWER_POLICY_STATUS_BALANCE {
  NV_GPU_POWER_POLICY_STATUS_BALANCE_RELATIONSHIP_ENTRY
  relEntries[NV_GPU_POWER_POLICY_STATUS_BALANCE_MAX_RELATIONSHIP_ENTRIES];
} NV_GPU_POWER_POLICY_STATUS_BALANCE;
typedef struct _NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT {
  NvU8 bBalanceDirty;
} NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT;
#define NV_GPU_POWER_POLICY_GEMINI_ACTION_TO_SLAVE -1
#define NV_GPU_POWER_POLICY_GEMINI_ACTION_NONE 0
#define NV_GPU_POWER_POLICY_GEMINI_ACTION_TO_MASTER 1
typedef struct {
  NvU32 freqAvgkHz;
} NV_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER_GPU;
typedef struct {
  NvS8 action;
  NvU8 bEnable;
  NvS32 limitDelta;
  NV_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER_GPU
  gpus[NV_GPU_POWER_POLICY_GEMINI_MAX_GPUS];
} NV_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER;
typedef struct _NV_GPU_POWER_POLICY_STATUS_GEMINI {
  NV_GPU_POWER_POLICY_STATUS_GEMINI_CONTROLLER controller;
} NV_GPU_POWER_POLICY_STATUS_GEMINI;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS_EXTRA limitInputsExtra;
  NvU8 rsvd[32];
} NV_GPU_POWER_POLICY_STATUS_EXTRA;
typedef struct {
  NvS32 currRunningDiff;
  NvS32 currIntegralLimit;
  NvU8 rsvd[64];
} NV_GPU_POWER_POLICY_STATUS_INTEGRAL;
#define NV_GPU_POWER_POLICY_LIMIT_ARBITRATION_MAX_LIMIT_INPUTS 8U
typedef struct {
  NvBool bArbMax;
  NvU8 numInputs;
  NvU32 output;
  NvU8 rsvd[64];
  NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUT
  inputs[NV_GPU_POWER_POLICY_LIMIT_ARBITRATION_MAX_LIMIT_INPUTS];
} NV_GPU_POWER_POLICY_LIMIT_ARBITRATION;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 limitCurr;
  NvU32 valueCurr;
  NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1 domGrp;
    NV_GPU_POWER_POLICY_STATUS_NDIV ndiv;
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1 bangBangVf;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N marchN;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00 marchNBA00;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V1 marchVF;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00 marchVFBA00;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V1 workload;
    NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL vControl;
    NvU8 rsvd[44];
  } data;
} NV_GPU_POWER_POLICY_STATUS_V1;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 limitCurr;
  NvU32 valueCurr;
  NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;
  NvS32 limitDelta;
  NvU8 rsvd[12];
  union {
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V1 domGrp;
    NV_GPU_POWER_POLICY_STATUS_NDIV ndiv;
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V1 bangBangVf;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N marchN;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00 marchNBA00;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V1 marchVF;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00 marchVFBA00;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V1 workload;
    NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL vControl;
    NV_GPU_POWER_POLICY_STATUS_BALANCE balance;
    NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT propLimit;
    NV_GPU_POWER_POLICY_STATUS_GEMINI gemini;
    NvU8 rsvd[48];
  } data;
} NV_GPU_POWER_POLICY_STATUS_V2;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 limitCurr;
  NvU32 valueCurr;
  NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;
  NvS32 limitDelta;
  NvS32 currRunningDiff;
  NvS32 currIntegralLimit;
  NvU32 preIntegralLimit;
  union {
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
    NV_GPU_POWER_POLICY_STATUS_NDIV ndiv;
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2 bangBangVf;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N marchN;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00 marchNBA00;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V2 marchVF;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00 marchVFBA00;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V2 workload;
    NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL vControl;
    NV_GPU_POWER_POLICY_STATUS_BALANCE balance;
    NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT propLimit;
    NV_GPU_POWER_POLICY_STATUS_GEMINI gemini;
    NvU8 rsvd[68];
  } data;
} NV_GPU_POWER_POLICY_STATUS_V3;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 limitCurr;
  NvU32 valueCurr;
  NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;
  NvS32 limitDelta;
  NvS32 currRunningDiff;
  NvS32 currIntegralLimit;
  NvU32 preIntegralLimit;
  union {
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
    NV_GPU_POWER_POLICY_STATUS_NDIV ndiv;
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2 bangBangVf;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N marchN;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00 marchNBA00;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V2 marchVF;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00 marchVFBA00;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V2 workload;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_V1
    workloadMulRail;
    NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL vControl;
    NV_GPU_POWER_POLICY_STATUS_BALANCE balance;
    NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT propLimit;
    NV_GPU_POWER_POLICY_STATUS_GEMINI gemini;
    NvU8 rsvd[156];
  } data;
} NV_GPU_POWER_POLICY_STATUS_V4;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 limitCurr;
  NvU32 valueCurr;
  NV_GPU_POWER_POLICY_STATUS_LIMIT_INPUTS limitInputs;
  NvS32 limitDelta;
  NvS32 currRunningDiff;
  NvS32 currIntegralLimit;
  NvU32 preIntegralLimit;
  union {
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
    NV_GPU_POWER_POLICY_STATUS_NDIV ndiv;
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2 bangBangVf;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N marchN;
    NV_GPU_POWER_POLICY_STATUS_MARCH_N_BA00 marchNBA00;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V2 marchVF;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_BA00 marchVFBA00;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V2 workload;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_V1
    workloadMulRail;
    NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    NV_GPU_POWER_POLICY_STATUS_VIOLATION_CONTROL vControl;
    NV_GPU_POWER_POLICY_STATUS_BALANCE balance;
    NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT propLimit;
    NV_GPU_POWER_POLICY_STATUS_GEMINI gemini;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_COMBINED_1X_V1
    combined1x;
    NvU8 rsvd[848];
  } data;
} NV_GPU_POWER_POLICY_STATUS_V5;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 limitCurr;
  NvU32 valueCurr;
  NvS32 limitDelta;
  NV_GPU_POWER_POLICY_STATUS_INTEGRAL integral;
  NV_GPU_POWER_POLICY_LIMIT_ARBITRATION limitArbRmCurr;
  NV_GPU_POWER_POLICY_LIMIT_ARBITRATION limitArbPmuCurr;
  NvU8 rsvd[2048];
  union {
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V2 domGrp;
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V2 bangBangVf;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V2 marchVF;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V2 workload;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_V1
    workloadMulRail;
    NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    NV_GPU_POWER_POLICY_STATUS_BALANCE balance;
    NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT propLimit;
    NV_GPU_POWER_POLICY_STATUS_GEMINI gemini;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_COMBINED_1X_V1
    combined1x;
    NvU8 rsvd[2048];
  } data;
} NV_GPU_POWER_POLICY_STATUS_V6;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 limitCurr;
  NvU32 valueCurr;
  NvS32 limitDelta;
  NV_GPU_POWER_POLICY_STATUS_INTEGRAL integral;
  NV_GPU_POWER_POLICY_LIMIT_ARBITRATION limitArbRmCurr;
  NV_GPU_POWER_POLICY_LIMIT_ARBITRATION limitArbPmuCurr;
  NvU8 rsvd[2048];
  union {
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V3 domGrp;
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V3 bangBangVf;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V3 marchVF;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V3 workload;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_V2
    workloadMulRail;
    NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    NV_GPU_POWER_POLICY_STATUS_BALANCE balance;
    NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT propLimit;
    NV_GPU_POWER_POLICY_STATUS_GEMINI gemini;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_COMBINED_1X_V2
    combined1x;
    NvU8 rsvd[10240];
  } data;
} NV_GPU_POWER_POLICY_STATUS_V7;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 limitCurr;
  NvU32 valueCurr;
  NvS32 limitDelta;
  NV_GPU_POWER_POLICY_STATUS_INTEGRAL integral;
  NV_GPU_POWER_POLICY_LIMIT_ARBITRATION limitArbRmCurr;
  NV_GPU_POWER_POLICY_LIMIT_ARBITRATION limitArbPmuCurr;
  NvU8 rsvd[2048];
  union {
    NV_GPU_POWER_POLICY_STATUS_DOMGRP_V3 domGrp;
    NV_GPU_POWER_POLICY_STATUS_BANG_BANG_VF_V3 bangBangVf;
    NV_GPU_POWER_POLICY_STATUS_MARCH_VF_V3 marchVF;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_V3 workload;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_V2
    workloadMulRail;
    NV_GPU_POWER_POLICY_STATUS_HW_THRESHOLD hwThreshold;
    NV_GPU_POWER_POLICY_STATUS_BALANCE balance;
    NV_GPU_POWER_POLICY_STATUS_PROP_LIMIT propLimit;
    NV_GPU_POWER_POLICY_STATUS_GEMINI gemini;
    NV_GPU_POWER_POLICY_STATUS_WORKLOAD_COMBINED_1X_V3
    combined1x;
    NvU8 rsvd[11776];
  } data;
} NV_GPU_POWER_POLICY_STATUS_V8;
typedef struct {
  NvU8 rsvd;
} NV_GPU_POWER_POLICY_STATUS_RPPM_1X_INTERFACE;
typedef struct {
  NvU32 fbPwrStaticmW;
  NvU32 fbPwrSlopePctNorm;
  NvU32 fbPwrSlopePct;
  NV_GPU_POWER_POLICY_STATUS_RPPM_1X_INTERFACE rppm1xIface;
} NV_GPU_POWER_POLICY_STATUS_RPPM_FB_1X;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_WORK_INPUT work;
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_FREQ_INPUT freq;
} NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_INTERFACE;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_WORKLOAD_MULTIRAIL_INTERFACE multiRail;
  NV_GPU_POWER_POLICY_STATUS_RPPM_1X_INTERFACE rppm1xIface;
} NV_GPU_POWER_POLICY_STATUS_RPPM_CWC_1X;
typedef struct {
  NvU8 rsvd;
} NV_GPU_POWER_POLICY_STATUS_TOTAL_GPU_INTERFACE;
typedef struct {
  NV_GPU_POWER_POLICY_STATUS_TOTAL_GPU_INTERFACE tgpIface;
  NV_GPU_POWER_POLICY_STATUS_RPPM_1X_INTERFACE rppm1xIface;
} NV_GPU_POWER_POLICY_STATUS_RPPM_TGP_1X;
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT {
  NvU8 bBalanceDirty;
  NvS32 valueOld;
  NvS32 valueNew;
  NvS32 limitRequestOld;
  NvS32 limitRequestNew;
} NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT;
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_NONE 0x0
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_TO_PRI 0x1
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_ACTION_TO_SEC 0x2
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT_PRI 0x0
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT_SEC 0x1
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_MAX_PROP_LIMITS 0x2
typedef struct _NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE {
  NvS8 action;
  NvU32 pwmPctCurr;
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_PROP_LIMIT
  propLimits[NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE_MAX_PROP_LIMITS];
} NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE;
typedef struct {
  NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE balance;
    NvU8 rsvd[48];
  } data;
} NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1;
typedef struct {
  NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;
  NvU8 rsvd[2048];
  union {
    NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_BALANCE balance;
    NvU8 rsvd[2048];
  } data;
} NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V2;
typedef struct _NV_GPU_POWER_VIOLATION_STATUS_PROPGAIN_V1 {
  NvS32 pwrLimitAdj;
} NV_GPU_POWER_VIOLATION_STATUS_PROPGAIN_V1;
typedef struct _NV_GPU_POWER_VIOLATION_STATUS_V1 {
  NV_GPU_POWER_VIOLATION_TYPE type;
  NvU16 violCurrent;
  NvU8 rsvd[64];
  union {
    NV_GPU_POWER_VIOLATION_STATUS_PROPGAIN_V1 propGain;
    NvU8 rsvd[64];
  } data;
} NV_GPU_POWER_VIOLATION_STATUS_V1;
typedef struct _NV_GPU_POWER_VIOLATION_STATUS_V2 {
  NV_GPU_POWER_VIOLATION_TYPE type;
  NvU16 violCurrent;
  NvU8 rsvd[2048];
  union {
    NV_GPU_POWER_VIOLATION_STATUS_PROPGAIN_V1 propGain;
    NvU8 rsvd[2048];
  } data;
} NV_GPU_POWER_VIOLATION_STATUS_V2;
typedef NV_GPU_BOARDOBJGRP_MASK_E32 NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_MASK;
typedef NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_MASK
    NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REASONS;
typedef NvBoardObjIdx NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID;
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_API 0U
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_PERF_CF_CONTROLLERS_CONTROLLER0 1U
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_PERF_CF_CONTROLLERS_CONTROLLER1 2U
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_PERF_CF_CONTROLLERS_CONTROLLER2 3U
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_PERF_CF_CONTROLLERS_CONTROLLER3 4U
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_NUM 5U
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_NUM_RSVD 16U
typedef NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID
    NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REASON;
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REASON_API                                                 \
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_API
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REASON_PERF_CF_CONTROLLERS                                 \
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_PERF_CF_CONTROLLERS_CONTROLLER0
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REASON_NUM 2U
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_MASK_INIT(_pRequestIdMask)                      \
  NV_GPU_BOARDOBJGRP_MASK_INIT(&(_pRequestIdMask)->super, NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS)
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_MASK_REQUEST(_pRequestIdMask, _requestId)       \
  NV_GPU_BOARDOBJGRP_MASK_BIT_SET(&(_pRequestIdMask)->super, (_requestId))
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_MASK_REQUEST_ID_REQUESTED(_pRequestIdMask,      \
                                                                                                 _requestId)           \
  NV_GPU_BOARDOBJGRP_MASK_BIT_IS_SET((_requestId), &(_pRequestIdMask)->super)
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REASONS_REQUESTED                                          \
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_MASK_REQUEST_ID_REQUESTED
typedef struct {
  NvU64 timestamp;
  NvU32 clientData;
  NvBoardObjIdx pstateIdxLowest;
  NvU8 rsvd[128];
} NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST;
#define NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_TIMESTAMP_INFINITELY_RECENT NV_U64_MAX
typedef struct {
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_MASK requestIdMask;
  NvU8 rsvd[128];
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST
      requests[NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST_ID_NUM_RSVD];
} NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
  NvU8 rsvd[16];
  NV_GPU_POWER_POLICY_STATUS_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V1;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
  NvU32 policyRelMask;
  NvU8 rsvd[32];
  NV_GPU_POWER_POLICY_STATUS_V2 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V2;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
  NvU32 policyRelMask;
  NvU8 rsvd[32];
  NV_GPU_POWER_POLICY_STATUS_V3 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V3;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
  NvU32 policyRelMask;
  NvU8 rsvd[32];
  NV_GPU_POWER_POLICY_STATUS_V3 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
  NV_GPU_POWER_POLICY_STATUS_EXTRA policyExtras[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V4;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
  NvU32 policyRelMask;
  NvU32 pwrViolMask;
  NvU8 rsvd[64];
  NV_GPU_POWER_POLICY_STATUS_V4 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
  NV_GPU_POWER_POLICY_STATUS_EXTRA policyExtras[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_VIOLATION_STATUS_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V5;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
  NvU32 policyRelMask;
  NvU32 pwrViolMask;
  NvU8 rsvd[64];
  NV_GPU_POWER_POLICY_STATUS_V5 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
  NV_GPU_POWER_POLICY_STATUS_EXTRA policyExtras[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_VIOLATION_STATUS_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V1];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V6;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
  NvU32 policyRelMask;
  NvU32 pwrViolMask;
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REASONS inflectionPointsDisableReasons;
  NvU8 rsvd[60];
  NV_GPU_POWER_POLICY_STATUS_V5 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V2];
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V2];
  NV_GPU_POWER_POLICY_STATUS_EXTRA policyExtras[NV_GPU_POWER_POLICY_MAX_POLICIES_V2];
  NV_GPU_POWER_VIOLATION_STATUS_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V2];
  NvU8 rsvd1[64];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V7;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS domGrpLimits;
  NV_GPU_BOARDOBJGRP_MASK_E32 policyRelMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 pwrViolMask;
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE inflectionPointsDisable;
  NvU8 rsvd[2048];
  NV_GPU_POWER_POLICY_STATUS_V6 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V2];
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V2
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V2];
  NV_GPU_POWER_VIOLATION_STATUS_V2
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V2];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V8;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS_V2 domGrpLimits;
  NV_GPU_BOARDOBJGRP_MASK_E32 policyRelMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 pwrViolMask;
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE inflectionPointsDisable;
  NvU8 rsvd[2048];
  NV_GPU_POWER_POLICY_STATUS_V7 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V2];
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V2
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V2];
  NV_GPU_POWER_VIOLATION_STATUS_V2
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V2];
  NvU8 rsvd1[128];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V9;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 policyMask;
  NV_GPU_POWER_POLICY_STATUS_DOMAIN_GROUP_LIMITS_V2 domGrpLimits;
  NV_GPU_BOARDOBJGRP_MASK_E32 policyRelMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 pwrViolMask;
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE inflectionPointsDisable;
  NvU8 rsvd[2048];
  NV_GPU_POWER_POLICY_STATUS_V8 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V2];
  NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V2
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V2];
  NV_GPU_POWER_VIOLATION_STATUS_V2
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V2];
  NvU8 rsvd1[128];
} NV_GPU_POWER_POLICY_STATUS_PARAMS_V10;
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V1, 1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V2, 1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_3 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V3, 1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_4 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V4, 1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_5 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V5, 1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_6 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V6, 1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_7 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V7, 1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_8 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V8, 1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_9 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V9, 1)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_10 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_STATUS_PARAMS_V10, 10)
#define NV_GPU_POWER_POLICY_STATUS_PARAMS_VER NV_GPU_POWER_POLICY_STATUS_PARAMS_VER_10
#define NV_GPU_POWER_POLICY_STATUS_PARAMS NV_GPU_POWER_POLICY_STATUS_PARAMS_V10
#define NV_GPU_POWER_POLICY_STATUS NV_GPU_POWER_POLICY_STATUS_V8
#define NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS NV_GPU_POWER_POLICY_RELATIONSHIP_STATUS_V2
#define NV_GPU_POWER_VIOLATION_STATUS NV_GPU_POWER_VIOLATION_STATUS_V2
NVAPI_INTERFACE NvAPI_GPU_PowerPolicyGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_POWER_POLICY_STATUS_PARAMS *pPolicyStatus);
typedef struct {
  NvU16 clkUpScale;
  NvU16 clkDownScale;
  NvU8 medianFilterSize;
} NV_GPU_POWER_POLICY_WORKLOAD_CONTROL;
typedef struct {
  NvU16 clkUpScale;
  NvU16 clkDownScale;
} NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_CONTROL;
typedef struct {
  NvU16 clkMasterUpScale;
  NvU16 clkMasterDownScale;
} NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_CONTROL;
typedef struct {
  NV_GPU_POWER_POLICY_TYPE type;
  NvU32 limitCurr;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_POLICY_WORKLOAD_CONTROL workload;
    NV_GPU_POWER_POLICY_WORKLOAD_MULTIRAIL_CONTROL workloadMulRail;
    NV_GPU_POWER_POLICY_WORKLOAD_COMBINED_1X_CONTROL combined1x;
    NvU8 rsvd[16];
  } data;
} NV_GPU_POWER_POLICY_CONTROL_V1;
typedef struct {
  NvU8 bPwmSim;
  NvU32 pwmPctSim;
} NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_BALANCE;
typedef struct {
  NV_GPU_POWER_POLICY_RELATIONSHIP_TYPE type;
  NvU8 rsvd[16];
  union {
    NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_BALANCE balance;
    NvU8 rsvd[48];
  } data;
} NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1;
typedef struct _NV_GPU_POWER_VIOLATION_CONTROL_PROPGAIN_V1 {
  NvS32 propGain;
} NV_GPU_POWER_VIOLATION_CONTROL_PROPGAIN_V1;
typedef struct {
  NV_GPU_POWER_VIOLATION_TYPE type;
  NvU16 violTarget;
  NvU8 rsvd[64];
  union {
    NV_GPU_POWER_VIOLATION_CONTROL_PROPGAIN_V1 propGain;
    NvU8 rsvd[64];
  } data;
} NV_GPU_POWER_VIOLATION_CONTROL_V1;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NvU8 rsvd[16];
  NV_GPU_POWER_POLICY_CONTROL_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
} NV_GPU_POWER_POLICY_CONTROL_PARAMS_V1;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NvU32 policyRelMask;
  NvU8 rsvd[16];
  NV_GPU_POWER_POLICY_CONTROL_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
} NV_GPU_POWER_POLICY_CONTROL_PARAMS_V2;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NvU32 policyRelMask;
  NvU32 pwrViolMask;
  NvU8 rsvd[12];
  NV_GPU_POWER_POLICY_CONTROL_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V1];
  NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V1];
  NV_GPU_POWER_VIOLATION_CONTROL_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V1];
  NvU8 rsvd1[64];
} NV_GPU_POWER_POLICY_CONTROL_PARAMS_V3;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NvU32 policyRelMask;
  NvU32 pwrViolMask;
  NvBool bInflectionPointsDisable;
  NvU8 rsvd[63];
  NV_GPU_POWER_POLICY_CONTROL_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V2];
  NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V2];
  NV_GPU_POWER_VIOLATION_CONTROL_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V2];
  NvU8 rsvd1[64];
} NV_GPU_POWER_POLICY_CONTROL_PARAMS_V4;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 policyMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 policyRelMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 pwrViolMask;
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST inflectionPointsDisableRequest;
  NvU8 rsvd[2048];
  NV_GPU_POWER_POLICY_CONTROL_V1 policies[NV_GPU_POWER_POLICY_MAX_POLICIES_V2];
  NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1
  policyRels[NV_GPU_POWER_POLICY_MAX_POLICY_RELATIONSHIPS_V2];
  NV_GPU_POWER_VIOLATION_CONTROL_V1
  violations[NV_GPU_POWER_POLICY_MAX_VIOLATIONS_V2];
} NV_GPU_POWER_POLICY_CONTROL_PARAMS_V5;
#define NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_CONTROL_PARAMS_V1, 1)
#define NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_CONTROL_PARAMS_V2, 1)
#define NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER_3 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_CONTROL_PARAMS_V3, 1)
#define NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER_4 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_CONTROL_PARAMS_V4, 1)
#define NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER_5 MAKE_NVAPI_VERSION(NV_GPU_POWER_POLICY_CONTROL_PARAMS_V5, 1)
#define NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER NV_GPU_POWER_POLICY_CONTROL_PARAMS_VER_5
#define NV_GPU_POWER_POLICY_CONTROL_PARAMS NV_GPU_POWER_POLICY_CONTROL_PARAMS_V5
#define NV_GPU_POWER_POLICY_CONTROL NV_GPU_POWER_POLICY_CONTROL_V1
#define NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL NV_GPU_POWER_POLICY_RELATIONSHIP_CONTROL_V1
#define NV_GPU_POWER_VIOLATION_CONTROL NV_GPU_POWER_VIOLATION_CONTROL_V1
NVAPI_INTERFACE NvAPI_GPU_PowerPolicyGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_POWER_POLICY_CONTROL_PARAMS *pPolicyControl);
NVAPI_INTERFACE NvAPI_GPU_PowerPolicySetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_POWER_POLICY_CONTROL_PARAMS *pPolicyControl);
typedef enum {
  NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID_TOTAL_GPU_POWER,
  NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID_NORMALIZED_TOTAL_POWER,
} NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID;
#define NV_GPU_CLIENT_POWER_CHANNEL_NUM_CHANNELS_V1 4
typedef struct {
  NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;
} NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_INFO_V1;
typedef struct {
  NvU32 version;
  NvU8 bSupported;
  NvU8 numChannels;
  NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_INFO_V1
  channels[NV_GPU_CLIENT_POWER_CHANNEL_NUM_CHANNELS_V1];
} NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1;
#define NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1, 1)
#define NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_VER NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_VER_1
#define NV_GPU_CLIENT_POWER_TOPOLOGY_INFO NV_GPU_CLIENT_POWER_TOPOLOGY_INFO_V1
NVAPI_INTERFACE NvAPI_GPU_ClientPowerTopologyGetInfo(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_POWER_TOPOLOGY_INFO *pClientPowerTopologyInfo);
typedef struct {
  NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;
  NV_GPU_CLIENT_POWER_READING_V1 power;
} NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU8 numChannels;
  NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_STATUS_V1
  channels[NV_GPU_CLIENT_POWER_CHANNEL_NUM_CHANNELS_V1];
} NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1;
#define NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1, 1)
#define NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_VER NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_VER_1
#define NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS_V1
NVAPI_INTERFACE NvAPI_GPU_ClientPowerTopologyGetStatus(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_POWER_TOPOLOGY_STATUS *pClientPowerTopologyStatus);
typedef enum {
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_TOTAL_GPU_POWER,
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_ID;
typedef enum {
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_BASE,
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_PFF,
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS;
typedef struct {
  NV_GPU_CLIENT_PFF_CURVE_V1 curve;
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_INFO_PFF_V1;
typedef union {
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_INFO_PFF_V1 pff;
  NvU8 rsvd[256];
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_INFO_UNION_V1;
#define NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1 4
#define NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V2 NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1
typedef struct {
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_ID policyId;
  NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;
  NV_GPU_CLIENT_POWER_READING_V1 powerLimitMin;
  NV_GPU_CLIENT_POWER_READING_V1 powerLimitDefault;
  NV_GPU_CLIENT_POWER_READING_V1 powerLimitMax;
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V1;
typedef struct {
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_ID policyId;
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS policyClass;
  NV_GPU_CLIENT_POWER_TOPOLOGY_CHANNEL_ID channelId;
  NV_GPU_CLIENT_POWER_READING_V1 powerLimitMin;
  NV_GPU_CLIENT_POWER_READING_V1 powerLimitDefault;
  NV_GPU_CLIENT_POWER_READING_V1 powerLimitMax;
  NvU8 rsvd[256];
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_INFO_UNION_V1 classInfo;
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V2;
typedef struct {
  NvU32 version;
  NvU8 bSupported;
  NvU8 numPolicies;
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V1
  policies[NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1];
} NV_GPU_CLIENT_POWER_POLICIES_INFO_V1;
typedef struct {
  NvU32 version;
  NvU8 bSupported;
  NvU8 numPolicies;
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V2
  policies[NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V2];
} NV_GPU_CLIENT_POWER_POLICIES_INFO_V2;
#define NV_GPU_CLIENT_POWER_POLICIES_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_POLICIES_INFO_V1, 1)
#define NV_GPU_CLIENT_POWER_POLICIES_INFO_VER_2 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_POLICIES_INFO_V2, 2)
#define NV_GPU_CLIENT_POWER_POLICIES_INFO_VER NV_GPU_CLIENT_POWER_POLICIES_INFO_VER_2
#define NV_GPU_CLIENT_POWER_POLICIES_INFO NV_GPU_CLIENT_POWER_POLICIES_INFO_V2
#define NV_GPU_CLIENT_POWER_POLICIES_POLICY_INFO NV_GPU_CLIENT_POWER_POLICIES_POLICY_INFO_V2
NVAPI_INTERFACE NvAPI_GPU_ClientPowerPoliciesGetInfo(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_POWER_POLICIES_INFO *pClientPowerPoliciesInfo);
typedef struct {
  NvBool bPffCurveChanged;
  NV_GPU_CLIENT_PFF_CURVE_V1 curve;
  NV_GPU_CLIENT_PFF_CURVE_STATUS_V1 curveRuntimeStatus;
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_STATUS_PFF_V1;
typedef union {
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_STATUS_PFF_V1 pff;
  NvU8 rsvd[256];
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_STATUS_UNION_V1;
typedef struct {
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_ID policyId;
  NV_GPU_CLIENT_POWER_READING_V1 powerLimit;
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS_V1;
typedef struct {
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_ID policyId;
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS policyClass;
  NV_GPU_CLIENT_POWER_READING_V1 powerLimit;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_CLASS_STATUS_UNION_V1 classStatus;
} NV_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS_V2;
typedef struct {
  NvU32 version;
  NvU8 numPolicies;
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS_V1
  policies[NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V1];
} NV_GPU_CLIENT_POWER_POLICIES_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU8 numPolicies;
  NV_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS_V2
  policies[NV_GPU_CLIENT_POWER_POLICIES_NUM_POLICIES_V2];
} NV_GPU_CLIENT_POWER_POLICIES_STATUS_V2;
#define NV_GPU_CLIENT_POWER_POLICIES_STATUS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_POLICIES_STATUS_V1, 1)
#define NV_GPU_CLIENT_POWER_POLICIES_STATUS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_POLICIES_STATUS_V2, 2)
#define NV_GPU_CLIENT_POWER_POLICIES_STATUS_VER NV_GPU_CLIENT_POWER_POLICIES_STATUS_VER_2
#define NV_GPU_CLIENT_POWER_POLICIES_STATUS NV_GPU_CLIENT_POWER_POLICIES_STATUS_V2
#define NV_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS NV_GPU_CLIENT_POWER_POLICIES_POLICY_STATUS_V2
NVAPI_INTERFACE NvAPI_GPU_ClientPowerPoliciesGetStatus(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_POWER_POLICIES_STATUS *pClientPowerPoliciesStatus);
NVAPI_INTERFACE NvAPI_GPU_ClientPowerPoliciesSetStatus(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_POWER_POLICIES_STATUS *pClientPowerPoliciesStatus);
NVAPI_INTERFACE NvAPI_GPU_GetPowerConnectorStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pConnectorCount,
                                                  NvU32 *pConnectionAtBoot, NvU32 *pCurrentConnection);
typedef enum _NV_LEVEL_INFO {
  NVAPI_PWR_MZR_HARD_LIMIT_MAX = 0x00000001,
  NVAPI_PWR_MZR_HARD_LIMIT_BAL = 0x00000002,
  NVAPI_PWR_MZR_MAX_BATT = 0x00000003,
  NVAPI_PWR_MZR_SOFT_LIMIT_MAX = 0x00000004,
  NVAPI_PWR_MZR_SOFT_LIMIT_BAL = 0x00000005,
  NVAPI_ADC_OFF = 0x00000006,
  NVAPI_ADC_ON = 0x00000007,
} NV_LEVEL_INFO;
typedef enum _NV_PWR_SOURCE_INFO {
  NVAPI_PWR_SOURCE_AC = 0x00000001,
  NVAPI_PWR_SOURCE_BATT = 0x00000002,
} NV_PWR_SOURCE_INFO;
typedef enum _NV_SELECT_INFO {
  NVAPI_INDEX_PWR_MZR_HARD = 0x00000001,
  NVAPI_INDEX_PWR_MZR_SOFT = 0x00000002,
  NVAPI_INDEX_ADC = 0x00000003,
} NV_SELECT_INFO;
NVAPI_INTERFACE NvAPI_GPU_GetPowerMizerInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PWR_SOURCE_INFO powerSourceInfo,
                                            NV_SELECT_INFO select, NV_LEVEL_INFO *pLevelInfo);
NVAPI_INTERFACE NvAPI_GPU_SetPowerMizerInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PWR_SOURCE_INFO powerSourceInfo,
                                            NV_SELECT_INFO select, NV_LEVEL_INFO levelInfo);
typedef enum _NV_GPU_LPWR_GC6_RESET_STATS_FLAG {
  NV_GPU_LPWR_GC6_RESET_STATS_KMD = 0,
  NV_GPU_LPWR_GC6_RESET_STATS_RM = 1,
  NV_GPU_LPWR_GC6_RESET_STATS_MAX = 2,
} NV_GPU_LPWR_GC6_RESET_STATS_FLAG;
typedef struct _NV_GPU_LPWR_GC6_RESET_STATS_PARAM_V1 {
  NvU32 version;
  NvU32 resetStatsMask;
} NV_GPU_LPWR_GC6_RESET_STATS_PARAM_V1;
#define NV_GPU_LPWR_GC6_RESET_STATS_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_GC6_RESET_STATS_PARAM_V1, 1)
#define NV_GPU_LPWR_GC6_RESET_STATS_PARAM_VER NV_GPU_LPWR_GC6_RESET_STATS_PARAM_VER1
typedef NV_GPU_LPWR_GC6_RESET_STATS_PARAM_V1 NV_GPU_LPWR_GC6_RESET_STATS_PARAM;
NVAPI_INTERFACE NvAPI_GPU_LpwrGC6ResetStatistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_LPWR_GC6_RESET_STATS_PARAM *pGpuGC6ResetStatsParam);
typedef enum _NV_GPU_LPWR_GENERIC_GROUP {
  NV_GPU_LPWR_FEATURE_ID_GENERIC = 0,
} NV_GPU_LPWR_GENERIC_GROUP;
typedef enum _NV_GPU_LPWR_CACHE_OP {
  NV_GPU_LPWR_CACHE_DISABLE = 1,
  NV_GPU_LPWR_CACHE_ENABLE,
} NV_GPU_LPWR_CACHE_OP;
typedef struct _NV_GPU_LPWR_CACHE_CONTROL_V1 {
  NvU32 version;
  NV_GPU_LPWR_CACHE_OP control;
  NvU8 bSupported;
  NvU8 bEnabled;
  NvU32 reserved;
} NV_GPU_LPWR_CACHE_CONTROL_V1;
#define NV_GPU_LPWR_CACHE_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_CACHE_CONTROL_V1, 1)
#define NV_GPU_LPWR_CACHE_CONTROL_VER NV_GPU_LPWR_CACHE_CONTROL_VER1
typedef NV_GPU_LPWR_CACHE_CONTROL_V1 NV_GPU_LPWR_CACHE_CONTROL;
NVAPI_INTERFACE NvAPI_GPU_LpwrCacheEnable(__in NvPhysicalGpuHandle hPhysicalGpu,
                                          __in NV_GPU_LPWR_CACHE_CONTROL *pGpuLpwrControlCache);
NVAPI_INTERFACE NvAPI_GPU_LpwrCacheGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_LPWR_CACHE_CONTROL *pGpuLpwrControlCache);
typedef struct _NV_GPU_LPWR_MODE_SUPPORT_V1 {
  NvU32 version;
  NvU32 modeSupportMask;
  NvU32 reserved;
} NV_GPU_LPWR_MODE_SUPPORT_V1;
#define NV_GPU_LPWR_MODE_SUPPORT_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_MODE_SUPPORT_V1, 1)
#define NV_GPU_LPWR_MODE_SUPPORT_VER NV_GPU_LPWR_MODE_SUPPORT_VER1
typedef NV_GPU_LPWR_MODE_SUPPORT_V1 NV_GPU_LPWR_MODE_SUPPORT;
NVAPI_INTERFACE NvAPI_GPU_LpwrGetModeSupportMask(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_LPWR_MODE_SUPPORT *pGpuLpwrModeSupport);
typedef struct _NV_GPU_LPWR_MODE_V1 {
  NvU32 version;
  NvU32 mode;
  NvU32 reserved;
} NV_GPU_LPWR_MODE_V1;
#define NV_GPU_LPWR_MODE_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_MODE_V1, 1)
#define NV_GPU_LPWR_MODE_VER NV_GPU_LPWR_MODE_VER1
typedef NV_GPU_LPWR_MODE_V1 NV_GPU_LPWR_MODE;
NVAPI_INTERFACE NvAPI_GPU_LpwrSetMode(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_LPWR_MODE *pGpuLpwrMode);
NVAPI_INTERFACE NvAPI_GPU_LpwrResetMode(__in NvPhysicalGpuHandle hPhysicalGpu);
typedef enum _NV_GPU_LPWR_TEST_ID {
  NV_GPU_LPWR_TEST_ID_MS_ODP_DMA = 0,
  NV_GPU_LPWR_TEST_ID_MS_ODP_HARD_CRITICAL_SECTION,
  NV_GPU_LPWR_TEST_ID_MS_ODP_SOFT_CRITICAL_SECTION,
  NV_GPU_LPWR_TEST_ID_MS_ODP_PAGE_FAULT,
  NV_GPU_LPWR_TEST_ID_MAX,
} NV_GPU_LPWR_TEST_ID;
typedef struct _NV_GPU_LPWR_TEST_V1 {
  NvU32 version;
  NV_GPU_LPWR_TEST_ID testId;
  NvU32 reserved;
} NV_GPU_LPWR_TEST_V1;
#define NV_GPU_LPWR_TEST_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_TEST_V1, 1)
#define NV_GPU_LPWR_TEST_VER NV_GPU_LPWR_TEST_VER1
typedef NV_GPU_LPWR_TEST_V1 NV_GPU_LPWR_TEST;
NVAPI_INTERFACE NvAPI_GPU_LpwrTestStart(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_LPWR_TEST *pGpuLpwrTest);
NVAPI_INTERFACE NvAPI_GPU_LpwrTestStop(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_LPWR_TEST *pGpuLpwrTest);
typedef enum _NV_GPU_LPWR_PG_FEATURE_ID {
  NV_GPU_LPWR_PG_FEATURE_ID_GR = 0,
  NV_GPU_LPWR_PG_FEATURE_ID_MS,
  NV_GPU_LPWR_PG_FEATURE_ID_DI,
  NV_GPU_LPWR_PG_FEATURE_ID_GR_RG,
  NV_GPU_LPWR_PG_FEATURE_ID_EI,
  NV_GPU_LPWR_PG_FEATURE_ID_GR_PASSIVE,
  NV_GPU_LPWR_PG_FEATURE_ID_MS_PASSIVE,
  NV_GPU_LPWR_PG_FEATURE_ID_EI_PASSIVE,
  NV_GPU_LPWR_PG_FEATURE_ID_MAX,
} NV_GPU_LPWR_PG_FEATURE_ID;
typedef struct _NV_GPU_LPWR_PG_SUPPORT_EXT_V1 {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID ctrlId;
  NvU32 bIsSupported : 1;
  NvU32 reserved : 31;
  NvU32 reserved2;
} NV_GPU_LPWR_PG_SUPPORT_EXT_V1;
#define NV_GPU_LPWR_PG_SUPPORT_EXT_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_SUPPORT_EXT_V1, 1)
typedef NV_GPU_LPWR_PG_SUPPORT_EXT_V1 NV_GPU_LPWR_PG_SUPPORT_EXT;
#define NV_GPU_LPWR_PG_SUPPORT_EXT_VER NV_GPU_LPWR_PG_SUPPORT_EXT_VER1
typedef struct _NV_GPU_LPWR_PG_STATISTICS_EXT_V1 {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID ctrlId;
  NvU32 entryCount;
  NvU32 maxEntryTime;
  NvU32 maxExitTime;
  NvU32 reserved[6];
} NV_GPU_LPWR_PG_STATISTICS_EXT_V1;
#define NV_GPU_LPWR_PG_STATISTICS_EXT_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_STATISTICS_EXT_V1, 1)
#define NV_GPU_LPWR_PG_STATISTICS_EXT_VER NV_GPU_LPWR_PG_STATISTICS_EXT_VER1
typedef NV_GPU_LPWR_PG_STATISTICS_EXT_V1 NV_GPU_LPWR_PG_STATISTICS_EXT;
NVAPI_INTERFACE NvAPI_GPU_LpwrPgGetSupportExt(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_LPWR_PG_SUPPORT_EXT *pGpuLpwrPgSupportExt);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgGetStatisticsExt(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_LPWR_PG_STATISTICS_EXT *pGpuLpwrPgStatisticsExt);
typedef enum _NV_GPU_LPWR_PG_THRESHOLD_ID {
  NV_GPU_LPWR_PG_THRESHOLD_ID_IDLE = 0,
  NV_GPU_LPWR_PG_THRESHOLD_ID_PPU,
} NV_GPU_LPWR_PG_THRESHOLD_ID;
typedef struct _NV_GPU_LPWR_PG_SUPPORT_PARAM_V1 {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID ctrlId;
  NvU32 pstateSupportMask;
  NvU32 subFeatureMask;
  NvBool bIsSupported;
  NvBool reserved1[3];
  NvU32 enabledMask;
  NvU32 reserved2;
} NV_GPU_LPWR_PG_SUPPORT_PARAM_V1;
#define NV_GPU_LPWR_PG_SUPPORT_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_SUPPORT_PARAM_V1, 1)
typedef NV_GPU_LPWR_PG_SUPPORT_PARAM_V1 NV_GPU_LPWR_PG_SUPPORT_PARAM;
#define NV_GPU_LPWR_PG_SUPPORT_PARAM_VER NV_GPU_LPWR_PG_SUPPORT_PARAM_VER1
typedef struct _NV_GPU_LPWR_PG_STATISTICS_V1 {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID ctrlId;
  NvU32 gatingCount;
  NvU32 exitCount;
  NvU32 denyCount;
  NvU32 totalSleepTime;
  NvU32 totalNonSleepTime;
  NvU32 avgEntryTime;
  NvU32 avgExitTime;
  NvU32 maxEntryTime;
  NvU32 maxExitTime;
  NvU32 idleThreshold;
  NvU32 ppuThreshold;
  NvU32 wakeupReason;
  NvU32 bCumulativeWakeupMask : 1;
  NvU32 reserved : 31;
  NvU32 abortReasonMask;
  NvU32 thrashingDetectionCount;
} NV_GPU_LPWR_PG_STATISTICS_V1;
#define NV_GPU_LPWR_PG_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_STATISTICS_V1, 1)
#define NV_GPU_LPWR_PG_STATISTICS_VER NV_GPU_LPWR_PG_STATISTICS_VER1
typedef NV_GPU_LPWR_PG_STATISTICS_V1 NV_GPU_LPWR_PG_STATISTICS;
typedef struct _NV_GPU_LPWR_PG_GET_ENABLE_V1 {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID ctrlId;
  NvBool bIsEnabled;
  NvBool reserved[3];
} NV_GPU_LPWR_PG_GET_ENABLE_V1;
#define NV_GPU_LPWR_PG_GET_ENABLE_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_GET_ENABLE_V1, 1)
#define NV_GPU_LPWR_PG_GET_ENABLE_VER NV_GPU_LPWR_PG_GET_ENABLE_VER1
typedef NV_GPU_LPWR_PG_GET_ENABLE_V1 NV_GPU_LPWR_PG_GET_ENABLE;
typedef struct _NV_GPU_LPWR_PG_ENABLE {
  NV_GPU_LPWR_PG_FEATURE_ID featureId;
  NvBool bEnable;
  NvBool reserved1[3];
  NvU32 reserved2[7];
} NV_GPU_LPWR_PG_ENABLE;
#define NV_GPU_LPWR_PG_ENABLE_MAX_PARAM_PER_FEATURE 1
#define NV_GPU_LPWR_PG_ENABLE_PARAM_MAX_FEATURE_LIST_SIZE 8
typedef struct _NV_GPU_LPWR_PG_ENABLE_PARAM {
  NvU32 version;
  NV_GPU_LPWR_PG_ENABLE FeatureList[NV_GPU_LPWR_PG_ENABLE_PARAM_MAX_FEATURE_LIST_SIZE];
  NvU32 size;
} NV_GPU_LPWR_PG_ENABLE_PARAM_V1;
#define NV_GPU_LPWR_PG_ENABLE_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_ENABLE_PARAM_V1, 1)
#define NV_GPU_LPWR_PG_ENABLE_PARAM_VER NV_GPU_LPWR_PG_ENABLE_PARAM_VER1
typedef NV_GPU_LPWR_PG_ENABLE_PARAM_V1 NV_GPU_LPWR_PG_ENABLE_PARAM;
#define NV_GPU_LPWR_PG_RESET_STATS_MAX_FEATURE_LIST_SIZE 6
typedef struct _NV_GPU_LPWR_PG_RESET_STATS_PARAM {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID featuresubId[NV_GPU_LPWR_PG_RESET_STATS_MAX_FEATURE_LIST_SIZE];
  NvU32 size;
} NV_GPU_LPWR_PG_RESET_STATS_PARAM_V1;
#define NV_GPU_LPWR_PG_RESET_STATS_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_RESET_STATS_PARAM_V1, 1)
#define NV_GPU_LPWR_PG_RESET_STATS_PARAM_VER NV_GPU_LPWR_PG_RESET_STATS_PARAM_VER1
typedef NV_GPU_LPWR_PG_RESET_STATS_PARAM_V1 NV_GPU_LPWR_PG_RESET_STATS_PARAM;
typedef struct _NV_GPU_LPWR_PG_SET_THRESHOLD_V1 {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID ctrlId;
  NV_GPU_LPWR_PG_THRESHOLD_ID thresholdId;
  NvU32 thresholdUs;
} NV_GPU_LPWR_PG_SET_THRESHOLD_V1;
#define NV_GPU_LPWR_PG_SET_THRESHOLD_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_SET_THRESHOLD_V1, 1)
#define NV_GPU_LPWR_PG_SET_THRESHOLD_VER NV_GPU_LPWR_PG_SET_THRESHOLD_VER1
typedef NV_GPU_LPWR_PG_SET_THRESHOLD_V1 NV_GPU_LPWR_PG_SET_THRESHOLD;
typedef struct _NV_GPU_LPWR_PG_SET_MIN_THRESHOLD_V1 {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID ctrlId;
} NV_GPU_LPWR_PG_SET_MIN_THRESHOLD_V1;
#define NV_GPU_LPWR_PG_SET_MIN_THRESHOLD_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_SET_MIN_THRESHOLD_V1, 1)
#define NV_GPU_LPWR_PG_SET_MIN_THRESHOLD_VER NV_GPU_LPWR_PG_SET_MIN_THRESHOLD_VER1
typedef NV_GPU_LPWR_PG_SET_MIN_THRESHOLD_V1 NV_GPU_LPWR_PG_SET_MIN_THRESHOLD;
typedef struct _NV_GPU_LPWR_PG_RESET_THRESHOLD_V1 {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID ctrlId;
} NV_GPU_LPWR_PG_RESET_THRESHOLD_V1;
#define NV_GPU_LPWR_PG_RESET_THRESHOLD_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_RESET_THRESHOLD_V1, 1)
#define NV_GPU_LPWR_PG_RESET_THRESHOLD_VER NV_GPU_LPWR_PG_RESET_THRESHOLD_VER1
typedef NV_GPU_LPWR_PG_RESET_THRESHOLD_V1 NV_GPU_LPWR_PG_RESET_THRESHOLD;
NVAPI_INTERFACE NvAPI_GPU_LpwrPgGetSupport(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_GPU_LPWR_PG_SUPPORT_PARAM *pGpuPgFeatureSupport);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgGetStatistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_LPWR_PG_STATISTICS *pGpuPgFeatureStatistics);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgGetEnable(__in NvPhysicalGpuHandle hPhysicalGpu,
                                          __inout NV_GPU_LPWR_PG_GET_ENABLE *pGpuPgFeatureEnable);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgGetSubFeatureMask(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_LPWR_PG_SUPPORT_PARAM *pGpuPgSubFeatureSupport);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgSubFeatureMaskSet(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_LPWR_PG_SUPPORT_PARAM *pGpuPgSubFeatureMask);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgEnable(__in NvPhysicalGpuHandle hPhysicalGpu,
                                       __in NV_GPU_LPWR_PG_ENABLE_PARAM *pGpuLpwrPgEnableParam);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgResetStats(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __in NV_GPU_LPWR_PG_RESET_STATS_PARAM *pGpuLpwrPgResetStatsParam);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgSetThreshold(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __in NV_GPU_LPWR_PG_SET_THRESHOLD *pGpuLpwrPgSetThreshold);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgSetMinThreshold(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __in NV_GPU_LPWR_PG_SET_MIN_THRESHOLD *pGpuLpwrPgSetMinThreshold);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgResetThreshold(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __in NV_GPU_LPWR_PG_RESET_THRESHOLD *pGpuLpwrPgResetThreshold);
#define NV_GPU_LPWR_PG_WAKEUP_TYPE_MAX_FEATURE_LIST_SIZE 6
typedef struct _NV_GPU_LPWR_PG_WAKEUP_TYPE_V1 {
  NvU32 version;
  NV_GPU_LPWR_PG_FEATURE_ID featuresubId[NV_GPU_LPWR_PG_WAKEUP_TYPE_MAX_FEATURE_LIST_SIZE];
  NvU32 size;
  NvU32 bCumulativeWakeupMask : 1;
  NvU32 reserved : 31;
} NV_GPU_LPWR_PG_WAKEUP_TYPE_V1;
#define NV_GPU_LPWR_PG_WAKEUP_TYPE_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PG_WAKEUP_TYPE_V1, 1)
#define NV_GPU_LPWR_PG_WAKEUP_TYPE_VER NV_GPU_LPWR_PG_WAKEUP_TYPE_VER1
typedef NV_GPU_LPWR_PG_WAKEUP_TYPE_V1 NV_GPU_LPWR_PG_WAKEUP_TYPE;
NVAPI_INTERFACE NvAPI_GPU_LpwrToggleWakeupType(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __in NV_GPU_LPWR_PG_WAKEUP_TYPE *pGpuLpwrPgWakeupTypeParam);
typedef enum _NV_GPU_LPWR_AP_FEATURE_ID {
  NV_GPU_LPWR_AP_FEATURE_ID_GR = 0,
  NV_GPU_LPWR_AP_FEATURE_ID_DI,
  NV_GPU_LPWR_AP_FEATURE_ID_MAX,
} NV_GPU_LPWR_AP_FEATURE_ID;
#define NV_GPU_LPWR_AP_CFG_HISTOGRAM_BIN_N 16
typedef struct _NV_GPU_LPWR_AP_SUPPORT_PARAM_V1 {
  NvU32 version;
  NV_GPU_LPWR_AP_FEATURE_ID ctrlId;
  NvU32 pstateSupportMask;
  NvU32 subFeatureMask;
  NvBool bIsSupported;
  NvBool reserved1[3];
  NvU32 reserved2[2];
} NV_GPU_LPWR_AP_SUPPORT_PARAM_V1;
#define NV_GPU_LPWR_AP_SUPPORT_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_AP_SUPPORT_PARAM_V1, 1)
typedef NV_GPU_LPWR_AP_SUPPORT_PARAM_V1 NV_GPU_LPWR_AP_SUPPORT_PARAM;
#define NV_GPU_LPWR_AP_SUPPORT_PARAM_VER NV_GPU_LPWR_AP_SUPPORT_PARAM_VER1
typedef struct _NV_GPU_LPWR_AP_STATS {
  NvU32 version;
  NV_GPU_LPWR_AP_FEATURE_ID featureId;
  NvBool bParentEnable;
  NvBool bActive;
  NvU8 idleFilterX;
  NvU8 residency;
  NvS32 powerSavingHCycles;
  NvU32 badDecisionCount;
  NvU32 skipCount;
  NvU16 bin[NV_GPU_LPWR_AP_CFG_HISTOGRAM_BIN_N];
  NvU32 thresholdCounter[NV_GPU_LPWR_AP_CFG_HISTOGRAM_BIN_N];
  NvU32 defaultThresholdCounter;
  NvU32 currentIdleThreshold;
  NvU32 rsvd1[16];
} NV_GPU_LPWR_AP_STATS_V1;
#define NV_GPU_LPWR_AP_STATS_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_AP_STATS_V1, 1)
typedef NV_GPU_LPWR_AP_STATS_V1 NV_GPU_LPWR_AP_STATS;
#define NV_GPU_LPWR_AP_STATS_VER NV_GPU_LPWR_AP_STATS_VER1
typedef struct _NV_GPU_LPWR_AP_ENABLE_V1 {
  NvU32 version;
  NV_GPU_LPWR_AP_FEATURE_ID ctrlId;
  NvBool bEnabled;
  NvBool reserved[3];
} NV_GPU_LPWR_AP_ENABLE_V1;
#define NV_GPU_LPWR_AP_ENABLE_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_AP_ENABLE_V1, 1)
#define NV_GPU_LPWR_AP_ENABLE_VER NV_GPU_LPWR_AP_ENABLE_VER1
typedef NV_GPU_LPWR_AP_ENABLE_V1 NV_GPU_LPWR_AP_ENABLE;
NVAPI_INTERFACE NvAPI_GPU_LpwrApGetSupport(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_GPU_LPWR_AP_SUPPORT_PARAM *pGpuApFeatureSupport);
NVAPI_INTERFACE NvAPI_GPU_LpwrApGetStatistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_LPWR_AP_STATS *pGpuLpwrApStats);
NVAPI_INTERFACE NvAPI_GPU_LpwrApGetEnable(__in NvPhysicalGpuHandle hPhysicalGpu,
                                          __inout NV_GPU_LPWR_AP_ENABLE *pGpuApFeatureEnable);
NVAPI_INTERFACE NvAPI_GPU_LpwrApSetEnable(__in NvPhysicalGpuHandle hPhysicalGpu,
                                          __in NV_GPU_LPWR_AP_ENABLE *pGpuApFeatureEnable);
typedef enum _NV_GPU_LPWR_PGISLAND_FEATURE_ID {
  NV_GPU_LPWR_PGISLAND_FEATURE_ID_SCI_PMGR_GPIO_SYNC = 0,
  NV_GPU_LPWR_PGISLAND_FEATURE_ID_MAX = 8,
} NV_GPU_LPWR_PGISLAND_FEATURE_ID;
typedef struct _NV_GPU_LPWR_PGISLAND_SUPPORT {
  NV_GPU_LPWR_PGISLAND_FEATURE_ID featureId;
  NvBool bSupport;
  NvBool reserved1[3];
  NvU32 reserved2[6];
} NV_GPU_LPWR_PGISLAND_SUPPORT;
#define NV_GPU_LPWR_PGISLAND_SUPPORT_MAX_PARAM_PER_FEATURE 1
#define NV_GPU_LPWR_PGISLAND_SUPPORT_MAX_FEATURE_LIST_SIZE 8
typedef struct _NV_GPU_LPWR_PGISLAND_SUPPORT_PARAM_V1 {
  NvU32 version;
  NV_GPU_LPWR_PGISLAND_SUPPORT FeatureList[NV_GPU_LPWR_PGISLAND_SUPPORT_MAX_FEATURE_LIST_SIZE];
  NvU32 size;
} NV_GPU_LPWR_PGISLAND_SUPPORT_PARAM_V1;
#define NV_GPU_LPWR_PGISLAND_SUPPORT_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PGISLAND_SUPPORT_PARAM_V1, 1)
#define NV_GPU_LPWR_PGISLAND_SUPPORT_PARAM_VER NV_GPU_LPWR_PGISLAND_SUPPORT_PARAM_VER1
typedef NV_GPU_LPWR_PGISLAND_SUPPORT_PARAM_V1 NV_GPU_LPWR_PGISLAND_SUPPORT_PARAM;
typedef struct _NV_GPU_LPWR_PGISLAND_STATISTICS_V1 {
  NvU32 version;
  NV_GPU_LPWR_PGISLAND_FEATURE_ID featureId;
  NvU32 gpioPinMask;
  NvU32 rsvd[16];
} NV_GPU_LPWR_PGISLAND_STATISTICS_V1;
#define NV_GPU_LPWR_PGISLAND_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PGISLAND_STATISTICS_V1, 1)
typedef NV_GPU_LPWR_PGISLAND_STATISTICS_V1 NV_GPU_LPWR_PGISLAND_STATISTICS;
#define NV_GPU_LPWR_PGISLAND_STATISTICS_VER NV_GPU_LPWR_PGISLAND_STATISTICS_VER1
NVAPI_INTERFACE NvAPI_GPU_LpwrPgislandGetSupport(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_LPWR_PGISLAND_SUPPORT_PARAM *pGpuPgisland);
NVAPI_INTERFACE NvAPI_GPU_LpwrPgislandGetStatistics(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_LPWR_PGISLAND_STATISTICS *pGpuLpwrPgislandStatistics);
typedef enum _NV_GPU_LPWR_DIDLE_FEATURE_ID {
  NV_GPU_LPWR_DIDLE_FEATURE_ID_DIOS = 0,
  NV_GPU_LPWR_DIDLE_FEATURE_ID_MAX,
} NV_GPU_LPWR_DIDLE_FEATURE_ID;
typedef struct _NV_GPU_LPWR_DIDLE_SUPPORT {
  NV_GPU_LPWR_DIDLE_FEATURE_ID featureId;
  NvBool bSupport;
  NvBool reserved1[3];
  NvU32 PStateSupportMask;
  NvU32 reserved2[6];
} NV_GPU_LPWR_DIDLE_SUPPORT;
#define NV_GPU_LPWR_DIDLE_SUPPORT_MAX_PARAM_PER_FEATURE 1
#define NV_GPU_LPWR_DIDLE_SUPPORT_MAX_FEATURE_LIST_SIZE 8
typedef struct _NV_GPU_LPWR_DIDLE_SUPPORT_PARAM {
  NvU32 version;
  NV_GPU_LPWR_DIDLE_SUPPORT FeatureList[NV_GPU_LPWR_DIDLE_SUPPORT_MAX_FEATURE_LIST_SIZE];
  NvU32 size;
} NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_V1;
#define NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_V1, 1)
#define NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_VER NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_VER1
typedef NV_GPU_LPWR_DIDLE_SUPPORT_PARAM_V1 NV_GPU_LPWR_DIDLE_SUPPORT_PARAM;
NVAPI_INTERFACE NvAPI_GPU_LpwrDidleGetSupport(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_LPWR_DIDLE_SUPPORT_PARAM *pGpuDidleSupport);
typedef enum _NV_GPU_LPWR_RPPG_FEATURE_ID {
  NV_GPU_LPWR_RPPG_FEATURE_ID_GR = 0,
  NV_GPU_LPWR_RPPG_FEATURE_ID_MS,
  NV_GPU_LPWR_RPPG_FEATURE_ID_DI,
} NV_GPU_LPWR_RPPG_FEATURE_ID;
typedef struct _NV_GPU_LPWR_RPPG_SUPPORT_V1 {
  NvU32 version;
  NV_GPU_LPWR_RPPG_FEATURE_ID ctrlId;
  NvU32 pstateSupportMask;
  NvBool bIsSupported;
  NvBool reserved1[3];
  NvU32 reserved2[2];
} NV_GPU_LPWR_RPPG_SUPPORT_V1;
#define NV_GPU_LPWR_RPPG_SUPPORT_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_RPPG_SUPPORT_V1, 1)
#define NV_GPU_LPWR_RPPG_SUPPORT_VER NV_GPU_LPWR_RPPG_SUPPORT_VER1
typedef NV_GPU_LPWR_RPPG_SUPPORT_V1 NV_GPU_LPWR_RPPG_SUPPORT;
typedef struct _NV_GPU_LPWR_RPPG_STATISTICS_V1 {
  NvU32 version;
  NV_GPU_LPWR_RPPG_FEATURE_ID ctrlId;
  NvU32 entryCount;
  NvU32 exitCount;
  NvU32 reserved[5];
} NV_GPU_LPWR_RPPG_STATISTICS_V1;
#define NV_GPU_LPWR_RPPG_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_RPPG_STATISTICS_V1, 1)
#define NV_GPU_LPWR_RPPG_STATISTICS_VER NV_GPU_LPWR_RPPG_STATISTICS_VER1
typedef NV_GPU_LPWR_RPPG_STATISTICS_V1 NV_GPU_LPWR_RPPG_STATISTICS;
#define NV_GPU_LPWR_RPPG_RESET_STATS_MAX_FEATURE_LIST_SIZE 6
typedef struct _NV_GPU_LPWR_RPPG_RESET_STATS_PARAM {
  NvU32 version;
  NV_GPU_LPWR_RPPG_FEATURE_ID featuresubId[NV_GPU_LPWR_RPPG_RESET_STATS_MAX_FEATURE_LIST_SIZE];
  NvU32 size;
} NV_GPU_LPWR_RPPG_RESET_STATS_PARAM_V1;
#define NV_GPU_LPWR_RPPG_RESET_STATS_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_RPPG_RESET_STATS_PARAM_V1, 1)
#define NV_GPU_LPWR_RPPG_RESET_STATS_PARAM_VER NV_GPU_LPWR_RPPG_RESET_STATS_PARAM_VER1
typedef NV_GPU_LPWR_RPPG_RESET_STATS_PARAM_V1 NV_GPU_LPWR_RPPG_RESET_STATS_PARAM;
#define NV_GPU_LPWR_RPPG_ENABLE_MAX_FEATURE_LIST_SIZE 6
typedef struct _NV_GPU_LPWR_RPPG_ENABLE_PARAM_V1 {
  NvU32 version;
  NV_GPU_LPWR_RPPG_FEATURE_ID featuresubId[NV_GPU_LPWR_RPPG_ENABLE_MAX_FEATURE_LIST_SIZE];
  NvU32 size;
  NvU32 bEnable : 1;
  NvU32 reserved : 31;
} NV_GPU_LPWR_RPPG_ENABLE_PARAM_V1;
#define NV_GPU_LPWR_RPPG_ENABLE_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_RPPG_ENABLE_PARAM_V1, 1)
#define NV_GPU_LPWR_RPPG_ENABLE_PARAM_VER NV_GPU_LPWR_RPPG_ENABLE_PARAM_VER1
typedef NV_GPU_LPWR_RPPG_ENABLE_PARAM_V1 NV_GPU_LPWR_RPPG_ENABLE_PARAM;
NVAPI_INTERFACE NvAPI_GPU_LpwrRppgGetSupport(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_LPWR_RPPG_SUPPORT *pGpuRppgFeatureSupport);
NVAPI_INTERFACE NvAPI_GPU_LpwrRppgGetStatistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_GPU_LPWR_RPPG_STATISTICS *pGpuRppgFeatureStatistics);
NVAPI_INTERFACE NvAPI_GPU_LpwrRppgResetStats(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_LPWR_RPPG_RESET_STATS_PARAM *pGpuRppgResetStatsParam);
NVAPI_INTERFACE NvAPI_GPU_LpwrRppgEnable(__in NvPhysicalGpuHandle hPhysicalGpu,
                                         __inout NV_GPU_LPWR_RPPG_ENABLE_PARAM *pGpuRppgEnableParam);
typedef enum _NV_GPU_LPWR_PSI_FEATURE_ID {
  NV_GPU_LPWR_PSI_FEATURE_ID_GR = 0,
  NV_GPU_LPWR_PSI_FEATURE_ID_MS,
  NV_GPU_LPWR_PSI_FEATURE_ID_DI,
  NV_GPU_LPWR_PSI_FEATURE_ID_GC6,
  NV_GPU_LPWR_PSI_FEATURE_ID_PSTATE,
} NV_GPU_LPWR_PSI_FEATURE_ID;
typedef struct _NV_GPU_LPWR_PSI_SUPPORT_V1 {
  NvU32 version;
  NV_GPU_LPWR_PSI_FEATURE_ID featureId;
  NvU32 pstateSupportMask;
  NvU32 railSupportMask;
  NvU32 bIsSupported : 1;
  NvU32 reserved1 : 31;
  NvU32 reserved2[2];
} NV_GPU_LPWR_PSI_SUPPORT_V1;
#define NV_GPU_LPWR_PSI_SUPPORT_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PSI_SUPPORT_V1, 1)
#define NV_GPU_LPWR_PSI_SUPPORT_VER NV_GPU_LPWR_PSI_SUPPORT_VER1
typedef NV_GPU_LPWR_PSI_SUPPORT_V1 NV_GPU_LPWR_PSI_SUPPORT;
NVAPI_INTERFACE NvAPI_GPU_LpwrPsiGetSupport(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __inout NV_GPU_LPWR_PSI_SUPPORT *pGpuPsiFeatureSupport);
#define NV_GPU_LPWR_PSI_MAX_RAIL_SIZE 8
typedef struct _NV_GPU_LPWR_PSI_CTRL_STATS_V1 {
  NvU32 psiFlavour;
  NvU32 engageCount;
  NvU32 crossoverCurrentmA;
  NvU32 sleepCurrentmA;
} NV_GPU_LPWR_PSI_CTRL_STATS_V1;
typedef struct _NV_GPU_LPWR_PSI_STATISTICS_V1 {
  NvU32 version;
  NV_GPU_LPWR_PSI_FEATURE_ID featureId;
  NV_GPU_LPWR_PSI_CTRL_STATS_V1 railStats[NV_GPU_LPWR_PSI_MAX_RAIL_SIZE];
  NvU32 railMask;
} NV_GPU_LPWR_PSI_STATISTICS_V1;
#define NV_GPU_LPWR_PSI_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PSI_STATISTICS_V1, 1)
#define NV_GPU_LPWR_PSI_STATISTICS_VER NV_GPU_LPWR_PSI_STATISTICS_VER1
typedef NV_GPU_LPWR_PSI_STATISTICS_V1 NV_GPU_LPWR_PSI_STATISTICS;
NVAPI_INTERFACE NvAPI_GPU_LpwrPsiGetStatistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_GPU_LPWR_PSI_STATISTICS *pGpuPsiFeatureStatistics);
typedef struct _NV_GPU_LPWR_PSI_RESET_STATS_PARAM {
  NvU32 version;
  NV_GPU_LPWR_PSI_FEATURE_ID featureId;
  NvU32 railMask;
} NV_GPU_LPWR_PSI_RESET_STATS_PARAM_V1;
#define NV_GPU_LPWR_PSI_RESET_STATS_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PSI_RESET_STATS_PARAM_V1, 1)
#define NV_GPU_LPWR_PSI_RESET_STATS_PARAM_VER NV_GPU_LPWR_PSI_RESET_STATS_PARAM_VER1
typedef NV_GPU_LPWR_PSI_RESET_STATS_PARAM_V1 NV_GPU_LPWR_PSI_RESET_STATS_PARAM;
NVAPI_INTERFACE NvAPI_GPU_LpwrPsiResetStats(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __inout NV_GPU_LPWR_PSI_RESET_STATS_PARAM *pGpuPsiResetStatsParam);
typedef struct _NV_GPU_LPWR_PSI_ENABLE_PARAM_V1 {
  NvU32 version;
  NV_GPU_LPWR_PSI_FEATURE_ID featureId;
  NvU32 bEnable : 1;
  NvU32 reserved : 31;
} NV_GPU_LPWR_PSI_ENABLE_PARAM_V1;
#define NV_GPU_LPWR_PSI_ENABLE_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PSI_ENABLE_PARAM_V1, 1)
#define NV_GPU_LPWR_PSI_ENABLE_PARAM_VER NV_GPU_LPWR_PSI_ENABLE_PARAM_VER1
typedef NV_GPU_LPWR_PSI_ENABLE_PARAM_V1 NV_GPU_LPWR_PSI_ENABLE_PARAM;
NVAPI_INTERFACE NvAPI_GPU_LpwrPsiEnableSet(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_GPU_LPWR_PSI_ENABLE_PARAM *pGpuPsiEnableParam);
#define NV_GPU_LPWR_PSI_MAX_RAIL_SIZE 8
typedef struct _NV_GPU_LPWR_PSI_SET_CROSSOVER_CURRENT_V1 {
  NvU32 version;
  NV_GPU_LPWR_PSI_FEATURE_ID featureId;
  NvU32 railMask;
  NvU32 crossoverCurrentmA[NV_GPU_LPWR_PSI_MAX_RAIL_SIZE];
} NV_GPU_LPWR_PSI_SET_CROSSOVER_CURRENT_V1;
#define NV_GPU_LPWR_PSI_SET_CROSSOVER_CURRENT_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PSI_SET_CROSSOVER_CURRENT_V1, 1)
#define NV_GPU_LPWR_PSI_SET_CROSSOVER_CURRENT_VER NV_GPU_LPWR_PSI_SET_CROSSOVER_CURRENT_VER1
typedef NV_GPU_LPWR_PSI_SET_CROSSOVER_CURRENT_V1 NV_GPU_LPWR_PSI_SET_CROSSOVER_CURRENT;
NVAPI_INTERFACE NvAPI_GPU_LpwrPsiCrossoverCurrrentSet(
    __in NvPhysicalGpuHandle hPhysicalGpu,
    __inout NV_GPU_LPWR_PSI_SET_CROSSOVER_CURRENT *pGpuLpwrPsiSetCrossoverCurrent);
typedef enum _NV_GPU_LPWR_PEX_FEATURE_ID {
  NV_GPU_LPWR_PEX_FEATURE_ID_L1 = 0,
  NV_GPU_LPWR_PEX_FEATURE_ID_DEEP_L1,
} NV_GPU_LPWR_PEX_FEATURE_ID;
typedef struct _NV_GPU_LPWR_PEX_SUPPORT_V1 {
  NvU32 version;
  NV_GPU_LPWR_PEX_FEATURE_ID featureId;
  NvU32 pstateSupportMask;
  NvU32 bIsSupported : 1;
  NvU32 reserved : 31;
} NV_GPU_LPWR_PEX_SUPPORT_V1;
#define NV_GPU_LPWR_PEX_SUPPORT_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PEX_SUPPORT_V1, 1)
#define NV_GPU_LPWR_PEX_SUPPORT_VER NV_GPU_LPWR_PEX_SUPPORT_VER1
typedef NV_GPU_LPWR_PEX_SUPPORT_V1 NV_GPU_LPWR_PEX_SUPPORT;
typedef struct _NV_GPU_LPWR_PEX_STATISTICS_V1 {
  NvU32 version;
  NV_GPU_LPWR_PEX_FEATURE_ID featureId;
  NvU32 entryCount;
  NvU32 reserved[5];
} NV_GPU_LPWR_PEX_STATISTICS_V1;
#define NV_GPU_LPWR_PEX_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PEX_STATISTICS_V1, 1)
#define NV_GPU_LPWR_PEX_STATISTICS_VER NV_GPU_LPWR_PEX_STATISTICS_VER1
typedef NV_GPU_LPWR_PEX_STATISTICS_V1 NV_GPU_LPWR_PEX_STATISTICS;
#define NV_GPU_LPWR_PEX_RESET_STATS_MAX_FEATURE_LIST_SIZE 6
typedef struct _NV_GPU_LPWR_PEX_RESET_STATS_PARAM_V1 {
  NvU32 version;
  NV_GPU_LPWR_PEX_FEATURE_ID featuresubId[NV_GPU_LPWR_PEX_RESET_STATS_MAX_FEATURE_LIST_SIZE];
  NvU32 size;
} NV_GPU_LPWR_PEX_RESET_STATS_PARAM_V1;
#define NV_GPU_LPWR_PEX_RESET_STATS_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PEX_RESET_STATS_PARAM_V1, 1)
#define NV_GPU_LPWR_PEX_RESET_STATS_PARAM_VER NV_GPU_LPWR_PEX_RESET_STATS_PARAM_VER1
typedef NV_GPU_LPWR_PEX_RESET_STATS_PARAM_V1 NV_GPU_LPWR_PEX_RESET_STATS_PARAM;
typedef struct _NV_GPU_LPWR_PEX_GET_ENABLE_V1 {
  NvU32 version;
  NV_GPU_LPWR_PEX_FEATURE_ID featureId;
  NvU32 bIsEnabled : 1;
  NvU32 reserved : 31;
} NV_GPU_LPWR_PEX_GET_ENABLE_V1;
#define NV_GPU_LPWR_PEX_GET_ENABLE_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PEX_GET_ENABLE_V1, 1)
#define NV_GPU_LPWR_PEX_GET_ENABLE_VER NV_GPU_LPWR_PEX_GET_ENABLE_VER1
typedef NV_GPU_LPWR_PEX_GET_ENABLE_V1 NV_GPU_LPWR_PEX_GET_ENABLE_PARAM;
#define NV_GPU_LPWR_PEX_ENABLE_MAX_FEATURE_LIST_SIZE 6
typedef struct _NV_GPU_LPWR_PEX_ENABLE_V1 {
  NvU32 version;
  NV_GPU_LPWR_PEX_FEATURE_ID featuresubId[NV_GPU_LPWR_PEX_ENABLE_MAX_FEATURE_LIST_SIZE];
  NvU32 size;
  NvU32 bEnable : 1;
  NvU32 reserved : 31;
} NV_GPU_LPWR_PEX_ENABLE_PARAM_V1;
#define NV_GPU_LPWR_PEX_ENABLE_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_PEX_ENABLE_PARAM_V1, 1)
#define NV_GPU_LPWR_PEX_ENABLE_PARAM_VER NV_GPU_LPWR_PEX_ENABLE_PARAM_VER1
typedef NV_GPU_LPWR_PEX_ENABLE_PARAM_V1 NV_GPU_LPWR_PEX_ENABLE_PARAM;
NVAPI_INTERFACE NvAPI_GPU_LpwrPexGetSupport(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __inout NV_GPU_LPWR_PEX_SUPPORT *pGpuPexFeatureSupport);
NVAPI_INTERFACE NvAPI_GPU_LpwrPexGetStatistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_GPU_LPWR_PEX_STATISTICS *pGpuPexFeatureStatistics);
NVAPI_INTERFACE NvAPI_GPU_LpwrPexResetStats(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __inout NV_GPU_LPWR_PEX_RESET_STATS_PARAM *pGpuPexResetStatsParam);
NVAPI_INTERFACE NvAPI_GPU_LpwrPexGetEnableStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_LPWR_PEX_GET_ENABLE_PARAM *pGpuPexGetEnableParam);
NVAPI_INTERFACE NvAPI_GPU_LpwrPexFeatureEnableSet(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_LPWR_PEX_ENABLE_PARAM *pGpuPexEnableParam);
typedef enum _NV_GPU_LPWR_CG_FEATURE_ID {
  NV_GPU_LPWR_CG_FEATURE_ID_UNKNOWN = 0,
  NV_GPU_LPWR_CG_FEATURE_ID_ELCG,
} NV_GPU_LPWR_CG_FEATURE_ID;
typedef struct _NV_GPU_LPWR_CG_PARAM_V1 {
  NvU32 version;
  NV_GPU_LPWR_CG_FEATURE_ID featureId;
  NvU32 supportMask;
  NvU32 enabledMask;
  NvU32 bEnable : 1;
  NvU32 reserved : 31;
} NV_GPU_LPWR_CG_PARAM_V1;
#define NV_GPU_LPWR_CG_PARAM_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_CG_PARAM_V1, 1)
#define NV_GPU_LPWR_CG_PARAM_VER NV_GPU_LPWR_CG_PARAM_VER1
typedef NV_GPU_LPWR_CG_PARAM_V1 NV_GPU_LPWR_CG_PARAM;
NVAPI_INTERFACE NvAPI_GPU_LpwrCgSupportGet(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_GPU_LPWR_CG_PARAM *pGpuCgFeatureSupport);
NVAPI_INTERFACE NvAPI_GPU_LpwrCgEnableMaskGet(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_LPWR_CG_PARAM *pGpuCgFeatureEnable);
NVAPI_INTERFACE NvAPI_GPU_LpwrCgEnableSet(__in NvPhysicalGpuHandle hPhysicalGpu,
                                          __in NV_GPU_LPWR_CG_PARAM *pGpuCgEnableParam);
typedef struct _NV_GPU_LPWR_AP_THRESHOLD_STATISTICS {
  NvU32 counterBin0;
  NvU32 counterBin1;
  NvU32 counterBin2;
  NvU32 counterBin3;
  NvU32 counterBin4;
  NvU32 counterBin5;
  NvU32 counterBin6;
  NvU32 counterBin7;
  NvU32 counterBin8;
  NvU32 counterBin9;
  NvU32 counterBin10;
  NvU32 counterBin11;
  NvU32 counterBin12;
  NvU32 counterBin13;
  NvU32 counterBin14;
  NvU32 counterBin15;
  NvU32 counterDefault;
  NvU32 rsvd[16];
} NV_GPU_LPWR_AP_THRESHOLD_STATISTICS;
typedef enum _NV_GPU_LPWR_AP_SUB_ID {
  AP_SUB_FEATURE_ID_NONE = 0,
  GET_ALL_THRESHOLD_COUNTERS,
} NV_GPU_LPWR_AP_SUB_ID;
typedef struct _NV_GPU_LPWR_AP_STATISTICS {
  NV_GPU_LPWR_AP_SUB_ID subId;
  union {
    NV_GPU_LPWR_AP_THRESHOLD_STATISTICS thresholds;
  } stats;
} NV_GPU_LPWR_AP_STATISTICS;
typedef enum _NV_GPU_LPWR_FEATURE_ID {
  FEATURE_ID_NONE = 0,
  ADAPTIVE_POWER,
} NV_GPU_LPWR_FEATURE_ID;
typedef union _NV_GPU_LPWR_FEATURE_STATISTICS {
  NV_GPU_LPWR_AP_STATISTICS ap;
} NV_GPU_LPWR_FEATURE_STATISTICS;
typedef struct _NV_GPU_LPWR_STATISTICS {
  NvU32 version;
  NV_GPU_LPWR_FEATURE_ID featureId;
  NV_GPU_LPWR_FEATURE_STATISTICS pLpwrFeatureStatistics;
} NV_GPU_LPWR_STATISTICS_V1;
#define NV_GPU_LPWR_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_GPU_LPWR_STATISTICS_V1, 1)
typedef NV_GPU_LPWR_STATISTICS_V1 NV_GPU_LPWR_STATISTICS;
#define NV_GPU_LPWR_STATISTICS_VER NV_GPU_LPWR_STATISTICS_VER1
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_GPU_LpwrApGetStatistics.")
    NVAPI_INTERFACE NvAPI_GPU_GetLpwrStatistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_GPU_LPWR_STATISTICS *pGpuLpwrStatistics);
typedef struct {
  NvU32 version;
  NvU32 goldD3HotCount;
  NvU32 gc6D3HotCount;
  NvU32 bClearStats : 1;
  NvU32 reserved : 31;
} NV_LPWR_D3HOT_INFO_V1;
typedef NV_LPWR_D3HOT_INFO_V1 NV_LPWR_D3HOT_INFO;
#define NV_LPWR_D3HOT_INFO_VER1 MAKE_NVAPI_VERSION(NV_LPWR_D3HOT_INFO_V1, 1)
#define NV_LPWR_D3HOT_INFO_VER NV_LPWR_D3HOT_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_LpwrGetD3HotCyclesInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_LPWR_D3HOT_INFO *d3HotParams);
typedef enum _NV_GPU_CLIENT_PWR_POLICY_ID {
  NV_GPU_CLIENT_PWR_POLICY_ID_KERNEL,
  NV_GPU_CLIENT_PWR_POLICY_ID_TGP,
  NV_GPU_CLIENT_PWR_POLICY_ID_INVALID = 0xFF
} NV_GPU_CLIENT_PWR_POLICY_ID,
    *PNV_GPU_CLIENT_PWR_POLICY_ID;
typedef struct _NV_GPU_CLIENT_PWR_POLICY_INFO_V1 {
  NV_GPU_CLIENT_PWR_POLICY_ID policyId;
  NV_GPU_POWER_POLICY_LIMIT_UNIT limitUnit;
  NvU32 limitMin;
  NvU32 limitRated;
  NvU32 limitMax;
  NvU32 limitBatt;
  NvU32 limitBattMax;
  NvU8 rsvd[28];
} NV_GPU_CLIENT_PWR_POLICY_INFO_V1, *PNV_GPU_CLIENT_PWR_POLICY_INFO_V1;
typedef struct _NV_GPU_CLIENT_PWR_POLICIES_INFO_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 clientPolicyMask;
  NvU8 rsvd[32];
  NV_GPU_CLIENT_PWR_POLICY_INFO_V1 clientPwrPolicies[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_CLIENT_PWR_POLICIES_INFO_V1, *PNV_GPU_CLIENT_PWR_POLICIES_INFO_V1;
typedef NV_GPU_CLIENT_PWR_POLICY_INFO_V1 NV_GPU_CLIENT_PWR_POLICY_INFO, *PNV_GPU_CLIENT_PWR_POLICY_INFO;
typedef NV_GPU_CLIENT_PWR_POLICIES_INFO_V1 NV_GPU_CLIENT_PWR_POLICIES_INFO, *PNV_GPU_CLIENT_PWR_POLICIES_INFO;
#define NV_GPU_CLIENT_PWR_POLICIES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_PWR_POLICIES_INFO_V1, 1)
#define NV_GPU_CLIENT_PWR_POLICIES_INFO_VER NV_GPU_CLIENT_PWR_POLICIES_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientPwrPoliciesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout PNV_GPU_CLIENT_PWR_POLICIES_INFO pInfo);
typedef struct _NV_GPU_CLIENT_PWR_POLICY_STATUS_V1 {
  NvU32 valueCurr;
  NvU32 limitCurr;
  NvU8 rsvd[32];
} NV_GPU_CLIENT_PWR_POLICY_STATUS_V1, *PNV_GPU_CLIENT_PWR_POLICY_STATUS_V1;
typedef struct _NV_GPU_CLIENT_PWR_POLICIES_STATUS_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 clientPolicyMask;
  NvU8 rsvd[32];
  NV_GPU_CLIENT_PWR_POLICY_STATUS_V1 clientPwrPolicies[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_CLIENT_PWR_POLICIES_STATUS_V1, *PNV_GPU_CLIENT_PWR_POLICIES_STATUS_V1;
typedef NV_GPU_CLIENT_PWR_POLICY_STATUS_V1 NV_GPU_CLIENT_PWR_POLICY_STATUS, *PNV_GPU_CLIENT_PWR_POLICY_STATUS;
typedef NV_GPU_CLIENT_PWR_POLICIES_STATUS_V1 NV_GPU_CLIENT_PWR_POLICIES_STATUS, *PNV_GPU_CLIENT_PWR_POLICIES_STATUS;
#define NV_GPU_CLIENT_PWR_POLICIES_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_PWR_POLICIES_STATUS_V1, 1)
#define NV_GPU_CLIENT_PWR_POLICIES_STATUS_VER NV_GPU_CLIENT_PWR_POLICIES_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientPwrPoliciesGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __inout PNV_GPU_CLIENT_PWR_POLICIES_STATUS pStatus);
typedef enum _NV_GPU_CLIENT_PWR_POLICY_LIMIT_INPUT_CLIENT_IDX {
  NV_GPU_CLIENT_PWR_POLICY_LIMIT_INPUT_CLIENT_IDX_RM = 0xFE,
  NV_GPU_CLIENT_PWR_POLICY_LIMIT_INPUT_CLIENT_IDX_KERNEL = 0xF8,
} NV_GPU_CLIENT_PWR_POLICY_LIMIT_INPUT_CLIENT_IDX,
    *PNV_GPU_CLIENT_PWR_POLICY_LIMIT_INPUT_CLIENT_IDX;
typedef struct _NV_GPU_CLIENT_PWR_POLICY_CONTROL_V1 {
  NvU32 limitClientCurr;
  NV_GPU_CLIENT_PWR_POLICY_LIMIT_INPUT_CLIENT_IDX
  limitClientIdx;
  NvU8 rsvd[32];
} NV_GPU_CLIENT_PWR_POLICY_CONTROL_V1, *PNV_GPU_CLIENT_PWR_POLICY_CONTROL_V1;
typedef struct _NV_GPU_CLIENT_PWR_POLICIES_CONTROL_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 clientPolicyMask;
  NvU8 rsvd[32];
  NV_GPU_CLIENT_PWR_POLICY_CONTROL_V1 clientPwrPolicies[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_CLIENT_PWR_POLICIES_CONTROL_V1, *PNV_GPU_CLIENT_PWR_POLICIES_CONTROL_V1;
typedef NV_GPU_CLIENT_PWR_POLICY_CONTROL_V1 NV_GPU_CLIENT_PWR_POLICY_CONTROL, *PNV_GPU_CLIENT_PWR_POLICY_CONTROL;
typedef NV_GPU_CLIENT_PWR_POLICIES_CONTROL_V1 NV_GPU_CLIENT_PWR_POLICIES_CONTROL, *PNV_GPU_CLIENT_PWR_POLICIES_CONTROL;
#define NV_GPU_CLIENT_PWR_POLICIES_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_PWR_POLICIES_CONTROL_V1, 1)
#define NV_GPU_CLIENT_PWR_POLICIES_CONTROL_VER NV_GPU_CLIENT_PWR_POLICIES_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientPwrPoliciesGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                      __inout PNV_GPU_CLIENT_PWR_POLICIES_CONTROL pControl);
NVAPI_INTERFACE NvAPI_GPU_ClientPwrPoliciesSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                      __inout PNV_GPU_CLIENT_PWR_POLICIES_CONTROL pControl);
#define NV_GPU_PWR_PMUMON_PWR_CHANNELS_SAMPLE_INVALID (NV_U32_MAX)
typedef struct _NV_GPU_PWR_PMUMON_PWR_CHANNELS_SAMPLE_V1 {
  NV_GPU_PMUMON_SAMPLE_SUPER_V1 super;
  NvU32 tgpmW;
  NvU32 coremW;
  NvU8 rsvd[64];
} NV_GPU_PWR_PMUMON_PWR_CHANNELS_SAMPLE_V1;
#define NV_GPU_PWR_PMUMON_PWR_CHANNELS_SAMPLE_COUNT_V1 (1000U)
typedef struct _NV_GPU_PWR_PMUMON_PWR_CHANNELS_GET_SAMPLES_V1 {
  NvU32 version;
  NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 super;
  NvU8 rsvd[64];
  NV_GPU_PWR_PMUMON_PWR_CHANNELS_SAMPLE_V1 samples[NV_GPU_PWR_PMUMON_PWR_CHANNELS_SAMPLE_COUNT_V1];
} NV_GPU_PWR_PMUMON_PWR_CHANNELS_GET_SAMPLES_V1;
typedef NV_GPU_PWR_PMUMON_PWR_CHANNELS_GET_SAMPLES_V1 NV_GPU_PWR_PMUMON_PWR_CHANNELS_GET_SAMPLES;
#define NV_GPU_PWR_PMUMON_PWR_CHANNELS_GET_SAMPLES_VER1                                                                \
  MAKE_NVAPI_VERSION(NV_GPU_PWR_PMUMON_PWR_CHANNELS_GET_SAMPLES_V1, 1)
#define NV_GPU_PWR_PMUMON_PWR_CHANNELS_GET_SAMPLES_VER NV_GPU_PWR_PMUMON_PWR_CHANNELS_GET_SAMPLES_VER1
NVAPI_INTERFACE NvAPI_GPU_PwrPmumonPwrChannelsGetSamples(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PWR_PMUMON_PWR_CHANNELS_GET_SAMPLES *pGetSamplesParams);
typedef struct {
  NvU32 displayMask;
  NvU32 padCurrMode;
  NvU32 padPowerState : 1;
  NvU32 usesHybridPad : 1;
  NvU32 reserved : 30;
} NV_HYBRID_PAD_DATA;
typedef struct {
  NvU32 version;
  NvU32 phyPortCount;
  NV_HYBRID_PAD_DATA *pHybridPadInfo;
} NV_GET_HYBRID_PAD_INFO_V1;
#define NV_GET_HYBRID_PAD_INFO_VER1 MAKE_NVAPI_VERSION(NV_GET_HYBRID_PAD_INFO_V1, 1)
#define NV_GET_HYBRID_PAD_INFO_VER NV_GET_HYBRID_PAD_INFO_VER1
typedef NV_GET_HYBRID_PAD_INFO_V1 NV_GET_HYBRID_PAD_INFO;
NVAPI_INTERFACE NvAPI_GPU_GetHybridPadInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GET_HYBRID_PAD_INFO *hybridPadInfo);
NVAPI_INTERFACE NvAPI_EnumPhysicalGPUs(NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);
NVAPI_INTERFACE NvAPI_EnumTCCPhysicalGPUs(NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS], NvU32 *pGpuCount);
NVAPI_INTERFACE NvAPI_EnumLogicalGPUs(NvLogicalGpuHandle nvGPUHandle[NVAPI_MAX_LOGICAL_GPUS], NvU32 *pGpuCount);
NVAPI_INTERFACE NvAPI_GetPhysicalGPUsFromDisplay(NvDisplayHandle hNvDisp,
                                                 NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS],
                                                 NvU32 *pGpuCount);
NVAPI_INTERFACE NvAPI_EnumPhysicalGPUsInternal(NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS],
                                               NvU32 *pGpuCount);
NVAPI_INTERFACE NvAPI_EnumLogicalGPUsInternal(NvLogicalGpuHandle nvGPUHandle[NVAPI_MAX_LOGICAL_GPUS], NvU32 *pGpuCount);
NVAPI_INTERFACE NvAPI_GetDisplayFromPhysicalGPU(NvPhysicalGpuHandle nvGPUHandle, NvDisplayHandle *hNvDisp);
NVAPI_INTERFACE NvAPI_DISP_GetUnAttachedDisplayFromPhysicalGPU(NvPhysicalGpuHandle nvGPUHandle,
                                                               NvUnAttachedDisplayHandle *hUnAttachedNvDisp);
NVAPI_INTERFACE NvAPI_GetAssociatedDisplayFromOutputId(NvPhysicalGpuHandle nvGPUHandle, NvU32 outputId,
                                                       NvDisplayHandle *hNvDisp);
NVAPI_INTERFACE NvAPI_GetPhysicalGPUFromUnAttachedDisplay(NvUnAttachedDisplayHandle hNvUnAttachedDisp,
                                                          NvPhysicalGpuHandle *pPhysicalGpu);
NVAPI_INTERFACE NvAPI_GetLogicalGPUFromDisplay(NvDisplayHandle hNvDisp, NvLogicalGpuHandle *pLogicalGPU);
NVAPI_INTERFACE NvAPI_DISP_GetLogicalCudaGPUFromDisplay(NvDisplayHandle hNvDisp, NvLogicalGpuHandle *pLogicalGPU);
NVAPI_INTERFACE NvAPI_GetLogicalGPUFromPhysicalGPU(NvPhysicalGpuHandle hPhysicalGPU, NvLogicalGpuHandle *pLogicalGPU);
NVAPI_INTERFACE NvAPI_GetPhysicalGPUsFromLogicalGPU(NvLogicalGpuHandle hLogicalGPU,
                                                    NvPhysicalGpuHandle hPhysicalGPU[NVAPI_MAX_PHYSICAL_GPUS],
                                                    NvU32 *pGpuCount);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 290. Instead, use "
                            "NvAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder.") NVAPI_INTERFACE
    NvAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder(NvLogicalGpuHandle hLogicalGPU,
                                                     NvPhysicalGpuHandle hPhysicalGPU[NVAPI_MAX_PHYSICAL_GPUS],
                                                     NvU32 *pGpuCount);
NVAPI_INTERFACE NvAPI_GetPhysicalGPUFromDisplay(NvDisplayHandle hNvDisplay, NvPhysicalGpuHandle *pPhysicalGpu);
NVAPI_INTERFACE NvAPI_GetPhysicalGPUFromGPUID(NvU32 gpuId, NvPhysicalGpuHandle *pPhysicalGPU);
NVAPI_INTERFACE NvAPI_GetGPUIDfromPhysicalGPU(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pGpuId);
NVAPI_INTERFACE NvAPI_DISP_GetTargetPhysicalGPUsFromUnAttachedDisplay(
    NvUnAttachedDisplayHandle hNvUnAttachedDisp, NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS],
    NvU32 *pGpuCount);
NVAPI_INTERFACE NvAPI_GPU_GetPerGpuRegistryPath(NvPhysicalGpuHandle hPhysicalGpu, char *pRegistryPath);
typedef struct _NV_SLI_MASTER_REGISTRY_PATHS {
  NvU32 numSliMasterGPUs;
  char szSliMasterRegistryPaths[NVAPI_PHYSICAL_GPUS][NVAPI_GENERIC_STRING_MAX];
} NV_SLI_MASTER_REGISTRY_PATHS;
NVAPI_INTERFACE NvAPI_GPU_GetSliMasterRegistryPath(__out NV_SLI_MASTER_REGISTRY_PATHS *pSliMasterRegistryPaths);
#define NVAPI_MAX_RAW_FUSE_DATA_SIZE 64
typedef struct _NV_RAW_FUSE_DATA_V1 {
  NvU32 version;
  NvU8 fuseData[NVAPI_MAX_RAW_FUSE_DATA_SIZE];
  NvU32 fuseDataSize;
} NV_RAW_FUSE_DATA_V1;
typedef NV_RAW_FUSE_DATA_V1 NV_RAW_FUSE_DATA;
#define NV_RAW_FUSE_DATA_VER1 MAKE_NVAPI_VERSION(NV_RAW_FUSE_DATA_V1, 1)
#define NV_RAW_FUSE_DATA_VER NV_RAW_FUSE_DATA_VER1
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 495.") NVAPI_INTERFACE
    NvAPI_GPU_GetRawFuseData(NvPhysicalGpuHandle hPhysicalGpu, NV_RAW_FUSE_DATA *pFuseData);
typedef enum {
  NVAPI_FOUNDRY_UNKNOWN = 0,
  NVAPI_FOUNDRY_TSMC = 1,
  NVAPI_FOUNDRY_UMC = 2,
  NVAPI_FOUNDRY_IBM = 3,
  NVAPI_FOUNDRY_SMIC = 4,
  NVAPI_FOUNDRY_CHARTERED = 5,
  NVAPI_FOUNDRY_TOSHIBA = 6,
} NVAPI_FOUNDRY_ID;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 510.") NVAPI_INTERFACE
    NvAPI_GPU_GetFoundry(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_FOUNDRY_ID *pFoundry);
NVAPI_INTERFACE NvAPI_GPU_GetVPECount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCount);
NVAPI_INTERFACE NvAPI_GPU_GetShaderPipeCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCount);
NVAPI_INTERFACE NvAPI_GPU_GetShaderSubPipeCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCount);
#define NVAPI_GPU_MAX_REGISTER_OP_COUNT 256
typedef enum {
  NVAPI_GPU_REG_OP_FLAG_READ = 0x00000001,
  NVAPI_GPU_REG_OP_FLAG_WRITE = 0x00000002,
  NVAPI_GPU_REG_OP_FLAG_32BIT = 0x00000004,
  NVAPI_GPU_REG_OP_FLAG_64BIT = 0x00000008,
  NVAPI_GPU_REG_OP_FLAG_TYPE_GLOBAL = 0x00000010,
  NVAPI_GPU_REG_OP_FLAG_TYPE_GR_CTX = 0x00000020,
} NVAPI_GPU_REG_OP_FLAGS;
typedef enum {
  NVAPI_GPU_REG_OP_STATUS_SUCCESS = 0x00000000,
  NVAPI_GPU_REG_OP_STATUS_INVALID_OP = 0x00000001,
  NVAPI_GPU_REG_OP_STATUS_INVALID_TYPE = 0x00000002,
  NVAPI_GPU_REG_OP_STATUS_INVALID_OFFSET = 0x00000004,
  NVAPI_GPU_REG_OP_STATUS_UNSUPPORTED_OP = 0x00000008,
} NVAPI_GPU_REG_OP_STATUS;
typedef struct {
  NvU16 flags;
  NvU16 status;
  NvU32 offset;
  NvU64 writeMask;
  NvU64 value;
} NV_GPU_REGISTER_OP;
typedef struct _NV_GPU_REGISTER_OP_DATA_V1 {
  NvU32 version;
  NvU32 opCount;
  NV_GPU_REGISTER_OP op[NVAPI_GPU_MAX_REGISTER_OP_COUNT];
} NV_GPU_REGISTER_OP_DATA_V1;
typedef NV_GPU_REGISTER_OP_DATA_V1 NV_GPU_REGISTER_OP_DATA;
#define NV_GPU_REGISTER_OP_DATA_VER1 MAKE_NVAPI_VERSION(NV_GPU_REGISTER_OP_DATA_V1, 1)
#define NV_GPU_REGISTER_OP_DATA_VER NV_GPU_REGISTER_OP_DATA_VER1
NVAPI_INTERFACE NvAPI_GPU_RegisterOp(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_REGISTER_OP_DATA *pRegOps);
NVAPI_INTERFACE NvAPI_GPU_GetPartitionCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCount);
NVAPI_INTERFACE NvAPI_GPU_GetMemPartitionMask(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pMask);
#define NV_GPU_MAX_FBPS 32
typedef struct {
  NvU32 version;
  NvU32 fbpMask;
  NvU32 fbpCount;
  NvU32 ltcCount;
  NvU32 ltsCount;
  NvU32 ltcMask[NV_GPU_MAX_FBPS];
} NV_GPU_FRAME_BUFFER_DETAILS_V1;
typedef struct _NV_GPU_FRAME_BUFFER_DETAILS_V2 {
  NvU32 version;
  NvU32 fbpMask;
  NvU32 fbpCount;
  NvU32 ltcCount;
  NvU32 ltsCount;
  NvU32 ltcMask[NV_GPU_MAX_FBPS];
  NvU32 ltsMask[NV_GPU_MAX_FBPS];
} NV_GPU_FRAME_BUFFER_DETAILS_V2;
#define NV_GPU_FRAME_BUFFER_DETAILS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FRAME_BUFFER_DETAILS_V1, 1)
#define NV_GPU_FRAME_BUFFER_DETAILS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_FRAME_BUFFER_DETAILS_V2, 2)
typedef NV_GPU_FRAME_BUFFER_DETAILS_V2 NV_GPU_FRAME_BUFFER_DETAILS;
#define NV_GPU_FRAME_BUFFER_DETAILS_VER NV_GPU_FRAME_BUFFER_DETAILS_VER_2
NVAPI_INTERFACE NvAPI_GPU_GetFrameBufferDetails(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_GPU_FRAME_BUFFER_DETAILS *pDetails);
NVAPI_INTERFACE NvAPI_GPU_GetGPCMask(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pMask);
NVAPI_INTERFACE NvAPI_GPU_GetTPCMaskOnGPC(NvPhysicalGpuHandle hPhysicalGpu, NvU32 gpcId, NvU32 *pMask);
NVAPI_INTERFACE NvAPI_GPU_GetZCULLMask(NvPhysicalGpuHandle hPhysicalGpu, NvU32 gpcId, NvU32 *pMask);
NVAPI_INTERFACE NvAPI_GPU_GetTPCMask(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pMask);
NVAPI_INTERFACE NvAPI_GPU_GetSMMask(NvPhysicalGpuHandle hPhysicalGpu, NvU32 tpcId, NvU32 *pMask);
NVAPI_INTERFACE NvAPI_GPU_GetTotalTPCCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCount);
NVAPI_INTERFACE NvAPI_GPU_GetTotalSMCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCount);
NVAPI_INTERFACE NvAPI_GPU_GetTotalSPCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCount);
NVAPI_INTERFACE NvAPI_GPU_GetGpuCoreCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCount);
typedef enum _NV_GPU_DISPLAY_CHANGE_INHIBIT {
  NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_SPAN = 0x00000001,
  NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_VIDEO = 0x00000002,
  NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_3D_FULLSCREEN = 0x00000004,
  NVAPI_GPU_DISPLAY_CHANGE_INHIBIT_DOS_FULLSCREEN = 0x00000008,
} NV_GPU_DISPLAY_CHANGE_INHIBIT;
NVAPI_INTERFACE NvAPI_GPU_GetDisplayChangeInhibitState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInhibitState);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetAllDisplayIds.")
    NVAPI_INTERFACE NvAPI_GPU_GetAllOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);
NVAPI_INTERFACE NvAPI_GPU_GetInternalDisplays(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInternalDisplaysMask);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
    NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
    NVAPI_INTERFACE NvAPI_GPU_GetConnectedSLIOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);
#define NV_GPU_CONNECTED_FLAG_UNCACHED 0x0
#define NV_GPU_CONNECTED_FLAG_CACHED 0x1
#define NV_GPU_CONNECTED_FLAG_FAKE 0x2
#define NV_GPU_CONNECTED_FLAG_DIRECTMODE 0x4
#define NV_GPU_CONNECTED_FLAG_OS_DEDICATED_DISPLAY 0x8
#define NV_GPU_CONNECTED_FLAG_INCLUDE_SLAVE_TILES 0x10
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
    NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputsEx(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask, NvU32 flag);
typedef enum {
  NV_MONITOR_CONN_TYPE_UNINITIALIZED = 0,
  NV_MONITOR_CONN_TYPE_VGA,
  NV_MONITOR_CONN_TYPE_COMPONENT,
  NV_MONITOR_CONN_TYPE_SVIDEO,
  NV_MONITOR_CONN_TYPE_HDMI,
  NV_MONITOR_CONN_TYPE_DVI,
  NV_MONITOR_CONN_TYPE_LVDS,
  NV_MONITOR_CONN_TYPE_DP,
  NV_MONITOR_CONN_TYPE_COMPOSITE,
  NV_MONITOR_CONN_TYPE_UNKNOWN = -1
} NV_MONITOR_CONN_TYPE;
#define NV_GPU_CONNECTED_IDS_FLAG_UNCACHED NV_BIT(0)
#define NV_GPU_CONNECTED_IDS_FLAG_SLI NV_BIT(1)
#define NV_GPU_CONNECTED_IDS_FLAG_LIDSTATE NV_BIT(2)
#define NV_GPU_CONNECTED_IDS_FLAG_FAKE NV_BIT(3)
#define NV_GPU_CONNECTED_IDS_FLAG_EXCLUDE_MST NV_BIT(4)
#define NV_GPU_CONNECTED_IDS_FLAG_SYMMETRIC NV_BIT(5)
#define NV_GPU_CONNECTED_IDS_FLAG_ORDERED NV_BIT(6)
#define NV_GPU_CONNECTED_IDS_DIRECT_MODE NV_BIT(7)
#define NV_GPU_CONNECTED_IDS_OS_DEDICATED_DISPLAY NV_BIT(8)
#define NV_GPU_CONNECTED_IDS_INCLUDE_SLAVE_TILES NV_BIT(9)
typedef struct _NV_GPU_DISPLAYIDS {
  NvU32 version;
  NV_MONITOR_CONN_TYPE connectorType;
  NvU32 displayId;
  NvU32 isDynamic : 1;
  NvU32 isMultiStreamRootNode : 1;
  NvU32 isActive : 1;
  NvU32 isCluster : 1;
  NvU32 isOSVisible : 1;
  NvU32 isWFD : 1;
  NvU32 isConnected : 1;
  NvU32 isTile : 1;
  NvU32 isVirtual : 1;
  NvU32 isSingleHeadMode : 1;
  NvU32 isVRDisplay : 1;
  NvU32 isDirectMode : 1;
  NvU32 isOsDedicatedDisplay : 1;
  NvU32 isMasterTile : 1;
  NvU32 isDscCapable : 1;
  NvU32 isMuxCapable : 1;
  NvU32 isRivermaxDisplay : 1;
  NvU32 isPhysicallyConnected : 1;
  NvU32 isUsb4Display : 1;
  NvU32 reserved : 13;
} NV_GPU_DISPLAYIDS;
#define NV_GPU_DISPLAYIDS_VER1 MAKE_NVAPI_VERSION(NV_GPU_DISPLAYIDS, 1)
#define NV_GPU_DISPLAYIDS_VER2 MAKE_NVAPI_VERSION(NV_GPU_DISPLAYIDS, 3)
#define NV_GPU_DISPLAYIDS_VER NV_GPU_DISPLAYIDS_VER2
NVAPI_INTERFACE NvAPI_GPU_GetConnectedDisplayIds(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount)
                                                     NV_GPU_DISPLAYIDS *pDisplayIds,
                                                 __inout NvU32 *pDisplayIdCount, __in NvU32 flags);
NVAPI_INTERFACE NvAPI_GPU_GetAllDisplayIds(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount)
                                               NV_GPU_DISPLAYIDS *pDisplayIds,
                                           __inout NvU32 *pDisplayIdCount);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
    NVAPI_INTERFACE NvAPI_GPU_GetConnectedOutputsWithLidState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
    NVAPI_INTERFACE NvAPI_GPU_GetConnectedSLIOutputsWithLidState(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
    NVAPI_INTERFACE
    NvAPI_GPU_GetConnectedOutputsWithLidStateEx(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask, NvU32 flag);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_GPU_GetConnectedDisplayIds.")
    NVAPI_INTERFACE
    NvAPI_GPU_GetConnectedSLIOutputsWithLidStateEx(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask, NvU32 flag);
typedef enum {
  NV_SYSTEM_TYPE_UNKNOWN = 0,
  NV_SYSTEM_TYPE_LAPTOP = 1,
  NV_SYSTEM_TYPE_DESKTOP = 2,
} NV_SYSTEM_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetSystemType(NvPhysicalGpuHandle hPhysicalGpu, NV_SYSTEM_TYPE *pSystemType);
NVAPI_INTERFACE NvAPI_GPU_GetActiveOutputs(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pOutputsMask);
NVAPI_INTERFACE NvAPI_GPU_GetEdidEx(NvU32 displayId, NV_EDID_FLAG *pFlag, NV_EDID *pEdid);
NVAPI_INTERFACE NvAPI_GPU_GetEdidEx2(NvU32 displayId, NV_EDID_FLAG *pFlag, NvU8 *pEdid, NvU32 *pSizeofEDID);
typedef struct _NV_VR_DESKTOP_CAPABILITY_INFO_V1 {
  NvU32 version;
  NvU32 vendorId;
  NvU32 isVRDesktopPossible : 1;
  NvU32 reserved : 31;
} NV_VR_DESKTOP_CAPABILITY_INFO_V1;
typedef NV_VR_DESKTOP_CAPABILITY_INFO_V1 NV_VR_DESKTOP_CAPABILITY_INFO;
#define NV_VR_DESKTOP_CAPABILITY_INFO_VER1 MAKE_NVAPI_VERSION(NV_VR_DESKTOP_CAPABILITY_INFO_V1, 1)
#define NV_VR_DESKTOP_CAPABILITY_INFO_VER NV_VR_DESKTOP_CAPABILITY_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetVRDesktopCapability(__inout NV_VR_DESKTOP_CAPABILITY_INFO *pVRDesktopCapabilityInfo);
typedef struct _NV_VR_DESKTOP_INFO_V1 {
  NvU32 version;
  NvU16 maxWidth;
  NvU16 maxHeight;
  NV_DISPLAY_REFRESH_RATE maxRefreshRate;
  NvBool bEnable;
  NvU32 vendorId;
  NvU32 displayId;
} NV_VR_DESKTOP_INFO_V1;
typedef NV_VR_DESKTOP_INFO_V1 NV_VR_DESKTOP_INFO;
#define NV_VR_DESKTOP_INFO_VER1 MAKE_NVAPI_VERSION(NV_VR_DESKTOP_INFO_V1, 1)
#define NV_VR_DESKTOP_INFO_VER NV_VR_DESKTOP_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_SetVRDesktop(__inout NV_VR_DESKTOP_INFO *pVRDesktopInfo);
NVAPI_INTERFACE NvAPI_GPU_SetEDID(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayOutputId, NV_EDID *pEDID);
typedef enum _NV_EDID_LOCKING_FLAG {
  NVAPI_EDID_LOCKING_DEFAULT = 0,
  NVAPI_INTERNAL_EDID_LOCKING = 1,
  NVAPI_DDAUTOTEST_EDID_LOCKING = 2,
  NVAPI_NON_PERSISTENT_EDID_LOCKING = 3,
  NVAPI_GUID_BASED_EDID_LOCKING = 4,
  NVAPI_RIVERMAXDISPLAY_EDID_LOCKING = 5,
} NV_EDID_LOCKING_FLAG;
NVAPI_INTERFACE NvAPI_GPU_SetEDIDInternal(NvU32 displayId, NV_EDID_LOCKING_FLAG flag, NvU8 *pEDID, NvU32 SizeofEDID);
NVAPI_INTERFACE NvAPI_GPU_GetTargetID(__in_opt NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 displayOutputId,
                                      __out NvU32 *pTargetId);
typedef enum _NV_GPU_OUTPUT_TYPE {
  NVAPI_GPU_OUTPUT_UNKNOWN = 0,
  NVAPI_GPU_OUTPUT_CRT = 1,
  NVAPI_GPU_OUTPUT_DFP = 2,
  NVAPI_GPU_OUTPUT_TV = 3,
} NV_GPU_OUTPUT_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetOutputType(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId,
                                        NV_GPU_OUTPUT_TYPE *pOutputType);
typedef struct {
  NvU32 version;
  NvU32 activeWidth;
  NvU32 activeHeight;
  NvU32 totalWidth;
  NvU32 totalHeight;
  NvU32 depth;
  NvU32 frequency;
} NV_GPU_DISPLAY_MODE;
#define NV_GPU_DISPLAY_MODE_VER MAKE_NVAPI_VERSION(NV_GPU_DISPLAY_MODE, 1)
NVAPI_INTERFACE NvAPI_GPU_GetDeviceDisplayMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayId,
                                               NV_GPU_DISPLAY_MODE *pDeviceDisplayMode);
typedef enum _NV_GPU_FLATPANEL_SIGNAL_TYPE {
  NV_GPU_FLATPANEL_SIGNAL_TYPE_TMDS = 0,
  NV_GPU_FLATPANEL_SIGNAL_TYPE_LVDS = 1,
  NV_GPU_FLATPANEL_SIGNAL_TYPE_SDI = 2,
  NV_GPU_FLATPANEL_SIGNAL_TYPE_DISPLAYPORT = 3,
} NV_GPU_FLATPANEL_SIGNAL_TYPE;
typedef enum _NV_GPU_FLATPANEL_SIGNAL_LINK {
  NV_GPU_FLATPANEL_SIGNAL_SINGLE_LINK = 1,
  NV_GPU_FLATPANEL_SIGNAL_DUAL_LINK = 2,
} NV_GPU_FLATPANEL_SIGNAL_LINK;
typedef enum _NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES {
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_NONE = 0,
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_SINGLE_LANE = 1,
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_DUAL_LANE = 2,
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_QUAD_LANE = 3,
} NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES;
typedef enum _NV_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS {
  NV_GPU_FLATPANEL_SIGNAL_COLOR_LIMITED_RANGE = 0x00000001,
  NV_GPU_FLATPANEL_SIGNAL_COLOR_AUTO_CONFIGURE = 0x00000002,
  NV_GPU_FLATPANEL_SIGNAL_COLOR_FORMAT_YCBCR422_CAPABLE = 0x00000004,
  NV_GPU_FLATPANEL_SIGNAL_COLOR_FORMAT_YCBCR444_CAPABLE = 0x00000008,
} NV_GPU_FLATPANEL_SIGNAL_COLOR_FLAGS;
typedef struct {
  NvU32 version;
  NV_GPU_FLATPANEL_SIGNAL_TYPE signalType;
  NV_GPU_FLATPANEL_SIGNAL_LINK linkType;
  NV_GPU_FLATPANEL_SIGNAL_DISPLAYPORT_LANES displayPortLanes;
  NvU32 colorFlags;
  NvU32 hdmiCapable : 1;
  NvU32 scalerDisabled : 1;
  NvU32 refreshRateLocked : 1;
} NV_GPU_FLAT_PANEL_INFO;
#define NV_GPU_FLAT_PANEL_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_FLAT_PANEL_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetFlatPanelInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId,
                                           NV_GPU_FLAT_PANEL_INFO *pFlatPanelInfo);
NVAPI_INTERFACE NvAPI_GPU_ValidateOutputCombination(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputsMask);
typedef struct _NV_CONNECTOR_STATE {
  NvU32 version;
  NvU64 isMultiStreamEnabled : 1;
  NvU64 isStreamCloneEnabled : 1;
  NvU64 isWronglyConnected : 1;
  NvU64 reserved : 61;
} NV_CONNECTOR_STATE_V1;
typedef NV_CONNECTOR_STATE_V1 NV_CONNECTOR_STATE;
#define NV_CONNECTOR_STATE_VER1 MAKE_NVAPI_VERSION(NV_CONNECTOR_STATE_V1, 1)
#define NV_CONNECTOR_STATE_VER NV_CONNECTOR_STATE_VER1
NVAPI_INTERFACE NvAPI_GPU_GetConnectorState(__in NvU32 displayId, __inout NV_CONNECTOR_STATE *pConnectorState);
NVAPI_INTERFACE NvAPI_GPU_GetShortName(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_ShortString szName);
NVAPI_INTERFACE NvAPI_GPU_GetFullName(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_ShortString szName);
NVAPI_INTERFACE NvAPI_GPU_GetPCIIdentifiers(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pDeviceId, NvU32 *pSubSystemId,
                                            NvU32 *pRevisionId, NvU32 *pExtDeviceId);
typedef enum _NV_GPU_TYPE {
  NV_SYSTEM_TYPE_GPU_UNKNOWN = 0,
  NV_SYSTEM_TYPE_IGPU = 1,
  NV_SYSTEM_TYPE_DGPU = 2,
  NV_SYSTEM_TYPE_SOCGPU = 3,
} NV_GPU_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetGPUType(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_TYPE *pGpuType);
typedef enum _NV_GPU_BUS_TYPE {
  NVAPI_GPU_BUS_TYPE_UNDEFINED = 0,
  NVAPI_GPU_BUS_TYPE_PCI = 1,
  NVAPI_GPU_BUS_TYPE_AGP = 2,
  NVAPI_GPU_BUS_TYPE_PCI_EXPRESS = 3,
  NVAPI_GPU_BUS_TYPE_FPCI = 4,
  NVAPI_GPU_BUS_TYPE_AXI = 5,
} NV_GPU_BUS_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetBusType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_BUS_TYPE *pBusType);
NVAPI_INTERFACE NvAPI_GPU_GetBusId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusId);
NVAPI_INTERFACE NvAPI_GPU_GetBusSlotId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusSlotId);
typedef struct {
  NvU32 version;
  NvU32 speedSwitchErrorCount;
  NvU32 widthSwitchErrorCount;
} NV_PCIELINK_SWITCH_ERROR_INFO_V1;
typedef NV_PCIELINK_SWITCH_ERROR_INFO_V1 NV_PCIELINK_SWITCH_ERROR_INFO;
#define NV_PCIELINK_SWITCH_ERROR_INFO_VER1 MAKE_NVAPI_VERSION(NV_PCIELINK_SWITCH_ERROR_INFO_V1, 1)
#define NV_PCIELINK_SWITCH_ERROR_INFO_VER NV_PCIELINK_SWITCH_ERROR_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetPCIELinkSwitchErrorInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                     NV_PCIELINK_SWITCH_ERROR_INFO *pSwitchErrorInfo);
typedef enum {
  NV_INTERRUPT_LEGACY_IRQL_TYPE = 0,
  NV_INTERRUPT_MSI_TYPE = 1,
} NV_INTERRUPT_TYPE;
typedef struct _NV_INTERRUPT_INFO {
  NvU32 version;
  NV_INTERRUPT_TYPE type;
  NvU32 IRQ;
} NV_INTERRUPT_INFO_V1;
typedef NV_INTERRUPT_INFO_V1 NV_INTERRUPT_INFO;
#define NV_INTERRUPT_INFO_VER1 MAKE_NVAPI_VERSION(NV_INTERRUPT_INFO_V1, 1)
#define NV_INTERRUPT_INFO_VER NV_INTERRUPT_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetInterruptInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_INTERRUPT_INFO *interruptInfo);
NVAPI_INTERFACE NvAPI_GPU_GetIRQ(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pIRQ);
NVAPI_INTERFACE NvAPI_GPU_GetVbiosRevision(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBiosRevision);
NVAPI_INTERFACE NvAPI_GPU_GetVbiosOEMRevision(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBiosRevision);
typedef struct _NV_VBIOS_PROJECT_INFO_V1 {
  NvU32 version;
  NvAPI_ShortString projectId;
  NvAPI_ShortString partner;
  NvAPI_ShortString sessionId;
  NvU8 rsvd[64];
} NV_VBIOS_PROJECT_INFO_V1;
typedef NV_VBIOS_PROJECT_INFO_V1 NV_VBIOS_PROJECT_INFO;
#define NV_VBIOS_PROJECT_INFO_VER_1 MAKE_NVAPI_VERSION(NV_VBIOS_PROJECT_INFO_V1, 1)
#define NV_VBIOS_PROJECT_INFO_VER NV_VBIOS_PROJECT_INFO_VER_1
NVAPI_INTERFACE NvAPI_GPU_GetVbiosProjectInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_VBIOS_PROJECT_INFO *pProjectInfo);
typedef enum _HWBC_RES_TYPE {
  HWBC_UNKNOWN = 0,
  HWBC_NVIDIA_MCP55,
  HWBC_NVIDIA_BR03,
  HWBC_NVIDIA_C55,
  HWBC_NVIDIA_MCP65,
  HWBC_NVIDIA_BR04,
  HWBC_NVIDIA_C73,
  HWBC_NVIDIA_MCP79,
  HWBC_PLX_PEX8747
} HWBC_RES_TYPE;
typedef struct _NV_BRIDGE_FIRMWARE_INFO_V1 {
  NvU32 version;
  NvU32 bridgeId;
  NvU32 fwVersion;
  NvU8 oemVersion;
  NvU8 siliconRevision;
  NvU8 bridgeName;
} NV_BRIDGE_FIRMWARE_INFO_V1;
typedef struct _NV_BRIDGE_FIRMWARE_INFO_V2 {
  NvU32 version;
  NvU32 bridgeId;
  NvU32 fwVersion;
  NvU8 oemVersion;
  NvU8 siliconRevision;
  NvU8 bridgeName;
  NvU32 domain;
  NvU8 bus;
  NvU8 device;
  NvU8 func;
} NV_BRIDGE_FIRMWARE_INFO_V2;
typedef NV_BRIDGE_FIRMWARE_INFO_V2 NV_BRIDGE_FIRMWARE_INFO;
#define NV_BRIDGE_FIRMWARE_INFO_VER_1 MAKE_NVAPI_VERSION(NV_BRIDGE_FIRMWARE_INFO_V1, 1)
#define NV_BRIDGE_FIRMWARE_INFO_VER_2 MAKE_NVAPI_VERSION(NV_BRIDGE_FIRMWARE_INFO_V2, 2)
#define NV_BRIDGE_FIRMWARE_INFO_VER NV_BRIDGE_FIRMWARE_INFO_VER_2
NVAPI_INTERFACE NvAPI_GPU_GetBridgeVersionInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout_ecount_part_opt(*pBridgeCount, *pBridgeCount)
                                                   NV_BRIDGE_FIRMWARE_INFO *pBridgeFirmwareInfo,
                                               __inout NvU32 *pBridgeCount);
typedef struct {
  NvU32 version;
  NvAPI_ShortString vendorName;
  NvAPI_ShortString productName;
  NvAPI_ShortString productRevision;
} NV_VBIOS_OEM_INFO;
#define NV_VBIOS_OEM_INFO_VER MAKE_NVAPI_VERSION(NV_VBIOS_OEM_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetVbiosOemInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_VBIOS_OEM_INFO *pVbiosOemInfo);
NVAPI_INTERFACE NvAPI_GPU_GetVbiosMxmVersion(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBiosMxmVersion);
#define NV_VBIOS_IMAGE_SIZE (64 * 1024)
#define NV_VBIOS_IMAGE_SIZE_EX (1000 * 1024)
typedef struct _NV_VBIOS_IMAGE_V1 {
  NvU32 version;
  NvU32 bufferSize;
  NvU8 buffer[NV_VBIOS_IMAGE_SIZE];
} NV_VBIOS_IMAGE_V1;
typedef struct _NV_VBIOS_IMAGE_V2 {
  NvU32 version;
  NvU32 bufferSize;
  NvU8 *buffer;
} NV_VBIOS_IMAGE_V2;
typedef NV_VBIOS_IMAGE_V2 NV_VBIOS_IMAGE;
#define NV_VBIOS_IMAGE_VER1 MAKE_NVAPI_VERSION(NV_VBIOS_IMAGE_V1, 1)
#define NV_VBIOS_IMAGE_VER2 MAKE_NVAPI_VERSION(NV_VBIOS_IMAGE_V2, 2)
#define NV_VBIOS_IMAGE_VER NV_VBIOS_IMAGE_VER2
NVAPI_INTERFACE NvAPI_GPU_GetVbiosImage(NvPhysicalGpuHandle hPhysicalGpu, NV_VBIOS_IMAGE *pImage);
typedef enum {
  NV_VBIOS_SECURITY_INFO_TYPE_INVALID = 0x00,
  NV_VBIOS_SECURITY_INFO_TYPE_UNSIGNED = 0x01,
  NV_VBIOS_SECURITY_INFO_TYPE_NVIDIA_DEBUG = 0x02,
  NV_VBIOS_SECURITY_INFO_TYPE_NVIDIA_RELEASE = 0x03,
  NV_VBIOS_SECURITY_INFO_TYPE_NVIDIA_AE_DEBUG = 0x04,
  NV_VBIOS_SECURITY_INFO_TYPE_PARTNER_DEBUG = 0x05,
  NV_VBIOS_SECURITY_INFO_TYPE_PARTNER = 0x06,
} NV_VBIOS_SECURITY_INFO_TYPE;
typedef enum _NV_VBIOS_INFO_STATUS {
  NV_VBIOS_INFO_STATUS_OK = 0x00,
  NV_VBIOS_INFO_STATUS_EXPIRED = 0x01,
  NV_VBIOS_INFO_STATUS_INVALID = 0x02,
  NV_VBIOS_INFO_STATUS_DEVID_MISMATCH = 0x03,
  NV_VBIOS_INFO_STATUS_ERR_ROMPACK_OFFSET = 0x04,
  NV_VBIOS_INFO_STATUS_INSUFFICIENT_RESOURCES = 0x05,
  NV_VBIOS_INFO_STATUS_NBSI_INCOMPLETE = 0x06,
  NV_VBIOS_INFO_STATUS_INVALID_CERT = 0x07,
  NV_VBIOS_INFO_STATUS_INVALID_HASH = 0x08,
  NV_VBIOS_INFO_STATUS_VBIOS_HASH_NOT_STARTED = 0x09,
  NV_VBIOS_INFO_STATUS_SECURITY_BLOCK_NOT_FOUND = 0x0a,
  NV_VBIOS_INFO_STATUS_FIRST_X509_NOT_FOUND = 0x0b,
  NV_VBIOS_INFO_STATUS_INVALID_PEM_FORMAT = 0x0c,
  NV_VBIOS_INFO_STATUS_UNKNOWN_CERT_TYPE = 0x0d,
  NV_VBIOS_INFO_STATUS_DUPLICATE_VENDOR_CERT_FOUND = 0x0e,
  NV_VBIOS_INFO_STATUS_NO_PUBLIC_KEY = 0x0f,
  NV_VBIOS_INFO_STATUS_POINTER_PAST_SECURITY_BLK = 0x10,
  NV_VBIOS_INFO_STATUS_INVALID_HASH_HEADER_VERSION = 0x11,
  NV_VBIOS_INFO_STATUS_ERR_HASH_HEADER_FLAG_SET = 0x12,
  NV_VBIOS_INFO_STATUS_INVALID_SIGNATURE_HEADER_VER = 0x13,
  NV_VBIOS_INFO_STATUS_SIG_UNKNOWN_DIGEST_ALGO = 0x14,
  NV_VBIOS_INFO_STATUS_SIG_UNKNOWN_FORMAT = 0x15,
  NV_VBIOS_INFO_STATUS_SIG_INVALID_SIZE = 0x16,
  NV_VBIOS_INFO_STATUS_SIG_VERIFICATION_FAILURE = 0x17,
  NV_VBIOS_INFO_STATUS_PRESERV_TABLE_HASH_NOT_STARTED = 0x18,
  NV_VBIOS_INFO_STATUS_NO_EXPANSION_ROM = 0x19,
  NV_VBIOS_INFO_STATUS_UNKNOWN_HASH_TYPE = 0x1a,
  NV_VBIOS_INFO_STATUS_POINTER_PAST_HASH_BLK = 0x1b,
  NV_VBIOS_INFO_STATUS_CERT_VALIDITY_PERIOD_NOT_FOUND = 0x1c,
  NV_VBIOS_INFO_STATUS_CERT_OEM_NAME_NOT_FOUND = 0x1d,
  NV_VBIOS_INFO_STATUS_CERT_CHAIN_OF_TRUST_FAILURE = 0x1e,
  NV_VBIOS_INFO_STATUS_NO_BIT_HEADER = 0x1f,
  NV_VBIOS_INFO_STATUS_NO_VBIOS_FOUND = 0x20,
  NV_VBIOS_INFO_STATUS_INVALID_PARAMS = 0x21,
  NV_VBIOS_INFO_STATUS_NOT_SILICON_OR_EMULATION = 0x22,
  NV_VBIOS_INFO_STATUS_NV_CONFIG_PCI_NV_20_READ_ERROR = 0x23,
  NV_VBIOS_INFO_STATUS_INVALID_PCI_ROM_SIG = 0x24,
  NV_VBIOS_INFO_STATUS_INVALID_PCI_DATA_SIG = 0x25,
  NV_VBIOS_INFO_STATUS_INVALID_PCI_HEADER = 0x26,
  NV_VBIOS_INFO_STATUS_INVALID_CHECKSUM = 0x27,
  NV_VBIOS_INFO_STATUS_NO_NBSI_BLOCK = 0x28,
  NV_VBIOS_INFO_STATUS_CANNOT_MAP_TO_KERNEL_SPACE = 0x29,
  NV_VBIOS_INFO_STATUS_IMAGE_EXCEEDS_PCIR_SIZE = 0x2a,
  NV_VBIOS_INFO_STATUS_PCIR_VENDOR_ID_MISMATCH = 0x2b,
  NV_VBIOS_INFO_STATUS_PCIR_LEN_EXCEEDS_IMAGE = 0x2c,
  NV_VBIOS_INFO_STATUS_IMAGE_SIZE_OUT_OF_BOUNDS = 0x2d,
  NV_VBIOS_INFO_STATUS_REGISTRY_NOT_FOUND = 0x2e,
  NV_VBIOS_INFO_STATUS_VOLATILE_REGISTRY_NOT_FOUND = 0x2f,
  NV_VBIOS_INFO_STATUS_GPUMGR_OBJECT_NOT_FOUND = 0x30,
  NV_VBIOS_INFO_STATUS_GPUMGR_BUFFER_TOO_SMALL = 0x31,
  NV_VBIOS_INFO_STATUS_INSTANCE_NOT_FOUND = 0x32,
  NV_VBIOS_INFO_STATUS_IMAGE_VERIFICATION_FAILURE = 0x33,
  NV_VBIOS_INFO_STATUS_UNSET = 0x34
} NV_VBIOS_INFO_STATUS;
typedef struct {
  NvU32 version;
  NvU8 vbiosType;
  NvU8 status;
  NvU8 expirationDay;
  NvU8 expirationMonth;
  NvU16 expirationYear;
  NvU8 bShowInCpl;
  NvU8 bShowInOverlay;
} NV_VBIOS_SECURITY_INFO_V1;
typedef struct {
  NvU32 version;
  NvU8 vbiosType;
  NvU8 status;
  NvU8 expirationDay;
  NvU8 expirationMonth;
  NvU16 expirationYear;
  NvU8 bShowInCpl;
  NvU8 bShowInOverlay;
  NvU8 creationDay;
  NvU8 creationMonth;
  NvU16 creationYear;
  NvAPI_String OEMName;
} NV_VBIOS_SECURITY_INFO_V2;
typedef struct {
  NvU32 version;
  NvU8 vbiosType;
  NvU8 status;
  NvU8 expirationDay;
  NvU8 expirationMonth;
  NvU16 expirationYear;
  NvU8 creationDay;
  NvU8 creationMonth;
  NvU16 creationYear;
  NvAPI_String OEMName;
  NvU16 vbiosDevId;
  NvU16 calculatedDevId;
} NV_VBIOS_SECURITY_INFO_V3;
typedef NV_VBIOS_SECURITY_INFO_V3 NV_VBIOS_SECURITY_INFO;
#define NV_VBIOS_SECURITY_INFO_VER_1 MAKE_NVAPI_VERSION(NV_VBIOS_SECURITY_INFO_V1, 1)
#define NV_VBIOS_SECURITY_INFO_VER_2 MAKE_NVAPI_VERSION(NV_VBIOS_SECURITY_INFO_V2, 2)
#define NV_VBIOS_SECURITY_INFO_VER_3 MAKE_NVAPI_VERSION(NV_VBIOS_SECURITY_INFO_V3, 3)
#define NV_VBIOS_SECURITY_INFO_VER NV_VBIOS_SECURITY_INFO_VER_3
NVAPI_INTERFACE NvAPI_GPU_GetVbiosSecurityInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_VBIOS_SECURITY_INFO *pVbiosSecurityInfo);
typedef struct {
  NvU32 version;
  NvU64 vbiosPostTime;
} NV_VBIOS_POST_DATA_V1;
typedef NV_VBIOS_POST_DATA_V1 NV_VBIOS_POST_DATA;
#define NV_VBIOS_POST_DATA_VER1 MAKE_NVAPI_VERSION(NV_VBIOS_POST_DATA_V1, 1)
#define NV_VBIOS_POST_DATA_VER NV_VBIOS_POST_DATA_VER1
NVAPI_INTERFACE NvAPI_GPU_GetPostTime(NvPhysicalGpuHandle hPhysicalGpu, NV_VBIOS_POST_DATA *pVbiosPostData);
#define NV_MXM_BLOCK_SIZE (64 * 1024)
typedef struct {
  NvU32 version;
  NvU32 bufferSize;
  NvU8 buffer[NV_MXM_BLOCK_SIZE];
} NV_MXM_BLOCK;
#define NV_MXM_BLOCK_VER MAKE_NVAPI_VERSION(NV_MXM_BLOCK, 1)
NVAPI_INTERFACE NvAPI_GPU_GetMXMBlock(NvPhysicalGpuHandle hPhysicalGpu, NV_MXM_BLOCK *pMXMBlock);
NVAPI_INTERFACE NvAPI_GPU_GetVbiosVersionString(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_ShortString szBiosRevision);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_GPU_GetAGPAperture(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pSize);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_GPU_GetCurrentAGPRate(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pRate);
NVAPI_INTERFACE NvAPI_GPU_GetCurrentPCIEDownstreamWidth(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pWidth);
NVAPI_INTERFACE NvAPI_GPU_SetCurrentPCIEWidth(NvPhysicalGpuHandle hPhysicalGpu, NvU32 newWidth);
NVAPI_INTERFACE NvAPI_GPU_SetCurrentPCIESpeed(NvPhysicalGpuHandle hPhysicalGpu, NvU32 newSpeed);
typedef enum {
  NV_PCIE_ASPM_STATE_DISABLED = 0,
  NV_PCIE_ASPM_STATE_L0S = 0x1,
  NV_PCIE_ASPM_STATE_L1 = 0x2,
  NV_PCIE_ASPM_STATE_L0S_L1 = 0x3,
} NV_PCIE_ASPM_STATE;
typedef enum {
  NV_PCIE_GENERATION_GEN_1 = 1,
  NV_PCIE_GENERATION_GEN_2 = 2,
  NV_PCIE_GENERATION_GEN_3 = 3,
  NV_PCIE_GENERATION_GEN_4 = 4,
  NV_PCIE_GENERATION_GEN_NONE = -1,
} NV_PCIE_GENERATION;
typedef struct {
  NvU32 maxSpeed;
  NvU32 maxWidth;
  NvU32 supportedStates;
  NvU32 currentSpeed;
  NvU32 currentWidth;
  NvU32 currentState;
} NV_PCIE_LINK_INFO_V1;
typedef struct {
  NvU32 version;
  NV_PCIE_LINK_INFO_V1 root;
  NV_PCIE_LINK_INFO_V1 gpu;
  NV_PCIE_LINK_INFO_V1 upstream;
  NV_PCIE_LINK_INFO_V1 downstream;
} NV_PCIE_INFO_V1;
typedef struct {
  NvU32 maxSpeed;
  NV_PCIE_GENERATION maxGeneration;
  NvU32 maxWidth;
  NV_PCIE_ASPM_STATE supportedStates;
  NvU32 currentSpeed;
  NV_PCIE_GENERATION currentGeneration;
  NvU32 currentWidth;
  NV_PCIE_ASPM_STATE currentState;
} NV_PCIE_LINK_INFO_V2;
typedef struct {
  NvU32 version;
  NV_PCIE_LINK_INFO_V2 root;
  NV_PCIE_LINK_INFO_V2 gpu;
  NV_PCIE_LINK_INFO_V2 upstream;
  NV_PCIE_LINK_INFO_V2 downstream;
  NV_PCIE_LINK_INFO_V2 board;
} NV_PCIE_INFO_V2;
typedef struct _NV_PCIE_ROOT_PORT_SURPRISE_REMOVAL_CAPABILITY_INFO_V1 {
  NvU32 vendorId;
  NvU32 deviceId;
  NvU32 isSurpriseRemovalSupported : 1;
  NvU32 reserved : 31;
} NV_PCIE_ROOT_PORT_SURPRISE_REMOVAL_CAPABILITY_INFO_V1;
typedef struct _NV_PCIE_INFO_V3 {
  NvU32 version;
  NV_PCIE_LINK_INFO_V2 root;
  NV_PCIE_LINK_INFO_V2 gpu;
  NV_PCIE_LINK_INFO_V2 upstream;
  NV_PCIE_LINK_INFO_V2 downstream;
  NV_PCIE_LINK_INFO_V2 board;
  NV_PCIE_ROOT_PORT_SURPRISE_REMOVAL_CAPABILITY_INFO_V1 rootPortSurpriseRemovalCaps;
} NV_PCIE_INFO_V3;
typedef enum _NV_KNOWN_SURPRISE_REMOVAL_BUS_TYPE {
  NV_KNOWN_SURPRISE_REMOVAL_BUS_TYPE_UNKNOWN = 0,
  NV_KNOWN_SURPRISE_REMOVAL_BUS_TYPE_TB2 = 1,
  NV_KNOWN_SURPRISE_REMOVAL_BUS_TYPE_TB3 = 2,
  NV_KNOWN_SURPRISE_REMOVAL_BUS_TYPE_OEM_SPECIFIC = 3
} NV_KNOWN_SURPRISE_REMOVAL_BUS_TYPE;
typedef struct _NV_PCIE_ROOT_PORT_SURPRISE_REMOVAL_CAPABILITY_INFO_V2 {
  NvU32 vendorId;
  NvU32 deviceId;
  NvU32 isSurpriseRemovalSupported : 1;
  NvU32 reserved : 31;
  NV_KNOWN_SURPRISE_REMOVAL_BUS_TYPE removalBusType;
} NV_PCIE_ROOT_PORT_SURPRISE_REMOVAL_CAPABILITY_INFO_V2;
typedef struct _NV_PCIE_INFO_V4 {
  NvU32 version;
  NV_PCIE_LINK_INFO_V2 root;
  NV_PCIE_LINK_INFO_V2 gpu;
  NV_PCIE_LINK_INFO_V2 upstream;
  NV_PCIE_LINK_INFO_V2 downstream;
  NV_PCIE_LINK_INFO_V2 board;
  NV_PCIE_ROOT_PORT_SURPRISE_REMOVAL_CAPABILITY_INFO_V2 rootPortSurpriseRemovalCaps;
} NV_PCIE_INFO_V4;
typedef NV_PCIE_LINK_INFO_V2 NV_PCIE_LINK_INFO;
typedef NV_PCIE_INFO_V4 NV_PCIE_INFO;
#define NV_PCIE_INFO_VER_1 MAKE_NVAPI_VERSION(NV_PCIE_INFO_V1, 1)
#define NV_PCIE_INFO_VER_2 MAKE_NVAPI_VERSION(NV_PCIE_INFO_V2, 2)
#define NV_PCIE_INFO_VER_3 MAKE_NVAPI_VERSION(NV_PCIE_INFO_V3, 3)
#define NV_PCIE_INFO_VER_4 MAKE_NVAPI_VERSION(NV_PCIE_INFO_V4, 4)
#define NV_PCIE_INFO_VER NV_PCIE_INFO_VER_4
NVAPI_INTERFACE NvAPI_GPU_GetPCIEInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PCIE_INFO *pInfo);
typedef struct _NV_BUS_GET_BFD_INFO_PARAMS {
  NvBool valid;
  NvU16 deviceID;
  NvU16 vendorID;
  NvU32 domain;
  NvU16 bus;
  NvU16 device;
  NvU8 function;
} NV_BUS_GET_BFD_INFO_PARAMS;
typedef struct _NV_BUS_GET_BFD_INFO_V1 {
  NvU32 version;
  NV_BUS_GET_BFD_INFO_PARAMS params[32];
} NV_BUS_GET_BFD_INFO_V1;
typedef NV_BUS_GET_BFD_INFO_V1 NV_BUS_GET_BFD_INFO;
#define NV_BUS_GET_BFD_INFO_VER_1 MAKE_NVAPI_VERSION(NV_BUS_GET_BFD_INFO_V1, 1)
#define NV_BUS_GET_BFD_INFO_VER NV_BUS_GET_BFD_INFO_VER_1
NVAPI_INTERFACE NvAPI_GPU_GetBusBFD(__in NvPhysicalGpuHandle hPhysicalGpuHandle, __inout NV_BUS_GET_BFD_INFO *info);
typedef enum {
  NV_PCIE_GPU_CYA_ASPM_DISABLED = 0x0,
  NV_PCIE_GPU_CYA_ASPM_L0S = 0x1,
  NV_PCIE_GPU_CYA_ASPM_L1 = 0x2,
  NV_PCIE_GPU_CYA_ASPM_L0S_L1 = 0x3
} NV_PCIE_GPU_CYA_ASPM;
typedef enum {
  NV_PCIE_GPU_CYA_ASPM_INFO_VALID_NO = 0x0,
  NV_PCIE_GPU_CYA_ASPM_INFO_VALID_YES = 0x1,
} NV_PCIE_GPU_CYA_ASPM_INFO_VALID;
typedef struct {
  NvU32 version;
  NvU32 bIsCyaAspmInfoValid;
  NV_PCIE_GPU_CYA_ASPM cyaAspmState;
} NV_PCIE_GPU_CYA_ASPM_INFO;
#define NV_PCIE_GPU_CYA_ASPM_INFO_VER MAKE_NVAPI_VERSION(NV_PCIE_GPU_CYA_ASPM_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetCyaAspmInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PCIE_GPU_CYA_ASPM_INFO *pInfo);
typedef enum {
  NV_PCIE_LINK_ERROR_CORR_ERROR = 0x00000001,
  NV_PCIE_LINK_ERROR_NON_FATAL_ERROR = 0x00000002,
  NV_PCIE_LINK_ERROR_FATAL_ERROR = 0x00000004,
  NV_PCIE_LINK_ERROR_UNSUPP_REQUEST = 0x00000008,
} NV_PCIE_LINK_ERROR;
typedef enum {
  NV_PCIE_LINK_ERROR_FLAG_MASK_KNOWN_CORR_ERROR_ON_RECOVERY = 0x00000001,
} NV_PCIE_LINK_ERROR_FLAG;
typedef struct {
  NvU32 version;
  NvU32 root;
  NvU32 gpu;
} NV_PCIE_LINK_ERROR_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 root;
  NvU32 gpu;
  NvU32 flags;
} NV_PCIE_LINK_ERROR_INFO_V2;
typedef NV_PCIE_LINK_ERROR_INFO_V2 NV_PCIE_LINK_ERROR_INFO;
#define NV_PCIE_LINK_ERROR_INFO_VER_1 MAKE_NVAPI_VERSION(NV_PCIE_LINK_ERROR_INFO_V1, 1)
#define NV_PCIE_LINK_ERROR_INFO_VER_2 MAKE_NVAPI_VERSION(NV_PCIE_LINK_ERROR_INFO_V2, 2)
#define NV_PCIE_LINK_ERROR_INFO_VER NV_PCIE_LINK_ERROR_INFO_VER_2
NVAPI_INTERFACE NvAPI_GPU_ClearPCIELinkErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_PCIE_LINK_ERROR_INFO *pInfo);
typedef enum {
  NV_PCIE_LINK_AER_UNCORR_TRAINING_ERR = 0x00000001,
  NV_PCIE_LINK_AER_UNCORR_DLINK_PROTO_ERR = 0x00000002,
  NV_PCIE_LINK_AER_UNCORR_POISONED_TLP = 0x00000004,
  NV_PCIE_LINK_AER_UNCORR_FC_PROTO_ERR = 0x00000008,
  NV_PCIE_LINK_AER_UNCORR_CPL_TIMEOUT = 0x00000010,
  NV_PCIE_LINK_AER_UNCORR_CPL_ABORT = 0x00000020,
  NV_PCIE_LINK_AER_UNCORR_UNEXP_CPL = 0x00000040,
  NV_PCIE_LINK_AER_UNCORR_RCVR_OVERFLOW = 0x00000080,
  NV_PCIE_LINK_AER_UNCORR_MALFORMED_TLP = 0x00000100,
  NV_PCIE_LINK_AER_UNCORR_ECRC_ERROR = 0x00000200,
  NV_PCIE_LINK_AER_UNCORR_UNSUPPORTED_REQ = 0x00000400,
  NV_PCIE_LINK_AER_CORR_RCV_ERR = 0x00010000,
  NV_PCIE_LINK_AER_CORR_BAD_TLP = 0x00020000,
  NV_PCIE_LINK_AER_CORR_BAD_DLLP = 0x00040000,
  NV_PCIE_LINK_AER_CORR_RPLY_ROLLOVER = 0x00080000,
  NV_PCIE_LINK_AER_CORR_RPLY_TIMEOUT = 0x00100000,
  NV_PCIE_LINK_AER_CORR_ADVISORY_NONFATAL = 0x00200000,
} NV_PCIE_LINK_AER;
NVAPI_INTERFACE NvAPI_GPU_ClearPCIELinkAERInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pInfo);
typedef struct {
  NvU32 version;
  NvU32 driveStrengthRiseCount;
  NvU32 driveStrengthFallCount;
  NvU32 driveStrengthTermCount;
  NvU32 slewStrengthRiseCount;
  NvU32 slewStrengthFallCount;
} NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO;
#define NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO_VER                                                          \
  MAKE_NVAPI_VERSION(NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetFrameBufferCalibrationLockFailures(
    NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_FRAMEBUFFER_CALIBRATION_LOCK_FAILURES_INFO *pParams);
typedef enum _NV_DISPLAY_UNDERFLOW_MODE {
  NV_DISPLAY_UNDERFLOW_MODE_DISABLED,
  NV_DISPLAY_UNDERFLOW_MODE_REPEAT,
  NV_DISPLAY_UNDERFLOW_MODE_STICKY,
} NV_DISPLAY_UNDERFLOW_MODE;
NVAPI_INTERFACE NvAPI_GPU_SetDisplayUnderflowMode(NvDisplayHandle hNvDisplay, NV_DISPLAY_UNDERFLOW_MODE mode);
NVAPI_INTERFACE NvAPI_GPU_GetDisplayUnderflowStatus(NvDisplayHandle hNvDisplay, NvU32 clearUnderflow,
                                                    NvU32 *pUnderflowDetected);
NVAPI_INTERFACE NvAPI_GPU_GetPhysicalFrameBufferSize(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pSize);
NVAPI_INTERFACE NvAPI_GPU_GetVirtualFrameBufferSize(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pSize);
#define NV_GPU_MAX_BAR_COUNT 8
typedef struct {
  NvU32 version;
  NvU8 count;
  struct {
    NvU32 flags;
    NvU32 barSize;
    NvU64 barOffset;
  } barInfo[NV_GPU_MAX_BAR_COUNT];
} NV_GPU_BAR_INFO_V1;
typedef struct {
  NvU32 version;
  NvU8 count;
  struct {
    NvU32 flags;
    NvU32 barSize;
    NvU64 barOffset;
    NvU64 barSizeBytes;
    NvU32 reserved[4];
  } barInfo[NV_GPU_MAX_BAR_COUNT];
} NV_GPU_BAR_INFO_V2;
typedef NV_GPU_BAR_INFO_V2 NV_GPU_BAR_INFO;
#define NV_GPU_BAR_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_BAR_INFO_V1, 1)
#define NV_GPU_BAR_INFO_VER_2 MAKE_NVAPI_VERSION(NV_GPU_BAR_INFO_V2, 2)
#define NV_GPU_BAR_INFO_VER NV_GPU_BAR_INFO_VER_2
NVAPI_INTERFACE NvAPI_GPU_GetBarInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_BAR_INFO *pInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 460.") NVAPI_INTERFACE
    NvAPI_GPU_GetQuadroStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pStatus);
NVAPI_INTERFACE NvAPI_GPU_GetPSFloorSweepStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pReturn);
NVAPI_INTERFACE NvAPI_GPU_GetVSFloorSweepStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pReturn);
NVAPI_INTERFACE NvAPI_GPU_GetSerialNumber(NvPhysicalGpuHandle hPhysicalGpu, NvU64 *pSerialNum);
#define NVAPI_GPU_MAX_PRODUCT_PART_NUMBER_LENGTH 0x00000014
typedef struct _NV_BOARD_INFO_V2 {
  NvU32 version;
  NvU8 BoardNum[16];
  NvU8 productPartNumber[NVAPI_GPU_MAX_PRODUCT_PART_NUMBER_LENGTH];
  NvU8 boardRevision[3];
  NvU8 boardType;
} NV_BOARD_INFO_V2;
#define NVAPI_GPU_MAX_OEM_INFO_LENGTH 0x000001F8
typedef struct _NV_BOARD_INFO_V3 {
  NvU32 version;
  NvU8 BoardNum[16];
  NvU8 productPartNumber[NVAPI_GPU_MAX_PRODUCT_PART_NUMBER_LENGTH];
  NvU8 boardRevision[3];
  NvU8 boardType;
  NvU8 oemInfo[NVAPI_GPU_MAX_OEM_INFO_LENGTH];
} NV_BOARD_INFO_V3;
#define NV_BOARD_INFO_VER2 MAKE_NVAPI_VERSION(NV_BOARD_INFO_V2, 2)
#define NV_BOARD_INFO_VER3 MAKE_NVAPI_VERSION(NV_BOARD_INFO_V3, 3)
typedef NV_BOARD_INFO_V3 NV_BOARD_INFO;
#define NV_BOARD_INFO_VER NV_BOARD_INFO_VER3
typedef struct _NV_BOARD_INFO {
  NvU32 version;
  NvU8 BoardNum[16];
} NV_BOARD_INFO_V1;
#define NV_BOARD_INFO_VER1 MAKE_NVAPI_VERSION(NV_BOARD_INFO_V1, 1)
#ifndef NV_BOARD_INFO_VER
typedef NV_BOARD_INFO_V1 NV_BOARD_INFO;
#define NV_BOARD_INFO_VER NV_BOARD_INFO_VER1
#endif
NVAPI_INTERFACE NvAPI_GPU_GetBoardInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_BOARD_INFO *pBoardInfo);
typedef struct _NV_MANUFACTURING_INFO_V1 {
  NvU32 version;
  NvU64 ecid[2];
} NV_MANUFACTURING_INFO_V1;
typedef NV_MANUFACTURING_INFO_V1 NV_MANUFACTURING_INFO;
#define NV_MANUFACTURING_INFO_VER1 MAKE_NVAPI_VERSION(NV_MANUFACTURING_INFO_V1, 1)
#define NV_MANUFACTURING_INFO_VER NV_MANUFACTURING_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ManufacturingInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_MANUFACTURING_INFO *info);
typedef enum {
  NV_GPU_RAM_TYPE_UNKNOWN = 0,
  NV_GPU_RAM_TYPE_SDRAM = 1,
  NV_GPU_RAM_TYPE_DDR1 = 2,
  NV_GPU_RAM_TYPE_DDR2 = 3,
  NV_GPU_RAM_TYPE_GDDR2 = 4,
  NV_GPU_RAM_TYPE_GDDR3 = 5,
  NV_GPU_RAM_TYPE_GDDR4 = 6,
  NV_GPU_RAM_TYPE_DDR3 = 7,
  NV_GPU_RAM_TYPE_GDDR5 = 8,
  NV_GPU_RAM_TYPE_LPDDR2 = 9,
  NV_GPU_RAM_TYPE_GDDR5X = 10,
  NV_GPU_RAM_TYPE_HBM1 = 11,
  NV_GPU_RAM_TYPE_HBM2 = 12,
  NV_GPU_RAM_TYPE_SDDR4 = 13,
  NV_GPU_RAM_TYPE_GDDR6 = 14,
  NV_GPU_RAM_TYPE_GDDR6X = 15,
} NV_GPU_RAM_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetRamType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_RAM_TYPE *pRamType);
typedef enum {
  NV_GPU_RAM_VENDOR_ID_UNKNOWN = 0,
  NV_GPU_RAM_VENDOR_ID_SAMSUNG = 1,
  NV_GPU_RAM_VENDOR_ID_QIMONDA = 2,
  NV_GPU_RAM_VENDOR_ID_ELPIDA = 3,
  NV_GPU_RAM_VENDOR_ID_ETRON = 4,
  NV_GPU_RAM_VENDOR_ID_NANYA = 5,
  NV_GPU_RAM_VENDOR_ID_HYNIX = 6,
  NV_GPU_RAM_VENDOR_ID_MOSEL = 7,
  NV_GPU_RAM_VENDOR_ID_WINBOND = 8,
  NV_GPU_RAM_VENDOR_ID_ESMT = 9,
  NV_GPU_RAM_VENDOR_ID_MICRON = 10
} NV_GPU_RAM_VENDOR_ID;
NVAPI_INTERFACE NvAPI_GPU_GetRamVendorID(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_RAM_VENDOR_ID *pVendorID);
NVAPI_INTERFACE NvAPI_GPU_GetRamConfigStrap(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pRamConfigStrap);
NVAPI_INTERFACE NvAPI_GPU_GetRamBusWidth(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusWidth);
typedef enum _NV_GPU_FB_LOCATION {
  NV_GPU_FB_RAM_LOCATION_UNKNOWN = 0,
  NV_GPU_FB_RAM_LOCATION_GPU_DEDICATED = 1,
  NV_GPU_FB_RAM_LOCATION_SYS_SHARED = 2,
  NV_GPU_FB_RAM_LOCATION_SYS_DEDICATED = 3,
} NV_GPU_FB_LOCATION;
NVAPI_INTERFACE NvAPI_GPU_GetFBWidthAndLocation(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBusWidth,
                                                NV_GPU_FB_LOCATION *pFBLocation);
NVAPI_INTERFACE NvAPI_GPU_GetRamBankCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pBankCount);
typedef struct {
  NvU32 version;
  NvU32 architecture;
  NvU32 implementation;
  NvU32 revision;
} NV_GPU_ARCH_INFO_V1;
typedef enum _NV_GPU_ARCHITECTURE_ID {
  NV_GPU_ARCHITECTURE_T2X = 0xE0000020,
  NV_GPU_ARCHITECTURE_T3X = 0xE0000030,
  NV_GPU_ARCHITECTURE_T4X = 0xE0000040,
  NV_GPU_ARCHITECTURE_T12X = 0xE0000040,
  NV_GPU_ARCHITECTURE_NV40 = 0x00000040,
  NV_GPU_ARCHITECTURE_NV50 = 0x00000050,
  NV_GPU_ARCHITECTURE_G78 = 0x00000060,
  NV_GPU_ARCHITECTURE_G80 = 0x00000080,
  NV_GPU_ARCHITECTURE_G90 = 0x00000090,
  NV_GPU_ARCHITECTURE_GT200 = 0x000000A0,
  NV_GPU_ARCHITECTURE_GF100 = 0x000000C0,
  NV_GPU_ARCHITECTURE_GF110 = 0x000000D0,
  NV_GPU_ARCHITECTURE_GK100 = 0x000000E0,
  NV_GPU_ARCHITECTURE_GK110 = 0x000000F0,
  NV_GPU_ARCHITECTURE_GK200 = 0x00000100,
  NV_GPU_ARCHITECTURE_GM000 = 0x00000110,
  NV_GPU_ARCHITECTURE_GM200 = 0x00000120,
  NV_GPU_ARCHITECTURE_GP100 = 0x00000130,
  NV_GPU_ARCHITECTURE_GV100 = 0x00000140,
  NV_GPU_ARCHITECTURE_GV110 = 0x00000150,
  NV_GPU_ARCHITECTURE_TU100 = 0x00000160,
  NV_GPU_ARCHITECTURE_GA100 = 0x00000170,
} NV_GPU_ARCHITECTURE_ID;
typedef enum _NV_GPU_ARCH_IMPLEMENTATION_ID {
  NV_GPU_ARCH_IMPLEMENTATION_T20 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_T30 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_T35 = 0x00000005,
  NV_GPU_ARCH_IMPLEMENTATION_T40 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_T124 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_NV40 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_NV41 = 0x00000001,
  NV_GPU_ARCH_IMPLEMENTATION_NV42 = 0x00000002,
  NV_GPU_ARCH_IMPLEMENTATION_NV43 = 0x00000003,
  NV_GPU_ARCH_IMPLEMENTATION_NV44 = 0x00000004,
  NV_GPU_ARCH_IMPLEMENTATION_NV44A = 0x0000000A,
  NV_GPU_ARCH_IMPLEMENTATION_NV46 = 0x00000006,
  NV_GPU_ARCH_IMPLEMENTATION_NV47 = 0x00000007,
  NV_GPU_ARCH_IMPLEMENTATION_NV49 = 0x00000009,
  NV_GPU_ARCH_IMPLEMENTATION_NV4B = 0x0000000B,
  NV_GPU_ARCH_IMPLEMENTATION_NV4C = 0x0000000C,
  NV_GPU_ARCH_IMPLEMENTATION_NV4E = 0x0000000E,
  NV_GPU_ARCH_IMPLEMENTATION_NV50 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_NV63 = 0x00000003,
  NV_GPU_ARCH_IMPLEMENTATION_NV67 = 0x00000007,
  NV_GPU_ARCH_IMPLEMENTATION_G84 = 0x00000004,
  NV_GPU_ARCH_IMPLEMENTATION_G86 = 0x00000006,
  NV_GPU_ARCH_IMPLEMENTATION_G92 = 0x00000002,
  NV_GPU_ARCH_IMPLEMENTATION_G94 = 0x00000004,
  NV_GPU_ARCH_IMPLEMENTATION_G96 = 0x00000006,
  NV_GPU_ARCH_IMPLEMENTATION_G98 = 0x00000008,
  NV_GPU_ARCH_IMPLEMENTATION_GT200 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_GT212 = 0x00000002,
  NV_GPU_ARCH_IMPLEMENTATION_GT214 = 0x00000004,
  NV_GPU_ARCH_IMPLEMENTATION_GT215 = 0x00000003,
  NV_GPU_ARCH_IMPLEMENTATION_GT216 = 0x00000005,
  NV_GPU_ARCH_IMPLEMENTATION_GT218 = 0x00000008,
  NV_GPU_ARCH_IMPLEMENTATION_MCP77 = 0x0000000A,
  NV_GPU_ARCH_IMPLEMENTATION_GT21C = 0x0000000B,
  NV_GPU_ARCH_IMPLEMENTATION_MCP79 = 0x0000000C,
  NV_GPU_ARCH_IMPLEMENTATION_GT21A = 0x0000000D,
  NV_GPU_ARCH_IMPLEMENTATION_MCP89 = 0x0000000F,
  NV_GPU_ARCH_IMPLEMENTATION_GF100 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_GF100B = 0x00000008,
  NV_GPU_ARCH_IMPLEMENTATION_GF104 = 0x00000004,
  NV_GPU_ARCH_IMPLEMENTATION_GF104B = 0x0000000E,
  NV_GPU_ARCH_IMPLEMENTATION_GF106 = 0x00000003,
  NV_GPU_ARCH_IMPLEMENTATION_GF106B = 0x0000000F,
  NV_GPU_ARCH_IMPLEMENTATION_GF108 = 0x00000001,
  NV_GPU_ARCH_IMPLEMENTATION_GF110 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_GF112 = 0x00000002,
  NV_GPU_ARCH_IMPLEMENTATION_GF116 = 0x00000006,
  NV_GPU_ARCH_IMPLEMENTATION_GF117 = 0x00000007,
  NV_GPU_ARCH_IMPLEMENTATION_GF118 = 0x00000008,
  NV_GPU_ARCH_IMPLEMENTATION_GF119 = 0x00000009,
  NV_GPU_ARCH_IMPLEMENTATION_GK100 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_GK104 = 0x00000004,
  NV_GPU_ARCH_IMPLEMENTATION_GK106 = 0x00000006,
  NV_GPU_ARCH_IMPLEMENTATION_GK107 = 0x00000007,
  NV_GPU_ARCH_IMPLEMENTATION_GK20A = 0x0000000A,
  NV_GPU_ARCH_IMPLEMENTATION_GK110 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_GK208 = 0x00000008,
  NV_GPU_ARCH_IMPLEMENTATION_GM000 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_GM204 = 0x00000004,
  NV_GPU_ARCH_IMPLEMENTATION_GM206 = 0x00000006,
  NV_GPU_ARCH_IMPLEMENTATION_GM20B = 0x0000000B,
  NV_GPU_ARCH_IMPLEMENTATION_GM20C = 0x0000000C,
  NV_GPU_ARCH_IMPLEMENTATION_GM20D = 0x0000000D,
  NV_GPU_ARCH_IMPLEMENTATION_GP100 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_GP000 = 0x00000001,
  NV_GPU_ARCH_IMPLEMENTATION_GP102 = 0x00000002,
  NV_GPU_ARCH_IMPLEMENTATION_GP104 = 0x00000004,
  NV_GPU_ARCH_IMPLEMENTATION_GP106 = 0x00000006,
  NV_GPU_ARCH_IMPLEMENTATION_GP107 = 0x00000007,
  NV_GPU_ARCH_IMPLEMENTATION_GP108 = 0x00000008,
  NV_GPU_ARCH_IMPLEMENTATION_GP10B = 0x0000000B,
  NV_GPU_ARCH_IMPLEMENTATION_GP10D = 0x0000000D,
  NV_GPU_ARCH_IMPLEMENTATION_GP10E = 0x0000000E,
  NV_GPU_ARCH_IMPLEMENTATION_GV100 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_GV000 = 0x00000001,
  NV_GPU_ARCH_IMPLEMENTATION_GV10B = 0x0000000B,
  NV_GPU_ARCH_IMPLEMENTATION_GV11B = 0x0000000B,
  NV_GPU_ARCH_IMPLEMENTATION_TU100 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_TU101 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_TU102 = 0x00000002,
  NV_GPU_ARCH_IMPLEMENTATION_TU104 = 0x00000004,
  NV_GPU_ARCH_IMPLEMENTATION_TU106 = 0x00000006,
  NV_GPU_ARCH_IMPLEMENTATION_TU116 = 0x00000008,
  NV_GPU_ARCH_IMPLEMENTATION_TU117 = 0x00000007,
  NV_GPU_ARCH_IMPLEMENTATION_TU000 = 0x00000001,
  NV_GPU_ARCH_IMPLEMENTATION_GA100 = 0x00000000,
  NV_GPU_ARCH_IMPLEMENTATION_GA102 = 0x00000002,
  NV_GPU_ARCH_IMPLEMENTATION_GA104 = 0x00000004,
} NV_GPU_ARCH_IMPLEMENTATION_ID;
typedef enum _NV_GPU_CHIP_REVISION {
  NV_GPU_CHIP_REV_EMULATION_QT = 0x00000000,
  NV_GPU_CHIP_REV_EMULATION_FPGA = 0x00000001,
  NV_GPU_CHIP_REV_A01 = 0x00000011,
  NV_GPU_CHIP_REV_A02 = 0x00000012,
  NV_GPU_CHIP_REV_A03 = 0x00000013,
  NV_GPU_CHIP_REV_UNKNOWN = 0xffffffff,
} NV_GPU_CHIP_REVISION;
typedef struct {
  NvU32 version;
  union {
    NvU32 architecture;
    NV_GPU_ARCHITECTURE_ID architecture_id;
  };
  union {
    NvU32 implementation;
    NV_GPU_ARCH_IMPLEMENTATION_ID implementation_id;
  };
  union {
    NvU32 revision;
    NV_GPU_CHIP_REVISION revision_id;
  };
} NV_GPU_ARCH_INFO_V2;
typedef NV_GPU_ARCH_INFO_V2 NV_GPU_ARCH_INFO;
#define NV_GPU_ARCH_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_ARCH_INFO_V1, 1)
#define NV_GPU_ARCH_INFO_VER_2 MAKE_NVAPI_VERSION(NV_GPU_ARCH_INFO_V2, 2)
#define NV_GPU_ARCH_INFO_VER NV_GPU_ARCH_INFO_VER_2
NVAPI_INTERFACE NvAPI_GPU_GetArchInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_ARCH_INFO *pGpuArchInfo);
NVAPI_INTERFACE NvAPI_GPU_GetExtendedMinorRevision(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pValue);
typedef enum _NV_GPU_SAMPLE_TYPE {
  NV_GPU_SAMPLE_NONE = 0,
  NV_GPU_SAMPLE_ES = 1,
  NV_GPU_SAMPLE_QS = 2,
  NV_GPU_SAMPLE_PS = 3,
  NV_GPU_SAMPLE_QS_PS_PROD = 4,
} NV_GPU_SAMPLE_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetSampleType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_SAMPLE_TYPE *pValue);
typedef enum _NV_GPU_HW_QUAL_TYPE {
  NV_GPU_HW_QUAL_TYPE_NONE = 0,
  NV_GPU_HW_QUAL_TYPE_NOMINAL = 1,
  NV_GPU_HW_QUAL_TYPE_SLOW = 2,
  NV_GPU_HW_QUAL_TYPE_FAST = 3,
  NV_GPU_HW_QUAL_TYPE_HIGH_LEAKAGE = 4,
} NV_GPU_HW_QUAL_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetHardwareQualType(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_HW_QUAL_TYPE *pValue);
typedef struct {
  NvU32 version;
  NvU32 hwSpeedo;
  NvU32 hwSpeedoVersion;
  NvU32 speedoVersion;
  NvU16 tempPollingPeriodms;
  NvU8 numEntries;
  NvU8 nominalP0VdtEntry;
  NvU8 reliabilityLimitEntry;
  NvU8 overVoltageLimitEntry;
  NvU8 voltageTuningEntry;
} NV_GPU_VDT_INFO_V1;
typedef NV_GPU_VDT_INFO_V1 NV_GPU_VDT_INFO;
#define NV_GPU_VDT_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_VDT_INFO_V1, 1)
#define NV_GPU_VDT_INFO_VER NV_GPU_VDT_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_VdtGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_VDT_INFO *pVdtInfo);
#define NV_GPU_VDT_ENTRY_INFO_MAX_ENTRIES_V1 128
typedef enum {
  NV_GPU_VDT_ENTRY_TYPE_CVB10 = 0x0,
  NV_GPU_VDT_ENTRY_TYPE_CVB20,
  NV_GPU_VDT_ENTRY_TYPE_CVB10_DPA,
  NV_GPU_VDT_ENTRY_TYPE_MAX,
  NV_GPU_VDT_ENTRY_TYPE_UNKNOWN = 0xFFFFFFFF
} NV_GPU_VDT_ENTRY_TYPE;
typedef struct {
  NvS64 coefficient0;
  NvS64 coefficient1;
  NvS64 coefficient2;
} NV_GPU_VDT_ENTRY_INFO_DATA_CVB10;
typedef struct {
  NvS32 coefficient5;
  NvS32 coefficient4;
  NvS32 coefficient3;
  NvS32 coefficient2;
  NvS32 coefficient1;
  NvS32 coefficient0;
} NV_GPU_VDT_ENTRY_INFO_DATA_CVB20;
typedef struct _NV_GPU_VDT_ENTRY_INFO_DATA_CVB10_DPA {
  NvS64 coefficient0;
  NvS64 coefficient1;
  NvS64 coefficient2;
} NV_GPU_VDT_ENTRY_INFO_DATA_CVB10_DPA;
typedef struct _NV_GPU_VDT_ENTRY_INFO_DATA_MAX {
  NvU8 index0;
  NvU8 index1;
} NV_GPU_VDT_ENTRY_INFO_DATA_MAX;
typedef union {
  NV_GPU_VDT_ENTRY_INFO_DATA_CVB10 cvb10;
  NV_GPU_VDT_ENTRY_INFO_DATA_CVB20 cvb20;
  NV_GPU_VDT_ENTRY_INFO_DATA_CVB10_DPA cvb10Dpa;
  NV_GPU_VDT_ENTRY_INFO_DATA_MAX vdtMax;
} NV_GPU_VDT_ENTRY_INFO_DATA;
typedef struct {
  NvU8 index;
  NvU32 currTargetVoltageuV;
  NvS32 localUnboundVoltageuV;
  NvU8 nextEntry;
  NvS32 voltageMinuV;
  NvS32 voltageMaxuV;
  NV_GPU_VDT_ENTRY_TYPE type;
  NV_GPU_VDT_ENTRY_INFO_DATA data;
} NV_GPU_VDT_ENTRY_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 numEntries;
  NV_GPU_VDT_ENTRY_INFO_V1 entries[NV_GPU_VDT_ENTRY_INFO_MAX_ENTRIES_V1];
} NV_GPU_VDT_ENTRIES_INFO_V1;
typedef NV_GPU_VDT_ENTRIES_INFO_V1 NV_GPU_VDT_ENTRIES_INFO;
#define NV_GPU_VDT_ENTRIES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_VDT_ENTRIES_INFO_V1, 1)
#define NV_GPU_VDT_ENTRIES_INFO_VER NV_GPU_VDT_ENTRIES_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_VdtEntriesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __inout NV_GPU_VDT_ENTRIES_INFO *pVdtEntriesInfo);
NVAPI_INTERFACE NvAPI_GPU_VdtEntriesSetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __in NV_GPU_VDT_ENTRIES_INFO *pVdtEntriesInfo);
typedef struct {
  NvU64 sampleId;
  NvU64 sampleTimens;
  NvU64 frameId;
  NvU64 frameTimens;
  NvU32 powermw;
  NvU32 voltageuv;
  NvU32 gpcclkMHz;
  NvU32 memclkMHz;
  NvU16 fbUtilPct;
  NvU16 grUtilPct;
  NvU16 pcieUtilPct;
  NvU16 rsvd;
} NV_GPU_FAS_TELEMETRY_SAMPLE_V1;
#define NV_GPU_FAS_TELEMETRY_SAMPLE_VER1 MAKE_NVAPI_VERSION(NV_GPU_FAS_TELEMETRY_SAMPLE_V1, 1)
#define NV_GPU_FAS_TELEMETRY_SAMPLE_VER NV_GPU_FAS_TELEMETRY_SAMPLE_VER1
typedef NV_GPU_FAS_TELEMETRY_SAMPLE_V1 NV_GPU_FAS_TELEMETRY_SAMPLE;
#define NV_GPU_FAS_MAX_TELEMETRY_SAMPLE_COUNT 250
typedef struct {
  NvU32 version;
  NvU32 count;
  NV_GPU_FAS_TELEMETRY_SAMPLE *pSamples;
} NV_GPU_FAS_TELEMETRY_INFO_V1;
#define NV_GPU_FAS_TELEMETRY_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_FAS_TELEMETRY_INFO_V1, 1)
#define NV_GPU_FAS_TELEMETRY_INFO_VER NV_GPU_FAS_TELEMETRY_INFO_VER1
typedef NV_GPU_FAS_TELEMETRY_INFO_V1 NV_GPU_FAS_TELEMETRY_INFO;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 465.") NVAPI_INTERFACE
    NvAPI_GPU_GetFasTelemetryInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FAS_TELEMETRY_INFO *pFasInfo);
typedef enum _NVAPI_DITHER_TYPE {
  NVAPI_DITHER_TYPE_DEFAULT = 0,
  NVAPI_DITHER_TYPE_ENABLE = 1,
  NVAPI_DITHER_TYPE_DISABLE = 2,
} NVAPI_DITHER_TYPE;
typedef enum _NVAPI_DITHER_BITS {
  NVAPI_DITHER_BITS_6BITS = 0,
  NVAPI_DITHER_BITS_8BITS = 1,
  NVAPI_DITHER_BITS_10BITS = 2,
} NVAPI_DITHER_BITS;
typedef enum _NVAPI_DITHER_MODE {
  NVAPI_DITHER_MODE_DYNAMIC_ERR_ACC = 0,
  NVAPI_DITHER_MODE_STATIC_ERR_ACC = 1,
  NVAPI_DITHER_MODE_DYNAMIC_2X2 = 2,
  NVAPI_DITHER_MODE_STATIC_2X2 = 3,
  NVAPI_DITHER_MODE_TEMPORAL = 4,
} NVAPI_DITHER_MODE;
NVAPI_INTERFACE NvAPI_GPU_SetDitherControl(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NVAPI_DITHER_TYPE type,
                                           NVAPI_DITHER_BITS bits, NVAPI_DITHER_MODE mode);
typedef enum _NVAPI_DITHER_CONTROL_CAP_MODE {
  NVAPI_DITHER_CONTROL_CAP_MODE_DYNAMIC_ERR_ACC = NV_BIT(NVAPI_DITHER_MODE_DYNAMIC_ERR_ACC),
  NVAPI_DITHER_CONTROL_CAP_MODE_STATIC_ERR_ACC = NV_BIT(NVAPI_DITHER_MODE_STATIC_ERR_ACC),
  NVAPI_DITHER_CONTROL_CAP_MODE_DYNAMIC_2X2 = NV_BIT(NVAPI_DITHER_MODE_DYNAMIC_2X2),
  NVAPI_DITHER_CONTROL_CAP_MODE_STATIC_2X2 = NV_BIT(NVAPI_DITHER_MODE_STATIC_2X2),
  NVAPI_DITHER_CONTROL_CAP_MODE_TEMPORAL = NV_BIT(NVAPI_DITHER_MODE_TEMPORAL),
} NVAPI_DITHER_CONTROL_CAP_MODE;
typedef enum _NVAPI_DITHER_CONTROL_CAP_BITS {
  NVAPI_DITHER_CONTROL_CAP_BITS_6BITS = NV_BIT(NVAPI_DITHER_BITS_6BITS),
  NVAPI_DITHER_CONTROL_CAP_BITS_8BITS = NV_BIT(NVAPI_DITHER_BITS_8BITS),
  NVAPI_DITHER_CONTROL_CAP_BITS_10BITS = NV_BIT(NVAPI_DITHER_BITS_10BITS),
} NVAPI_DITHER_CONTROL_CAP_BITS;
typedef struct _NV_GPU_DITHER_CONTROL_V1 {
  NvU32 version;
  NVAPI_DITHER_TYPE ditherEnable;
  NVAPI_DITHER_BITS ditherBitDepth;
  NVAPI_DITHER_MODE ditherMode;
  NvU32 ditherBitDepths;
  NvU32 ditherModes;
} NV_GPU_DITHER_CONTROL_V1;
typedef NV_GPU_DITHER_CONTROL_V1 NV_GPU_DITHER_CONTROL;
#define NV_GPU_DITHER_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_DITHER_CONTROL_V1, 1)
#define NV_GPU_DITHER_CONTROL_VER NV_GPU_DITHER_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_GetDitherControl(NvU32 displayId, NV_GPU_DITHER_CONTROL *pDitherData);
#define NVAPI_CSC_MATRIX_WIDTH 3
#define NVAPI_CSC_MATRIX_HEIGHT 4
typedef struct _NVAPI_CSC_MATRIX {
  NvU32 useCustomMatrix : 1;
  NvU32 reserved : 31;
  float aCSCCoeff[NVAPI_CSC_MATRIX_WIDTH][NVAPI_CSC_MATRIX_HEIGHT];
} NVAPI_CSC_MATRIX;
typedef enum _NV_STANDARD_COLORSPACE {
  NV_STANDARD_COLORSPACE_DISABLED = 0,
  NV_STANDARD_COLORSPACE_AUTOSELECT = 1,
  NV_STANDARD_COLORSPACE_sRGB = 2,
  NV_STANDARD_COLORSPACE_MONITOR_RGB = 3,
  NV_STANDARD_COLORSPACE_ADOBE_RGB = 4,
  NV_STANDARD_COLORSPACE_ADOBE_WIDE_GAMUT = 5,
  NV_STANDARD_COLORSPACE_APPLE = 6,
  NV_STANDARD_COLORSPACE_NTSC = 7,
  NV_STANDARD_COLORSPACE_HDTV = 8,
  NV_STANDARD_COLORSPACE_PAL = 9,
  NV_STANDARD_COLORSPACE_DCIP3 = 10,
  NV_STANDARD_COLORSPACE_BT2020 = 11,
  NV_STANDARD_COLORSPACE_BT2020_PQ = 12,
  NV_STANDARD_COLORSPACE_MAX
} NV_STANDARD_COLORSPACE;
typedef enum _NV_COLORSPACE_CONVERSION_STATUS_FLAG {
  NV_COLORSPACE_CONVERSION_STATUS_FLAG_USER_MATRIX_RANGE_CLAMPED = NV_BIT(0),
  NV_COLORSPACE_CONVERSION_STATUS_FLAG_SW_EMULATION = NV_BIT(1),
  NV_COLORSPACE_CONVERSION_STATUS_FLAG_INFOFRAME_EXT_COLORIMETRY = NV_BIT(2),
} NV_COLORSPACE_CONVERSION_STATUS_FLAG;
typedef struct _NV_GPU_COLORSPACE_CONVERSION_V1 {
  NvU32 version;
  NV_STANDARD_COLORSPACE sourceColorSpace;
  NV_STANDARD_COLORSPACE outputColorSpace;
  NvU32 flags;
  NvU32 clientID;
  NVAPI_CSC_MATRIX MatrixPre;
  NVAPI_CSC_MATRIX MatrixPost;
} NV_GPU_COLORSPACE_CONVERSION_V1;
#define NV_GPU_COLORSPACE_CONVERSION_VER1 MAKE_NVAPI_VERSION(NV_GPU_COLORSPACE_CONVERSION_V1, 1)
#define NVAPI_CSC_LUT_SIZE 1024
typedef struct _NV_COLOR_RGB {
  float Red;
  float Green;
  float Blue;
} NV_COLOR_RGB;
typedef struct _NV_GPU_COLORSPACE_CONVERSION_V2 {
  NvU32 version;
  NV_STANDARD_COLORSPACE sourceColorSpace;
  NV_STANDARD_COLORSPACE outputColorSpace;
  NvU32 flags;
  NvU32 clientID;
  NVAPI_CSC_MATRIX MatrixPre;
  NVAPI_CSC_MATRIX MatrixPost;
  NV_COLOR_RGB *pDeGammaLut;
  NV_COLOR_RGB *pReGammaLut;
  void *pLutData;
  NvU32 lutDataSize;
} NV_GPU_COLORSPACE_CONVERSION_V2;
#define NV_GPU_COLORSPACE_CONVERSION_VER2 MAKE_NVAPI_VERSION(NV_GPU_COLORSPACE_CONVERSION_V2, 2)
typedef enum _NV_CSC_3DLUT_SIZE {
  NV_CSC_3DLUT_SIZE_ZERO = 0,
  NV_CSC_3DLUT_SIZE_17x17x17 = sizeof(NV_COLOR_RGB) * 17 * 17 * 17,
  NV_CSC_3DLUT_SIZE_32x32x32 = sizeof(NV_COLOR_RGB) * 32 * 32 * 32,
  NV_CSC_3DLUT_SIZE_64x64x64 = sizeof(NV_COLOR_RGB) * 64 * 64 * 64
} NV_CSC_3DLUT_SIZE;
typedef enum _NV_CSC_3DLUT_PLACEMENT {
  NV_CSC_3DLUT_PLACEMENT_POST_MATRIX = 0,
  NV_CSC_3DLUT_PLACEMENT_PRE_FIRST_1DLUT = 1,
} NV_CSC_3DLUT_PLACEMENT;
typedef struct _NV_GPU_COLORSPACE_CONVERSION_V3 {
  NvU32 version;
  NV_STANDARD_COLORSPACE sourceColorSpace;
  NV_STANDARD_COLORSPACE outputColorSpace;
  NvU32 flags;
  NvU32 clientID;
  NVAPI_CSC_MATRIX MatrixPre;
  NVAPI_CSC_MATRIX MatrixPost;
  NV_COLOR_RGB *pDeGammaLut;
  NV_COLOR_RGB *pReGammaLut;
  void *pLutData;
  NvU32 lutDataSize;
  NV_COLOR_RGB *p3dLut;
  NV_CSC_3DLUT_SIZE lut3dDataSize;
  NV_CSC_3DLUT_PLACEMENT lut3dPlacement;
} NV_GPU_COLORSPACE_CONVERSION_V3;
typedef NV_GPU_COLORSPACE_CONVERSION_V3 NV_GPU_COLORSPACE_CONVERSION;
#define NV_GPU_COLORSPACE_CONVERSION_VER3 MAKE_NVAPI_VERSION(NV_GPU_COLORSPACE_CONVERSION_V3, 3)
#define NV_GPU_COLORSPACE_CONVERSION_VER NV_GPU_COLORSPACE_CONVERSION_VER3
NVAPI_INTERFACE NvAPI_GPU_GetColorSpaceConversion(NvU32 displayId, NV_GPU_COLORSPACE_CONVERSION *pColorData);
NVAPI_INTERFACE NvAPI_GPU_SetColorSpaceConversion(NvU32 displayId, NV_GPU_COLORSPACE_CONVERSION *pColorData);
typedef enum _NVAPI_SYS_ENABLE_LICENSE_COMMAND {
  NVAPI_SYS_ENABLE_LICENSE_CMD_CHALLENGE = 0x01,
  NVAPI_SYS_ENABLE_LICENSE_CMD_RESPONSE = 0x02,
} NVAPI_SYS_ENABLE_LICENSE_COMMAND;
#define NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_SIZE 16
#define NVAPI_SYS_ENABLE_LICENSE_RESPONSE_SIZE 20
typedef struct _NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_PARAMS {
  NvU8 challenge[NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_SIZE];
} NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_PARAMS;
typedef struct _NVAPI_SYS_ENABLE_LICENSE_RESPONSE_PARAMS {
  NvU8 response[NVAPI_SYS_ENABLE_LICENSE_RESPONSE_SIZE];
} NVAPI_SYS_ENABLE_LICENSE_RESPONSE_PARAMS;
typedef struct _NVAPI_SYS_ENABLE_LICENSE {
  NvU32 version;
  NVAPI_SYS_ENABLE_LICENSE_COMMAND dwCommand;
  NvGUID vendorGUID;
  union {
    NVAPI_SYS_ENABLE_LICENSE_CHALLENGE_PARAMS ChallengeParams;
    NVAPI_SYS_ENABLE_LICENSE_RESPONSE_PARAMS ResponseParams;
    NvU32 ClientID;
  };
} NVAPI_SYS_ENABLE_LICENSE_V1;
typedef NVAPI_SYS_ENABLE_LICENSE_V1 NVAPI_SYS_ENABLE_LICENSE;
#define NVAPI_SYS_ENABLE_LICENSE_VER1 MAKE_NVAPI_VERSION(NVAPI_SYS_ENABLE_LICENSE_V1, 1)
#define NVAPI_SYS_ENABLE_LICENSE_VER NVAPI_SYS_ENABLE_LICENSE_VER1
NVAPI_INTERFACE NvAPI_SYS_EnableLicense(__inout NVAPI_SYS_ENABLE_LICENSE *pEnableLicenseParams);
typedef enum {
  NV_GPU_TOPOLOGY_STATUS_OK = 0x00000000,
  NV_GPU_TOPOLOGY_STATUS_INVALID_GPU_COUNT = 0x00000001,
  NV_GPU_TOPOLOGY_STATUS_OS_NOT_SUPPORTED = 0x00000002,
  NV_GPU_TOPOLOGY_STATUS_OS_ERROR = 0x00000004,
  NV_GPU_TOPOLOGY_STATUS_NO_VIDLINK = 0x00000008,
  NV_GPU_TOPOLOGY_STATUS_INSUFFICIENT_LINK_WIDTH = 0x00000010,
  NV_GPU_TOPOLOGY_STATUS_CPU_NOT_SUPPORTED = 0x00000020,
  NV_GPU_TOPOLOGY_STATUS_GPU_NOT_SUPPORTED = 0x00000040,
  NV_GPU_TOPOLOGY_STATUS_BUS_NOT_SUPPORTED = 0x00000080,
  NV_GPU_TOPOLOGY_STATUS_NON_APPROVED_CHIPSET = 0x00000100,
  NV_GPU_TOPOLOGY_STATUS_VBIOS_NOT_SUPPORTED = 0x00000200,
  NV_GPU_TOPOLOGY_STATUS_GR_MISMATCH = NV_GPU_TOPOLOGY_STATUS_VBIOS_NOT_SUPPORTED,
  NV_GPU_TOPOLOGY_STATUS_GPU_MISMATCH = 0x00000400,
  NV_GPU_TOPOLOGY_STATUS_ARCH_MISMATCH = 0x00000800,
  NV_GPU_TOPOLOGY_STATUS_IMPL_MISMATCH = 0x00001000,
  NV_GPU_TOPOLOGY_STATUS_SLI_WITH_TCC_NOT_SUPPORTED = 0x00002000,
  NV_GPU_TOPOLOGY_STATUS_NON_PCIE_BUS = 0x00004000,
  NV_GPU_TOPOLOGY_STATUS_FB_MISMATCH = 0x00008000,
  NV_GPU_TOPOLOGY_STATUS_VBIOS_MISMATCH = 0x00010000,
  NV_GPU_TOPOLOGY_STATUS_NVIDIA_RTX_MISMATCH = 0x00020000,
  NV_GPU_TOPOLOGY_STATUS_QUADRO_MISMATCH = NV_GPU_TOPOLOGY_STATUS_NVIDIA_RTX_MISMATCH,
  NV_GPU_TOPOLOGY_STATUS_BUS_TOPOLOGY_ERROR = 0x00040000,
  NV_GPU_TOPOLOGY_STATUS_PCI_ID_MISMATCH = 0x00080000,
  NV_GPU_TOPOLOGY_STATUS_CONFIGSPACE_ACCESS_ERROR = 0x00100000,
  NV_GPU_TOPOLOGY_STATUS_INCONSISTENT_CONFIG_SPACE = 0x00200000,
  NV_GPU_TOPOLOGY_STATUS_CONFIG_NOT_SUPPORTED = 0x00400000,
  NV_GPU_TOPOLOGY_STATUS_RM_NOT_SUPPORTED = 0x00800000,
  NV_GPU_TOPOLOGY_STATUS_TOPOLOGY_NOT_ALLOWED = 0x01000000,
  NV_GPU_TOPOLOGY_STATUS_MOBILE_MISMATCH = 0x02000000,
  NV_GPU_TOPOLOGY_STATUS_GPU_DRAINING = 0x04000000,
  NV_GPU_TOPOLOGY_STATUS_INSUFFICIENT_FB = 0x08000000,
  NV_GPU_TOPOLOGY_STATUS_ECC_MISMATCH = 0x10000000,
  NV_GPU_TOPOLOGY_STATUS_SLI_COOKIE_NOT_PRESENT = 0x20000000,
  NV_GPU_TOPOLOGY_STATUS_SLI_FINGER_NOT_SUPPORTED = 0x40000000,
  NV_GPU_TOPOLOGY_STATUS_SLI_WITH_ECC_NOT_SUPPORTED = 0x80000000,
} NV_GPU_TOPOLOGY_STATUS_FLAGS;
typedef enum {
  NV_SET_GPU_TOPOLOGY_DEFER_APPLY = 0x00000001,
  NV_SET_GPU_TOPOLOGY_DEFER_3D_APP_SHUTDOWN = 0x00000002,
  NV_SET_GPU_TOPOLOGY_DEFER_DISPLAY_RECONFIG = 0x00000004,
  NV_SET_GPU_TOPOLOGY_RELOAD_DRIVER = 0x80000000,
  NV_SET_GPU_TOPOLOGY_DEFER_DISPLAY_REAPPLY = 0x00000008,
} NV_SET_GPU_TOPOLOGY_FLAGS;
typedef enum {
  NV_GPU_TOPOLOGY_ACTIVE = 0x00000001,
  NV_GPU_TOPOLOGY_VIDLINK_PRESENT = 0x00000002,
  NV_GPU_TOPOLOGY_MULTIGPU = 0x00000004,
  NV_GPU_TOPOLOGY_GX2_BOARD = 0x00000008,
  NV_GPU_TOPOLOGY_DYNAMIC_NOT_ALLOWED = 0x00000010,
  NV_GPU_TOPOLOGY_ACTIVE_IMPLICIT = 0x00000020,
  NV_GPU_TOPOLOGY_ENABLE_SLI_BY_DEFAULT = 0x00000040,
  NV_GPU_TOPOLOGY_UNLINKED_SLI = 0x00000080,
  NV_GPU_TOPOLOGY_ENABLE_CORELOGIC_BROADCAST = 0x00000080,
  NV_GPU_TOPOLOGY_BROADCAST = 0x00000100,
  NV_GPU_TOPOLOGY_UNICAST = 0x00000200,
  NV_GPU_TOPOLOGY_4_WAY_SLI = 0x00000400,
  NV_GPU_TOPOLOGY_WS_OVERRIDE = 0x00000800,
  NV_GPU_TOPOLOGY_NO_BRIDGE_REQUIRED = 0x00001000,
  NV_GPU_TOPOLOGY_PREPASCAL = 0x00002000,
  NV_GPU_TOPOLOGY_UEFI = 0x00004000,
  NV_GPU_TOPOLOGY_COMPUTE = 0x00010000,
  NV_GPU_TOPOLOGY_SLIMULTIMON = 0x00020000,
  NV_GPU_TOPOLOGY_VIDLINK_CONNECTOR_PRESENT = 0x00040000,
  NV_GPU_TOPOLOGY_VIEW_CAN_SPAN_GPUS = 0x00080000,
  NV_GPU_TOPOLOGY_DRIVER_RELOADING = 0x00100000,
  NV_GPU_TOPOLOGY_BASE_MOSAIC = 0x00200000,
  NV_GPU_TOPOLOGY_ALLOW_SLI_MOSAIC = 0x00400000,
  NV_GPU_TOPOLOGY_ALLOW_SLI_MOSAIC_ONLY = 0x00800000,
  NV_GPU_TOPOLOGY_DUAL_MIO = 0x01000000,
  NV_GPU_TOPOLOGY_GPUS_DUAL_MIO_CAPABLE = 0x02000000,
  NV_GPU_TOPOLOGY_NVLINK_PRESENT = 0x04000000,
  NV_GPU_TOPOLOGY_NVLINK_CONNECTOR_PRESENT = 0x08000000,
  NV_GPU_TOPOLOGY_DUAL_MIO_OPTIMAL = 0x10000000,
  NV_GPU_TOPOLOGY_ALLOW_SLI_BASE_MOSAIC = 0x20000000,
  NV_GPU_TOPOLOGY_DUAL_MIO_POSSIBLE = 0x40000000,
  NV_GPU_TOPOLOGY_HIGH_SPEED_VIDEO_BRIDGE = 0x80000000,
} NV_GPU_TOPOLOGY_FLAGS;
typedef enum {
  NV_SLI_GROUP_ACTIVE = 0x00000001,
} NV_SLI_GROUP_FLAGS;
typedef struct {
  NvU32 version;
  NvU32 gpuCount;
  NvPhysicalGpuHandle hPhysicalGpu[NVAPI_MAX_GPU_PER_TOPOLOGY];
  NvU32 displayGpuIndex;
  NvU32 displayOutputTargetMask;
  NvU32 flags;
  NvU32 status;
} NV_GPU_TOPOLOGY_V1;
#define NV_GPU_TOPOLOGY_VER_1 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_V1, 1)
typedef struct {
  NvU32 version;
  NvU32 gpuCount;
  NvPhysicalGpuHandle hPhysicalGpu[NVAPI_MAX_GPU_PER_TOPOLOGY];
  NvU32 displayGpuIndex;
  union {
    NvU32 displayOutputTargetMask;
    NvU32 displayId;
  };
  NvU32 noDisplayGpuMask;
  NvU32 flags;
  NvU32 status;
} NV_GPU_TOPOLOGY_V2;
#define NV_GPU_TOPOLOGY_VER_2 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_V2, 2)
#define NV_GPU_TOPOLOGY NV_GPU_TOPOLOGY_V2
#define NV_GPU_TOPOLOGY_VER NV_GPU_TOPOLOGY_VER_2
typedef struct {
  NvU32 version;
  NvU64 topologyMask;
  NvU32 flags;
} NV_SLI_GROUP;
#define NV_GPU_SLI_GROUP_VER MAKE_NVAPI_VERSION(NV_SLI_GROUP, 1)
typedef struct {
  NvU32 version;
  NvU32 gpuTopoCount;
  NV_GPU_TOPOLOGY_V1 gpuTopo[NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];
} NV_GPU_TOPOLOGIES_V1;
#define NV_GPU_TOPOLOGIES_VER_1 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGIES_V1, 1)
typedef struct {
  NvU32 version;
  NvU32 gpuTopoCount;
  NV_GPU_TOPOLOGY_V1 gpuTopo[NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];
  NvU32 sliGroupCount;
  NV_SLI_GROUP sliGroup[NVAPI_MAX_AVAILABLE_SLI_GROUPS];
} NV_GPU_TOPOLOGIES_V2;
#define NV_GPU_TOPOLOGIES_VER_2 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGIES_V2, 2)
typedef struct {
  NvU32 version;
  NvU32 gpuTopoCount;
  NV_GPU_TOPOLOGY gpuTopo[NVAPI_MAX_AVAILABLE_GPU_TOPOLOGIES];
  NvU32 sliGroupCount;
  NV_SLI_GROUP sliGroup[NVAPI_MAX_AVAILABLE_SLI_GROUPS];
} NV_GPU_TOPOLOGIES;
#define NV_GPU_TOPOLOGIES_VER MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGIES, 3)
#define NV_GPU_VALID_GPU_TOPOLOGIES NV_GPU_TOPOLOGIES
#define NV_GPU_INVALID_GPU_TOPOLOGIES NV_GPU_TOPOLOGIES
#define NV_GPU_VALID_GPU_TOPOLOGIES_VER NV_GPU_TOPOLOGIES_VER
#define NV_GPU_INVALID_GPU_TOPOLOGIES_VER NV_GPU_TOPOLOGIES_VER
#define NV_GPU_VALID_GPU_TOPOLOGIES_V1 NV_GPU_TOPOLOGIES_V1
#define NV_GPU_INVALID_GPU_TOPOLOGIES_V1 NV_GPU_TOPOLOGIES_V1
#define NV_GPU_VALID_GPU_TOPOLOGIES_VER_1 NV_GPU_TOPOLOGIES_VER_1
#define NV_GPU_INVALID_GPU_TOPOLOGIES_VER_1 NV_GPU_TOPOLOGIES_VER_1
#define NV_GPU_VALID_GPU_TOPOLOGIES_V2 NV_GPU_TOPOLOGIES_V2
#define NV_GPU_INVALID_GPU_TOPOLOGIES_V2 NV_GPU_TOPOLOGIES_V2
#define NV_GPU_VALID_GPU_TOPOLOGIES_VER_2 NV_GPU_TOPOLOGIES_VER_2
#define NV_GPU_INVALID_GPU_TOPOLOGIES_VER_2 NV_GPU_TOPOLOGIES_VER_2
NVAPI_INTERFACE NvAPI_GetValidGpuTopologies(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 *pStatus);
#define NVAPI_MAX_SIZEOF_I2C_DATA_BUFFER 4096
#define NVAPI_MAX_SIZEOF_I2C_REG_ADDRESS 4
#define NVAPI_DISPLAY_DEVICE_MASK_MAX 24
#define NVAPI_I2C_SPEED_DEPRECATED 0xFFFF
typedef enum {
  NVAPI_I2C_SPEED_DEFAULT,
  NVAPI_I2C_SPEED_3KHZ,
  NVAPI_I2C_SPEED_10KHZ,
  NVAPI_I2C_SPEED_33KHZ,
  NVAPI_I2C_SPEED_100KHZ,
  NVAPI_I2C_SPEED_200KHZ,
  NVAPI_I2C_SPEED_400KHZ,
} NV_I2C_SPEED;
typedef struct {
  NvU32 version;
  NvU32 displayMask;
  NvU8 bIsDDCPort;
  NvU8 i2cDevAddress;
  NvU8 *pbI2cRegAddress;
  NvU32 regAddrSize;
  NvU8 *pbData;
  NvU32 cbSize;
  NvU32 i2cSpeed;
} NV_I2C_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 displayMask;
  NvU8 bIsDDCPort;
  NvU8 i2cDevAddress;
  NvU8 *pbI2cRegAddress;
  NvU32 regAddrSize;
  NvU8 *pbData;
  NvU32 cbSize;
  NvU32 i2cSpeed;
  NV_I2C_SPEED i2cSpeedKhz;
} NV_I2C_INFO_V2;
typedef struct {
  NvU32 version;
  NvU32 displayMask;
  NvU8 bIsDDCPort;
  NvU8 i2cDevAddress;
  NvU8 *pbI2cRegAddress;
  NvU32 regAddrSize;
  NvU8 *pbData;
  NvU32 cbSize;
  NvU32 i2cSpeed;
  NV_I2C_SPEED i2cSpeedKhz;
  NvU8 portId;
  NvU32 bIsPortIdSet;
} NV_I2C_INFO_V3;
typedef NV_I2C_INFO_V3 NV_I2C_INFO;
#define NV_I2C_INFO_VER3 MAKE_NVAPI_VERSION(NV_I2C_INFO_V3, 3)
#define NV_I2C_INFO_VER2 MAKE_NVAPI_VERSION(NV_I2C_INFO_V2, 2)
#define NV_I2C_INFO_VER1 MAKE_NVAPI_VERSION(NV_I2C_INFO_V1, 1)
#define NV_I2C_INFO_VER NV_I2C_INFO_VER3
NVAPI_INTERFACE NvAPI_I2CRead(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo);
NVAPI_INTERFACE NvAPI_I2CWrite(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo);
#define NVAPI_I2C_FLAGS_NONE 0
#define NVAPI_I2C_FLAGS_PRIVILEGE 0x1
#define NVAPI_I2C_FLAGS_DATA_ENCRYPTED 0x2
#define NVAPI_I2C_FLAGS_NONSTD_SI1930UC 0x4
#define NVAPI_I2C_FLAGS_FORCE_MOT 0x8
#define NVAPI_I2C_FLAGS_PX3540 0x10
typedef struct {
  NvU32 flags;
  NvU32 encrClientID;
} NV_I2C_INFO_EX;
NVAPI_INTERFACE NvAPI_I2CWriteEx(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo, NV_I2C_INFO_EX *pI2cInfoEx);
NVAPI_INTERFACE NvAPI_I2CReadEx(NvPhysicalGpuHandle hPhysicalGpu, NV_I2C_INFO *pI2cInfo, NV_I2C_INFO_EX *pI2cInfoEx);
typedef enum {
  NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_QUICK_RW,
  NV_I2C_INFO_TRANSACTION_TYPE_I2C_BYTE_RW,
  NV_I2C_INFO_TRANSACTION_TYPE_I2C_BLOCK_RW,
  NV_I2C_INFO_TRANSACTION_TYPE_I2C_BUFFER_RW,
  NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BYTE_RW,
  NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_WORD_RW,
  NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_RW,
  NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_PROCESS_CALL,
  NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_BLOCK_PROCESS_CALL,
  NV_I2C_INFO_TRANSACTION_TYPE_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW,
  NV_I2C_INFO_TRANSACTION_TYPE_READ_EDID_DDC
} NV_I2C_INFO_TRANSACTION_TYPE;
#define NV_I2C_INFO_SMBUS_QUICK_RW_WAR_FLAGS_NONE 0
#define NV_I2C_INFO_SMBUS_QUICK_RW_WAR_FLAGS_TEST_PORT 1
typedef struct {
  NvU8 bWrite;
  NvU32 warFlags;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_QUICK_RW;
typedef struct {
  NvU8 bWrite;
  NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_I2C_BYTE_RW;
typedef struct {
  NvU8 bWrite;
  NvU32 messageLength;
  NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_I2C_BLOCK_RW;
typedef struct {
  NvU8 bWrite;
  NvU8 registerAddress;
  NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BYTE_RW;
typedef struct {
  NvU8 bWrite;
  NvU8 registerAddress;
  NvU16 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_WORD_RW;
typedef struct {
  NvU8 bWrite;
  NvU32 warFlags;
  NvU8 registerAddress;
  NvU32 messageLength;
  NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_I2C_BUFFER_RW;
typedef struct {
  NvU8 bWrite;
  NvU8 registerAddress;
  NvU32 messageLength;
  NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_RW;
typedef struct {
  NvU8 registerAddress;
  NvU16 *pWriteMessage;
  NvU16 *pReadMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_PROCESS_CALL;
typedef struct {
  NvU8 registerAddress;
  NvU32 writeMessageLength;
  NvU8 *pWriteMessage;
  NvU32 readMessageLength;
  NvU8 *pReadMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_PROCESS_CALL;
#define NV_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_NONE 0
#define NV_I2C_INFO_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW_WAR_FLAGS_NO_AUTO_INC 1
typedef struct {
  NvU8 bWrite;
  NvU32 warFlags;
  NvU32 indexLength;
  NvU8 *pIndex;
  NvU32 messageLength;
  NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW;
typedef struct {
  NvU8 segmentNumber;
  NvU8 registerAddress;
  NvU32 messageLength;
  NvU8 *pMessage;
} NV_I2C_INFO_TRANSACTION_DATA_READ_EDID_DDC;
typedef union {
  NV_I2C_INFO_TRANSACTION_DATA_SMBUS_QUICK_RW smbusQuickData;
  NV_I2C_INFO_TRANSACTION_DATA_I2C_BYTE_RW i2cByteData;
  NV_I2C_INFO_TRANSACTION_DATA_I2C_BLOCK_RW i2cBlockData;
  NV_I2C_INFO_TRANSACTION_DATA_I2C_BUFFER_RW i2cBufferData;
  NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BYTE_RW smbusByteData;
  NV_I2C_INFO_TRANSACTION_DATA_SMBUS_WORD_RW smbusWordData;
  NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_RW smbusBlockData;
  NV_I2C_INFO_TRANSACTION_DATA_SMBUS_PROCESS_CALL smbusProcessData;
  NV_I2C_INFO_TRANSACTION_DATA_SMBUS_BLOCK_PROCESS_CALL smbusBlockProcessData;
  NV_I2C_INFO_TRANSACTION_DATA_SMBUS_MULTIBYTE_REGISTER_BLOCK_RW smbusMultibyteRegisterData;
  NV_I2C_INFO_TRANSACTION_DATA_READ_EDID_DDC edidData;
} NV_I2C_INFO_TRANSACTION_DATA;
typedef enum {
  LOCATION_TYPE_DISPLAY = 0x0,
  LOCATION_TYPE_ADDRESS,
} LOCATION_TYPE;
typedef struct {
  NvU32 displayId;
} LOCATION_TYPE_DATA_DISPLAY;
typedef struct {
  NvU16 deviceAddress;
} LOCATION_TYPE_DATA_ADDRESS;
#define NV_I2C_INFO_PORT_ID_UNITIALIZED (+255U)
typedef struct {
  union {
    LOCATION_TYPE_DATA_DISPLAY display;
    LOCATION_TYPE_DATA_ADDRESS address;
    NvU8 rsvd[16];
  };
  NvU8 portId;
  LOCATION_TYPE locDataType;
} LOCATION_DATA;
typedef struct {
  NvU32 version;
  NvU32 flags;
  LOCATION_DATA locData;
  NV_I2C_SPEED i2cSpeedKhz;
  NV_I2C_INFO_TRANSACTION_TYPE transType;
  NV_I2C_INFO_TRANSACTION_DATA transData;
  NvU8 rsvd[32];
} NV_I2C_TRANSACTION_INFO_V1;
typedef NV_I2C_TRANSACTION_INFO_V1 NV_I2C_TRANSACTION_INFO;
#define NV_I2C_TRANSACTION_INFO_VER1 MAKE_NVAPI_VERSION(NV_I2C_TRANSACTION_INFO_V1, 1)
#define NV_I2C_TRANSACTION_INFO_VER NV_I2C_TRANSACTION_INFO_VER1
NVAPI_INTERFACE NvAPI_I2CTransaction(__in NvPhysicalGpuHandle hPhysicalGpu,
                                     __inout NV_I2C_TRANSACTION_INFO *pI2CTranInfo);
typedef struct {
  NvU32 version;
  NvU32 portId;
  NvU32 portSpeed;
} NV_I2C_PORT_INFO_V1;
typedef NV_I2C_PORT_INFO_V1 NV_I2C_PORT_INFO;
#define NV_I2C_PORT_INFO_VER1 MAKE_NVAPI_VERSION(NV_I2C_PORT_INFO_V1, 1)
#define NV_I2C_PORT_INFO_VER NV_I2C_PORT_INFO_VER1
#define NV_NVAPI_MAX_I2C_NUM_PORTS 16
NVAPI_INTERFACE NvAPI_GPU_Get_I2C_Ports_Info(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout_ecount(numPorts) NV_I2C_PORT_INFO *pI2CPorts, __in NvU32 numPorts);
NVAPI_INTERFACE NvAPI_RestartDisplayDriver();
NVAPI_INTERFACE NvAPI_GetValidGpuTopologiesInternal(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 *pStatus);
NVAPI_INTERFACE NvAPI_GPU_GetValidGpuTopologiesMosaic(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 *pStatus);
NVAPI_INTERFACE NvAPI_GetInvalidGpuTopologies(NV_GPU_INVALID_GPU_TOPOLOGIES *pTopology);
NVAPI_INTERFACE NvAPI_SetGpuTopologies(NV_GPU_VALID_GPU_TOPOLOGIES *pTopology, NvU32 flags);
NVAPI_INTERFACE NvAPI_GPU_GetPerGpuTopologyStatus(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pStatus);
NVAPI_INTERFACE NvAPI_GetTopologyStatusString(NvU32 nr, NvAPI_String szDesc);
NVAPI_INTERFACE NvAPI_GetTopologyFlagString(NvU32 nr, NvAPI_String szDesc);
NVAPI_INTERFACE NvAPI_GetSliGroupFlagString(NvU32 nr, NvAPI_String szDesc);
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemProperties(NV_GPU_TOPOLOGY *pTopology, NvU32 *pSystemProperties);
typedef enum {
  NV_GPU_TOPOLOGY_SYSPROP_IS_MOBILE = 0x00000001,
  NV_GPU_TOPOLOGY_SYSPROP_IS_CANOAS = 0x00000002,
  NV_GPU_TOPOLOGY_SYSPROP_IS_E551 = 0x00000004,
  NV_GPU_TOPOLOGY_SYSPROP_IS_BR02 = 0x00000008,
  NV_GPU_TOPOLOGY_SYSPROP_IS_BR03 = 0x00000010,
  NV_GPU_TOPOLOGY_SYSPROP_IS_BR04 = 0x00000020,
  NV_GPU_TOPOLOGY_SYSPROP_IS_BR_ANY = 0x00000040,
  NV_GPU_TOPOLOGY_SYSPROP_IS_CPU_XEON = 0x00000080,
  NV_GPU_TOPOLOGY_SYSPROP_IS_QUADRO = 0x00000100,
  NV_GPU_TOPOLOGY_SYSPROP_IS_OS_VISTA = 0x00000200,
  NV_GPU_TOPOLOGY_SYSPROP_IS_2BR03 = 0x00000400,
  NV_GPU_TOPOLOGY_SYSPROP_IS_3BR03 = 0x00000800,
  NV_GPU_TOPOLOGY_SYSPROP_IS_OS_XP = 0x00001000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_VIDEO_BRIDGE = 0x00002000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_OS_UNIX = 0x00004000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_GEFORCE = 0x00008000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_CANOAS2 = 0x00010000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_OS_MODS = 0x00040000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_COMMON_BR03 = 0x00080000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_COMMON_BR04 = 0x00100000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_SHARED_BR03 = 0x00200000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_SHARED_BR04 = 0x00400000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_2BR04 = 0x00800000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_BR04_REV_A03 = 0x01000000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_MXM_INTERPOSER = 0x02000000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_NO_BR_NOTBR04A03 = 0x04000000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_SLI_APPROVAL_COOKIE = 0x08000000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_BR04_PRESENT = 0x10000000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_2BR04_NOT_CASCADED = 0x20000000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_4_WAY_SLI_APPROVAL_COOKIE = 0x40000000,
  NV_GPU_TOPOLOGY_SYSPROP_IS_TEMPLATE_APPROVAL_COOKIE = 0x80000000,
} NV_GPU_TOPOLOGY_SYSTEM_PROPERTY_FLAGS;
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemPropertiesString(NvU32 nr, NvAPI_String szDesc);
typedef struct {
  NvU32 version;
  NvU32 bIsMobile : 1;
  NvU32 bIsCanoas : 1;
  NvU32 bIsE551 : 1;
  NvU32 bIsBR02 : 1;
  NvU32 bIsBR03 : 1;
  NvU32 bIsBR04 : 1;
  NvU32 bIsBrAny : 1;
  NvU32 bIsCPUXeon : 1;
  NvU32 bIsQuadro : 1;
  NvU32 bIsOSVista : 1;
  NvU32 bIs2BR03 : 1;
  NvU32 bIs3BR03 : 1;
  NvU32 bIsOSXP : 1;
  NvU32 bIsVideoBridge : 1;
  NvU32 bIsOSUnix : 1;
  NvU32 bIsGeForce : 1;
  NvU32 bIsCanoas2 : 1;
  NvU32 bIsOSMODS : 1;
  NvU32 bIsCommonBR03 : 1;
  NvU32 bIsCommonBR04 : 1;
  NvU32 bIsSharedBR03 : 1;
  NvU32 bIsSharedBR04 : 1;
  NvU32 bIs2BR04 : 1;
  NvU32 bIsBR04RevA03 : 1;
  NvU32 bIsMXMIinterposer : 1;
  NvU32 bIsNoBrNorBR04A03 : 1;
  NvU32 bIsSliAapprovalCookie : 1;
  NvU32 bIsBR04Present : 1;
  NvU32 bIs2BR04NotCascaded : 1;
  NvU32 bIs4WaySliApprovalCookie : 1;
  NvU32 bIsTemplateApprovalCookie : 1;
  NvU32 bIsCircularVideoBridge : 1;
  NvU32 bIsGeforceOnWorkstation : 1;
} NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V1;
typedef NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V1 NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V2;
typedef struct {
  NvU32 version;
  NvU32 bIsMobile : 1;
  NvU32 bIsCanoas : 1;
  NvU32 bIsE551 : 1;
  NvU32 bIsBR02 : 1;
  NvU32 bIsBR03 : 1;
  NvU32 bIsBR04 : 1;
  NvU32 bIsBrAny : 1;
  NvU32 bIsCPUXeon : 1;
  NvU32 bIsQuadro : 1;
  NvU32 bIsOSVista : 1;
  NvU32 bIs2BR03 : 1;
  NvU32 bIs3BR03 : 1;
  NvU32 bIsOSXP : 1;
  NvU32 bIsVideoBridge : 1;
  NvU32 bIsOSUnix : 1;
  NvU32 bIsGeForce : 1;
  NvU32 bIsCanoas2 : 1;
  NvU32 bIsOSMODS : 1;
  NvU32 bIsCommonBR03 : 1;
  NvU32 bIsCommonBR04 : 1;
  NvU32 bIsSharedBR03 : 1;
  NvU32 bIsSharedBR04 : 1;
  NvU32 bIs2BR04 : 1;
  NvU32 bIsBR04RevA03 : 1;
  NvU32 bIsMXMIinterposer : 1;
  NvU32 bIsNoBrNorBR04A03 : 1;
  NvU32 bIsSliAapprovalCookie : 1;
  NvU32 bIsBR04Present : 1;
  NvU32 bIs2BR04NotCascaded : 1;
  NvU32 bIs4WaySliApprovalCookie : 1;
  NvU32 bIsTemplateApprovalCookie : 1;
  NvU32 bIsCircularVideoBridge : 1;
  NvU32 bIsGeforceOnWorkstation : 1;
  NvU32 bIsGpuNoSliSupport : 1;
  NvU32 bIsGpuGt200AndAbove : 1;
  NvU32 bIsNoVideoBridge : 1;
  NvU32 bIsP2PWriteAllowed : 1;
  NvU32 bIsP2PReadAllowed : 1;
  NvU32 bIsGpuBaseMosaicSupport : 1;
  NvU32 bIsPLX : 1;
  NvU32 bIsCommonPLX : 1;
  NvU32 bIsSharedPLX : 1;
  NvU32 bIsNoBr3rdParty;
  NvU32 reserved1 : 21;
  NvU32 reserved;
} NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V3;
typedef struct {
  NvU32 version;
  NvU32 bIsMobile : 1;
  NvU32 bIsCanoas : 1;
  NvU32 bIsE551 : 1;
  NvU32 bIsBR02 : 1;
  NvU32 bIsBR03 : 1;
  NvU32 bIsBR04 : 1;
  NvU32 bIsBrAny : 1;
  NvU32 bIsCPUXeon : 1;
  NvU32 bIsQuadro : 1;
  NvU32 bIsOSVista : 1;
  NvU32 bIs2BR03 : 1;
  NvU32 bIs3BR03 : 1;
  NvU32 bIsOSXP : 1;
  NvU32 bIsVideoBridge : 1;
  NvU32 bIsOSUnix : 1;
  NvU32 bIsGeForce : 1;
  NvU32 bIsCanoas2 : 1;
  NvU32 bIsOSMODS : 1;
  NvU32 bIsCommonBR03 : 1;
  NvU32 bIsCommonBR04 : 1;
  NvU32 bIsSharedBR03 : 1;
  NvU32 bIsSharedBR04 : 1;
  NvU32 bIs2BR04 : 1;
  NvU32 bIsBR04RevA03 : 1;
  NvU32 bIsMXMIinterposer : 1;
  NvU32 bIsNoBrNorBR04A03 : 1;
  NvU32 bIsSliAapprovalCookie : 1;
  NvU32 bIsBR04Present : 1;
  NvU32 bIs2BR04NotCascaded : 1;
  NvU32 bIs4WaySliApprovalCookie : 1;
  NvU32 bIsTemplateApprovalCookie : 1;
  NvU32 bIsCircularVideoBridge : 1;
  NvU32 bIsGeforceOnWorkstation : 1;
  NvU32 bIsGpuNoSliSupport : 1;
  NvU32 bIsGpuGt200AndAbove : 1;
  NvU32 bIsNoVideoBridge : 1;
  NvU32 bIsP2PWriteAllowed : 1;
  NvU32 bIsP2PReadAllowed : 1;
  NvU32 bIsGpuBaseMosaicSupport : 1;
  NvU32 bIsPLX : 1;
  NvU32 bIsCommonPLX : 1;
  NvU32 bIsSharedPLX : 1;
  NvU32 bIsNoBr3rdParty : 1;
  NvU32 bIsOSWDDM : 1;
  NvU32 bIsGX2 : 1;
  NvU32 bIsNoOnboardBR04 : 1;
  NvU32 bIsNoUnsupportedPCIBridge : 1;
  NvU32 bIsSLIApprovalCookieRecheck : 1;
  NvU32 bIsQSync : 1;
  NvU32 bIsNvLink : 1;
  NvU32 bIsWSOverride : 1;
  NvU32 bIsPrePascal : 1;
  NvU32 reserved1 : 12;
  NvU32 reserved2;
  NvU32 reserved3;
  NvU32 reserved;
} NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V4;
typedef NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V4 NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES;
#define NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_1 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V1, 1)
#define NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_2 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V2, 2)
#define NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_3 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V3, 1)
#define NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_4 MAKE_NVAPI_VERSION(NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_V4, 4)
#define NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES_VER_4
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemPropertiesEx(NV_GPU_TOPOLOGY *pTopology,
                                                       NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES *pSystemProperties);
NVAPI_INTERFACE NvAPI_GetGpuTopologySystemPropertiesStringEx(NV_GPU_TOPOLOGY_SYSTEM_PROPERTIES *pSystemProperties,
                                                             NvAPI_String szDesc);
NVAPI_INTERFACE NvAPI_GPU_GetAllGpusOnSameBoard(NvPhysicalGpuHandle hPhysicalGpu,
                                                NvPhysicalGpuHandle nvGPUHandle[NVAPI_MAX_PHYSICAL_GPUS],
                                                NvU32 *pGpuCount);
NVAPI_INTERFACE NvAPI_SYS_GetChipSetTopologyStatus(NvU32 *pStatus);
NVAPI_INTERFACE NvAPI_SetTopologyDisplayGPU(NvLogicalGpuHandle hLogicalGPU, NvPhysicalGpuHandle hGPU,
                                            NvU32 displayOutputId);
NVAPI_INTERFACE NvAPI_GetTopologyDisplayGPU(NvLogicalGpuHandle hLogicalGPU, NvPhysicalGpuHandle *pPhysicalGpu,
                                            NvU32 *pDisplayOutputId);
typedef struct {
  NvU32 version;
  struct {
    NvU32 displayMask;
  } input;
  struct {
    NvU32 isDP2DVI : 1;
    NvU32 isDP2HDMI : 1;
    NvU32 isDMS592DVI : 1;
    NvU32 isDMS592VGA : 1;
    NvU32 isDP2VGA : 1;
    NvU32 isDP2DVIActive : 1;
    NvU32 isDP2HDMIActive : 1;
    NvU32 reserved : 25;
  } output;
} NV_NVAPI_GET_DP_DONGLE_INFO;
#define NV_NVAPI_GET_DP_DONGLE_INFO_VER MAKE_NVAPI_VERSION(NV_NVAPI_GET_DP_DONGLE_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_Get_DisplayPort_DongleInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                     NV_NVAPI_GET_DP_DONGLE_INFO *pDongleInfo);
typedef enum {
  NVAPI_GPU_CAP_UNDEFINED = 0,
  NVAPI_GPU_CAP_GAMMA_CORRECT_AA_SUPPORTED = 1,
  NVAPI_GPU_CAP_TRANSPARENCY_AA_SUPPORTED = 2,
  NVAPI_GPU_CAP_SLI_RENDERING_DISABLED_DUE_TO_INTERLACE_MODE = 3,
  NVAPI_GPU_CAP_STEREO_DIN_AVAILABLE = 4,
  NVAPI_GPU_CAP_STEREO_CAPS = 5,
  NVAPI_GPU_CAP_STEREO_DEFAULT = 6,
  NVAPI_GPU_CAP_ROTATION_COMPATIBLE_STEREO_CAPS = 7,
  NVAPI_GPU_CAP_ROTATION_COMPATIBLE_STEREO_DEFAULT = 8,
  NVAPI_GPU_CAP_SWAPGROUP_FOR_ALL_APPS_SUPPORTED = 9,
  NVAPI_GPU_CAP_DEEP_COLOR_CAPS = 10,
  NVAPI_GPU_CAP_COUNT
} NVAPI_GPU_CAP;
typedef enum {
  NVAPI_GPU_CAP_STEREO_CAP_DIN_AVAILABLE = 0x00000001,
  NVAPI_GPU_CAP_STEREO_CAP_VERTICAL_INTERLACED = 0x00000002,
  NVAPI_GPU_CAP_STEREO_CAP_TWINVIEW = 0x00000004,
  NVAPI_GPU_CAP_STEREO_CAP_DDC_AVAILABLE = 0x00000008,
  NVAPI_GPU_CAP_STEREO_CAP_COLOR_LINE = 0x00000010,
  NVAPI_GPU_CAP_STEREO_CAP_COLOR_INTERLEAVED = 0x00000020,
  NVAPI_GPU_CAP_STEREO_CAP_ANAGLYPH = 0x00000040,
  NVAPI_GPU_CAP_STEREO_CAP_HORIZONTAL_INTERLACED = 0x00000080,
  NVAPI_GPU_CAP_STEREO_CAP_SIDE_FIELD = 0x00000100,
  NVAPI_GPU_CAP_STEREO_CAP_SUB_FIELD = 0x00000200,
  NVAPI_GPU_CAP_STEREO_CAP_CHECKERBOARD = 0x00000400,
  NVAPI_GPU_CAP_STEREO_CAP_INVERSE_CHECKERBOARD = 0x00000800,
  NVAPI_GPU_CAP_STEREO_CAP_TRIDELITY_SL = 0x00001000,
  NVAPI_GPU_CAP_STEREO_CAP_TRIDELITY_MV = 0x00002000,
  NVAPI_GPU_CAP_STEREO_CAP_SEEFRONT = 0x00004000,
  NVAPI_GPU_CAP_STEREO_CAP_STEREO_MIRROR = 0x00008000,
  NVAPI_GPU_CAP_STEREO_CAP_FRAME_SEQUENTIAL = 0x00010000,
  NVAPI_GPU_CAP_STEREO_CAP_USB_EMITTER = 0x00020000,
  NVAPI_GPU_CAP_STEREO_CAP_PER_EYE_PAIR_FLIP = 0x00040000,
  NVAPI_GPU_CAP_STEREO_CAP_PER_EYE_FLIP = 0x00080000,
  NVAPI_GPU_CAP_STEREO_CAP_DP_INBAND = 0x00100000,
} NVAPI_GPU_CAP_STEREO_CAP;
typedef enum {
  NVAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_GPU = 0x00000001,
  NVAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_DISPLAY = 0x00000002,
  NVAPI_GPU_CAP_DEEP_COLOR_CAP_SUPPORTED_BY_DISPLAY_MODE = 0x00000004,
} NVAPI_GPU_CAP_DEEP_COLOR_CAP;
NVAPI_INTERFACE NvAPI_QueryGpuCap(NvLogicalGpuHandle hLogicalGPU, NVAPI_GPU_CAP capToQuery, NvU32 *pVal);
typedef enum {
  NVAPI_GPU_WORKSTATION_FEATURE_MASK_SWAPGROUP = 0x00000001,
  NVAPI_GPU_WORKSTATION_FEATURE_MASK_STEREO = 0x00000010,
  NVAPI_GPU_WORKSTATION_FEATURE_MASK_WARPING = 0x00000100,
  NVAPI_GPU_WORKSTATION_FEATURE_MASK_PIXINTENSITY = 0x00000200,
  NVAPI_GPU_WORKSTATION_FEATURE_MASK_GRAYSCALE = 0x00000400,
  NVAPI_GPU_WORKSTATION_FEATURE_MASK_BPC10 = 0x00001000
} NVAPI_GPU_WORKSTATION_FEATURE_MASK;
NVAPI_INTERFACE NvAPI_GPU_WorkstationFeatureSetup(__in NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 featureEnableMask,
                                                  __in NvU32 featureDisableMask);
NVAPI_INTERFACE NvAPI_GPU_WorkstationFeatureQuery(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __out_opt NvU32 *pConfiguredFeatureMask,
                                                  __out_opt NvU32 *pConsistentFeatureMask);
NVAPI_INTERFACE NvAPI_GPU_WorkstationFeatureCommit();
NVAPI_INTERFACE NvAPI_NVPM_GetExportSetting(NvDisplayHandle hNvDisplay, NvU32 *pReturn);
typedef struct {
  NvU32 version;
  NvU32 gpuCount;
  NvU64 hClient[NVAPI_MAX_PHYSICAL_GPUS];
  NvU64 hDevice[NVAPI_MAX_PHYSICAL_GPUS];
  void *pMapping[NVAPI_MAX_PHYSICAL_GPUS];
} NV_NVPM_GPU_MAPPING;
#define NV_NVPM_GPU_MAPPING_VER MAKE_NVAPI_VERSION(NV_NVPM_GPU_MAPPING, 1)
typedef enum {
  NV_NVPM_GPU_RELEASE_REQUEST = 0,
  NV_NVPM_GPU_RESERVE_REQUEST,
} NV_NVPM_RESERVE_RELEASE_TYPE;
typedef struct {
  NvU32 version;
  NvU32 gpuCount;
  NvPhysicalGpuHandle hPhysicalGpus[NVAPI_MAX_PHYSICAL_GPUS];
  NV_NVPM_RESERVE_RELEASE_TYPE requestType;
} NV_NVPM_GPU_PERFMON_MAPPING;
#define NV_NVPM_GPU_PERFMON_MAPPING_VER MAKE_NVAPI_VERSION(NV_NVPM_GPU_PERFMON_MAPPING, 1)
NVAPI_INTERFACE NvAPI_NVPM_CreateGPUMapping(NV_NVPM_GPU_MAPPING *pMapping);
NVAPI_INTERFACE NvAPI_NVPM_DestroyGPUMapping(NV_NVPM_GPU_MAPPING *pMapping);
NVAPI_INTERFACE NvAPI_NVPM_CreateSharedMemory();
NVAPI_INTERFACE NvAPI_NVPM_DestroySharedMemory();
NVAPI_INTERFACE NvAPI_NVPM_ReservePerfmonHW(NV_NVPM_GPU_MAPPING *pMapping);
NVAPI_INTERFACE NvAPI_NVPM_ReleasePerfmonHW(NV_NVPM_GPU_MAPPING *pMapping);
NVAPI_INTERFACE NvAPI_NVPM_SetPMTriggerInsert(NvDisplayHandle hNvDisplay, NvU32 value);
NVAPI_INTERFACE NvAPI_NVPM_ReserveReleasePerfmonHW(NV_NVPM_GPU_PERFMON_MAPPING *pMapping);
typedef enum {
  NVAPI_AELPG_OPCODE_GET_ELPGINFO = 0,
  NVAPI_AELPG_OPCODE_DEPRECATED = 1,
  NVAPI_AELPG_OPCODE_HOLDOFF_AELPG = 2,
  NVAPI_AELPG_OPCODE_GET_VIDEOELPGINFO = 3,
  NVAPI_AELPG_OPCODE_GET_ELPGSTATS = 4,
  NVAPI_AELPG_OPCODE_GET_VIDEOELPGSTATS = 5,
  NVAPI_AELPG_OPCODE_GET_MSPGSTATS = 6,
  NVAPI_AELPG_OPCODE_GET_AELPGINFO = 7,
  NVAPI_AELPG_OPCODE_GET_AELPG1INFO = 8,
  NVAPI_AELPG_OPCODE_SET_IDLE_THRESHOLD = 9,
} NVAPI_AELPG_OPCODE;
typedef struct _NVAPI_ELPG_INFO {
  NvU8 initialized;
  NvU8 enabled;
  NvU8 aelpgEnabled;
  NvU32 idleThreshold;
  NvU32 postPowerupThreshold;
  NvU8 powerStateEngine;
  NvU32 gatingCount;
  NvU32 denyCount;
} NVAPI_ELPG_INFO;
typedef NVAPI_ELPG_INFO NVAPI_VIDEO_ELPG_INFO;
#define NVAPI_AELPG_HISTOGRAM_SIZE 16
typedef struct _NVAPI_AELPG_INFO {
  NvU8 enabled;
  NvU8 active;
  NvU32 holdTimeInSec;
  NvU32 badDecisionCount;
  NvU32 idleFilter;
  NvU32 powerSaving;
  NvU8 histogramBin[NVAPI_AELPG_HISTOGRAM_SIZE];
} NVAPI_AELPG_INFO;
typedef struct _NVAPI_ELPG_STATS_V1 {
  NvU32 gatingCount;
  NvU32 gatingTimeUs;
  NvU32 ungatingCount;
  NvU32 ungatingTimeUs;
  NvU32 avgEntryTimeUs;
  NvU32 avgExitTimeUs;
} NVAPI_ELPG_STATS_V1;
typedef struct _NVAPI_ELPG_STATS_V2 {
  NvU32 gatingCount;
  NvU32 gatingTimeUs;
  NvU32 ungatingCount;
  NvU32 ungatingTimeUs;
  NvU32 avgEntryTimeUs;
  NvU32 avgExitTimeUs;
  NvU32 maxEntryTimeUs;
  NvU32 maxExitTimeUs;
} NVAPI_ELPG_STATS_V2;
typedef struct _NVAPI_ELPG_STATS_V3 {
  NvU32 gatingCount;
  NvU32 gatingTimeUs;
  NvU32 ungatingCount;
  NvU32 ungatingTimeUs;
  NvU32 avgEntryTimeUs;
  NvU32 avgExitTimeUs;
  NvU32 maxEntryTimeUs;
  NvU32 maxExitTimeUs;
  NvU32 denyCount;
} NVAPI_ELPG_STATS_V3;
typedef struct _NVAPI_AELPG_REQUEST_V1 {
  NvU32 version;
  NVAPI_AELPG_OPCODE opCode;
  union {
    NVAPI_ELPG_INFO elpgInfo;
    NVAPI_AELPG_INFO aelpgInfo;
    NvU32 aelpgHoldTimeInSec;
    NVAPI_ELPG_STATS_V1 elpgStats;
    NvU32 idleThreshold;
  } data;
  NvU64 reserved;
} NVAPI_AELPG_REQUEST_V1;
typedef struct _NVAPI_AELPG_REQUEST_V2 {
  NvU32 version;
  NVAPI_AELPG_OPCODE opCode;
  union {
    NVAPI_ELPG_INFO elpgInfo;
    NVAPI_AELPG_INFO aelpgInfo;
    NvU32 aelpgHoldTimeInSec;
    NVAPI_ELPG_STATS_V2 elpgStats;
    NvU32 idleThreshold;
  } data;
  NvU64 reserved;
} NVAPI_AELPG_REQUEST_V2;
typedef struct _NVAPI_AELPG_REQUEST_V3 {
  NvU32 version;
  NVAPI_AELPG_OPCODE opCode;
  union {
    NVAPI_ELPG_INFO elpgInfo;
    NVAPI_AELPG_INFO aelpgInfo;
    NvU32 aelpgHoldTimeInSec;
    NVAPI_ELPG_STATS_V3 elpgStats;
    NvU32 idleThreshold;
  } data;
  NvU64 reserved;
} NVAPI_AELPG_REQUEST_V3;
typedef NVAPI_AELPG_REQUEST_V3 NVAPI_AELPG_REQUEST;
#define NVAPI_HANDLE_AELPG_VER_1 MAKE_NVAPI_VERSION(NVAPI_AELPG_REQUEST_V1, 1)
#define NVAPI_HANDLE_AELPG_VER_2 MAKE_NVAPI_VERSION(NVAPI_AELPG_REQUEST_V2, 2)
#define NVAPI_HANDLE_AELPG_VER_3 MAKE_NVAPI_VERSION(NVAPI_AELPG_REQUEST_V3, 3)
#define NVAPI_HANDLE_AELPG_VER NVAPI_HANDLE_AELPG_VER_3
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_GPU_HandleAELPG(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_AELPG_REQUEST *pParms);
typedef enum _NVAPI_PSI_OPCODE {
  NVAPI_PSI_OPCODE_GET_PSISTAT = 0,
  NVAPI_PSI_SET_CURRENT_MA = 1,
  NVAPI_PSI_GET_SUPPORT = 2,
  NVAPI_PSI_GET_SLEEP_MA = 3,
  NVAPI_PSI_GET_OPTIMAL_MA = 4,
  NVAPI_PSI_CTRL_RESET_ENGAGE_COUNT = 5,
  NVAPI_PSI_RESET_ENGAGE_COUNT = 6,
  NVAPI_PSI_SET_CURRENT_MA_LOGIC = NVAPI_PSI_SET_CURRENT_MA,
  NVAPI_PSI_SET_CURRENT_MA_SRAM = 7,
  NVAPI_PSI_GET_OPTIMAL_MA_LOGIC = NVAPI_PSI_GET_OPTIMAL_MA,
  NVAPI_PSI_GET_OPTIMAL_MA_SRAM = 8,
  NVAPI_PSI_GET_SLEEP_MA_LOGIC = NVAPI_PSI_GET_SLEEP_MA,
  NVAPI_PSI_GET_SLEEP_MA_SRAM = 9,
  NVAPI_PSI_GET_PSTATE_SUPPORT = 10,
  NVAPI_PSI_SET_ENABLE = 11,
} NVAPI_PSI_OPCODE;
typedef struct _NVPSI_SUPPORT {
  NvU32 elpgCoupled : 1;
  NvU32 mscgCoupled : 1;
  NvU32 gc4Coupled : 1;
  NvU32 diCoupled : 1;
  NvU32 psiSupported : 1;
  NvU32 psiCurrentaware : 1;
  NvU32 psiFlavor : 2;
  NvU32 pStateSupport : 16;
  NvU32 bEnable : 1;
  NvU32 reserved : 7;
} NVPSI_SUPPORT;
typedef struct _NVAPI_ELPG_STAT {
  NvU32 psiCount;
  NvU32 iSleepmA;
} NVAPI_ELPG_STAT;
typedef struct _NVAPI_MSCG_STAT {
  NvU32 psiCount;
  NvU32 iSleepmA;
} NVAPI_MSCG_STAT;
typedef struct _NVAPI_GC4_STAT {
  NvU32 psiCount;
  NvU32 iSleepmA;
} NVAPI_GC4_STAT;
typedef struct _NVAPI_DI_STAT {
  NvU32 psiCount;
  NvU32 iSleepmA;
} NVAPI_DI_STAT;
typedef struct _NVPSI_STAT_V1 {
  union {
    NvU32 psiCount;
  } elpg;
  union {
    NvU32 psiCount;
  } mscg;
  union {
    NvU32 psiCount;
  } gc4;
  union {
    NvU32 psiCount;
  } di;
} NVPSI_STAT_V1;
typedef struct _NVPSI_STAT {
  NVAPI_ELPG_STAT elpg;
  NVAPI_MSCG_STAT mscg;
  NVAPI_GC4_STAT gc4;
  NVAPI_DI_STAT di;
} NVPSI_STAT;
typedef struct _NVAPI_PSI_REQUEST_V1 {
  NvU32 version;
  NVAPI_PSI_OPCODE opCode;
  union {
    NvU32 onePhaseCurrentmA;
    NVPSI_STAT_V1 psiStat;
    NVPSI_SUPPORT psiSupport;
  } data;
} NVAPI_PSI_REQUEST_V1;
typedef struct _NVAPI_PSI_REQUEST_V2 {
  NvU32 version;
  NVAPI_PSI_OPCODE opCode;
  NVPSI_SUPPORT psiSupport;
  union {
    NvU32 onePhaseCurrentmA;
    NVPSI_STAT psiStat;
  } data;
} NVAPI_PSI_REQUEST_V2;
typedef NVAPI_PSI_REQUEST_V2 NVAPI_PSI_REQUEST;
#define NVAPI_PSI_REQUEST_VER_1 MAKE_NVAPI_VERSION(NVAPI_PSI_REQUEST_V1, 1)
#define NVAPI_PSI_REQUEST_VER_2 MAKE_NVAPI_VERSION(NVAPI_PSI_REQUEST_V2, 2)
#define NVAPI_PSI_REQUEST_VER NVAPI_PSI_REQUEST_VER_2
NVAPI_INTERFACE NvAPI_GPU_HandlePSI(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NVAPI_PSI_REQUEST *pParams);
#define NVAPI_MAX_NBSI_PARAM_SIZE 256
typedef enum _NVAPI_BIOS_NBSI_MODULE_TYPES {
  NVAPI_BIOS_NBSI_MODULE_GLOBAL = 0,
  NVAPI_BIOS_NBSI_MODULE_RM,
  NVAPI_BIOS_NBSI_MODULE_DD,
  NVAPI_BIOS_NBSI_MODULE_VIDEO,
  NVAPI_BIOS_NBSI_MODULE_CPL,
  NVAPI_BIOS_NBSI_MODULE_D3D,
  NVAPI_BIOS_NBSI_MODULE_OGL,
  NVAPI_BIOS_NBSI_PMU,
  NVAPI_BIOS_NBSI_MODE
} NVAPI_BIOS_NBSI_MODULE_TYPES;
typedef enum _NVAPI_BIOS_NBSI_ERROR_CODES {
  NVAPI_BIOS_GET_NBSI_SUCCESS = 0x00000000,
  NVAPI_BIOS_GET_NBSI_OVERRIDE = 0x00000001,
  NVAPI_BIOS_GET_NBSI_BAD_HASH = 0xFFFFFFFA,
  NVAPI_BIOS_GET_NBSI_APITEST_SUCCESS = 0xFFFFFFFB,
  NVAPI_BIOS_GET_NBSI_BAD_TABLE = 0xFFFFFFFC,
  NVAPI_BIOS_GET_NBSI_NO_TABLE = 0xFFFFFFFD,
  NVAPI_BIOS_GET_NBSI_INCOMPLETE = 0xFFFFFFFE,
  NVAPI_BIOS_GET_NBSI_NOT_FOUND = 0xFFFFFFFF,
} NVAPI_BIOS_NBSI_ERROR_CODES;
NVAPI_INTERFACE NvAPI_GPU_GetNBSIParams(NvPhysicalGpuHandle hPhysicalGpu, NvAPI_LongString key, NvAPI_LongString val,
                                        NVAPI_BIOS_NBSI_MODULE_TYPES moduleId, NvU8 data[NVAPI_MAX_NBSI_PARAM_SIZE],
                                        NvU32 *psizeofdata, NVAPI_BIOS_NBSI_ERROR_CODES *pnbsiErrorCode);
#ifndef ANY_SIZE_ARRAY
#define ANY_SIZE_ARRAY 127
#endif
#define NBSIDIRHDRSTRING (NvU32)(('N' << 24) + ('B' << 16) + ('S' << 8) + 'I')
#pragma pack(1)
typedef union _NBSI_DIRECTORY {
  struct OLD_FORMAT {
    NvU8 numGlobs;
    NvU8 dirVer;
    NvU16 globType[1];
  } od;
  struct NEW_FORMAT {
    NvU32 nbsiHeaderString;
    NvU32 size;
    NvU8 numGlobs;
    NvU8 dirVer;
    NvU16 globType[1];
  } d;
} NBSI_DIRECTORY, *PNBSI_DIRECTORY;
#pragma pack()
#pragma pack(1)
typedef struct _NBSI_GEN_OBJ {
  NvU64 sig;
  NvU16 globType;
  NvU32 size;
  NvU16 majMinVer;
  NvU8 objData[ANY_SIZE_ARRAY];
} NBSI_GEN_OBJ, *PNBSI_GEN_OBJ;
#pragma pack()
typedef enum _NBSI_TBL_SOURCES {
  NBSI_TBL_SOURCE_BEST_FIT = 0,
  NBSI_TBL_SOURCE_REGISTRY = 1,
  NBSI_TBL_SOURCE_VBIOS = 2,
  NBSI_TBL_SOURCE_I2C = 4,
  NBSI_TBL_SOURCE_SBIOS = 8,
  NBSI_TBL_SOURCE_ACPI = 0x10
} NBSI_TBL_SOURCES,
    *PNBSI_TBL_SOURCES;
#define NBSI_TBL_SOURCE_MAX 5
#define nbsiobjtype(ch1, ch2) (NvU16)((ch1 << 8) + ch2)
typedef enum _NBSI_GLOB_TYPES {
  NBSI_RSRVD_GLOB = 0,
  NBSI_DRIVER = nbsiobjtype('D', 'R'),
  NBSI_VBIOS = nbsiobjtype('V', 'B'),
  NBSI_HDCP = nbsiobjtype('H', 'K'),
  NBSI_HDD = nbsiobjtype('H', 'D'),
  NBSI_NONVOLATILE = nbsiobjtype('N', 'V')
} NBSI_GLOB_TYPE,
    *PNBSI_GLOB_TYPE;
#define GLOB_TYPE_APITEST 0xffff
#define GLOB_TYPE_GET_NBSI_DIR 0xfffe
#define GLOB_TYPE_GET_NBSI_ACPI_RAW 0xfffd
#define NBSI_FUNC_SUPPORT 0
#define NBSI_SOURCE_LOC NvU16
#define NVAPI_MAX_GET_NBSI_OBJ_SIZE 4096
#define NVAPI_MAX_GET_MAX_GLOB_INDEX 15
typedef struct _NVAPI_GET_NBSI_OBJ {
  NvU32 version;
  NvU16 globType;
  NvU8 globIndex;
  NBSI_SOURCE_LOC globSource;
  NvU32 dataOffset;
  NvU8 data[NVAPI_MAX_GET_NBSI_OBJ_SIZE];
  NvU32 pSizeOfData;
  NvU32 totalObjSize;
  NVAPI_BIOS_NBSI_ERROR_CODES pNbsiErrorCode;
} NVAPI_GET_NBSI_OBJ;
#define NVAPI_GET_NBSI_OBJ_VER MAKE_NVAPI_VERSION(NVAPI_GET_NBSI_OBJ, 1)
NVAPI_INTERFACE NvAPI_GPU_GetNBSIObj(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_GET_NBSI_OBJ *getNbsiObjParms);
#define NV_IMP_INTERLACED 0
#define NV_IMP_PROGRESSIVE 1
#define NV_IMP_VERTICAL_TAPS1 2
#define NV_IMP_VERTICAL_TAPS2 3
#define NV_IMP_VERTICAL_TAPS3 4
#define NV_IMP_VERTICAL_TAPS3_ADAPTIVE 5
#define NV_IMP_VERTICAL_TAPS5 6
#define NV_IMP_HORIZONTAL_TAPS1 7
#define NV_IMP_HORIZONTAL_TAPS2 8
#define NV_IMP_HORIZONTAL_TAPS8 9
#define NV_IMP_FORMAT_I8 10
#define NV_IMP_FORMAT_VOID16 11
#define NV_IMP_FORMAT_VOID32 12
#define NV_IMP_FORMAT_RF16_GF16_BF16_AF16 13
#define NV_IMP_FORMAT_A8R8G8B8 14
#define NV_IMP_FORMAT_A2B10G10R10 15
#define NV_IMP_FORMAT_A8B8G8R8 16
#define NV_IMP_FORMAT_R5G6B5 17
#define NV_IMP_FORMAT_A1R5G5B5 18
#define NV_IMP_SS_X1AA 19
#define NV_IMP_SS_X4AA 20
#define NV_IMP_BASE_USAGE_BOUNDS_USABLE_CURRENT 21
#define NV_IMP_BASE_USAGE_BOUNDS_USABLE_NO 22
#define NV_IMP_BASE_USAGE_BOUNDS_USABLE_YES 23
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_CURRENT 24
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_8 25
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_16 26
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_32 27
#define NV_IMP_BASE_USAGE_BOUNDS_DEPTH_64 28
#define NV_IMP_BASE_USAGE_BOUNDS_SS_CURRENT 29
#define NV_IMP_BASE_USAGE_BOUNDS_SS_X1AA 30
#define NV_IMP_BASE_USAGE_BOUNDS_SS_X4AA 31
typedef struct _NV_IMP_MODE {
  NvU32 PixelClock;
  NvU32 RasterWidth;
  NvU32 RasterHeight;
  NvU32 RasterBlankStartX;
  NvU32 RasterBlankStartY;
  NvU32 RasterBlankEndX;
  NvU32 RasterBlankEndY;
  NvU32 RasterVertBlank2YStart;
  NvU32 RasterVertBlank2YEnd;
  NvU32 ViewportOutWidth;
  NvU32 ViewportOutHeight;
  NvU32 ViewportOutMinWidth;
  NvU32 ViewportOutMinHeight;
  NvU32 ViewportInWidth;
  NvU32 ViewportInHeight;
  NvU32 OverlayBpp;
  NvU32 Interlaced;
  struct {
    NvU32 VerticalTaps;
    NvU32 HorizontalTaps;
  } OutputScaler;
  struct {
    NvU32 Format;
    NvU32 SuperSample;
  } Params;
  struct {
    NvU32 Usable;
    NvU32 PixelDepth;
    NvU32 SuperSample;
  } BaseUsageBounds;
} NV_IMP_MODE;
NVAPI_INTERFACE NvAPI_Disp_ConstructIMPMode(NV_DISP_PATH *pPath, NV_IMP_MODE *pIMPMode);
NVAPI_INTERFACE NvAPI_IsModePossible(NvPhysicalGpuHandle nvGPUHandle, NV_IMP_MODE *mode, NvU32 modeCount,
                                     NvU8 *impResult);
#define NV_MAX_LINES_PER_IMP_LOG_ENTRY 180
#define NV_FLAGS_CMDLINE_SHOW_IMPOSSIBLE_ENTRIES_ONLY 0x01
#define NV_FLAGS_CMDLINE_SHOW_POSSIBLE_ENTRIES_ONLY 0x02
#define NV_FLAGS_CMDLINE_READ_LAST_N_ENTRIES 0x04
#define NV_FLAGS_CMDLINE_RESET_IMP_LOG_ONLY 0x08
typedef struct _NV_IMP_LOG_ENTRY {
  NvU32 lineCount;
  NvAPI_ShortString line[NV_MAX_LINES_PER_IMP_LOG_ENTRY];
} NV_IMP_LOG_ENTRY;
NVAPI_INTERFACE NvAPI_DIAG_GetIsModePossibleLog(NvPhysicalGpuHandle nvGPUHandle, NV_IMP_LOG_ENTRY *pTextLog,
                                                NvU32 *pCount, NvU32 nCount, NvU32 flags);
typedef enum _NVAPI_DISPLAY_CRC_CONTROL_CHANNEL {
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_DEFAULT,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_CORE,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_BASE,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_OVERLAY,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW0,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW1,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW2,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW3,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW4,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW5,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW6,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW7,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW8,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW9,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW10,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW11,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW12,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW13,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW14,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW15,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW16,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW17,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW18,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW19,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW20,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW21,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW22,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW23,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW24,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW25,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW26,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW27,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW28,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW29,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW30,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_WINDOW31,
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL_LAST
} NVAPI_DISPLAY_CRC_CONTROL_CHANNEL;
typedef enum _NVAPI_DISPLAY_CRC_MODE {
  NVAPI_DISPLAY_CRC_MODE_DEFAULT,
  NVAPI_DISPLAY_CRC_MODE_ACTIVE_RASTER,
  NVAPI_DISPLAY_CRC_MODE_COMPLETE_RASTER,
  NVAPI_DISPLAY_CRC_MODE_NON_ACTIVE_RASTER,
  NVAPI_DISPLAY_CRC_MODE_LAST
} NVAPI_DISPLAY_CRC_MODE;
typedef enum _NVAPI_DISPLAY_CRC_OR_TYPE {
  NVAPI_DISPLAY_CRC_OR_TYPE_DEFAULT = 0,
  NVAPI_DISPLAY_CRC_OR_TYPE_DAC,
  NVAPI_DISPLAY_CRC_OR_TYPE_RG,
  NVAPI_DISPLAY_CRC_OR_TYPE_SOR,
  NVAPI_DISPLAY_CRC_OR_TYPE_SF,
  NVAPI_DISPLAY_CRC_OR_TYPE_PIOR,
  NVAPI_DISPLAY_CRC_OR_TYPE_WBOR,
  NVAPI_DISPLAY_CRC_OR_TYPE_DSI,
  NVAPI_DISPLAY_CRC_OR_TYPE_LAST
} NVAPI_DISPLAY_CRC_OR_TYPE;
typedef enum _NVAPI_DISPLAY_CRC_CONTROL_FLAG {
  NVAPI_DISPLAY_CRC_CONTROL_FLAG_DEFAULT,
  NVAPI_DISPLAY_CRC_CONTROL_FLAG_FALSE,
  NVAPI_DISPLAY_CRC_CONTROL_FLAG_TRUE,
  NVAPI_DISPLAY_CRC_CONTROL_FLAG_LAST
} NVAPI_DISPLAY_CRC_CONTROL_FLAG;
typedef struct _NVAPI_DISPLAY_CRC_CONFIG_V1 {
  NvU32 version;
  NVAPI_DISPLAY_CRC_MODE crcMode;
  NVAPI_DISPLAY_CRC_CONTROL_CHANNEL controlChannel;
  NVAPI_DISPLAY_CRC_OR_TYPE crcOrType[2];
  NvU32 crcOrIndex[2];
  NVAPI_DISPLAY_CRC_CONTROL_FLAG expectBufferCollapse;
  NVAPI_DISPLAY_CRC_CONTROL_FLAG timestampMode;
  NVAPI_DISPLAY_CRC_CONTROL_FLAG hwFliplockMode;
  NVAPI_DISPLAY_CRC_CONTROL_FLAG crcDuringSnooze;
  NvU32 userData;
  NvU32 reserved[4];
} NVAPI_DISPLAY_CRC_CONFIG_V1;
typedef NVAPI_DISPLAY_CRC_CONFIG_V1 NVAPI_DISPLAY_CRC_CONFIG;
#define NVAPI_DISPLAY_CRC_CONFIG_VER1 MAKE_NVAPI_VERSION(NVAPI_DISPLAY_CRC_CONFIG_V1, 1)
#define NVAPI_DISPLAY_CRC_CONFIG_VER NVAPI_DISPLAY_CRC_CONFIG_VER1
NVAPI_INTERFACE NvAPI_SetDisplayCrcConfigEx(__in NvU32 displayId, __in NVAPI_DISPLAY_CRC_CONFIG *pDisplayCrcConfig);
typedef enum _NVAPI_DISPLAY_CRC_DATA_FORMAT {
  NVAPI_DISPLAY_CRC_DATA_FORMAT_VER_UNKNOWN = 0,
  NVAPI_DISPLAY_CRC_DATA_FORMAT_VER1,
  NVAPI_DISPLAY_CRC_DATA_FORMAT_VER2
} NVAPI_DISPLAY_CRC_DATA_FORMAT;
typedef enum _NVAPI_DISPLAY_CRC_MAX_ENTRY_COUNT {
  NVAPI_DISPLAY_CRC_MAX_ENTRY_COUNT_FORMAT_1 = 255,
  NVAPI_DISPLAY_CRC_MAX_ENTRY_COUNT_FORMAT_2 = 2047
} NVAPI_DISPLAY_CRC_MAX_ENTRY_COUNT;
typedef struct _NVAPI_DISPLAY_CRC_STATUS_FORMAT_1 {
  NvU32 bDone : 1;
  NvU32 bOverrun : 1;
  NvU32 bDsiOverflow : 1;
  NvU32 bCompositorOverflow : 1;
  NvU32 bPrimaryOutputOverflow : 1;
  NvU32 bSecondaryOutputOverflow : 1;
  NvU32 bExpectBufferCollapse : 1;
  NvU32 bWidePipeCrc : 1;
  NvU32 reserved : 24;
} NVAPI_DISPLAY_CRC_STATUS_FORMAT_1;
typedef struct _NVAPI_DISPLAY_CRC_ENTRY_FORMAT_1 {
  NvU32 auditTimestamp : 20;
  NvU32 tag : 8;
  NvU32 bTimestampMode : 1;
  NvU32 bHwFliplockMode : 1;
  NvU32 bPresentIntervalMet : 1;
  NvU32 reserved : 1;
  NvU32 compositorCrc;
  NvU32 primaryOutputCrc;
  NvU32 secondaryOutputCrc;
} NVAPI_DISPLAY_CRC_ENTRY_FORMAT_1;
typedef struct _NVAPI_DISPLAY_CRC_STATUS_FORMAT_2 {
  NvU32 bDone : 1;
  NvU32 bOverrun : 1;
  NvU32 bCompositorOverflow : 1;
  NvU32 bPrimaryOutputOverflow : 1;
  NvU32 bSecondaryOutputOverflow : 1;
  NvU32 bExpectBufferCollapse : 1;
  NvU32 bFeOverflow : 1;
  NvU32 bRgOverflow : 1;
  NvU32 bColorDepthAgnostic : 1;
  NvU32 reserved : 23;
} NVAPI_DISPLAY_CRC_STATUS_FORMAT_2;
typedef struct _NVAPI_DISPLAY_CRC_ENTRY_FORMAT_2 {
  NvU32 tag : 8;
  NvU32 bPresentIntervalMet : 1;
  NvU32 bInterlaced : 1;
  NvU32 bDither : 1;
  NvU32 bStereo : 1;
  NvU32 bTimestampMode : 1;
  NvU32 bSli : 1;
  NvU32 interlacedMode : 1;
  NvU32 stereoMode : 1;
  NvU32 ditherPhase : 2;
  NvU32 stereoPhase : 1;
  NvU32 interlacedField : 1;
  NvU32 reserved : 12;
  NvU32 compositorCrc;
  NvU32 rgCrc;
  NvU32 primaryOutputCrc;
  NvU32 secondaryOutputCrc;
  NvU32 userDefinedInfo;
} NVAPI_DISPLAY_CRC_ENTRY_FORMAT_2;
typedef struct _NVAPI_DISPLAY_CRC_DATA_V1 {
  NvU32 version;
  NvU32 reqEntryCount;
  NvU32 readEntryCount;
  NvU32 reserved[4];
  NVAPI_DISPLAY_CRC_DATA_FORMAT format;
  union {
    struct {
      NVAPI_DISPLAY_CRC_STATUS_FORMAT_1 status;
      NVAPI_DISPLAY_CRC_ENTRY_FORMAT_1 entry[NVAPI_DISPLAY_CRC_MAX_ENTRY_COUNT_FORMAT_1];
    } format1;
    struct {
      NVAPI_DISPLAY_CRC_STATUS_FORMAT_2 status;
      NVAPI_DISPLAY_CRC_ENTRY_FORMAT_2 entry[NVAPI_DISPLAY_CRC_MAX_ENTRY_COUNT_FORMAT_2];
    } format2;
  };
} NVAPI_DISPLAY_CRC_DATA_V1;
typedef NVAPI_DISPLAY_CRC_DATA_V1 NVAPI_DISPLAY_CRC_DATA;
#define NVAPI_DISPLAY_CRC_DATA_VER1 MAKE_NVAPI_VERSION(NVAPI_DISPLAY_CRC_DATA_V1, 1)
#define NVAPI_DISPLAY_CRC_DATA_VER NVAPI_DISPLAY_CRC_DATA_VER1
NVAPI_INTERFACE NvAPI_ReadDisplayCrcDataEx(__in NvU32 displayId, __inout NVAPI_DISPLAY_CRC_DATA *pDisplayCrcData);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 340. Instead, use NvAPI_GPU_QueryActiveAppsEx.")
    NVAPI_INTERFACE
    NvAPI_GPU_QueryActiveApps(NvPhysicalGpuHandle hPhysicalGpu, NV_3D_APP_INFO apps[NVAPI_MAX_3D_Apps], NvU32 *total);
#define NV_APP_ALL 0x8fffffff
#define NV_APP_3D_CONTEXT 0x00000001
#define NV_APP_OPEN_ADAPTER 0x00000002
NVAPI_INTERFACE NvAPI_GPU_QueryActiveAppsEx(__in NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 flag,
                                            __inout NV_3D_APP_INFO *apps, __inout NvU32 *count);
typedef enum { NV_GPU_NETLIST_REV0 = 0x00000012, NV_GPU_NETLIST_REV1 = 0x00000013 } NV_GPU_NETLIST_REV;
NVAPI_INTERFACE NvAPI_GPU_GetNetlistIdentifier(NvPhysicalGpuHandle nvGPUHandle, NV_GPU_NETLIST_REV revIndex,
                                               NvU32 *pValue);
#define NVAPI_GPIO_SIZE_QUERY_ARRAY 0x00000020
typedef enum { NVAPI_GPIO_DIRECTION_INPUT, NVAPI_GPIO_DIRECTION_OUTPUT } NVAPI_GPIO_DIRECTION;
typedef struct {
  NvU32 version;
  NvU32 gpioPinCount;
  NvU32 gpioLegalPins[NVAPI_GPIO_SIZE_QUERY_ARRAY];
} NV_GPU_GPIO_LEGAL_PINS;
#define NV_GPU_GPIO_LEGAL_PINS_VER MAKE_NVAPI_VERSION(NV_GPU_GPIO_LEGAL_PINS, 1)
NVAPI_INTERFACE NvAPI_GPU_GPIOQueryLegalPins(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GPIO_LEGAL_PINS *pgpioLegalPins);
typedef struct {
  NvU32 version;
  NvU32 gpioPinNumber;
  NvU32 gpioDataReadWrite;
  NVAPI_GPIO_DIRECTION gpioDirection;
} NV_GPU_GPIO_PIN_DATA;
#define NV_GPU_GPIO_PIN_DATA_VER MAKE_NVAPI_VERSION(NV_GPU_GPIO_PIN_DATA, 1)
NVAPI_INTERFACE NvAPI_GPU_GPIOReadFromPin(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GPIO_PIN_DATA *pgpioReadPin);
NVAPI_INTERFACE NvAPI_GPU_GPIOWriteToPin(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_GPIO_PIN_DATA *pgpioWritePin);
typedef enum _NV_GPU_HDCP_FUSE_STATE {
  NV_GPU_HDCP_FUSE_STATE_UNKNOWN = 0,
  NV_GPU_HDCP_FUSE_STATE_DISABLED = 1,
  NV_GPU_HDCP_FUSE_STATE_ENABLED = 2,
} NV_GPU_HDCP_FUSE_STATE;
typedef enum _NV_GPU_HDCP_KEY_SOURCE {
  NV_GPU_HDCP_KEY_SOURCE_UNKNOWN = 0,
  NV_GPU_HDCP_KEY_SOURCE_NONE = 1,
  NV_GPU_HDCP_KEY_SOURCE_CRYPTO_ROM = 2,
  NV_GPU_HDCP_KEY_SOURCE_SBIOS = 3,
  NV_GPU_HDCP_KEY_SOURCE_I2C_ROM = 4,
  NV_GPU_HDCP_KEY_SOURCE_FUSES = 5,
} NV_GPU_HDCP_KEY_SOURCE;
typedef enum _NV_GPU_HDCP_KEY_SOURCE_STATE {
  NV_GPU_HDCP_KEY_SOURCE_STATE_UNKNOWN = 0,
  NV_GPU_HDCP_KEY_SOURCE_STATE_ABSENT = 1,
  NV_GPU_HDCP_KEY_SOURCE_STATE_PRESENT = 2,
} NV_GPU_HDCP_KEY_SOURCE_STATE;
typedef struct {
  NvU32 version;
  NV_GPU_HDCP_FUSE_STATE hdcpFuseState;
  NV_GPU_HDCP_KEY_SOURCE hdcpKeySource;
  NV_GPU_HDCP_KEY_SOURCE_STATE hdcpKeySourceState;
} NV_GPU_GET_HDCP_SUPPORT_STATUS;
#define NV_GPU_GET_HDCP_SUPPORT_STATUS_VER MAKE_NVAPI_VERSION(NV_GPU_GET_HDCP_SUPPORT_STATUS, 1)
NVAPI_INTERFACE NvAPI_GPU_GetHDCPSupportStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_GET_HDCP_SUPPORT_STATUS *pGetHDCPSupportStatus);
typedef struct {
  NvU32 version;
  struct {
    NvU32 bGpuCapable : 1;
    NvU32 bGpuFusePresent : 1;
    NvU32 bDfpCapable : 1;
    NvU32 bDfpAllowed : 1;
    NvU32 bDfpDualLink : 1;
    NvU32 bRomError : 1;
    NvU32 bDownstreamChecksumError : 1;
    NV_HDCP_PACKET packet;
  } hdcp;
  struct {
    NvU32 bGpuCapable : 1;
    NvU32 bDfpCapable : 1;
    NvU32 bDfpAllowed : 1;
    NvU32 bDfpDualLink : 1;
  } hdmi;
} NV_HDCP_HDMI_DIAGNOSTICS;
#define NV_GET_HDCP_HDMI_DIAGNOSTICS_VER MAKE_NVAPI_VERSION(NV_HDCP_HDMI_DIAGNOSTICS, 1)
NVAPI_INTERFACE NvAPI_GetHdcpHdmiDiagnostics(NvPhysicalGpuHandle hPhysicalGpu, NvU32 displayId,
                                             NV_HDCP_HDMI_DIAGNOSTICS *pHdcpHdmiDiagnostics);
NVAPI_INTERFACE NvAPI_GPU_GetACPIIdFromOutputId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 pOutputId[NVAPI_MAX_ACPI_IDS],
                                                NvU32 uOutputIdCount, NvU32 pACPIid[NVAPI_MAX_ACPI_IDS]);
NVAPI_INTERFACE NvAPI_GPU_GetOutputIdFromACPIId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 pACPIid[NVAPI_MAX_ACPI_IDS],
                                                NvU32 uACPIidCount, NvU32 pOutputId[NVAPI_MAX_ACPI_IDS]);
typedef enum {
  NV_DISPLAY_POWER_SAVING_NOT_SUPPORTED = -1,
  NV_DISPLAY_POWER_SAVING_DISABLED = 0,
  NV_DISPLAY_POWER_SAVING_ENABLED = 1
} NV_DISPLAY_POWER_SAVING;
NVAPI_INTERFACE NvAPI_SYS_GetDisplayPowerSavingState(NV_DISPLAY_POWER_SAVING *pState);
NVAPI_INTERFACE NvAPI_SYS_SetDisplayPowerSavingState(NV_DISPLAY_POWER_SAVING State);
NVAPI_INTERFACE NvAPI_GPU_GetSupportedSLIViews(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_TARGET_VIEW_MODE pTargetViews[NVAPI_MAX_VIEW_MODES],
                                               NvU32 *pViewCount);
NVAPI_INTERFACE NvAPI_SetTopologyFocusDisplayAndView(NvLogicalGpuHandle hLogicalGPU, NvU32 focusDisplayOutputId,
                                                     NV_DISPLAY_PATH_INFO *pPathInfo, NV_TARGET_VIEW_MODE displayView);
NVAPI_INTERFACE NvAPI_GetDriverModel(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pDriverModel);
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_CAPABLE NV_BIT(0)
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_ENABLE NV_BIT(1)
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_DEDICATED NV_BIT(2)
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_RECOMMENDED NV_BIT(3)
#define NV_COMPUTE_GPU_TOPOLOGY_CUDA_AVAILABLE NV_BIT(4)
#define NV_COMPUTE_GPU_PRIVATE_MASK 0xFFFF0000
#define NV_COMPUTE_GPU_TOPOLOGY_CUDA_CAPABLE NV_BIT(16)
#define NV_COMPUTE_GPU_TOPOLOGY_CUDA_DISABLED NV_BIT(17)
#define NV_COMPUTE_GPU_TOPOLOGY_IDM_ENABLED NV_BIT(18)
#define NV_COMPUTE_GPU_TOPOLOGY_IDM_ACTIVE NV_BIT(19)
#define NV_COMPUTE_GPU_TOPOLOGY_CUDA_HYBRID_DISABLED NV_BIT(20)
#define NV_COMPUTE_GPU_TOPOLOGY_PHYSICS_AVAILABLE NV_BIT(21)
typedef struct {
  NvU32 version;
  NvU32 gpuCount;
  struct {
    NvPhysicalGpuHandle hPhysicalGpu;
    NvU32 flags;
  } computeGpus[NVAPI_MAX_GPU_PER_TOPOLOGY];
} NV_COMPUTE_GPU_TOPOLOGY_V1;
typedef struct _NV_COMPUTE_GPU {
  NvPhysicalGpuHandle hPhysicalGpu;
  NvU32 flags;
} NV_COMPUTE_GPU;
typedef struct _NV_COMPUTE_GPU_TOPOLOGY_V2 {
  NvU32 version;
  NvU32 gpuCount;
  NV_COMPUTE_GPU *computeGpus;
} NV_COMPUTE_GPU_TOPOLOGY_V2;
#define NV_COMPUTE_GPU_TOPOLOGY_VER1 MAKE_NVAPI_VERSION(NV_COMPUTE_GPU_TOPOLOGY_V1, 1)
#define NV_COMPUTE_GPU_TOPOLOGY_VER MAKE_NVAPI_VERSION(NV_COMPUTE_GPU_TOPOLOGY_V2, 2)
typedef NV_COMPUTE_GPU_TOPOLOGY_V2 NV_COMPUTE_GPU_TOPOLOGY;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 319.") NVAPI_INTERFACE
    NvAPI_GPU_CudaEnumComputeCapableGpus(__inout NV_COMPUTE_GPU_TOPOLOGY *pComputeTopo);
NVAPI_INTERFACE NvAPI_CUDA_EnumComputeCapableByTopology(__inout NV_COMPUTE_GPU_TOPOLOGY *computeTopo,
                                                        __in_opt NV_GPU_VALID_GPU_TOPOLOGIES *gpuTopology,
                                                        __in NvU32 pathInfoCount,
                                                        __in_opt NV_DISPLAYCONFIG_PATH_INFO *pathInfo);
typedef enum { NV_DEEP_IDLE_NOT_SUPPORTED = -1, NV_DEEP_IDLE_DISABLE = 0, NV_DEEP_IDLE_ENABLE = 1 } NV_DEEP_IDLE_STATE;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 510.") NVAPI_INTERFACE
    NvAPI_GPU_GetDeepIdleState(NvLogicalGpuHandle hLogicalGpu, NV_DEEP_IDLE_STATE *pState);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 510.") NVAPI_INTERFACE
    NvAPI_GPU_SetDeepIdleState(NvLogicalGpuHandle hLogicalGpu, NV_DEEP_IDLE_STATE State);
typedef enum {
  NV_DEEP_IDLE_STATISTICS_MODE_NH,
  NV_DEEP_IDLE_STATISTICS_MODE_VE,
  NV_DEEP_IDLE_STATISTICS_MODE_SSC,
  NV_DEEP_IDLE_STATISTICS_MODE_FO
} NV_DEEP_IDLE_STATISTICS_MODE;
typedef struct {
  NvU32 version;
  NvU32 attempts;
  NvU32 entries;
  NvU32 exits;
  NvU32 time;
  NvU32 maxEntryLatency;
  NvU32 maxExitLatency;
  NvU32 veFrames;
  NvU32 veVblankExits;
  NvU32 veDeepL1Exits;
} NV_DEEP_IDLE_STATISTICS;
#define NV_DEEP_IDLE_STATISTICS_VER MAKE_NVAPI_VERSION(NV_DEEP_IDLE_STATISTICS, 1)
NVAPI_INTERFACE NvAPI_GPU_SetDeepIdleStatisticsMode(NvPhysicalGpuHandle hPhysicalGpu, NV_DEEP_IDLE_STATISTICS_MODE Mode,
                                                    NvU32 bReset);
NVAPI_INTERFACE NvAPI_GPU_GetDeepIdleStatistics(NvPhysicalGpuHandle hPhysicalGpu, NV_DEEP_IDLE_STATISTICS *pStatistics);
NVAPI_INTERFACE NvAPI_GPU_GetTachReading(NvPhysicalGpuHandle hPhysicalGPU, NvU32 *pValue);
NVAPI_INTERFACE NvAPI_GPU_CreateStringHashFromPhysicalGpu(NvPhysicalGpuHandle hPhysicalGpu, NvU32 nSize,
                                                          NvAPI_String szHash);
NVAPI_INTERFACE NvAPI_GPU_ConvertStringHashToPhysicalGpu(NvAPI_String szHash, NvPhysicalGpuHandle hPhysicalGpu);
NVAPI_INTERFACE NvAPI_GPU_QueryDPTopology(__in NvU32 displayId,
                                          __inout_ecount_full_opt(*pNumOfNodes) NV_DP_NODE_INFO *pNodes,
                                          __inout NvU32 *pNumOfNodes);
#define NV_DP_QUERY_TOPOLOGY_EX_FLAGS_DEFAULT 0
#define NV_DP_QUERY_TOPOLOGY_EX_FLAGS_INCLUDE_DIRECTMODE_DISPLAYS 1 << 0
#define NV_DP_QUERY_TOPOLOGY_EX_FLAGS_INCLUDE_OS_DEDICATED_DISPLAYS 1 << 1
#define NV_DP_QUERY_TOPOLOGY_EX_FLAGS_INCLUDE_SLAVE_TILE_DISPLAYS 1 << 2
typedef struct _NV_DP_QUERY_TOPOLOGY_EX_PARAMS_V1 {
  NvU32 version;
  NvU32 rootDisplayId;
  NvU32 flags;
  NvU32 numNodes;
  NV_DP_NODE_INFO *pNodes;
} NV_DP_QUERY_TOPOLOGY_EX_PARAMS_V1;
typedef NV_DP_QUERY_TOPOLOGY_EX_PARAMS_V1 NV_DP_QUERY_TOPOLOGY_EX_PARAMS;
#define NV_DP_QUERY_TOPOLOGY_EX_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_DP_QUERY_TOPOLOGY_EX_PARAMS, 1)
#define NV_DP_QUERY_TOPOLOGY_EX_PARAMS_VER NV_DP_QUERY_TOPOLOGY_EX_PARAMS_VER_1
NVAPI_INTERFACE NvAPI_GPU_QueryDPTopologyEx(__inout NV_DP_QUERY_TOPOLOGY_EX_PARAMS *pParams);
#define MAX_PCLK_RANGES 10
typedef struct {
  NvU32 uMaxPixClk;
  NvU32 uMinPixClk;
} NV_PCLK_RANGE;
typedef struct {
  NvU32 uOrgPixelClock;
  NvU32 uCurrPixelClock;
  NvU32 uCurrSpreadSpectrum;
  NV_PCLK_RANGE uFineAdjustBounds;
  NV_PCLK_RANGE uCourseAdjustBounds;
} NV_GET_PCLK;
typedef struct {
  NV_PCLK_RANGE uAllowedRanges[MAX_PCLK_RANGES];
  NV_PCLK_RANGE uDisallowedRanges[MAX_PCLK_RANGES];
} NV_SET_PCLK;
typedef struct _NV_GET_PLATFORM_POWER_MODE_PARM_V1 {
  NvU32 version;
  NvU32 currentPPMIndex;
  NvU32 supportedPPMMask;
} NV_GET_PLATFORM_POWER_MODE_PARM_V1;
typedef NV_GET_PLATFORM_POWER_MODE_PARM_V1 NV_GET_PLATFORM_POWER_MODE_PARM;
#define NV_GET_PLATFORM_POWER_MODE_PARM_VER_1 MAKE_NVAPI_VERSION(NV_GET_PLATFORM_POWER_MODE_PARM_V1, 1)
#define NV_GET_PLATFORM_POWER_MODE_PARM_VER NV_GET_PLATFORM_POWER_MODE_PARM_VER_1
NVAPI_INTERFACE NvAPI_GetPlatformPowerMode(__inout NV_GET_PLATFORM_POWER_MODE_PARM *pParams);
typedef struct _NV_SET_PLATFORM_POWER_MODE_PARM_V1 {
  NvU32 version;
  NvU32 newPPMIndex;
} NV_SET_PLATFORM_POWER_MODE_PARM_V1;
typedef NV_SET_PLATFORM_POWER_MODE_PARM_V1 NV_SET_PLATFORM_POWER_MODE_PARM;
#define NV_SET_PLATFORM_POWER_MODE_PARM_VER_1 MAKE_NVAPI_VERSION(NV_SET_PLATFORM_POWER_MODE_PARM_V1, 1)
#define NV_SET_PLATFORM_POWER_MODE_PARM_VER NV_SET_PLATFORM_POWER_MODE_PARM_VER_1
NVAPI_INTERFACE NvAPI_SetPlatformPowerMode(__in NV_SET_PLATFORM_POWER_MODE_PARM *pParams);
typedef enum { NV_GPS_PS_DISABLED = 0, NV_GPS_PS_ENABLED = 1, NV_GPS_PS_NOT_SUPPORTED = 2 } NV_GPS_PS_STATUS;
NVAPI_INTERFACE NvAPI_GPS_GetPowerSteeringStatus(__out NV_GPS_PS_STATUS *pPowerSteeringStatus);
NVAPI_INTERFACE NvAPI_GPS_SetPowerSteeringStatus(__in NV_GPS_PS_STATUS PowerSteeringStatus);
#define MAX_GPS_FRM_BUFFER_SIZE 64
typedef struct _NV_GPS_GET_FRM_DATA_NODE {
  NvU16 frameTime;
  NvU16 renderTime;
  NvU16 targetTime;
  NvU8 sleepTime;
  NvU8 sampleNumber;
} NV_GPS_GET_FRM_DATA_NODE;
typedef struct _NV_GPS_GET_FRM_DATA {
  NvU32 version;
  NvU8 nextSampleNumber;
  NV_GPS_GET_FRM_DATA_NODE frmSampleData[MAX_GPS_FRM_BUFFER_SIZE];
} NV_GPS_GET_FRM_DATA_V1;
typedef NV_GPS_GET_FRM_DATA_V1 NV_GPS_GET_FRM_DATA;
#define NV_GPS_GET_FRM_DATA_VER_1 MAKE_NVAPI_VERSION(NV_GPS_GET_FRM_DATA, 1)
#define NV_GPS_GET_FRM_DATA_VER NV_GPS_GET_FRM_DATA_VER_1
NVAPI_INTERFACE NvAPI_GPS_GetFrmData(__inout NV_GPS_GET_FRM_DATA *pFrmData);
NVAPI_INTERFACE NvAPI_GPS_SetVPStateCap(__in NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 newCap);
NVAPI_INTERFACE NvAPI_GPS_GetVPStateCap(__in NvPhysicalGpuHandle hPhysicalGpu, __out NvU32 *pCurCap);
typedef enum {
  NV_GPS_SENSOR_INDEX_TGPU_LIMIT = 9,
  NV_GPS_SENSOR_INDEX_PDTS_LIMIT = 10,
  NV_GPS_SENSOR_INDEX_SFAN_LIMIT = 11,
  NV_GPS_SENSOR_INDEX_SKNT_LIMIT = 12,
  NV_GPS_SENSOR_INDEX_CPUE_LIMIT = 13,
  NV_GPS_SENSOR_INDEX_TMP1_LIMIT = 14,
  NV_GPS_SENSOR_INDEX_TMP2_LIMIT = 15
} NV_GPS_SENSOR_INDEX;
typedef enum {
  NV_GPS_THERM_LIMIT_SRC_USER_LIMITED = 1,
  NV_GPS_THERM_LIMIT_SRC_SBIOS_LIMITED = 2,
  NV_GPS_THERM_LIMIT_SRC_SBIOS_UNLIMITED = 3,
  NV_GPS_THERM_LIMIT_SRC_SBIOS_NOT_SUPPORTED = 4,
  NV_GPS_THERM_LIMIT_SRC_USER_DISABLED = 5
} NV_GPS_THERM_LIMIT_SRC;
#define NV_GPS_THERM_LIMIT_SBIOS_LIMITED 0
#define NV_GPS_THERM_LIMIT_NOT_LIMITED 1
typedef struct _NV_GPS_GET_THERMAL_LIMIT_PARM {
  NvU32 version;
  NV_GPS_SENSOR_INDEX sensorIndex;
  NvU32 limit;
  NvU32 lowerBound;
  NvU32 upperBound;
  NV_GPS_THERM_LIMIT_SRC limitSource;
} NV_GPS_GET_THERMAL_LIMIT_PARM_V1;
typedef NV_GPS_GET_THERMAL_LIMIT_PARM_V1 NV_GPS_GET_THERMAL_LIMIT_PARM;
#define NV_GPS_GET_THERMAL_LIMIT_PARM_VER_1 MAKE_NVAPI_VERSION(NV_GPS_GET_THERMAL_LIMIT_PARM_V1, 1)
#define NV_GPS_GET_THERMAL_LIMIT_PARM_VER NV_GPS_GET_THERMAL_LIMIT_PARM_VER_1
NVAPI_INTERFACE NvAPI_GPS_GetThermalLimit(__inout NV_GPS_GET_THERMAL_LIMIT_PARM *pParams);
typedef struct _NV_GPS_SET_THERMAL_LIMIT_PARM {
  NvU32 version;
  NV_GPS_SENSOR_INDEX sensorIndex;
  NvU32 newLimit;
} NV_GPS_SET_THERMAL_LIMIT_PARM_V1;
typedef NV_GPS_SET_THERMAL_LIMIT_PARM_V1 NV_GPS_SET_THERMAL_LIMIT_PARM;
#define NV_GPS_SET_THERMAL_LIMIT_PARM_VER_1 MAKE_NVAPI_VERSION(NV_GPS_SET_THERMAL_LIMIT_PARM_V1, 1)
#define NV_GPS_SET_THERMAL_LIMIT_PARM_VER NV_GPS_SET_THERMAL_LIMIT_PARM_VER_1
NVAPI_INTERFACE NvAPI_GPS_SetThermalLimit(__in NV_GPS_SET_THERMAL_LIMIT_PARM *pParams);
typedef enum {
  NvGpsGetPowerSteeringStatus = 0,
  NvGpsSetPowerSteeringStatus = 1,
  NvGpsGetThermLimit = 2,
  NvGpsSetThermLimit = 3,
  NvGpsGetTempCtrlDownNDelta = 4,
  NvGpsSetTempCtrlDownNDelta = 5,
  NvGpsGetTempCtrlHoldDelta = 6,
  NvGpsSetTempCtrlHoldDelta = 7,
  NvGpsGetTempCtrlUpDelta = 8,
  NvGpsSetTempCtrlUpDelta = 9,
  NvGpsGetTempCtrlEngageDelta = 10,
  NvGpsSetTempCtrlEngageDelta = 11,
  NvGpsGetTempCtrlDisengageDelta = 12,
  NvGpsSetTempCtrlDisengageDelta = 13,
  NvGpuGetEngadgeThresholdUp = 14,
  NvGpuSetEngadgeThresholdUp = 15,
  NvGpuGetDisengageThresholdDown = 16,
  NvGpuSetDisengageThresholdDown = 17,
  NvCpuGetHystHigh = 18,
  NvCpuSetHystHigh = 19,
  NvCpuGetHystLow = 20,
  NvCpuSetHystLow = 21,
  NvGpsGetTempCtrl = 22,
  NvGpsSetTempCtrl = 23,
  NvCpuGetUtilAvgNum = 24,
  NvCpuSetUtilAvgNum = 25,
  NvGpsGetPerfCounter = 26,
  NvGpsCallAcpi = 27,
  NvGpsSetIGpuTurbo = 28,
  NvGpsGetHystHighAc = 55,
  NvGpsSetHystHighAc = 56,
  NvGpsGetHystLowAc = 57,
  NvGpsSetHystLowAc = 58,
  NvGpsGetHystHighBatt = 59,
  NvGpsSetHystHighBatt = 60,
  NvGpsGetHystLowBatt = 61,
  NvGpsSetHystLowBatt = 62,
  NvGpsGetHystHighBBoost = 63,
  NvGpsSetHystHighBBoost = 64,
  NvGpsGetHystLowBBoost = 65,
  NvGpsSetHystLowBBoost = 66,
  NvGpsGetCpuPackageLimits = 68,
  NvGpsSetCpuPackageLimits = 69,
  NvGpsGetCpuFrequencyLimit = 70,
  NvGpsSetCpuFrequencyLimit = 71,
  NvGpsGetPlatformPowerMode = 72,
  NvGpsSetPlatformPowerMode = 73
} NV_GPS_CTRL_CMD;
typedef struct _NV_GPS_CTRL_PARM_V1 {
  NvU32 version;
  NV_GPS_CTRL_CMD cmd;
  NvS32 input[2];
  NvS32 result[4];
} NV_GPS_CTRL_PARM_V1;
typedef NV_GPS_CTRL_PARM_V1 NV_GPS_CTRL_PARM;
#define NV_GPS_CTRL_PARM_VER_1 MAKE_NVAPI_VERSION(NV_GPS_CTRL_PARM_V1, 1)
#define NV_GPS_CTRL_PARM_VER NV_GPS_CTRL_PARM_VER_1
NVAPI_INTERFACE NvAPI_GPS_Ctrl(__inout NV_GPS_CTRL_PARM *pParams);
#define MAX_GPS_ACPI_RESULT_BUFFER 192
#define MAX_GPS_ACPI_RESULT_BUFFER_VER2 288
typedef struct _NV_GPS_ACPI_PARM_V1 {
  NvU32 version;
  NvU32 cmd;
  NvU32 input;
  NvU32 resultSz;
  NvU32 result[MAX_GPS_ACPI_RESULT_BUFFER];
} NV_GPS_ACPI_PARM_V1;
typedef struct _NV_GPS_ACPI_PARM_V2 {
  NvU32 version;
  NvU32 cmd;
  NvU32 input;
  NvU32 resultSz;
  NvU32 result[MAX_GPS_ACPI_RESULT_BUFFER_VER2];
} NV_GPS_ACPI_PARM_V2;
typedef NV_GPS_ACPI_PARM_V2 NV_GPS_ACPI_PARM;
#define NV_GPS_ACPI_PARM_VER_1 MAKE_NVAPI_VERSION(NV_GPS_ACPI_PARM_V1, 1)
#define NV_GPS_ACPI_PARM_VER_2 MAKE_NVAPI_VERSION(NV_GPS_ACPI_PARM_V2, 2)
#define NV_GPS_ACPI_PARM_VER NV_GPS_ACPI_PARM_VER_2
NVAPI_INTERFACE NvAPI_GPS_CallACPI(__inout NV_GPS_ACPI_PARM *pParams);
#define GPS_PSC_PS_TC_DYNAMIC_SENSOR_BLOCK 0
#define GPS_PSC_PS_TC_CPU_UTIL_SENSOR_BLOCK 2
#define GPS_PSC_ACPI_SENSOR_BLOCK 3
typedef enum {
  GPS_PSC_SB0_PS_SID = 0,
  GPS_PSC_SB0_PS_ENABLE = 1,
  GPS_PSC_SB0_CPU_PSTATE_CAP = 5,
  GPS_PSC_SB0_CPU_TSTATE_CAP = 7,
  GPS_PSC_SB0_GPU_UTIL = 9,
  GPS_PSC_SB0_GPU_TEMP = 15,
  GPS_PSC_SB0_TC_TRGT_TEMP = 16,
  GPS_PSC_SB0_PM1_STATE_AVAIL = 18,
  GPS_PSC_SB0_TDP_IDX = 19,
  GPS_PSC_SB0_GPU_VPSTATE = 24,
  GPS_PSC_SB0_GPU_VPSTATE_CAP = 25,
  GPS_PSC_SB0_TGPU_CURR_VALUE = 26,
} GPS_PSC_SB0_INDEX;
typedef struct _NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1 {
  NvU32 version;
  NvU32 objHndl;
  NvU16 blockId;
  NvU32 nextExpectedSampleTime;
  NvU32 countersReq;
  NvU32 countersReturned;
  NvU32 counterBlock[32];
} NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1;
typedef NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1 NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM;
#define NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_VER_1 MAKE_NVAPI_VERSION(NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_V1, 1)
#define NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_VER NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM_VER_1
NVAPI_INTERFACE NvAPI_GPS_GetPerfSensors(__inout NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM *pParams);
typedef enum {
  GPS_PSC_EXT_SB0_PS_SID = 0,
  GPS_PSC_EXT_SB0_PS_ENABLE = 1,
  GPS_PSC_EXT_SB0_CPU_TEMP = 2,
  GPS_PSC_EXT_SB0_PS_CPU_CORE_UTIL_MAX = 3,
  GPS_PSC_EXT_SB0_CPU_PSTATE = 4,
  GPS_PSC_EXT_SB0_CPU_PSTATE_CAP = 5,
  GPS_PSC_EXT_SB0_CPU_TSTATE = 6,
  GPS_PSC_EXT_SB0_CPU_TSTATE_CAP = 7,
  GPS_PSC_EXT_SB0_PPC_LIMIT = 8,
  GPS_PSC_EXT_SB0_GPU_UTIL = 9,
  GPS_PSC_EXT_SB0_GPU_CORE_UTIL = 10,
  GPS_PSC_EXT_SB0_GPU_FB_UTIL = 11,
  GPS_PSC_EXT_SB0_GPU_VIDEO_UTIL = 12,
  GPS_PSC_EXT_SB0_TC_SID = 13,
  GPS_PSC_EXT_SB0_TC_ENABLE = 14,
  GPS_PSC_EXT_SB0_GPU_TEMP = 15,
  GPS_PSC_EXT_SB0_TC_TRGT_TEMP = 16,
  GPS_PSC_EXT_SB0_PM1_SID = 17,
  GPS_PSC_EXT_SB0_PM1_STATE_AVAIL = 18,
  GPS_PSC_EXT_SB0_TDP_IDX = 19,
  GPS_PSC_EXT_SB0_MS_SID = 20,
  GPS_PSC_EXT_SB0_IGP_TURBO_STATUS = 21,
  GPS_PSC_EXT_SB0_GPU_GPC_CLK = 22,
  GPS_PSC_EXT_SB0_GPU_NVDD = 23,
  GPS_PSC_EXT_SB0_GPU_FSTATE = 24,
  GPS_PSC_EXT_SB0_GPU_FSTATE_CAP = 25,
  GPS_PSC_EXT_SB0_TGPU_CURR_VALUE = 26,
  GPS_PSC_EXT_SB0_PS_APERF_CPU_FREQ = 28,
  GPS_PSC_EXT_SB0_PS_MSR_CPU_FREQ = 29,
  GPS_PSC_EXT_SB0_PS_EXP_CPU_FREQ = 30,
} GPS_PSC_EXT_SB0_INDEX;
typedef enum {
  GPS_PSC_EXT_SB1_PS_SID = 0,
  GPS_PSC_EXT_SB1_PS_SAMPLE_PERIOD_MS = 1,
  GPS_PSC_EXT_SB1_PS_ENGAGE_TEMP_DELTA = 2,
  GPS_PSC_EXT_SB1_PS_CPU_MIN_FREQ_MHZ = 3,
  GPS_PSC_EXT_SB1_PS_CPU_MAX_FREQ_MHZ = 4,
  GPS_PSC_EXT_SB1_PS_CPU_HYST_HIGH = 5,
  GPS_PSC_EXT_SB1_PS_CPU_HYST_LOW = 6,
  GPS_PSC_EXT_SB1_PS_CPU_C0_CORE_THRESH = 7,
  GPS_PSC_EXT_SB1_PS_CPU_UTIL_AVG_NUM = 8,
  GPS_PSC_EXT_SB1_TC_SID = 12,
  GPS_PSC_EXT_SB1_TC_SAMPLE_PERIOD_MS = 13,
  GPS_PSC_EXT_SB1_TC_ENGAGE_TEMP = 14,
  GPS_PSC_EXT_SB1_TC_DISENGAGE_TEMP = 15,
  GPS_PSC_EXT_SB1_TC_DOWN_N_THRESH = 16,
  GPS_PSC_EXT_SB1_TC_HOLD_THRESH = 17,
  GPS_PSC_EXT_SB1_TC_UP_THRESH = 18,
} GPS_PSC_EXT_SB1_INDEX;
typedef enum {
  GPS_PSC_EXT_SB3_TGPU_CURR_VALUE = 0,
  GPS_PSC_EXT_SB3_PDTS_CURR_VALUE = 1,
  GPS_PSC_EXT_SB3_SFAN_CURR_VALUE = 2,
  GPS_PSC_EXT_SB3_SKNT_CURR_VALUE = 3,
  GPS_PSC_EXT_SB3_CPUE_CURR_VALUE = 4,
  GPS_PSC_EXT_SB3_TMP1_CURR_VALUE = 5,
  GPS_PSC_EXT_SB3_TMP2_CURR_VALUE = 6,
  GPS_PSC_EXT_SB3_TGPU_LIMIT = 8,
  GPS_PSC_EXT_SB3_PDTS_LIMIT = 9,
  GPS_PSC_EXT_SB3_FAN_LIMIT = 10,
  GPS_PSC_EXT_SB3_SKNT_LIMIT = 11,
  GPS_PSC_EXT_SB3_CPUE_LIMIT = 12,
  GPS_PSC_EXT_SB3_TMP1_LIMIT = 13,
  GPS_PSC_EXT_SB3_TMP2_LIMIT = 14,
  GPS_PSC_EXT_SB3_TGPU_PERIOD = 16,
  GPS_PSC_EXT_SB3_PDTS_PERIOD = 17,
  GPS_PSC_EXT_SB3_SFAN_PERIOD = 18,
  GPS_PSC_EXT_SB3_SKNT_PERIOD = 19,
  GPS_PSC_EXT_SB3_CPUE_PERIOD = 20,
  GPS_PSC_EXT_SB3_TMP1_PERIOD = 21,
  GPS_PSC_EXT_SB3_TMP2_PERIOD = 22,
  GPS_PSC_EXT_SB3_AVAIL_SENSOR_MSK = 24,
  GPS_PSC_EXT_SB3_IGP_TURBO_STATUS = 25,
  GPS_PSC_EXT_SB3_CPU_CORE_COUNT = 26,
  GPS_PSC_EXT_SB3_CPU_CORE_UTIL_MAX = 27,
} GPS_PSC_EXT_SB3_INDEX;
NVAPI_INTERFACE NvAPI_GPS_GetPerfSensorsInternal(__inout NV_GPS_GET_PERF_SENSOR_COUNTERS_PARAM *pParams);
NVAPI_INTERFACE NvAPI_GPS_GetPM1Available(__out NvU32 *pAvailable);
NVAPI_INTERFACE NvAPI_GPS_SetPM1Available(__in NvU32 Available);
typedef struct {
  NvU32 version;
  NvU32 enabled : 1;
  NvU32 frameTimeFloorUs : 31;
  NvU32 frameTimeUs;
} NV_GPS_WEB_INFO_V1;
typedef NV_GPS_WEB_INFO_V1 NV_GPS_WEB_INFO;
#define NV_GPS_WEB_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPS_WEB_INFO_V1, 1)
#define NV_GPS_WEB_INFO_VER NV_GPS_WEB_INFO_VER1
NVAPI_INTERFACE NvAPI_GPS_SetWebInfo(__in NV_GPS_WEB_INFO *pInfo);
typedef enum _NV_ECC_CONFIGURATION {
  NV_ECC_CONFIGURATION_NOT_SUPPORTED = 0,
  NV_ECC_CONFIGURATION_DEFERRED,
  NV_ECC_CONFIGURATION_IMMEDIATE,
} NV_ECC_CONFIGURATION;
typedef struct {
  NvU32 version;
  NvU32 isSupported : 1;
  NV_ECC_CONFIGURATION configurationOptions;
  NvU32 isEnabled : 1;
} NV_GPU_ECC_STATUS_INFO;
#define NV_GPU_ECC_STATUS_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_ECC_STATUS_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetECCStatusInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_ECC_STATUS_INFO *pECCStatusInfo);
typedef struct {
  NvU32 version;
  struct {
    NvU64 singleBitErrors;
    NvU64 doubleBitErrors;
  } current;
  struct {
    NvU64 singleBitErrors;
    NvU64 doubleBitErrors;
  } aggregate;
} NV_GPU_ECC_ERROR_INFO;
#define NV_GPU_ECC_ERROR_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_ECC_ERROR_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetECCErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_ECC_ERROR_INFO *pECCErrorInfo);
typedef enum _NVAPI_GPU_ECC_STATUS_FLAGS_TYPE {
  NVAPI_GPU_ECC_STATUS_FLAGS_TYPE_FILTERED = 0x00000000,
  NVAPI_GPU_ECC_STATUS_FLAGS_TYPE_RAW = 0x00000001
} NVAPI_GPU_ECC_STATUS_FLAGS_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetECCErrorInfoEx(NvPhysicalGpuHandle hPhysicalGpu, NVAPI_GPU_ECC_STATUS_FLAGS_TYPE filter,
                                            NV_GPU_ECC_ERROR_INFO *pECCErrorInfo);
NVAPI_INTERFACE NvAPI_GPU_ResetECCErrorInfo(NvPhysicalGpuHandle hPhysicalGpu, NvU8 bResetCurrent, NvU8 bResetAggregate);
typedef struct {
  NvU32 version;
  NvU32 isEnabled : 1;
  NvU32 isEnabledByDefault : 1;
} NV_GPU_ECC_CONFIGURATION_INFO;
#define NV_GPU_ECC_CONFIGURATION_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_ECC_CONFIGURATION_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetECCConfigurationInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_ECC_CONFIGURATION_INFO *pECCConfigurationInfo);
NVAPI_INTERFACE NvAPI_GPU_SetECCConfiguration(NvPhysicalGpuHandle hPhysicalGpu, NvU8 bEnable, NvU8 bEnableImmediately);
NVAPI_INTERFACE NvAPI_GPU_InjectECCErrors(NvPhysicalGpuHandle hPhysicalGpu, NvU64 singleBitErrors,
                                          NvU64 doubleBitErrors);
NVAPI_INTERFACE NvAPI_CUDA_PhysxSetState(NvPhysicalGpuHandle hPhysicalGpu);
NVAPI_INTERFACE NvAPI_GPU_GetMaxSourceCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *maxSourceCount);
typedef struct {
  NvU32 version;
  NvU32 cudaAccessible : 1;
  NvU32 cudaCapable : 1;
  NvU32 cudaDisabled : 1;
  NvU32 cudaBlockedHybrid : 1;
  NvU32 cudaReserved : 4;
  NvU32 physxAvailable : 1;
  NvU32 physxCapable : 1;
  NvU32 physxEnabled : 1;
  NvU32 physxReserved : 5;
  NvU32 idmEnabled : 1;
  NvU32 idmActive : 1;
  NvU32 reserved : 14;
} NV_GPU_COMPUTE_CAPS;
#define NV_GPU_COMPUTE_CAPS_VER MAKE_NVAPI_VERSION(NV_GPU_COMPUTE_CAPS, 1)
NVAPI_INTERFACE NvAPI_GPU_QueryComputeCaps(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_COMPUTE_CAPS *pComputeCaps);
typedef struct {
  NvU32 version;
  NvU32 bIsInUse : 1;
  NvU32 bIsLinkedToSliDevice : 1;
  NvU32 bIsSysconConnected : 1;
  NvU32 bIsMobile : 1;
  NvU32 bIsBootMaster : 1;
  NvU32 bIsQuadro : 1;
  NvU32 bIsHackedDevId : 1;
  NvU32 bIsPanAndScanSupported : 1;
  NvU32 bIsCloneToFitSupported : 1;
  NvU32 bIsVRRSupported : 1;
  NvU32 reserved : 22;
} NV_GPU_FLAGS_V1;
typedef NV_GPU_FLAGS_V1 NV_GPU_FLAGS;
#define NV_GPU_FLAGS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FLAGS_V1, 1)
#define NV_GPU_FLAGS_VER NV_GPU_FLAGS_VER_1
NVAPI_INTERFACE NvAPI_GPU_QueryGpuFlags(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_FLAGS *pGpuFlags);
typedef enum {
  UNKNOWN_LEVEL = 0,
  NORMAL_LEVEL = 1,
  WARNING_LEVEL = 2,
  CRITICAL_LEVEL = 3,
} NV_EVENT_LEVEL;
typedef enum {
  NV_QSYNC_EVENT_NONE = 0,
  NV_QSYNC_EVENT_SYNC_LOSS = 1,
  NV_QSYNC_EVENT_SYNC_GAIN = 2,
  NV_QSYNC_EVENT_HOUSESYNC_GAIN = 3,
  NV_QSYNC_EVENT_HOUSESYNC_LOSS = 4,
  NV_QSYNC_EVENT_RJ45_GAIN = 5,
  NV_QSYNC_EVENT_RJ45_LOSS = 6,
} NV_QSYNC_EVENT;
typedef struct {
  NV_QSYNC_EVENT qsyncEvent;
  NvU32 reserved[7];
} NV_QSYNC_EVENT_DATA;
typedef void(__cdecl *NVAPI_CALLBACK_QSYNCEVENT)(NV_QSYNC_EVENT_DATA qyncEventData, void *callbackParam);
typedef enum _NV_RIVERMAXDISPLAY_EVENT_TYPE {
  NV_RIVERMAXDISPLAY_EVENT_TYPE_NONE = 0,
  NV_RIVERMAXDISPLAY_EVENT_TYPE_CONNECT = 1,
  NV_RIVERMAXDISPLAY_EVENT_TYPE_DISCONNECT = 2,
  NV_RIVERMAXDISPLAY_EVENT_TYPE_ATTACH = 3,
  NV_RIVERMAXDISPLAY_EVENT_TYPE_DETACH = 4,
  NV_RIVERMAXDISPLAY_EVENT_TYPE_BLANK = 5,
  NV_RIVERMAXDISPLAY_EVENT_TYPE_UNBLANK = 6,
  NV_RIVERMAXDISPLAY_EVENT_TYPE_PRESENT = 7,
} NV_RIVERMAXDISPLAY_EVENT_TYPE;
typedef struct _NV_RIVERMAXDISPLAY_EVENT_DATA {
  NV_RIVERMAXDISPLAY_EVENT_TYPE eventType;
  NvU32 displayId;
  NvU64 eventSignalTimestamp;
  NvU64 eventOccuringTimestamp;
  NvU64 handle;
} NV_RIVERMAXDISPLAY_EVENT_DATA;
typedef void(__cdecl *NVAPI_CALLBACK_RIVERMAXDISPLAYEVENT)(NV_RIVERMAXDISPLAY_EVENT_DATA *pRivermaxDisplayEventData,
                                                           void *callbackParam);
typedef enum {
  NV_EVENT_TYPE_NONE = 0,
  NV_EVENT_TYPE_FAN_SPEED_CHANGE = 1,
  NV_EVENT_TYPE_THERMAL_CHANGE = 2,
  NV_EVENT_TYPE_HOTPLUG_UNPLUG = 3,
  NV_EVENT_TYPE_HDCP_LINK_FAILED = 4,
  NV_EVENT_TYPE_HDCP_STATUS = 5,
  NV_EVENT_TYPE_QSYNC = 6,
  NV_EVENT_TYPE_GPU_POWER_STATE_CHANGE = 7,
  NV_EVENT_TYPE_RIVERMAXDISPLAY = 100,
} NV_EVENT_TYPE;
typedef void(__cdecl *NVAPI_CALLBACK_THERMALEVENT)(NvPhysicalGpuHandle gpuHandle, NV_EVENT_LEVEL thermalLevel,
                                                   void *callbackParam);
typedef void(__cdecl *NVAPI_CALLBACK_FANSPEEDEVENT)(NvPhysicalGpuHandle gpuHandle, NV_EVENT_LEVEL fanSpeedLevel,
                                                    void *callbackParam);
typedef void(__cdecl *NVAPI_CALLBACK_HPDEVENT)(NvU32 displayId, NvU32 bIsHotplug, void *callbackParam);
typedef void(__cdecl *NVAPI_CALLBACK_GPU_POWERSTATEEVENT)(NvPhysicalGpuHandle gpuHandle, NvU8 bIsPowerOff,
                                                          void *callbackParam);
#define NV_HDCP_ERROR_LINK_LOST 1
#define NV_HDCP_ERROR_TAMPERED (1 << 1)
#define NV_HDCP_ERROR_DEVICE_REVOKED (1 << 2)
#define NV_HDCP_STATUS_CHANGED (1 << 16)
typedef void(__cdecl *NVAPI_CALLBACK_HDCPEVENT)(NvU32 displayId, NvU32 errorCode, void *callbackParam);
typedef struct {
  NvU32 version;
  NV_EVENT_TYPE eventId;
  void *callbackParam;
  union {
    NVAPI_CALLBACK_THERMALEVENT nvThermalCallback;
    NVAPI_CALLBACK_FANSPEEDEVENT nvFanSpeedCallback;
    NVAPI_CALLBACK_HPDEVENT nvHPDCallback;
    NVAPI_CALLBACK_HDCPEVENT nvHDCPCallback;
    NVAPI_CALLBACK_HDCPEVENT nvHDCPStatusCallback;
    NVAPI_CALLBACK_GPU_POWERSTATEEVENT nvGpuPowerStateChangeEventCallback;
    NVAPI_CALLBACK_QSYNCEVENT nvQSYNCEventCallback;
    NVAPI_CALLBACK_RIVERMAXDISPLAYEVENT nvRivermaxDisplayEventCallback;
  } nvCallBackFunc;
} NV_EVENT_REGISTER_CALLBACK, *PNV_EVENT_REGISTER_CALLBACK;
#define NV_EVENT_REGISTER_CALLBACK_VERSION MAKE_NVAPI_VERSION(NV_EVENT_REGISTER_CALLBACK, 1)
typedef struct {
  NvU32 version;
  NvU32 boardID;
  NvAPI_ShortString chipSKU;
  NvAPI_ShortString chipSKUMod;
  NvAPI_ShortString project;
  NvAPI_ShortString projectSKU;
  NvAPI_ShortString cdp;
} NV_GPU_SKU_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 boardID;
  NvAPI_ShortString chipSKU;
  NvAPI_ShortString chipSKUMod;
  NvAPI_ShortString project;
  NvAPI_ShortString projectSKU;
  NvAPI_ShortString cdp;
  NvAPI_ShortString projectSKUMod;
} NV_GPU_SKU_INFO_V2;
typedef struct {
  NvU32 version;
  NvU32 boardID;
  NvAPI_ShortString chipSKU;
  NvAPI_ShortString chipSKUMod;
  NvAPI_ShortString project;
  NvAPI_ShortString projectSKU;
  NvAPI_ShortString cdp;
  NvAPI_ShortString projectSKUMod;
  NvU32 businessCycle;
  NvU8 rsvd[64];
} NV_GPU_SKU_INFO_V3;
typedef NV_GPU_SKU_INFO_V3 NV_GPU_SKU_INFO;
#define NV_GPU_SKU_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_SKU_INFO_V1, 1)
#define NV_GPU_SKU_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_SKU_INFO_V2, 2)
#define NV_GPU_SKU_INFO_VER3 MAKE_NVAPI_VERSION(NV_GPU_SKU_INFO_V3, 3)
#define NV_GPU_SKU_INFO_VER NV_GPU_SKU_INFO_VER3
NVAPI_INTERFACE NvAPI_GPU_GetSKUInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_SKU_INFO *pGpuSKUInfo);
typedef enum {
  NV_GPU_BRAND_TYPE_UNKNOWN = 0,
  NV_GPU_BRAND_TYPE_GEFORCE_RTX = 1,
  NV_GPU_BRAND_TYPE_GEFORCE = NV_GPU_BRAND_TYPE_GEFORCE_RTX,
  NV_GPU_BRAND_TYPE_NVIDIA_RTX = 2,
  NV_GPU_BRAND_TYPE_QUADRO = NV_GPU_BRAND_TYPE_NVIDIA_RTX,
  NV_GPU_BRAND_TYPE_QUADRO_AD = 3,
  NV_GPU_BRAND_TYPE_QUADRO_NVS = 4,
  NV_GPU_BRAND_TYPE_NVIDIA_NVS = 5,
  NV_GPU_BRAND_TYPE_TESLA = 6,
  NV_GPU_BRAND_TYPE_TESLA_Q = 7,
  NV_GPU_BRAND_TYPE_TITAN = 8,
  NV_GPU_BRAND_TYPE_TITAN_Q = 9,
  NV_GPU_BRAND_TYPE_NVIDIA_VAPPS = 10,
  NV_GPU_BRAND_TYPE_NVIDIA_VPC = 11,
  NV_GPU_BRAND_TYPE_NVIDIA_VCS = 12,
  NV_GPU_BRAND_TYPE_NVIDIA_VWS = 13,
  NV_GPU_BRAND_TYPE_NVIDIA_CLOUD_GAMING = 14,
  NV_GPU_BRAND_TYPE_NVIDIA_VGAMING = NV_GPU_BRAND_TYPE_NVIDIA_CLOUD_GAMING,
} NV_GPU_BRAND_TYPE;
NVAPI_INTERFACE NvAPI_GPU_GetBrandType(NvPhysicalGpuHandle physicalGpu, NV_GPU_BRAND_TYPE *gpuBrandType);
typedef enum _NV_GPU_WORKSTATION_FEATURE_TYPE {
  NV_GPU_WORKSTATION_FEATURE_TYPE_NVIDIA_RTX_VR_READY = 1,
  NV_GPU_WORKSTATION_FEATURE_TYPE_QUADRO_VR_READY = NV_GPU_WORKSTATION_FEATURE_TYPE_NVIDIA_RTX_VR_READY,
  NV_GPU_WORKSTATION_FEATURE_TYPE_PROVIZ = 2,
  NV_GPU_WORKSTATION_FEATURE_TYPE_RIVERMAXDISPLAY = 3,
} NV_GPU_WORKSTATION_FEATURE_TYPE;
NVAPI_INTERFACE NvAPI_GPU_QueryWorkstationFeatureSupport(NvPhysicalGpuHandle physicalGpu,
                                                         NV_GPU_WORKSTATION_FEATURE_TYPE gpuWorkstationFeature);
typedef struct {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  float *blendingTexture;
} NV_SCANOUT_INTENSITY_DATA_V1;
typedef struct {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  float *blendingTexture;
  float *offsetTexture;
  NvU32 offsetTexChannels;
} NV_SCANOUT_INTENSITY_DATA_V2;
typedef NV_SCANOUT_INTENSITY_DATA_V2 NV_SCANOUT_INTENSITY_DATA;
#define NV_SCANOUT_INTENSITY_DATA_VER1 MAKE_NVAPI_VERSION(NV_SCANOUT_INTENSITY_DATA_V1, 1)
#define NV_SCANOUT_INTENSITY_DATA_VER2 MAKE_NVAPI_VERSION(NV_SCANOUT_INTENSITY_DATA_V2, 2)
#define NV_SCANOUT_INTENSITY_DATA_VER NV_SCANOUT_INTENSITY_DATA_VER2
NVAPI_INTERFACE NvAPI_GPU_SetScanoutIntensity(NvU32 displayId, NV_SCANOUT_INTENSITY_DATA *scanoutIntensityData,
                                              int *pbSticky);
typedef struct _NV_SCANOUT_INTENSITY_STATE_DATA {
  NvU32 version;
  NvU32 bEnabled;
} NV_SCANOUT_INTENSITY_STATE_DATA;
#define NV_SCANOUT_INTENSITY_STATE_VER MAKE_NVAPI_VERSION(NV_SCANOUT_INTENSITY_STATE_DATA, 1)
NVAPI_INTERFACE NvAPI_GPU_GetScanoutIntensityState(__in NvU32 displayId,
                                                   __inout NV_SCANOUT_INTENSITY_STATE_DATA *scanoutIntensityStateData);
typedef enum {
  NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLESTRIP_XYUVRQ = 0,
  NV_GPU_WARPING_VERTICE_FORMAT_TRIANGLES_XYUVRQ = 1,
} NV_GPU_WARPING_VERTICE_FORMAT;
typedef struct {
  NvU32 version;
  float *vertices;
  NV_GPU_WARPING_VERTICE_FORMAT vertexFormat;
  int numVertices;
  NvSBox *textureRect;
} NV_SCANOUT_WARPING_DATA;
#define NV_SCANOUT_WARPING_VER MAKE_NVAPI_VERSION(NV_SCANOUT_WARPING_DATA, 1)
NVAPI_INTERFACE NvAPI_GPU_SetScanoutWarping(NvU32 displayId, NV_SCANOUT_WARPING_DATA *scanoutWarpingData,
                                            int *piMaxNumVertices, int *pbSticky);
typedef struct _NV_SCANOUT_WARPING_STATE_DATA {
  NvU32 version;
  NvU32 bEnabled;
} NV_SCANOUT_WARPING_STATE_DATA;
#define NV_SCANOUT_WARPING_STATE_VER MAKE_NVAPI_VERSION(NV_SCANOUT_WARPING_STATE_DATA, 1)
NVAPI_INTERFACE NvAPI_GPU_GetScanoutWarpingState(__in NvU32 displayId,
                                                 __inout NV_SCANOUT_WARPING_STATE_DATA *scanoutWarpingStateData);
typedef enum {
  NV_GPU_SCANOUT_COMPOSITION_PARAMETER_WARPING_RESAMPLING_METHOD = 0
} NV_GPU_SCANOUT_COMPOSITION_PARAMETER;
typedef enum {
  NV_GPU_SCANOUT_COMPOSITION_PARAMETER_SET_TO_DEFAULT = 0,
  NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BILINEAR = 0x100,
  NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_TRIANGULAR = 0x101,
  NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BELL_SHAPED = 0x102,
  NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_BSPLINE = 0x103,
  NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_TRIANGULAR = 0x104,
  NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BELL_SHAPED = 0x105,
  NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE_WARPING_RESAMPLING_METHOD_BICUBIC_ADAPTIVE_BSPLINE = 0x106
} NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE;
NVAPI_INTERFACE NvAPI_GPU_SetScanoutCompositionParameter(NvU32 displayId,
                                                         NV_GPU_SCANOUT_COMPOSITION_PARAMETER parameter,
                                                         NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE parameterValue,
                                                         float *pContainer);
NVAPI_INTERFACE NvAPI_GPU_GetScanoutCompositionParameter(
    __in NvU32 displayId, __in NV_GPU_SCANOUT_COMPOSITION_PARAMETER parameter,
    __out NV_GPU_SCANOUT_COMPOSITION_PARAMETER_VALUE *parameterData, __out float *pContainer);
NVAPI_INTERFACE NvAPI_GPU_GetScanoutConfiguration(NvU32 displayId, NvSBox *desktopRect, NvSBox *scanoutRect);
typedef struct _NV_SCANOUT_INFORMATION {
  NvU32 version;
  NvSBox sourceDesktopRect;
  NvSBox sourceViewportRect;
  NvSBox targetViewportRect;
  NvU32 targetDisplayWidth;
  NvU32 targetDisplayHeight;
  NvU32 cloneImportance;
  NV_ROTATE sourceToTargetRotation;
} NV_SCANOUT_INFORMATION;
#define NV_SCANOUT_INFORMATION_VER MAKE_NVAPI_VERSION(NV_SCANOUT_INFORMATION, 1)
NVAPI_INTERFACE NvAPI_GPU_GetScanoutConfigurationEx(__in NvU32 displayId,
                                                    __inout NV_SCANOUT_INFORMATION *pScanoutInformation);
NVAPI_INTERFACE NvAPI_GPU_GetAdapterIdFromPhysicalGpu(NvPhysicalGpuHandle hPhysicalGpu, void *pOSAdapterId);
typedef struct {
  NvU32 version;
  NvU16 bufferSize;
  NvU8 buffer[NV_MXM_BLOCK_SIZE];
} NV_ACPI_METHOD_DATA_SET_V1;
typedef NV_ACPI_METHOD_DATA_SET_V1 NV_ACPI_METHOD_DATA_SET;
#define NV_ACPI_METHOD_DATA_SET_VER1 MAKE_NVAPI_VERSION(NV_ACPI_METHOD_DATA_SET, 1)
#define NV_ACPI_METHOD_DATA_SET_VER NV_ACPI_METHOD_DATA_SET_VER1
typedef enum _NV_ACPI_METHOD_ID {
  NVAPI_ACPI_METHOD_MXM2X_MXMI = 0,
  NVAPI_ACPI_METHOD_MXM2X_MXMS,
  NVAPI_ACPI_METHOD_DSM_MXM3X_MXSS,
  NVAPI_ACPI_METHOD_DSM_MXM3X_MXMI,
  NVAPI_ACPI_METHOD_DSM_MXM3X_MXMS,
  NVAPI_ACPI_METHOD_DSM_MXM3X_MXPP,
  NVAPI_ACPI_METHOD_DSM_MXM3X_MXDP,
  NVAPI_ACPI_METHOD_DSM_MXM3X_MDTL,
  NVAPI_ACPI_METHOD_DSM_MXM3X_MXCB,
  NVAPI_ACPI_METHOD_DOD,
  NVAPI_ACPI_METHOD_MXMX,
  NVAPI_ACPI_METHOD_MXDS,
  NVAPI_ACPI_METHOD_DSM_MXM3X_EVENTLIST,
  NVAPI_ACPI_METHOD_DSM_GPS,
  NVAPI_ACPI_METHOD_DSM_JT,
  NVAPI_ACPI_METHOD_NBCI_MXDS,
  NVAPI_ACPI_METHOD_NBCI_MXDM,
  NVAPI_ACPI_METHOD_NBCI_MXID,
  NVAPI_ACPI_METHOD_NBCI_LRST,
  NVAPI_ACPI_METHOD_DDC_EDID,
  NVAPI_ACPI_NUM_SUPPORTED_METHODS
} NV_ACPI_METHOD_ID;
NVAPI_INTERFACE NvAPI_SYS_ACPI_GetValues(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_ACPI_METHOD_ID acpiMethod,
                                         __inout NV_ACPI_METHOD_DATA_SET *pBuf);
typedef enum _NV_VIRTUALIZATION_MODE {
  NV_VIRTUALIZATION_MODE_NONE = 0,
  NV_VIRTUALIZATION_MODE_NMOS = 1,
  NV_VIRTUALIZATION_MODE_VGX = 2,
  NV_VIRTUALIZATION_MODE_HOST_VGPU = 3
} NV_VIRTUALIZATION_MODE;
typedef struct _NV_GPU_VIRTUALIZATION_INFO {
  NvU32 version;
  NV_VIRTUALIZATION_MODE virtualizationMode;
  NvU32 reserved;
} NV_GPU_VIRTUALIZATION_INFO_V1;
typedef NV_GPU_VIRTUALIZATION_INFO_V1 NV_GPU_VIRTUALIZATION_INFO;
#define NV_GPU_VIRTUALIZATION_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_VIRTUALIZATION_INFO_V1, 1)
#define NV_GPU_VIRTUALIZATION_INFO_VER NV_GPU_VIRTUALIZATION_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetVirtualizationInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_GPU_VIRTUALIZATION_INFO *pVirtualizationInfo);
#define NV_GPU_NODE_INFO_MAX_NODES 16
#define NV_GPU_NODE_INFO_MAX_NODES_EX 64
typedef struct _NV_GPU_NODE_INFO_V1 {
  NvU32 version;
  NvU32 nodeCount;
  struct {
    NvU32 type;
    NvU32 bHwScheduling : 1;
    NvU32 reserved : 31;
    NvAPI_ShortString name;
  } node[NV_GPU_NODE_INFO_MAX_NODES];
  NvU32 reserved;
} NV_GPU_NODE_INFO_V1;
typedef struct _NV_GPU_NODE_INFO_V2 {
  NvU32 version;
  NvU32 nodeCount;
  struct {
    NvU32 type;
    NvU32 bHwScheduling : 1;
    NvU32 reserved : 31;
    NvAPI_ShortString name;
  } node[NV_GPU_NODE_INFO_MAX_NODES_EX];
  NvU32 reserved;
} NV_GPU_NODE_INFO_V2;
typedef NV_GPU_NODE_INFO_V2 NV_GPU_NODE_INFO;
#define NV_GPU_NODE_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_NODE_INFO_V1, 1)
#define NV_GPU_NODE_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_NODE_INFO_V2, 2)
#define NV_GPU_NODE_INFO_VER NV_GPU_NODE_INFO_VER2
NVAPI_INTERFACE NvAPI_GPU_QueryNodeInfo(__in NvLogicalGpuHandle hLogicalGpu, __inout NV_GPU_NODE_INFO *pGpuNodeInfo);
typedef struct _NV_LOGICAL_GPU_DATA_V1 {
  NvU32 version;
  void *pOSAdapterId;
  NvU32 physicalGpuCount;
  NvPhysicalGpuHandle physicalGpuHandles[NVAPI_MAX_PHYSICAL_GPUS];
  NvU32 reserved[8];
} NV_LOGICAL_GPU_DATA_V1;
typedef NV_LOGICAL_GPU_DATA_V1 NV_LOGICAL_GPU_DATA;
#define NV_LOGICAL_GPU_DATA_VER1 MAKE_NVAPI_VERSION(NV_LOGICAL_GPU_DATA_V1, 1)
#define NV_LOGICAL_GPU_DATA_VER NV_LOGICAL_GPU_DATA_VER1
NVAPI_INTERFACE NvAPI_GPU_GetLogicalGpuInfo(__in NvLogicalGpuHandle hLogicalGpu,
                                            __inout NV_LOGICAL_GPU_DATA *pLogicalGpuData);
NVAPI_INTERFACE NvAPI_GPU_QueryIsGRIDDisplayless(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __out NvU32 *pIsGridDisplayless);
typedef enum _NV_GPU_POWER_STATE {
  NV_GPU_POWER_STATE_ERROR = 0,
  NV_GPU_POWER_STATE_ON,
  NV_GPU_POWER_STATE_GOLD,
  NV_GPU_POWER_STATE_EXITING_GOLD,
  NV_GPU_POWER_STATE_ENTERING_GOLD,
  NV_GPU_POWER_STATE_WAITING_FOR_SVC,
  NV_GPU_POWER_STATE_GC6,
  NV_GPU_POWER_STATE_EXITING_GC6,
  NV_GPU_POWER_STATE_ENTERING_GC6,
} NV_GPU_POWER_STATE;
#define NV_GPU_STATE_CHANGE_LOG_COUNT 32
typedef enum _NV_GPU_FEATURE_LPWR_INFO_FLAG {
  NV_GPU_FEATURE_LPWR_INFO_ENABLE = 0,
  NV_GPU_FEATURE_LPWR_INFO_DISABLE,
} NV_GPU_FEATURE_LPWR_INFO_FLAG;
typedef struct {
  NvU32 min;
  NvU32 max;
  NvU32 avg;
  NvU32 tot;
} NV_COUNTER_INFO;
typedef struct _NV_GPU_GC6_STATISTICS {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
} NV_GPU_GC6_STATISTICS_V1;
#define NV_GPU_GC6_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V1, 1)
typedef struct _NV_GPU_GC6_STATISTICS_V2 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
} NV_GPU_GC6_STATISTICS_V2;
#define NV_GPU_GC6_STATISTICS_VER2 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V2, 2)
typedef struct _NV_GPU_GC6_STATISTICS_V3 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
} NV_GPU_GC6_STATISTICS_V3;
#define NV_GPU_GC6_STATISTICS_VER3 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V3, 3)
typedef struct _NV_GPU_GC6_STATISTICS_V4 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
  NvU32 minTimeInIdleToEnterGC6Ms;
  NvU32 maxTimeInIdleToEnterGC6Ms;
  NvU32 avgTimeInIdleToEnterGC6Ms;
  NvU32 totTimeInIdleToEnterGC6Ms;
} NV_GPU_GC6_STATISTICS_V4;
#define NV_GPU_GC6_STATISTICS_VER4 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V4, 4)
typedef struct _NV_GPU_GC6_STATISTICS_V5 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
  NvU32 minTimeInIdleToEnterGC6Ms;
  NvU32 maxTimeInIdleToEnterGC6Ms;
  NvU32 avgTimeInIdleToEnterGC6Ms;
  NvU32 totTimeInIdleToEnterGC6Ms;
  NvU32 GC6BounceCount;
} NV_GPU_GC6_STATISTICS_V5;
#define NV_GPU_GC6_STATISTICS_VER5 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V5, 5)
typedef struct _NV_GPU_GC6_STATISTICS_V6 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
  NvU32 minTimeInIdleToEnterGC6Ms;
  NvU32 maxTimeInIdleToEnterGC6Ms;
  NvU32 avgTimeInIdleToEnterGC6Ms;
  NvU32 totTimeInIdleToEnterGC6Ms;
  NvU32 GC6BounceCount;
  NvU32 minTimeExitEventGC6Ms;
  NvU32 maxTimeExitEventGC6Ms;
  NvU32 avgTimeExitEventGC6Ms;
  NvU32 totTimeExitEventGC6Ms;
  NvU32 minTimeRmExitGC6DurationMs;
  NvU32 maxTimeRmExitGC6DurationMs;
  NvU32 avgTimeRmExitGC6DurationMs;
  NvU32 totTimeRmExitGC6DurationMs;
  NvU32 minTimeRmEnterSRDurationMs;
  NvU32 maxTimeRmEnterSRDurationMs;
  NvU32 avgTimeRmEnterSRDurationMs;
  NvU32 totTimeRmEnterSRDurationMs;
  NvU32 minTimeRmExitSRDurationMs;
  NvU32 maxTimeRmExitSRDurationMs;
  NvU32 avgTimeRmExitSRDurationMs;
  NvU32 totTimeRmExitSRDurationMs;
} NV_GPU_GC6_STATISTICS_V6;
#define NV_GPU_GC6_STATISTICS_VER6 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V6, 6)
typedef struct _NV_GPU_GC6_STATISTICS_V7 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
  NvU32 minTimeInIdleToEnterGC6Ms;
  NvU32 maxTimeInIdleToEnterGC6Ms;
  NvU32 avgTimeInIdleToEnterGC6Ms;
  NvU32 totTimeInIdleToEnterGC6Ms;
  NvU32 GC6BounceCount;
  NvU32 minTimeExitEventGC6Ms;
  NvU32 maxTimeExitEventGC6Ms;
  NvU32 avgTimeExitEventGC6Ms;
  NvU32 totTimeExitEventGC6Ms;
  NvU32 minTimeRmExitGC6DurationMs;
  NvU32 maxTimeRmExitGC6DurationMs;
  NvU32 avgTimeRmExitGC6DurationMs;
  NvU32 totTimeRmExitGC6DurationMs;
  NvU32 minTimeRmEnterSRDurationMs;
  NvU32 maxTimeRmEnterSRDurationMs;
  NvU32 avgTimeRmEnterSRDurationMs;
  NvU32 totTimeRmEnterSRDurationMs;
  NvU32 minTimeRmExitSRDurationMs;
  NvU32 maxTimeRmExitSRDurationMs;
  NvU32 avgTimeRmExitSRDurationMs;
  NvU32 totTimeRmExitSRDurationMs;
  NvU32 minNVSREndUserGC6ExitingLatency;
  NvU32 maxNVSREndUserGC6ExitingLatency;
  NvU32 avgNVSREndUserGC6ExitingLatency;
  NvU32 totTimeNVSREndUserGC6ExitingLatency;
} NV_GPU_GC6_STATISTICS_V7;
#define NV_GPU_GC6_STATISTICS_VER7 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V7, 7)
typedef struct _NV_GPU_GC6_STATISTICS_V8 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
  NvU32 minTimeInIdleToEnterGC6Ms;
  NvU32 maxTimeInIdleToEnterGC6Ms;
  NvU32 avgTimeInIdleToEnterGC6Ms;
  NvU32 totTimeInIdleToEnterGC6Ms;
  NvU32 GC6BounceCount;
  NvU32 minTimeExitEventGC6Ms;
  NvU32 maxTimeExitEventGC6Ms;
  NvU32 avgTimeExitEventGC6Ms;
  NvU32 totTimeExitEventGC6Ms;
  NvU32 minTimeRmExitGC6DurationMs;
  NvU32 maxTimeRmExitGC6DurationMs;
  NvU32 avgTimeRmExitGC6DurationMs;
  NvU32 totTimeRmExitGC6DurationMs;
  NvU32 minTimeRmEnterSRDurationMs;
  NvU32 maxTimeRmEnterSRDurationMs;
  NvU32 avgTimeRmEnterSRDurationMs;
  NvU32 totTimeRmEnterSRDurationMs;
  NvU32 minTimeRmExitSRDurationMs;
  NvU32 maxTimeRmExitSRDurationMs;
  NvU32 avgTimeRmExitSRDurationMs;
  NvU32 totTimeRmExitSRDurationMs;
  NvU32 minNVSREndUserGC6ExitingLatency;
  NvU32 maxNVSREndUserGC6ExitingLatency;
  NvU32 avgNVSREndUserGC6ExitingLatency;
  NvU32 totTimeNVSREndUserGC6ExitingLatency;
  NV_GPU_FEATURE_LPWR_INFO_FLAG bEnableLPWRInfo;
} NV_GPU_GC6_STATISTICS_V8;
#define NV_GPU_GC6_STATISTICS_VER8 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V8, 8)
typedef struct _NV_GPU_GC6_STATISTICS_V9 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
  NvU32 minTimeInIdleToEnterGC6Ms;
  NvU32 maxTimeInIdleToEnterGC6Ms;
  NvU32 avgTimeInIdleToEnterGC6Ms;
  NvU32 totTimeInIdleToEnterGC6Ms;
  NvU32 GC6BounceCount;
  NvU32 minTimeExitEventGC6Ms;
  NvU32 maxTimeExitEventGC6Ms;
  NvU32 avgTimeExitEventGC6Ms;
  NvU32 totTimeExitEventGC6Ms;
  NvU32 minTimeRmExitGC6DurationMs;
  NvU32 maxTimeRmExitGC6DurationMs;
  NvU32 avgTimeRmExitGC6DurationMs;
  NvU32 totTimeRmExitGC6DurationMs;
  NvU32 minTimeRmEnterSRDurationMs;
  NvU32 maxTimeRmEnterSRDurationMs;
  NvU32 avgTimeRmEnterSRDurationMs;
  NvU32 totTimeRmEnterSRDurationMs;
  NvU32 minTimeRmExitSRDurationMs;
  NvU32 maxTimeRmExitSRDurationMs;
  NvU32 avgTimeRmExitSRDurationMs;
  NvU32 totTimeRmExitSRDurationMs;
  NvU32 minNVSREndUserGC6ExitingLatency;
  NvU32 maxNVSREndUserGC6ExitingLatency;
  NvU32 avgNVSREndUserGC6ExitingLatency;
  NvU32 totTimeNVSREndUserGC6ExitingLatency;
  NV_GPU_FEATURE_LPWR_INFO_FLAG bEnableLPWRInfo;
  NvU32 refCountGC6Mask;
  NvU32 refCountGC6MaskCumulative;
  NvU32 timeInSx;
  NvS32 idleToEnterGC6MsHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
} NV_GPU_GC6_STATISTICS_V9;
#define NV_GPU_GC6_STATISTICS_VER9 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V9, 9)
typedef struct _NV_GPU_GC6_STATISTICS_V10 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
  NvU32 minTimeInIdleToEnterGC6Ms;
  NvU32 maxTimeInIdleToEnterGC6Ms;
  NvU32 avgTimeInIdleToEnterGC6Ms;
  NvU32 totTimeInIdleToEnterGC6Ms;
  NvU32 GC6BounceCount;
  NvU32 minTimeExitEventGC6Ms;
  NvU32 maxTimeExitEventGC6Ms;
  NvU32 avgTimeExitEventGC6Ms;
  NvU32 totTimeExitEventGC6Ms;
  NvU32 minTimeRmExitGC6DurationMs;
  NvU32 maxTimeRmExitGC6DurationMs;
  NvU32 avgTimeRmExitGC6DurationMs;
  NvU32 totTimeRmExitGC6DurationMs;
  NvU32 minTimeRmEnterSRDurationMs;
  NvU32 maxTimeRmEnterSRDurationMs;
  NvU32 avgTimeRmEnterSRDurationMs;
  NvU32 totTimeRmEnterSRDurationMs;
  NvU32 minTimeRmExitSRDurationMs;
  NvU32 maxTimeRmExitSRDurationMs;
  NvU32 avgTimeRmExitSRDurationMs;
  NvU32 totTimeRmExitSRDurationMs;
  NvU32 minNVSREndUserGC6ExitingLatency;
  NvU32 maxNVSREndUserGC6ExitingLatency;
  NvU32 avgNVSREndUserGC6ExitingLatency;
  NvU32 totTimeNVSREndUserGC6ExitingLatency;
  NV_GPU_FEATURE_LPWR_INFO_FLAG bEnableLPWRInfo;
  NvU32 refCountGC6Mask;
  NvU32 refCountGC6MaskCumulative;
  NvU32 timeInSx;
  NvS32 idleToEnterGC6MsHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvU32 fastGC6TransitionCount;
  NvU32 incrementalGC6TransitionCount;
  NvU32 minTimeInFGC6DurationMs;
  NvU32 maxTimeInFGC6DurationMs;
  NvU32 avgTimeInFGC6DurationMs;
  NvU32 totTimeInFGC6DurationMs;
  NvU32 minTimeExitFGC6DurationMs;
  NvU32 maxTimeExitFGC6DurationMs;
  NvU32 avgTimeExitFGC6DurationMs;
  NvU32 totTimeExitFGC6DurationMs;
  NvU32 minTimeEnterFGC6DurationMs;
  NvU32 maxTimeEnterFGC6DurationMs;
  NvU32 avgTimeEnterFGC6DurationMs;
  NvU32 totTimeEnterFGC6DurationMs;
  NvU32 minTimeRmEnterFGC6DurationMs;
  NvU32 maxTimeRmEnterFGC6DurationMs;
  NvU32 avgTimeRmEnterFGC6DurationMs;
  NvU32 totTimeRmEnterFGC6DurationMs;
  NvU32 minTimeRmExitFGC6DurationMs;
  NvU32 maxTimeRmExitFGC6DurationMs;
  NvU32 avgTimeRmExitFGC6DurationMs;
  NvU32 totTimeRmExitFGC6DurationMs;
  NvU32 minTimeRmEnterGC6DurationMs;
  NvU32 maxTimeRmEnterGC6DurationMs;
  NvU32 avgTimeRmEnterGC6DurationMs;
  NvU32 totTimeRmEnterGC6DurationMs;
  NvS32 enteringRmGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingRmGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 fGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingRmFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringRmFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
} NV_GPU_GC6_STATISTICS_V10;
#define NV_GPU_GC6_STATISTICS_VER10 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V10, 10)
typedef struct _NV_GPU_GC6_STATISTICS_V11 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
  NvU32 minTimeInIdleToEnterGC6Ms;
  NvU32 maxTimeInIdleToEnterGC6Ms;
  NvU32 avgTimeInIdleToEnterGC6Ms;
  NvU32 totTimeInIdleToEnterGC6Ms;
  NvU32 GC6BounceCount;
  NvU32 minTimeExitEventGC6Ms;
  NvU32 maxTimeExitEventGC6Ms;
  NvU32 avgTimeExitEventGC6Ms;
  NvU32 totTimeExitEventGC6Ms;
  NvU32 minTimeRmExitGC6DurationMs;
  NvU32 maxTimeRmExitGC6DurationMs;
  NvU32 avgTimeRmExitGC6DurationMs;
  NvU32 totTimeRmExitGC6DurationMs;
  NvU32 minTimeRmEnterSRDurationMs;
  NvU32 maxTimeRmEnterSRDurationMs;
  NvU32 avgTimeRmEnterSRDurationMs;
  NvU32 totTimeRmEnterSRDurationMs;
  NvU32 minTimeRmExitSRDurationMs;
  NvU32 maxTimeRmExitSRDurationMs;
  NvU32 avgTimeRmExitSRDurationMs;
  NvU32 totTimeRmExitSRDurationMs;
  NvU32 minNVSREndUserGC6ExitingLatency;
  NvU32 maxNVSREndUserGC6ExitingLatency;
  NvU32 avgNVSREndUserGC6ExitingLatency;
  NvU32 totTimeNVSREndUserGC6ExitingLatency;
  NV_GPU_FEATURE_LPWR_INFO_FLAG bEnableLPWRInfo;
  NvU32 refCountGC6Mask;
  NvU32 refCountGC6MaskCumulative;
  NvU32 timeInSx;
  NvS32 idleToEnterGC6MsHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvU32 fastGC6TransitionCount;
  NvU32 incrementalGC6TransitionCount;
  NvU32 minTimeInFGC6DurationMs;
  NvU32 maxTimeInFGC6DurationMs;
  NvU32 avgTimeInFGC6DurationMs;
  NvU32 totTimeInFGC6DurationMs;
  NvU32 minTimeExitFGC6DurationMs;
  NvU32 maxTimeExitFGC6DurationMs;
  NvU32 avgTimeExitFGC6DurationMs;
  NvU32 totTimeExitFGC6DurationMs;
  NvU32 minTimeEnterFGC6DurationMs;
  NvU32 maxTimeEnterFGC6DurationMs;
  NvU32 avgTimeEnterFGC6DurationMs;
  NvU32 totTimeEnterFGC6DurationMs;
  NvU32 minTimeRmEnterFGC6DurationMs;
  NvU32 maxTimeRmEnterFGC6DurationMs;
  NvU32 avgTimeRmEnterFGC6DurationMs;
  NvU32 totTimeRmEnterFGC6DurationMs;
  NvU32 minTimeRmExitFGC6DurationMs;
  NvU32 maxTimeRmExitFGC6DurationMs;
  NvU32 avgTimeRmExitFGC6DurationMs;
  NvU32 totTimeRmExitFGC6DurationMs;
  NvU32 minTimeRmEnterGC6DurationMs;
  NvU32 maxTimeRmEnterGC6DurationMs;
  NvU32 avgTimeRmEnterGC6DurationMs;
  NvU32 totTimeRmEnterGC6DurationMs;
  NvS32 enteringRmGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingRmGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 fGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingRmFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringRmFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvU32 exitD3HotGC6Count;
  NvU32 minTimeExitD3HotGC6DurationMs;
  NvU32 maxTimeExitD3HotGC6DurationMs;
  NvU32 avgTimeExitD3HotGC6DurationMs;
  NvU32 totTimeExitD3HotGC6DurationMs;
  NvU32 minTimeRmExitD3HotGC6DurationMs;
  NvU32 maxTimeRmExitD3HotGC6DurationMs;
  NvU32 avgTimeRmExitD3HotGC6DurationMs;
  NvU32 totTimeRmExitD3HotGC6DurationMs;
  NvS32 exitD3HotGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 rmExitD3HotGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
} NV_GPU_GC6_STATISTICS_V11;
#define NV_GPU_GC6_STATISTICS_VER11 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V11, 11)
typedef struct _NV_GPU_GC6_STATISTICS_V12 {
  NvU32 version;
  NvU32 GC6TimeoutValue;
  NvU32 GC6TransitionCount;
  NvU32 minTimeInGC6Ms;
  NvU32 maxTimeInGC6Ms;
  NvU32 avgTimeInGC6Ms;
  NvU32 totTimeInGC6Ms;
  NvU32 minTimeEnteringGC6Ms;
  NvU32 maxTimeEnteringGC6Ms;
  NvU32 avgTimeEnteringGC6Ms;
  NvU32 totTimeEnteringGC6Ms;
  NvU32 minTimeExitingGC6Ms;
  NvU32 maxTimeExitingGC6Ms;
  NvU32 avgTimeExitingGC6Ms;
  NvU32 totTimeExitingGC6Ms;
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvS32 GC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_GPU_POWER_STATE state;
  NvU32 maxTimeEnteringGC6RM;
  NvU32 minTimeEnteringGC6RM;
  NvU32 totTimeEnteringGC6RM;
  NvU32 maxTimeExitingGC6RM;
  NvU32 minTimeExitingGC6RM;
  NvU32 totTimeExitingGC6RM;
  NvU32 maxStateLoadGC6;
  NvU32 minStateLoadGC6;
  NvU32 totStateLoadGC6;
  NvU32 maxStateUnloadGC6;
  NvU32 minStateUnloadGC6;
  NvU32 totStateUnloadGC6;
  NvU32 maxPowerOnTimeGC6;
  NvU32 minPowerOnTimeGC6;
  NvU32 totPowerOnTimeGC6;
  NvU32 maxPowerOffTimeGC6;
  NvU32 minPowerOffTimeGC6;
  NvU32 totPowerOffTimeGC6;
  NvU32 maxSCIPowerOnTimeGC6;
  NvU32 minSCIPowerOnTimeGC6;
  NvU32 totSCIPowerOnTimeGC6;
  NvU32 maxSCIPowerOffTimeGC6;
  NvU32 minSCIPowerOffTimeGC6;
  NvU32 totSCIPowerOffTimeGC6;
  NvU32 maxDevinitTimeGC6;
  NvU32 minDevinitTimeGC6;
  NvU32 totDevinitTimeGC6;
  NvU32 maxPMUBootstrapTimeGC6;
  NvU32 minPMUBootstrapTimeGC6;
  NvU32 totPMUBootstrapTimeGC6;
  NvU32 minTimeInIdleToEnterGC6Ms;
  NvU32 maxTimeInIdleToEnterGC6Ms;
  NvU32 avgTimeInIdleToEnterGC6Ms;
  NvU32 totTimeInIdleToEnterGC6Ms;
  NvU32 GC6BounceCount;
  NvU32 minTimeExitEventGC6Ms;
  NvU32 maxTimeExitEventGC6Ms;
  NvU32 avgTimeExitEventGC6Ms;
  NvU32 totTimeExitEventGC6Ms;
  NvU32 minTimeRmExitGC6DurationMs;
  NvU32 maxTimeRmExitGC6DurationMs;
  NvU32 avgTimeRmExitGC6DurationMs;
  NvU32 totTimeRmExitGC6DurationMs;
  NvU32 minTimeRmEnterSRDurationMs;
  NvU32 maxTimeRmEnterSRDurationMs;
  NvU32 avgTimeRmEnterSRDurationMs;
  NvU32 totTimeRmEnterSRDurationMs;
  NvU32 minTimeRmExitSRDurationMs;
  NvU32 maxTimeRmExitSRDurationMs;
  NvU32 avgTimeRmExitSRDurationMs;
  NvU32 totTimeRmExitSRDurationMs;
  NvU32 minNVSREndUserGC6ExitingLatency;
  NvU32 maxNVSREndUserGC6ExitingLatency;
  NvU32 avgNVSREndUserGC6ExitingLatency;
  NvU32 totTimeNVSREndUserGC6ExitingLatency;
  NV_GPU_FEATURE_LPWR_INFO_FLAG bEnableLPWRInfo;
  NvU32 refCountGC6Mask;
  NvU32 refCountGC6MaskCumulative;
  NvU32 timeInSx;
  NvS32 idleToEnterGC6MsHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvU32 fastGC6TransitionCount;
  NvU32 incrementalGC6TransitionCount;
  NvU32 minTimeInFGC6DurationMs;
  NvU32 maxTimeInFGC6DurationMs;
  NvU32 avgTimeInFGC6DurationMs;
  NvU32 totTimeInFGC6DurationMs;
  NvU32 minTimeExitFGC6DurationMs;
  NvU32 maxTimeExitFGC6DurationMs;
  NvU32 avgTimeExitFGC6DurationMs;
  NvU32 totTimeExitFGC6DurationMs;
  NvU32 minTimeEnterFGC6DurationMs;
  NvU32 maxTimeEnterFGC6DurationMs;
  NvU32 avgTimeEnterFGC6DurationMs;
  NvU32 totTimeEnterFGC6DurationMs;
  NvU32 minTimeRmEnterFGC6DurationMs;
  NvU32 maxTimeRmEnterFGC6DurationMs;
  NvU32 avgTimeRmEnterFGC6DurationMs;
  NvU32 totTimeRmEnterFGC6DurationMs;
  NvU32 minTimeRmExitFGC6DurationMs;
  NvU32 maxTimeRmExitFGC6DurationMs;
  NvU32 avgTimeRmExitFGC6DurationMs;
  NvU32 totTimeRmExitFGC6DurationMs;
  NvU32 minTimeRmEnterGC6DurationMs;
  NvU32 maxTimeRmEnterGC6DurationMs;
  NvU32 avgTimeRmEnterGC6DurationMs;
  NvU32 totTimeRmEnterGC6DurationMs;
  NvS32 enteringRmGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingRmGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 fGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingRmFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringRmFGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvU32 exitD3HotGC6Count;
  NvU32 minTimeExitD3HotGC6DurationMs;
  NvU32 maxTimeExitD3HotGC6DurationMs;
  NvU32 avgTimeExitD3HotGC6DurationMs;
  NvU32 totTimeExitD3HotGC6DurationMs;
  NvU32 minTimeRmExitD3HotGC6DurationMs;
  NvU32 maxTimeRmExitD3HotGC6DurationMs;
  NvU32 avgTimeRmExitD3HotGC6DurationMs;
  NvU32 totTimeRmExitD3HotGC6DurationMs;
  NvS32 exitD3HotGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 rmExitD3HotGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_COUNTER_INFO inGC6D3HotDurationMs;
  NV_COUNTER_INFO enterGC6D3HotDurationMs;
  NV_COUNTER_INFO rmEnterD3HotGC6DurationMs;
  NvS32 inGC6D3HotHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enterGC6D3HotHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 rmEnterD3HotGC6Histogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
} NV_GPU_GC6_STATISTICS_V12;
#define NV_GPU_GC6_STATISTICS_VER12 MAKE_NVAPI_VERSION(NV_GPU_GC6_STATISTICS_V12, 12)
typedef NV_GPU_GC6_STATISTICS_V12 NV_GPU_GC6_STATISTICS;
#define NV_GPU_GC6_STATISTICS_VER NV_GPU_GC6_STATISTICS_VER12
NVAPI_INTERFACE NvAPI_GPU_GetGC6Statistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_GPU_GC6_STATISTICS *pGpuGC6Stats);
typedef enum _NV_GPU_GC6_CONTROL_OP {
  CLEAR_STATS = 0,
  SET_STATS_ENABLED,
  SET_STATS_DISABLED,
  IS_GC6_SUPPORTED,
  IS_GC6_ENABLED,
} NV_GPU_GC6_CONTROL_OP;
typedef enum _NV_GPU_GC6_CONTROL_STATUS {
  SUCCESS = 0,
  FEATURE_DISABLED,
  CANNOT_ENABLE_STATS,
  STATS_DISABLED,
  FAILED,
} NV_GPU_GC6_CONTROL_STATUS;
typedef struct _NV_GPU_GC6_CONTROL {
  NvU32 version;
  NV_GPU_GC6_CONTROL_OP controlOp;
  NV_GPU_GC6_CONTROL_STATUS controlStatus;
} NV_GPU_GC6_CONTROL_V1;
#define NV_GPU_GC6_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_GC6_CONTROL_V1, 1)
typedef NV_GPU_GC6_CONTROL_V1 NV_GPU_GC6_CONTROL;
#define NV_GPU_GC6_CONTROL_VER NV_GPU_GC6_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_GC6Control(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_GC6_CONTROL *pGpuGC6Control);
NVAPI_INTERFACE NvAPI_GPU_ForceGC6Exit(__in NvPhysicalGpuHandle hPhysicalGpu);
typedef enum _NV_GCX_GET_WAKEUP_REASON_POWER_STATE {
  NV_GCX_GET_WAKEUP_REASON_POWER_STATE_UNKNOWN = 0x0,
  NV_GCX_GET_WAKEUP_REASON_POWER_STATE_GC6 = 0x1,
  NV_GCX_GET_WAKEUP_REASON_POWER_STATE_GC5MINUS_SSC = 0x2,
} NV_GCX_GET_WAKEUP_REASON_POWER_STATE;
typedef enum _NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE {
  NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE_GC5_SSC_UNKNOWN = 0x0,
  NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE_GC5_SSC_EXIT = 0x1,
  NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE_GC5_SSC_ABORT = 0x2,
} NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE;
typedef enum _NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE {
  NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE_UNKNOWN = 0x0,
  NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE_GC5_SSC_WITH_DEEP_L1 = 0x2,
  NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE_GC5_SSC_WITH_L1_1 = 0x3,
  NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE_GC5_SSC_WITH_L1_2 = 0x4,
} NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE;
typedef struct _NV_GPU_GCX_GET_WAKEUP_REASON_INFO_V1 {
  NvU32 version;
  NV_GCX_GET_WAKEUP_REASON_POWER_STATE selectPowerState;
  NvU32 statId;
  NV_GCX_GET_WAKEUP_REASON_EXIT_TYPE gc5ExitType;
  NV_GCX_GET_WAKEUP_REASON_DEEP_L1_TYPE deepL1Type;
  NvU32 gc5AbortCode_DeepL1EntryTimeOut : 1;
  NvU32 gc5AbortCode_DeepL1Exit : 1;
  NvU32 gc5AbortCode_MSCGAbort : 1;
  NvU32 gc5AbortCode_RTOSAbort : 1;
  NvU32 gc5AbortCode_AzaliaActive : 1;
  NvU32 gc5AbortCode_HostNotIdle : 1;
  NvU32 gc5AbortCode_PendingPMCIntr : 1;
  NvU32 gc5AbortCode_PendingSCIIntr : 1;
  NvU32 gc5AbortCode_ThermI2CSBusy : 1;
  NvU32 gc5AbortCode_SpeculativePTimerAlarm : 1;
  NvU32 gc5AbortCode_LateDeepL1Exit : 1;
  NvU32 reserved : 21;
  NvU32 sciIntr0;
  NvU32 sciIntr1;
  NvU32 pmcIntr0;
  NvU32 pmcIntr1;
} NV_GPU_GCX_GET_WAKEUP_REASON_INFO_V1;
typedef NV_GPU_GCX_GET_WAKEUP_REASON_INFO_V1 NV_GPU_GCX_GET_WAKEUP_REASON_INFO;
#define NV_GPU_GCX_GET_WAKEUP_REASON_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_GCX_GET_WAKEUP_REASON_INFO_V1, 1)
#define NV_GPU_GCX_GET_WAKEUP_REASON_INFO_VER NV_GPU_GCX_GET_WAKEUP_REASON_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetGCXWakeUpReasonInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_GCX_GET_WAKEUP_REASON_INFO *pGpuGCXWakeUpReasonInfo);
typedef struct _NV_REF_COUNT_ACCESS_PARAM_V1 {
  NvU32 version;
  NvU8 incrementRefCount : 1;
  NvU8 reserved : 7;
} NV_REF_COUNT_ACCESS_PARAM_V1;
typedef NV_REF_COUNT_ACCESS_PARAM_V1 NV_REF_COUNT_ACCESS_PARAM;
#define NV_REF_COUNT_ACCESS_PARAM_VER_1 MAKE_NVAPI_VERSION(NV_REF_COUNT_ACCESS_PARAM_V1, 1)
#define NV_REF_COUNT_ACCESS_PARAM_VER NV_REF_COUNT_ACCESS_PARAM_VER_1
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 465.") NVAPI_INTERFACE
    NvAPI_GPU_AccessRefCount(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_REF_COUNT_ACCESS_PARAM *pRefCountParams);
typedef struct _NV_PCIE_LTR_INFO_V1 {
  NvU32 version;
  NvU8 bLtrRegkeyOverride : 1;
  NvU8 bRootPortLtrSupported : 1;
  NvU8 bGpuLtrSupported : 1;
  NvU8 reserved : 5;
  NvU16 snoopLatencyValue;
  NvU8 snoopLatencyScale;
  NvU16 noSnoopLatencyValue;
  NvU8 noSnoopLatencyScale;
} NV_PCIE_LTR_INFO_V1;
typedef NV_PCIE_LTR_INFO_V1 NV_PCIE_LTR_INFO;
#define NV_PCIE_LTR_INFO_VER_1 MAKE_NVAPI_VERSION(NV_PCIE_LTR_INFO_V1, 1)
#define NV_PCIE_LTR_INFO_VER NV_PCIE_LTR_INFO_VER_1
NVAPI_INTERFACE NvAPI_GPU_GetPCIELtrInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_PCIE_LTR_INFO *pPexLtrInfo);
NVAPI_INTERFACE NvAPI_GPU_SetPCIELtrInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_PCIE_LTR_INFO *pPexLtrInfo);
typedef enum _NV_UEFI_SUPPORT_FLAGS {
  NV_UEFI_SUPPORT_FLAGS_UNDEFINED = 0x00000000,
  NV_UEFI_SUPPORT_FLAGS_PRESENCE_NO = 0x00000001,
  NV_UEFI_SUPPORT_FLAGS_PRESENCE_YES = 0x00000002,
  NV_UEFI_SUPPORT_FLAGS_PRESENCE_PLACEHOLDER = 0x00000004,
  NV_UEFI_SUPPORT_FLAGS_PRESENCE_HIDDEN = 0x00000008,
  NV_UEFI_SUPPORT_FLAGS_RUNNING_FALSE = 0x00000010,
  NV_UEFI_SUPPORT_FLAGS_RUNNING_TRUE = 0x00000020,
} NV_UEFI_SUPPORT_FLAGS;
typedef struct _NV_UEFI_INFO_V1 {
  NvU32 version;
  NvU32 UEFIVersion;
  NvU32 flags;
} NV_UEFI_INFO_V1;
typedef NV_UEFI_INFO_V1 NV_UEFI_INFO;
#define NV_UEFI_INFO_VER1 MAKE_NVAPI_VERSION(NV_UEFI_INFO_V1, 1)
#define NV_UEFI_INFO_VER NV_UEFI_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetUEFIInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_UEFI_INFO *pUEFIInfo);
typedef enum { NV_SINGLE_PRECISION = 0, NV_DOUBLE_PRECISION = 1 } NV_COMPUTE_PRECISION;
typedef struct _NV_COMPUTE_PRECISION_INFO_V1 {
  NvU32 version;
  NV_COMPUTE_PRECISION maxSupportedPrecision;
  NV_COMPUTE_PRECISION currPrecision;
} NV_COMPUTE_PRECISION_INFO_V1;
typedef NV_COMPUTE_PRECISION_INFO_V1 NV_COMPUTE_PRECISION_INFO;
#define NV_COMPUTE_PRECISION_INFO_VER1 MAKE_NVAPI_VERSION(NV_COMPUTE_PRECISION_INFO_V1, 1)
#define NV_COMPUTE_PRECISION_INFO_VER NV_COMPUTE_PRECISION_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetComputePrecisionInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_COMPUTE_PRECISION_INFO *computePrecisionInfo);
NVAPI_INTERFACE NvAPI_GPU_SetComputePrecision(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __in NV_COMPUTE_PRECISION computePrecision);
#define NV_GPU_INFOROM_IMAGE_VERSION_LEN 16
typedef struct _NV_INFOROM_IMAGE_INFO_V1 {
  NvU32 version;
  NvU8 InfoROM_image_version[NV_GPU_INFOROM_IMAGE_VERSION_LEN];
} NV_INFOROM_IMAGE_INFO_V1;
typedef NV_INFOROM_IMAGE_INFO_V1 NV_INFOROM_IMAGE_INFO;
#define NV_INFOROM_IMAGE_INFO_VER1 MAKE_NVAPI_VERSION(NV_INFOROM_IMAGE_INFO_V1, 1)
#define NV_INFOROM_IMAGE_INFO_VER NV_INFOROM_IMAGE_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetInfoROMData(__in NvPhysicalGpuHandle hPhysicalGpu,
                                         __inout NV_INFOROM_IMAGE_INFO *pInfoROMInfo);
typedef enum _NV_GPU_OPTIMIZATION_MODE {
  NV_GPU_OPTIMIZATION_MODE_NONE = 0,
  NV_GPU_OPTIMIZATION_MODE_DEFAULT = 1,
  NV_GPU_OPTIMIZATION_MODE_COMPUTE = 2,
  NV_GPU_OPTIMIZATION_MODE_SPARSE_TEXTURE = 3,
} NV_GPU_OPTIMIZATION_MODE;
typedef struct _NV_GPU_GET_OPTIMIZATION_DATA_V1 {
  NvU32 version;
  NvPhysicalGpuHandle hPhysicalGpu;
  NV_GPU_OPTIMIZATION_MODE defaultOptimizationMode;
  NV_GPU_OPTIMIZATION_MODE currentOptimizationMode;
} NV_GPU_GET_OPTIMIZATION_DATA_V1;
typedef NV_GPU_GET_OPTIMIZATION_DATA_V1 NV_GPU_GET_OPTIMIZATION_DATA;
#define NV_GPU_GET_OPTIMIZATION_DATA_VER1 MAKE_NVAPI_VERSION(NV_GPU_GET_OPTIMIZATION_DATA_V1, 1)
#define NV_GPU_GET_OPTIMIZATION_DATA_VER NV_GPU_GET_OPTIMIZATION_DATA_VER1
NVAPI_INTERFACE NvAPI_GPU_GetOptimizationData(__inout_ecount_part_opt(*count, *count)
                                                  NV_GPU_GET_OPTIMIZATION_DATA *gpuOptimizationData,
                                              __inout NvU32 *count);
typedef struct _NV_GPU_SET_OPTIMIZATION_DATA_V1 {
  NvU32 version;
  NvPhysicalGpuHandle hPhysicalGpu;
  NV_GPU_OPTIMIZATION_MODE setOptimizationMode;
} NV_GPU_SET_OPTIMIZATION_DATA_V1;
typedef NV_GPU_SET_OPTIMIZATION_DATA_V1 NV_GPU_SET_OPTIMIZATION_DATA;
#define NV_GPU_SET_OPTIMIZATION_DATA_VER1 MAKE_NVAPI_VERSION(NV_GPU_SET_OPTIMIZATION_DATA_V1, 1)
#define NV_GPU_SET_OPTIMIZATION_DATA_VER NV_GPU_SET_OPTIMIZATION_DATA_VER1
NVAPI_INTERFACE NvAPI_GPU_SetOptimizationData(__in_ecount(count) NV_GPU_SET_OPTIMIZATION_DATA *gpuOptimizationData,
                                              __in NvU32 count);
typedef enum _NV_VBIOS_SOURCE_TYPE {
  NV_VBIOS_SRC_TYPE_UNSET = 0x00,
  NV_VBIOS_SRC_TYPE_NOT_FOUND = 0x01,
  NV_VBIOS_SRC_TYPE_REGISTRY = 0x02,
  NV_VBIOS_SRC_TYPE_SW = 0x03,
  NV_VBIOS_SRC_TYPE_GPUMGR_CACHE = 0x04,
  NV_VBIOS_SRC_TYPE_INSTANCE_MEMORY = 0x05,
  NV_VBIOS_SRC_TYPE_ACPI_ROM = 0x06,
  NV_VBIOS_SRC_TYPE_ROM = 0x07,
  NV_VBIOS_SRC_TYPE_SBIOS = 0x08
} NV_VBIOS_SOURCE_TYPE;
#define NV_BIOS_MAX_SUBIMAGES 0x08
typedef struct _NV_VBIOS_SOURCE_INFO {
  NvU8 status;
  NvU8 nImages;
  NvU8 bLastImage[NV_BIOS_MAX_SUBIMAGES];
  NvU32 offset[NV_BIOS_MAX_SUBIMAGES];
  NvU32 imageLength[NV_BIOS_MAX_SUBIMAGES];
  NvU32 superImageLength;
  NvU32 romSig;
  NvU32 pciDataSig;
} NV_VBIOS_SOURCE_INFO;
typedef struct _NV_VBIOS_EXTRACTION_INFO_V1 {
  NvU32 version;
  NV_VBIOS_SOURCE_TYPE source;
  NV_VBIOS_SOURCE_INFO srcInfoReg;
  NV_VBIOS_SOURCE_INFO srcInfoCachedVbios;
  NV_VBIOS_SOURCE_INFO srcInfoInstanceMem;
  NV_VBIOS_SOURCE_INFO srcInfoRom;
  NV_VBIOS_SOURCE_INFO srcInfoAcpiRom;
  NV_VBIOS_SOURCE_INFO srcInfoSbios;
  NV_VBIOS_INFO_STATUS statusExpansionRom;
} NV_VBIOS_EXTRACTION_INFO_V1;
typedef NV_VBIOS_EXTRACTION_INFO_V1 NV_VBIOS_EXTRACTION_INFO;
#define NV_VBIOS_EXTRACTION_INFO_VER1 MAKE_NVAPI_VERSION(NV_VBIOS_EXTRACTION_INFO_V1, 1)
#define NV_VBIOS_EXTRACTION_INFO_VER NV_VBIOS_EXTRACTION_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetVbiosExtractionInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_VBIOS_EXTRACTION_INFO *pNvapiVbiosExtractionInfo);
NVAPI_INTERFACE NvAPI_GPU_GetVbiosStatusString(__in NV_VBIOS_INFO_STATUS status, __out NvAPI_ShortString szDesc);
NVAPI_INTERFACE NvAPI_GPU_GetRasterBackendCount(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCount);
#define NV_ECID_HASH_SIZE_IN_BYTES (32)
#define NV_SIGNED_ECID_RSA_1024_BUF_SIZE (0x00000080)
#define NV_SIGNED_ECID_RSA_2048_BUF_SIZE (0x00000100)
typedef enum { NV_ECID_SIGNALGO_RSA_1024 = 1, NV_ECID_SIGNALGO_RSA_2048 = 2 } NV_ECID_SIGNALGO;
typedef struct _NV_GPU_ECID {
  NvU8 ecidSha2Hash[NV_ECID_HASH_SIZE_IN_BYTES];
} NV_GPU_ECID;
typedef struct _NV_GPU_DEVICE_INFO {
  NvU16 vendorId;
  NvU16 deviceId;
  NvU16 subSystemId;
  NvU16 subVendorId;
  NvU16 revisionId;
  NvU16 chipId;
} NV_GPU_DEVICE_INFO;
typedef struct _NV_SIGN_GPUID_INPUT {
  NvU8 Nonce[16];
  NvU32 ProgramId;
  NvU32 SessionId;
  NV_ECID_SIGNALGO SignAlgo;
} NV_SIGN_GPUID_INPUT;
typedef struct _NV_ENCRYPTED_KEY_INFO {
  NvU8 *encryptedKey;
  NvU32 encryptedKeySize;
} NV_ENCRYPTED_KEY_INFO;
typedef struct _NV_SIGNED_GPUID_V1 {
  NvU32 version;
  NV_SIGN_GPUID_INPUT input;
  NV_GPU_ECID ecid;
  NvU32 uCodeVersion;
  NvU32 reserved;
  union {
    NvU8 RSA_1024_BUF[NV_SIGNED_ECID_RSA_1024_BUF_SIZE];
    NvU8 RSA_2048_BUF[NV_SIGNED_ECID_RSA_2048_BUF_SIZE];
  } signedPayload;
} NV_SIGNED_GPUID_V1;
typedef struct _NV_SIGNED_GPUID_V2 {
  NvU32 version;
  NV_SIGN_GPUID_INPUT input;
  NV_GPU_ECID ecid;
  NV_GPU_DEVICE_INFO deviceInfo;
  NvU32 uCodeVersion;
  union {
    NvU8 RSA_1024_BUF[NV_SIGNED_ECID_RSA_1024_BUF_SIZE];
    NvU8 RSA_2048_BUF[NV_SIGNED_ECID_RSA_2048_BUF_SIZE];
  } signedPayload;
} NV_SIGNED_GPUID_V2;
typedef NV_SIGNED_GPUID_V2 NV_SIGNED_GPUID;
#define NV_SIGNED_GPUID_VER1 MAKE_NVAPI_VERSION(NV_SIGNED_GPUID_V1, 1)
#define NV_SIGNED_GPUID_VER2 MAKE_NVAPI_VERSION(NV_SIGNED_GPUID_V2, 2)
#define NV_SIGNED_GPUID_VER NV_SIGNED_GPUID_VER2
NVAPI_INTERFACE NvAPI_GPU_GetSignedGPUID(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_ENCRYPTED_KEY_INFO *pKeyInfo,
                                         __inout NV_SIGNED_GPUID *pSignedGpuId);
#define NV_LICENSE_MAX_COUNT 3
#define NV_LICENSE_SIGNATURE_SIZE (128)
#define NV_LICENSE_INFO_MAX_LENGTH (128)
typedef char NvAPI_LicenseString[NV_LICENSE_INFO_MAX_LENGTH];
typedef enum _NV_LICENSE_FEATURE_TYPE {
  NV_LICENSE_FEATURE_UNKNOWN = 0,
  NV_LICENSE_FEATURE_VGPU = 1,
  NV_LICENSE_FEATURE_NVIDIA_RTX = 2,
  NV_LICENSE_FEATURE_QUADRO = NV_LICENSE_FEATURE_NVIDIA_RTX,
  NV_LICENSE_FEATURE_GAMING = 3,
} NV_LICENSE_FEATURE_TYPE;
typedef struct _NV_LICENSE_EXPIRY_DETAILS {
  NvU32 year;
  NvU16 month;
  NvU16 day;
  NvU16 hour;
  NvU16 min;
  NvU16 sec;
  NvU8 status;
} NV_LICENSE_EXPIRY_DETAILS;
typedef struct _NV_LICENSE_FEATURE_DETAILS_V1 {
  NvU32 version;
  NvU32 isEnabled : 1;
  NvU32 reserved : 31;
  NV_LICENSE_FEATURE_TYPE featureCode;
  NvAPI_LicenseString licenseInfo;
} NV_LICENSE_FEATURE_DETAILS_V1;
typedef struct _NV_LICENSE_FEATURE_DETAILS_V2 {
  NvU32 version;
  NvU32 isEnabled : 1;
  NvU32 reserved : 31;
  NV_LICENSE_FEATURE_TYPE featureCode;
  NvAPI_LicenseString licenseInfo;
  NvAPI_LicenseString productName;
} NV_LICENSE_FEATURE_DETAILS_V2;
typedef struct _NV_LICENSE_FEATURE_DETAILS_V3 {
  NvU32 version;
  NvU32 isEnabled : 1;
  NvU32 isFeatureEnabled : 1;
  NvU32 reserved : 30;
  NV_LICENSE_FEATURE_TYPE featureCode;
  NvAPI_LicenseString licenseInfo;
  NvAPI_LicenseString productName;
} NV_LICENSE_FEATURE_DETAILS_V3;
typedef struct _NV_LICENSE_FEATURE_DETAILS_V4 {
  NvU32 version;
  NvU32 isEnabled : 1;
  NvU32 isFeatureEnabled : 1;
  NvU32 reserved : 30;
  NV_LICENSE_FEATURE_TYPE featureCode;
  NvAPI_LicenseString licenseInfo;
  NvAPI_LicenseString productName;
  NV_LICENSE_EXPIRY_DETAILS licenseExpiry;
} NV_LICENSE_FEATURE_DETAILS_V4;
typedef NV_LICENSE_FEATURE_DETAILS_V1 NV_LICENSE_FEATURE_DETAILS;
#define NV_LICENSE_FEATURE_DETAILS_VER1 MAKE_NVAPI_VERSION(NV_LICENSE_FEATURE_DETAILS_V1, 1)
#define NV_LICENSE_FEATURE_DETAILS_VER NV_LICENSE_FEATURE_DETAILS_VER1
typedef struct _NV_LICENSABLE_FEATURES_V1 {
  NvU32 version;
  NvU32 isLicenseSupported : 1;
  NvU32 reserved : 31;
  NvU32 licensableFeatureCount;
  NvU8 signature[NV_LICENSE_SIGNATURE_SIZE];
  NV_LICENSE_FEATURE_DETAILS_V1 licenseDetails[NV_LICENSE_MAX_COUNT];
} NV_LICENSABLE_FEATURES_V1;
typedef struct _NV_LICENSABLE_FEATURES_V2 {
  NvU32 version;
  NvU32 isLicenseSupported : 1;
  NvU32 reserved : 31;
  NvU32 licensableFeatureCount;
  NvU8 signature[NV_LICENSE_SIGNATURE_SIZE];
  NV_LICENSE_FEATURE_DETAILS_V2 licenseDetails[NV_LICENSE_MAX_COUNT];
} NV_LICENSABLE_FEATURES_V2;
typedef struct _NV_LICENSABLE_FEATURES_V3 {
  NvU32 version;
  NvU32 isLicenseSupported : 1;
  NvU32 reserved : 31;
  NvU32 licensableFeatureCount;
  NvU8 signature[NV_LICENSE_SIGNATURE_SIZE];
  NV_LICENSE_FEATURE_DETAILS_V3 licenseDetails[NV_LICENSE_MAX_COUNT];
} NV_LICENSABLE_FEATURES_V3;
typedef struct _NV_LICENSABLE_FEATURES_V4 {
  NvU32 version;
  NvU32 isLicenseSupported : 1;
  NvU32 reserved : 31;
  NvU32 licensableFeatureCount;
  NvU8 signature[NV_LICENSE_SIGNATURE_SIZE];
  NV_LICENSE_FEATURE_DETAILS_V4 licenseDetails[NV_LICENSE_MAX_COUNT];
} NV_LICENSABLE_FEATURES_V4;
typedef NV_LICENSABLE_FEATURES_V4 NV_LICENSABLE_FEATURES;
#define NV_LICENSABLE_FEATURES_VER1 MAKE_NVAPI_VERSION(NV_LICENSABLE_FEATURES_V1, 1)
#define NV_LICENSABLE_FEATURES_VER2 MAKE_NVAPI_VERSION(NV_LICENSABLE_FEATURES_V2, 2)
#define NV_LICENSABLE_FEATURES_VER3 MAKE_NVAPI_VERSION(NV_LICENSABLE_FEATURES_V3, 3)
#define NV_LICENSABLE_FEATURES_VER4 MAKE_NVAPI_VERSION(NV_LICENSABLE_FEATURES_V4, 4)
#define NV_LICENSABLE_FEATURES_VER NV_LICENSABLE_FEATURES_VER4
NVAPI_INTERFACE NvAPI_GPU_GetLicensableFeatures(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_LICENSABLE_FEATURES *pLicensableFeatures);
NVAPI_INTERFACE NvAPI_GPU_GetLicensableFeaturesInternal(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                        __inout NV_LICENSABLE_FEATURES *pLicensableFeatures);
typedef struct _NV_ENABLE_LICENSED_FEATURE_V1 {
  NvU32 version;
  NV_LICENSE_FEATURE_TYPE featureCode;
  NvU8 signature[NV_LICENSE_SIGNATURE_SIZE];
} NV_ENABLE_LICENSED_FEATURE_V1;
typedef struct _NV_ENABLE_LICENSED_FEATURE_V2 {
  NvU32 version;
  NV_LICENSE_FEATURE_TYPE featureCode;
  NvU8 signature[NV_LICENSE_SIGNATURE_SIZE];
  NvU32 bEnableFeature : 1;
  NvU32 bSetLicenseState : 1;
  NvU32 reserved : 30;
} NV_ENABLE_LICENSED_FEATURE_V2;
typedef struct _NV_ENABLE_LICENSED_FEATURE_V3 {
  NvU32 version;
  NV_LICENSE_FEATURE_TYPE featureCode;
  NvU8 signature[NV_LICENSE_SIGNATURE_SIZE];
  NvU32 bEnableFeature : 1;
  NvU32 bSetLicenseState : 1;
  NvU32 reserved : 30;
  NvU32 licenseExpiryTimestamp;
  NvU8 licenseExpiryStatus;
} NV_ENABLE_LICENSED_FEATURE_V3;
typedef NV_ENABLE_LICENSED_FEATURE_V3 NV_ENABLE_LICENSED_FEATURE;
#define NV_ENABLE_LICENSED_FEATURE_VER1 MAKE_NVAPI_VERSION(NV_ENABLE_LICENSED_FEATURE_V1, 1)
#define NV_ENABLE_LICENSED_FEATURE_VER2 MAKE_NVAPI_VERSION(NV_ENABLE_LICENSED_FEATURE_V2, 2)
#define NV_ENABLE_LICENSED_FEATURE_VER3 MAKE_NVAPI_VERSION(NV_ENABLE_LICENSED_FEATURE_V3, 3)
#define NV_ENABLE_LICENSED_FEATURE_VER NV_ENABLE_LICENSED_FEATURE_VER3
NVAPI_INTERFACE NvAPI_GPU_EnableLicensedFeature(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __in NV_ENABLE_LICENSED_FEATURE *pLicensedFeature);
typedef struct _NV_DISABLE_LICENSED_FEATURE_V1 {
  NvU32 version;
  NV_LICENSE_FEATURE_TYPE featureCode;
} NV_DISABLE_LICENSED_FEATURE_V1;
typedef NV_DISABLE_LICENSED_FEATURE_V1 NV_DISABLE_LICENSED_FEATURE;
#define NV_DISABLE_LICENSED_FEATURE_VER1 MAKE_NVAPI_VERSION(NV_DISABLE_LICENSED_FEATURE_V1, 1)
#define NV_DISABLE_LICENSED_FEATURE_VER NV_DISABLE_LICENSED_FEATURE_VER1
NVAPI_INTERFACE NvAPI_GPU_DisableLicensedFeature(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __in NV_DISABLE_LICENSED_FEATURE *pLicensedFeature);
#define NVAPI_NVLINK_COUNTER_MAX_TYPES 32
#define NVAPI_NVLINK_MAX_LINKS 32
#define NVAPI_NVLINK_COUNTER_TL_TX0 0x00000001
#define NVAPI_NVLINK_COUNTER_TL_TX1 0x00000002
#define NVAPI_NVLINK_COUNTER_TL_RX0 0x00000004
#define NVAPI_NVLINK_COUNTER_TL_RX1 0x00000008
#define NVAPI_NVLINK_COUNTER_DL_RX_ERR_CRC_FLIT 0x00010000
#define NVAPI_NVLINK_COUNTER_DL_RX_ERR_CRC_LANE_L0 0x00020000
#define NVAPI_NVLINK_COUNTER_DL_RX_ERR_CRC_LANE_L1 0x00040000
#define NVAPI_NVLINK_COUNTER_DL_RX_ERR_CRC_LANE_L2 0x00080000
#define NVAPI_NVLINK_COUNTER_DL_RX_ERR_CRC_LANE_L3 0x00100000
#define NVAPI_NVLINK_COUNTER_DL_RX_ERR_CRC_LANE_L4 0x00200000
#define NVAPI_NVLINK_COUNTER_DL_RX_ERR_CRC_LANE_L5 0x00400000
#define NVAPI_NVLINK_COUNTER_DL_RX_ERR_CRC_LANE_L6 0x00800000
#define NVAPI_NVLINK_COUNTER_DL_RX_ERR_CRC_LANE_L7 0x01000000
#define NVAPI_NVLINK_COUNTER_DL_TX_ERR_REPLAY 0x02000000
#define NVAPI_NVLINK_COUNTER_DL_TX_ERR_RECOVERY 0x04000000
typedef struct {
  NvU32 version;
  NvU32 linkMask;
  NvU32 counterMask[NVAPI_NVLINK_MAX_LINKS];
} NVLINK_CLEAR_COUNTERS_V1;
typedef NVLINK_CLEAR_COUNTERS_V1 NVLINK_CLEAR_COUNTERS;
#define NVLINK_CLEAR_COUNTERS_VER1 MAKE_NVAPI_VERSION(NVLINK_CLEAR_COUNTERS_V1, 1)
#define NVLINK_CLEAR_COUNTERS_VER NVLINK_CLEAR_COUNTERS_VER1
NVAPI_INTERFACE NvAPI_GPU_NVLINK_ClearCounters(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __in NVLINK_CLEAR_COUNTERS *clearParams);
#define NVAPI_BIT_IDX_32(n)                                                                                            \
  ((((n) & 0xFFFF0000) ? 0x10 : 0) | (((n) & 0xFF00FF00) ? 0x08 : 0) | (((n) & 0xF0F0F0F0) ? 0x04 : 0) |               \
   (((n) & 0xCCCCCCCC) ? 0x02 : 0) | (((n) & 0xAAAAAAAA) ? 0x01 : 0))
typedef struct {
  NvU32 counterMask;
  NvU32 overflowMask;
  NvU64 counters[NVAPI_NVLINK_COUNTER_MAX_TYPES];
} NVLINK_COUNTER_DATA;
typedef struct {
  NvU32 version;
  NvU32 linkMask;
  NVLINK_COUNTER_DATA counterData[NVAPI_NVLINK_MAX_LINKS];
} NVLINK_GET_COUNTERS_V1;
typedef NVLINK_GET_COUNTERS_V1 NVLINK_GET_COUNTERS;
#define NVLINK_GET_COUNTERS_VER1 MAKE_NVAPI_VERSION(NVLINK_GET_COUNTERS_V1, 1)
#define NVLINK_GET_COUNTERS_VER NVLINK_GET_COUNTERS_VER1
NVAPI_INTERFACE NvAPI_GPU_NVLINK_GetCounters(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NVLINK_GET_COUNTERS *getParams);
#define NVAPI_NVLINK_CAPS_SUPPORTED 0x00000001
#define NVAPI_NVLINK_CAPS_P2P_SUPPORTED 0x00000002
#define NVAPI_NVLINK_CAPS_SYSMEM_ACCESS 0x00000004
#define NVAPI_NVLINK_CAPS_P2P_ATOMICS 0x00000008
#define NVAPI_NVLINK_CAPS_SYSMEM_ATOMICS 0x00000010
#define NVAPI_NVLINK_CAPS_ROUTE_THROUGH 0x00000020
#define NVAPI_NVLINK_CAPS_SYSMEM_CACHE_COHERENCE 0x00000040
#define NVAPI_NVLINK_CAPS_PEX_TUNNELING 0x00000080
#define NVAPI_NVLINK_CAPS_SLI_BRIDGE 0x00000100
#define NVAPI_NVLINK_CAPS_VALID 0x00000200
#define NVAPI_NVLINK_CAPS_NVLINK_VERSION_INVALID (0x00000000)
#define NVAPI_NVLINK_CAPS_NVLINK_VERSION_1_0 (0x00000001)
#define NVAPI_NVLINK_CAPS_NVLINK_VERSION_2_0 (0x00000002)
#define NVAPI_NVLINK_CAPS_NCI_VERSION_INVALID (0x00000000)
#define NVAPI_NVLINK_CAPS_NCI_VERSION_1_0 (0x00000001)
#define NVAPI_NVLINK_CAPS_NCI_VERSION_2_0 (0x00000002)
typedef struct {
  NvU32 version;
  NvU32 capsTbl;
  NvU8 lowestNvlinkVersion;
  NvU8 highestNvlinkVersion;
  NvU8 lowestNciVersion;
  NvU8 highestNciVersion;
  NvU32 linkMask;
} NVLINK_GET_CAPS_V1;
typedef NVLINK_GET_CAPS_V1 NVLINK_GET_CAPS;
#define NVLINK_GET_CAPS_VER1 MAKE_NVAPI_VERSION(NVLINK_GET_CAPS_V1, 1)
#define NVLINK_GET_CAPS_VER NVLINK_GET_CAPS_VER1
NVAPI_INTERFACE NvAPI_GPU_NVLINK_GetCaps(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NVLINK_GET_CAPS *capsParams);
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_ID_FLAGS_NONE (0x00000000)
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_ID_FLAGS_PCI (0x00000001)
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_ID_FLAGS_UUID (0x00000002)
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_TYPE_EBRIDGE (0x00000000)
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_TYPE_NPU (0x00000001)
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_TYPE_GPU (0x00000002)
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_TYPE_SWITCH (0x00000003)
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_TYPE_TEGRA (0x00000004)
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_TYPE_NONE (0x000000FF)
#define NVAPI_NVLINK_DEVICE_INFO_DEVICE_UUID_INVALID (0xFFFFFFFF)
typedef struct {
  NvU32 deviceIdFlags;
  NvU16 domain;
  NvU16 bus;
  NvU16 device;
  NvU16 function;
  NvU32 pciDeviceId;
  NvU64 deviceType;
  NvU8 deviceUUID[16];
} NVLINK_DEVICE_INFO_V1;
#define NVAPI_NVLINK_STATUS_LINK_STATE_INIT (0x00000000)
#define NVAPI_NVLINK_STATUS_LINK_STATE_HWCFG (0x00000001)
#define NVAPI_NVLINK_STATUS_LINK_STATE_SWCFG (0x00000002)
#define NVAPI_NVLINK_STATUS_LINK_STATE_ACTIVE (0x00000003)
#define NVAPI_NVLINK_STATUS_LINK_STATE_FAULT (0x00000004)
#define NVAPI_NVLINK_STATUS_LINK_STATE_RECOVERY (0x00000006)
#define NVAPI_NVLINK_STATUS_LINK_STATE_INVALID (0xFFFFFFFF)
#define NVAPI_NVLINK_STATUS_SUBLINK_RX_STATE_HIGH_SPEED_1 (0x00000000)
#define NVAPI_NVLINK_STATUS_SUBLINK_RX_STATE_TRAINING (0x00000005)
#define NVAPI_NVLINK_STATUS_SUBLINK_RX_STATE_SAFE_MODE (0x00000006)
#define NVAPI_NVLINK_STATUS_SUBLINK_RX_STATE_OFF (0x00000007)
#define NVAPI_NVLINK_STATUS_SUBLINK_RX_STATE_INVALID (0x000000FF)
#define NVAPI_NVLINK_STATUS_SUBLINK_TX_STATE_HIGH_SPEED_1 (0x00000000)
#define NVAPI_NVLINK_STATUS_SUBLINK_TX_STATE_TRAINING (0x00000005)
#define NVAPI_NVLINK_STATUS_SUBLINK_TX_STATE_SAFE_MODE (0x00000006)
#define NVAPI_NVLINK_STATUS_SUBLINK_TX_STATE_OFF (0x00000007)
#define NVAPI_NVLINK_STATUS_SUBLINK_TX_STATE_INVALID (0x000000FF)
#define NVAPI_NVLINK_STATUS_PHY_NVHS (0x00000001)
#define NVAPI_NVLINK_STATUS_PHY_GRS (0x00000002)
#define NVAPI_NVLINK_STATUS_PHY_INVALID (0x000000FF)
#define NVAPI_NVLINK_STATUS_NVLINK_VERSION_1_0 (0x00000001)
#define NVAPI_NVLINK_STATUS_NVLINK_VERSION_2_0 (0x00000002)
#define NVAPI_NVLINK_STATUS_NVLINK_VERSION_INVALID (0x000000FF)
#define NVAPI_NVLINK_STATUS_NCI_VERSION_1_0 (0x00000001)
#define NVAPI_NVLINK_STATUS_NCI_VERSION_2_0 (0x00000002)
#define NVAPI_NVLINK_STATUS_NCI_VERSION_INVALID (0x000000FF)
#define NVAPI_NVLINK_STATUS_NVHS_VERSION_1_0 (0x00000001)
#define NVAPI_NVLINK_STATUS_NVHS_VERSION_INVALID (0x000000FF)
#define NVAPI_NVLINK_STATUS_GRS_VERSION_1_0 (0x00000001)
#define NVAPI_NVLINK_STATUS_GRS_VERSION_INVALID (0x000000FF)
#define NVAPI_NVLINK_STATUS_CONNECTED_TRUE (0x00000001)
#define NVAPI_NVLINK_STATUS_CONNECTED_FALSE (0x00000000)
#define NVAPI_NVLINK_STATUS_LOOP_PROPERTY_LOOPBACK (0x00000001)
#define NVAPI_NVLINK_STATUS_LOOP_PROPERTY_LOOPOUT (0x00000002)
#define NVAPI_NVLINK_STATUS_LOOP_PROPERTY_NONE (0x00000000)
#define NVAPI_NVLINK_STATUS_REMOTE_LINK_NUMBER_INVALID (0x000000FF)
#define NVAPI_NVLINK_REFCLK_TYPE_INVALID (0x00)
#define NVAPI_NVLINK_REFCLK_TYPE_NVHS (0x01)
#define NVAPI_NVLINK_REFCLK_TYPE_PEX (0x02)
typedef struct {
  NvU32 capsTbl;
  NvU8 phyType;
  NvU8 subLinkWidth;
  NvU32 linkState;
  NvU8 rxSublinkStatus;
  NvU8 txSublinkStatus;
  NvU8 nvlinkVersion;
  NvU8 nciVersion;
  NvU8 phyVersion;
  NvU32 nvlinkCommonClockSpeedMhz;
  NvU32 nvlinkRefClkSpeedMhz;
  NvU8 nvlinkRefClkType;
  NvU32 nvlinkLinkClockMhz;
  NvU32 connected : 1;
  NvU32 reserved : 31;
  NvU8 loopProperty;
  NvU8 remoteDeviceLinkNumber;
  NVLINK_DEVICE_INFO_V1 remoteDeviceInfo;
} NVLINK_LINK_STATUS_INFO_V1;
typedef struct {
  NvU32 capsTbl;
  NvU8 phyType;
  NvU8 subLinkWidth;
  NvU32 linkState;
  NvU8 rxSublinkStatus;
  NvU8 txSublinkStatus;
  NvU8 nvlinkVersion;
  NvU8 nciVersion;
  NvU8 phyVersion;
  NvU32 nvlinkCommonClockSpeedMhz;
  NvU32 nvlinkRefClkSpeedMhz;
  NvU8 nvlinkRefClkType;
  NvU32 nvlinkLinkClockMhz;
  NvU32 connected : 1;
  NvU32 reserved : 31;
  NvU8 loopProperty;
  NvU8 remoteDeviceLinkNumber;
  NVLINK_DEVICE_INFO_V1 remoteDeviceInfo;
  NvU8 localDeviceLinkNumber;
  NVLINK_DEVICE_INFO_V1 localDeviceInfo;
  NvU32 nvlinkLineRateMbps;
  NvU32 reservedEx[8];
} NVLINK_LINK_STATUS_INFO_V2;
typedef struct {
  NvU32 version;
  NvU32 linkMask;
  NVLINK_LINK_STATUS_INFO_V1 linkInfo[NVAPI_NVLINK_MAX_LINKS];
} NVLINK_GET_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 linkMask;
  NVLINK_LINK_STATUS_INFO_V2 linkInfo[NVAPI_NVLINK_MAX_LINKS];
} NVLINK_GET_STATUS_V2;
typedef NVLINK_GET_STATUS_V2 NVLINK_GET_STATUS;
#define NVLINK_GET_STATUS_VER1 MAKE_NVAPI_VERSION(NVLINK_GET_STATUS_V1, 1)
#define NVLINK_GET_STATUS_VER2 MAKE_NVAPI_VERSION(NVLINK_GET_STATUS_V2, 2)
#define NVLINK_GET_STATUS_VER NVLINK_GET_STATUS_VER2
NVAPI_INTERFACE NvAPI_GPU_NVLINK_GetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NVLINK_GET_STATUS *statusParams);
#define NVAPI_NVLINK_GET_TL_ERRLOG_BIT(intr, i) (((1U << i) & (intr)) >> i)
#define NVAPI_NVLINK_GET_TL_INTEN_BIT(intr, i) NVAPI_NVLINK_GET_TL_ERRLOG_BIT(intr, i)
#define NVAPI_NVLINK_TL_INTEN_IDX_RXDLDATAPARITYEN 0
#define NVAPI_NVLINK_TL_INTEN_IDX_RXDLCTRLPARITYEN 1
#define NVAPI_NVLINK_TL_INTEN_IDX_RXPROTOCOLEN 2
#define NVAPI_NVLINK_TL_INTEN_IDX_RXOVERFLOWEN 3
#define NVAPI_NVLINK_TL_INTEN_IDX_RXRAMDATAPARITYEN 4
#define NVAPI_NVLINK_TL_INTEN_IDX_RXRAMHDRPARITYEN 5
#define NVAPI_NVLINK_TL_INTEN_IDX_RXRESPEN 6
#define NVAPI_NVLINK_TL_INTEN_IDX_RXPOISONEN 7
#define NVAPI_NVLINK_TL_INTEN_IDX_TXRAMDATAPARITYEN 8
#define NVAPI_NVLINK_TL_INTEN_IDX_TXRAMHDRPARITYEN 9
#define NVAPI_NVLINK_TL_INTEN_IDX_DLFLOWPARITYEN 10
#define NVAPI_NVLINK_TL_INTEN_IDX_DLHDRPARITYEN 12
#define NVAPI_NVLINK_TL_INTEN_IDX_TXCREDITEN 13
#define NVAPI_NVLINK_TL_INTEN_IDX_MAX 14
#define NVAPI_NVLINK_TL_ERRLOG_IDX_RXDLDATAPARITYERR 0
#define NVAPI_NVLINK_TL_ERRLOG_IDX_RXDLCTRLPARITYERR 1
#define NVAPI_NVLINK_TL_ERRLOG_IDX_RXPROTOCOLERR 2
#define NVAPI_NVLINK_TL_ERRLOG_IDX_RXOVERFLOWERR 3
#define NVAPI_NVLINK_TL_ERRLOG_IDX_RXRAMDATAPARITYERR 4
#define NVAPI_NVLINK_TL_ERRLOG_IDX_RXRAMHDRPARITYERR 5
#define NVAPI_NVLINK_TL_ERRLOG_IDX_RXRESPERR 6
#define NVAPI_NVLINK_TL_ERRLOG_IDX_RXPOISONERR 7
#define NVAPI_NVLINK_TL_ERRLOG_IDX_TXRAMDATAPARITYERR 8
#define NVAPI_NVLINK_TL_ERRLOG_IDX_TXRAMHDRPARITYERR 9
#define NVAPI_NVLINK_TL_ERRLOG_IDX_DLFLOWPARITYERR 10
#define NVAPI_NVLINK_TL_ERRLOG_IDX_DLHDRPARITYERR 12
#define NVAPI_NVLINK_TL_ERRLOG_IDX_TXCREDITERR 13
#define NVAPI_NVLINK_TL_ERRLOG_IDX_MAX 14
#define NVAPI_NVLINK_SL0_SLSM_STATUS_TX_PRIMARY_STATE_HS (0x00000000)
#define NVAPI_NVLINK_SL0_SLSM_STATUS_TX_PRIMARY_STATE_TRAIN (0x00000005)
#define NVAPI_NVLINK_SL0_SLSM_STATUS_TX_PRIMARY_STATE_SAFE (0x00000006)
#define NVAPI_NVLINK_SL0_SLSM_STATUS_TX_PRIMARY_STATE_OFF (0x00000007)
#define NVAPI_NVLINK_SL1_SLSM_STATUS_RX_PRIMARY_STATE_HS (0x00000000)
#define NVAPI_NVLINK_SL1_SLSM_STATUS_RX_PRIMARY_STATE_TRAIN (0x00000005)
#define NVAPI_NVLINK_SL1_SLSM_STATUS_RX_PRIMARY_STATE_SAFE (0x00000006)
#define NVAPI_NVLINK_SL1_SLSM_STATUS_RX_PRIMARY_STATE_OFF (0x00000007)
typedef struct {
  NvU32 TLErrlog;
  NvU32 TLIntrEn;
  NvU32 DLSpeedStatusTx;
  NvU32 DLSpeedStatusRx;
  NvU32 bExcessErrorDL : 1;
  NvU32 reserved : 31;
} NVLINK_ERR_INFO;
typedef struct {
  NvU32 version;
  NvU32 linkMask;
  NVLINK_ERR_INFO linkErrInfo[NVAPI_NVLINK_MAX_LINKS];
} NVLINK_GET_ERR_INFO_V1;
typedef NVLINK_GET_ERR_INFO_V1 NVLINK_GET_ERR_INFO;
#define NVLINK_GET_ERR_INFO_VER1 MAKE_NVAPI_VERSION(NVLINK_GET_ERR_INFO_V1, 1)
#define NVLINK_GET_ERR_INFO_VER NVLINK_GET_ERR_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_NVLINK_GetErrorInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NVLINK_GET_ERR_INFO *flagParams);
typedef struct {
  NvU32 version;
  NvU32 flags : 1;
  NvU32 reserved : 31;
} NVLINK_RESERVE_COUNTERS_V1;
typedef NVLINK_RESERVE_COUNTERS_V1 NVLINK_RESERVE_COUNTERS;
#define NVLINK_RESERVE_COUNTERS_VER1 MAKE_NVAPI_VERSION(NVLINK_RESERVE_COUNTERS_V1, 1)
#define NVLINK_RESERVE_COUNTERS_VER NVLINK_RESERVE_COUNTERS_VER1
NVAPI_INTERFACE NvAPI_GPU_NVLINK_ReserveCounters(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __in NVLINK_RESERVE_COUNTERS *reserveParams);
#define NVAPI_NVLINK_NUM_FATAL_ERROR_TYPES 20
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_RX_DL_DATA_PARITY 0
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_RX_DL_CTRL_PARITY 1
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_RX_PROTOCOL 2
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_RX_OVERFLOW 3
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_RX_RAM_DATA_PARITY 4
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_RX_RAM_HDR_PARITY 5
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_RX_POISON 7
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_TX_RAM_DATA_PARITY 8
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_TX_RAM_HDR_PARITY 9
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_TX_CREDIT 10
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_DL_FLOW_CTRL_PARITY 11
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_TL_DL_HDR_PARITY 12
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_DL_TX_RECOVERY_LONG 13
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_DL_TX_FAULT_RAM 14
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_DL_TX_FAULT_INTERFACE 15
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_DL_TX_FAULT_SUBLINK_CHANGE 16
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_DL_RX_FAULT_SUBLINK_CHANGE 17
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_DL_RX_FAULT_DL_PROTOCOL 18
#define NVAPI_NVLINK_FATAL_ERROR_TYPE_DL_LTSSM_FAULT 19
typedef struct {
  NvU32 version;
  NvU32 linkId;
  NvU8 fatalErrorCounts[NVAPI_NVLINK_NUM_FATAL_ERROR_TYPES];
} NVLINK_GET_LINK_FATAL_ERROR_COUNTS_V1;
typedef NVLINK_GET_LINK_FATAL_ERROR_COUNTS_V1 NVLINK_GET_LINK_FATAL_ERROR_COUNTS;
#define NVLINK_GET_LINK_FATAL_ERROR_COUNTS_VER1 MAKE_NVAPI_VERSION(NVLINK_GET_LINK_FATAL_ERROR_COUNTS_V1, 1)
#define NVLINK_GET_LINK_FATAL_ERROR_COUNTS_VER NVLINK_GET_LINK_FATAL_ERROR_COUNTS_VER1
NVAPI_INTERFACE NvAPI_GPU_NVLINK_GetFatalErrorsCount(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __inout NVLINK_GET_LINK_FATAL_ERROR_COUNTS *errorParams);
#define NVAPI_NVLINK_BRIDGE_FIRMWARE_VERSION_LENGTH (16 + 1)
#define NVAPI_NVLINK_BRIDGE_VENDOR_LENGTH (20 + 1)
#define NVAPI_NVLINK_BRIDGE_BOARD_PART_NUMBER_LENGTH (20 + 1)
#define NVAPI_NVLINK_BRIDGE_BOARD_REVISION_LENGTH (3 + 1)
#define NVAPI_NVLINK_BRIDGE_BUSINESS_UNIT_UNDEFINED (0x00)
#define NVAPI_NVLINK_BRIDGE_BUSINESS_UNIT_GEFORCE (0x01)
#define NVAPI_NVLINK_BRIDGE_BUSINESS_UNIT_QUADRO (0x02)
#define NVAPI_NVLINK_BRIDGE_BUSINESS_UNIT_TESLA (0x03)
#define NVAPI_NVLINK_BRIDGE_CONFIGURATION_UNDEFINED (0x00)
#define NVAPI_NVLINK_BRIDGE_CONFIGURATION_2_WAY (0x02)
#define NVAPI_NVLINK_BRIDGE_CONFIGURATION_3_WAY (0x03)
#define NVAPI_NVLINK_BRIDGE_CONFIGURATION_4_WAY (0x04)
#define NVAPI_NVLINK_BRIDGE_SPACING_UNDEFINED (0x00)
#define NVAPI_NVLINK_BRIDGE_SPACING_2_SLOT (0x02)
#define NVAPI_NVLINK_BRIDGE_SPACING_3_SLOT (0x03)
#define NVAPI_NVLINK_BRIDGE_SPACING_4_SLOT (0x04)
#define NVAPI_NVLINK_BRIDGE_INTERCONNECT_TYPE_UNDEFINED (0x00)
#define NVAPI_NVLINK_BRIDGE_INTERCONNECT_TYPE_NVLINK_2 (0x02)
#define NVAPI_NVLINK_BRIDGE_INTERCONNECT_TYPE_NVLINK_3 (0x03)
#define NVAPI_NVLINK_BRIDGE_INTERCONNECT_WIDTH_UNDEFINED (0x00)
#define NVAPI_NVLINK_BRIDGE_INTERCONNECT_WIDTH_4_LANES (0x02)
#define NVAPI_NVLINK_BRIDGE_INTERCONNECT_WIDTH_8_LANES (0x03)
#define NVAPI_NVLINK_BRIDGE_INTERCONNECT_WIDTH_16_LANES (0x04)
#define NVAPI_NVLINK_BRIDGE_ILLUMINATION_FEATURE_NONE (0x00)
#define NVAPI_NVLINK_BRIDGE_ILLUMINATION_FEATURE_SINGLE_COLOR (0x01)
#define NVAPI_NVLINK_BRIDGE_ILLUMINATION_FEATURE_RGB (0x02)
typedef struct {
  NvU32 version;
  NvU8 linkId;
  NvU8 bPresent : 1;
  NvU8 bValid : 1;
  NvU8 reserved : 6;
  char firmwareVersion[NVAPI_NVLINK_BRIDGE_FIRMWARE_VERSION_LENGTH];
  char bridgeVendor[NVAPI_NVLINK_BRIDGE_VENDOR_LENGTH];
  char boardPartNumber[NVAPI_NVLINK_BRIDGE_BOARD_PART_NUMBER_LENGTH];
  char boardRevision[NVAPI_NVLINK_BRIDGE_BOARD_REVISION_LENGTH];
  NvU8 businessUnit;
  NvU8 configuration;
  NvU8 spacing;
  NvU8 interconnectType;
  NvU8 interconnectWidth;
  NvF32 maximumLaneDataRate;
  NvU8 featureIllumination;
} NVLINK_GET_BRIDGE_EEPROM_STATUS_V1;
typedef NVLINK_GET_BRIDGE_EEPROM_STATUS_V1 NVLINK_GET_BRIDGE_EEPROM_STATUS;
#define NVLINK_GET_BRIDGE_EEPROM_STATUS_VER1 MAKE_NVAPI_VERSION(NVLINK_GET_BRIDGE_EEPROM_STATUS_V1, 1)
#define NVLINK_GET_BRIDGE_EEPROM_STATUS_VER NVLINK_GET_BRIDGE_EEPROM_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_NVLINK_GetBridgeEEPROMStatus(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NVLINK_GET_BRIDGE_EEPROM_STATUS *bridgeEEPROMStatusParams);
typedef struct {
  NvU32 version;
  NvU32 gpcId;
  NvU32 numPesInGpc;
  NvU32 activePesMask;
  NvU32 maxTpcPerGpcCount;
  NvU32 *tpcToPesMap;
} NVAPI_GPU_GET_PES_INFO_V1;
typedef NVAPI_GPU_GET_PES_INFO_V1 NVAPI_GPU_GET_PES_INFO;
#define NVAPI_GPU_GET_PES_INFO_VER1 MAKE_NVAPI_VERSION(NVAPI_GPU_GET_PES_INFO_V1, 1)
#define NVAPI_GPU_GET_PES_INFO_VER NVAPI_GPU_GET_PES_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_Get_PES_INFO(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NVAPI_GPU_GET_PES_INFO *pesInfo);
typedef enum _NV_D3COLD_SUPPORT {
  NV_D3COLD_SUPPORT_DISABLE,
  NV_D3COLD_SUPPORT_ENABLE,
} NV_D3COLD_SUPPORT;
NVAPI_INTERFACE NvAPI_GPU_DisableD3ColdSupportOnStopDevice(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                           __in NV_D3COLD_SUPPORT bDisableD3ColdOnStopDevice);
typedef struct _NV_ENCODER_STATISTICS_V1 {
  NvU32 version;
  NvU32 sessionsCount;
  NvU32 averageFps;
  NvU32 averageLatency;
} NV_ENCODER_STATISTICS_V1;
typedef NV_ENCODER_STATISTICS_V1 NV_ENCODER_STATISTICS;
#define NV_ENCODER_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_ENCODER_STATISTICS_V1, 1)
#define NNV_ENCODER_STATISTICS_VER NV_ENCODER_STATISTICS_VER1
NVAPI_INTERFACE NvAPI_GPU_GetEncoderStatistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_ENCODER_STATISTICS *pEncoderStatistics);
typedef enum _NV_ENCODER_TYPE {
  NV_ENCODER_H264,
  NV_ENCODER_HEVC,
  NV_ENCODER_UNKNOWN = 0xFFFFFFFF,
} NV_ENCODER_TYPE;
typedef struct _NV_ENCODER_PER_SESSION_INFO_V1 {
  NvU32 sessionId;
  NvU32 processId;
  NvU32 vgpuInstance;
  NV_ENCODER_TYPE codecType;
  NvU32 hResolution;
  NvU32 vResolution;
  NvU32 averageEncodeFps;
  NvU32 averageEncodeLatency;
} NV_ENCODER_PER_SESSION_INFO_V1;
#define NV_ENCODER_SESSION_INFO_MAX_ENTRIES_V1 0x200
typedef struct _NV_ENCODER_SESSIONS_INFO_V1 {
  NvU32 version;
  NvU32 sessionsCount;
  NV_ENCODER_PER_SESSION_INFO_V1 *pSessionInfo;
} NV_ENCODER_SESSIONS_INFO_V1;
typedef NV_ENCODER_SESSIONS_INFO_V1 NV_ENCODER_SESSIONS_INFO;
#define NV_ENCODER_SESSIONS_INFO_VER1 MAKE_NVAPI_VERSION(NV_ENCODER_SESSIONS_INFO_V1, 1)
#define NV_ENCODER_SESSIONS_INFO_VER NV_ENCODER_SESSIONS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetEncoderSessionsInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_ENCODER_SESSIONS_INFO *pEncoderSessionsInfo);
typedef struct _NV_FBC_STATISTICS_V1 {
  NvU32 version;
  NvU32 sessionsCount;
  NvU32 averageFPS;
  NvU32 averageLatency;
} NV_FBC_STATISTICS_V1;
typedef NV_FBC_STATISTICS_V1 NV_FBC_STATISTICS;
#define NV_FBC_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_FBC_STATISTICS_V1, 1)
#define NV_FBC_STATISTICS_VER NV_FBC_STATISTICS_VER1
NVAPI_INTERFACE NvAPI_GPU_GetFBCStatistics(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_FBC_STATISTICS *pFBCStatistics);
typedef enum _NV_FBC_SESSION_TYPE {
  NV_FBC_SESSION_TYPE_UNKNOWN = 0,
  NV_FBC_SESSION_TYPE_TOSYS,
  NV_FBC_SESSION_TYPE_CUDA,
  NV_FBC_SESSION_TYPE_VID,
  NV_FBC_SESSION_TYPE_HWENC,
} NV_FBC_SESSION_TYPE;
#define NV_FBC_WITH_WAIT_NO_WAIT 0
#define NV_FBC_WITH_WAIT_INFINITE 1
#define NV_FBC_WITH_WAIT_TIMEOUT 2
typedef struct _NV_FBC_PER_SESSION_INFO_V1 {
  NvU32 sessionId;
  NvU32 processId;
  NvU32 vgpuInstance;
  NvU32 displayOrdinal;
  NV_FBC_SESSION_TYPE sessionType;
  NvU32 isDiffMapEnabled : 1;
  NvU32 isClassificationMapEnabled : 1;
  NvU32 captureWithWait : 2;
  NvU32 reserved : 28;
  NvU32 hMaxResolution;
  NvU32 vMaxResolution;
  NvU32 hResolution;
  NvU32 vResolution;
  NvU32 averageFPS;
  NvU32 averageLatency;
} NV_FBC_PER_SESSION_INFO_V1;
#define NV_FBC_SESSION_INFO_MAX_ENTRIES_V1 256
typedef struct _NV_FBC_SESSIONS_INFO_V1 {
  NvU32 version;
  NvU32 sessionsCount;
  NV_FBC_PER_SESSION_INFO_V1 *pSessionInfo;
} NV_FBC_SESSIONS_INFO_V1;
typedef NV_FBC_SESSIONS_INFO_V1 NV_FBC_SESSIONS_INFO;
#define NV_FBC_SESSIONS_INFO_VER1 MAKE_NVAPI_VERSION(NV_FBC_SESSIONS_INFO_V1, 1)
#define NV_FBC_SESSIONS_INFO_VER NV_FBC_SESSIONS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetFBCSessionsInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_FBC_SESSIONS_INFO *pFBCSessionsInfo);
typedef struct _NV_PROCESS_UTILIZATION_SAMPLE_V1 {
  NvU32 pid;
  NvU64 timeStamp;
  NvU32 smUtilization;
  NvU32 memUtilization;
  NvU32 encUtilization;
  NvU32 decUtilization;
} NV_PROCESS_UTILIZATION_SAMPLE_V1;
#define NV_PROCESS_UTILIIZATION_MAX_SAMPLE_COUNT_V1 100
typedef struct _NV_PROCESS_UTILIZATION_INFO_V1 {
  NvU32 version;
  NvU64 previousQueryTimestamp;
  NvU32 samplesCount;
  NV_PROCESS_UTILIZATION_SAMPLE_V1 *pUtilizationSample;
} NV_PROCESS_UTILIZATION_INFO_V1;
typedef NV_PROCESS_UTILIZATION_INFO_V1 NV_PROCESS_UTILIZATION_INFO;
#define NV_PROCESS_UTILIZATION_INFO_VER1 MAKE_NVAPI_VERSION(NV_PROCESS_UTILIZATION_INFO_V1, 1)
#define NV_PROCESS_UTILIZATION_INFO_VER NV_PROCESS_UTILIZATION_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetProcessUtilizationInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_PROCESS_UTILIZATION_INFO *pProcessUtilizationInfo);
typedef struct _NV_GPU_FB_SET_RRD {
  NvU32 version;
  NvU32 rrd;
} NV_GPU_FB_SET_RRD_V1;
#define NV_GPU_FB_SET_RRD_VER1 MAKE_NVAPI_VERSION(NV_GPU_FB_SET_RRD_V1, 1)
#define NV_GPU_FB_SET_RRD_VER NV_GPU_FB_SET_RRD_VER1
typedef NV_GPU_FB_SET_RRD_V1 NV_GPU_FB_SET_RRD;
#define NV_GPU_FB_SET_RRD_RESET_VALUE (~(NvU32)0)
NVAPI_INTERFACE NvAPI_GPU_FbSetRrd(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FB_SET_RRD *pSetRrd);
typedef struct _NV_GPU_FB_SET_READ_WRITE_LIMIT {
  NvU32 version;
  NvU8 limit;
} NV_GPU_FB_SET_READ_WRITE_LIMIT_V1;
#define NV_GPU_FB_SET_READ_WRITE_LIMIT_VER1 MAKE_NVAPI_VERSION(NV_GPU_FB_SET_READ_WRITE_LIMIT_V1, 1)
#define NV_GPU_FB_SET_READ_WRITE_LIMIT_VER NV_GPU_FB_SET_READ_WRITE_LIMIT_VER1
typedef NV_GPU_FB_SET_READ_WRITE_LIMIT_V1 NV_GPU_FB_SET_READ_WRITE_LIMIT;
#define NV_GPU_FB_SET_READ_WRITE_LIMIT_RESET_VALUE (0xFF)
typedef NV_GPU_FB_SET_READ_WRITE_LIMIT_V1 NV_GPU_FB_SET_READ_LIMIT_V1;
typedef NV_GPU_FB_SET_READ_LIMIT_V1 NV_GPU_FB_SET_READ_LIMIT;
#define NV_GPU_FB_SET_READ_LIMIT_VER1 MAKE_NVAPI_VERSION(NV_GPU_FB_SET_READ_LIMIT_V1, 1)
#define NV_GPU_FB_SET_READ_LIMIT_VER NV_GPU_FB_SET_READ_LIMIT_VER1
#define NV_GPU_FB_SET_READ_LIMIT_RESET_VALUE NV_GPU_FB_SET_READ_WRITE_LIMIT_RESET_VALUE
typedef NV_GPU_FB_SET_READ_WRITE_LIMIT_V1 NV_GPU_FB_SET_WRITE_LIMIT_V1;
typedef NV_GPU_FB_SET_WRITE_LIMIT_V1 NV_GPU_FB_SET_WRITE_LIMIT;
#define NV_GPU_FB_SET_WRITE_LIMIT_VER1 MAKE_NVAPI_VERSION(NV_GPU_FB_SET_WRITE_LIMIT_V1, 1)
#define NV_GPU_FB_SET_WRITE_LIMIT_VER NV_GPU_FB_SET_WRITE_LIMIT_VER1
#define NV_GPU_FB_SET_WRITE_LIMIT_RESET_VALUE NV_GPU_FB_SET_READ_WRITE_LIMIT_RESET_VALUE
NVAPI_INTERFACE NvAPI_GPU_FbSetReadLimit(__in NvPhysicalGpuHandle hPhysicalGpu,
                                         __inout NV_GPU_FB_SET_READ_LIMIT *pSetReadLimit);
NVAPI_INTERFACE NvAPI_GPU_FbSetWriteLimit(__in NvPhysicalGpuHandle hPhysicalGpu,
                                          __inout NV_GPU_FB_SET_WRITE_LIMIT *pSetWriteLimit);
typedef struct _NV_GPU_FB_PATCH_PBR_FOR_MINING_V1 {
  NvU32 version;
  NvBool bEnable;
} NV_GPU_FB_PATCH_PBR_FOR_MINING_V1;
#define NV_GPU_FB_PATCH_PBR_FOR_MINING_VER1 MAKE_NVAPI_VERSION(NV_GPU_FB_PATCH_PBR_FOR_MINING_V1, 1)
#define NV_GPU_FB_PATCH_PBR_FOR_MINING_VER NV_GPU_FB_PATCH_PBR_FOR_MINING_VER1
typedef NV_GPU_FB_PATCH_PBR_FOR_MINING_V1 NV_GPU_FB_PATCH_PBR_FOR_MINING;
NVAPI_INTERFACE NvAPI_GPU_FbPatchPbrForMining(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_FB_PATCH_PBR_FOR_MINING *pPatchPbr);
typedef struct _NV_GPU_INFO_V1 {
  NvU32 version;
  NvU32 bIsExternalGpu : 1;
  NvU32 reserved : 31;
} NV_GPU_INFO_V1;
typedef struct _NV_GPU_INFO_V2 {
  NvU32 version;
  NvU32 bIsExternalGpu : 1;
  NvU32 reserved : 31;
  NvU64 pdi;
  NvU32 rayTracingCores;
  NvU32 tensorCores;
  NvU32 reservedEx[14];
} NV_GPU_INFO_V2;
#define NV_GPU_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_INFO_V1, 1)
#define NV_GPU_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_INFO_V2, 2)
#define NV_GPU_INFO_VER NV_GPU_INFO_VER2
typedef NV_GPU_INFO_V2 NV_GPU_INFO;
NVAPI_INTERFACE NvAPI_GPU_GetGPUInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_INFO *pGpuInfo);
typedef struct _NV_GPU_ASPM_CONTROL_DATA_V1 {
  NvU32 version;
  NvU32 bEnable : 1;
  NvU32 reserved : 31;
} NV_GPU_ASPM_CONTROL_DATA_V1;
#define NV_GPU_ASPM_CONTROL_DATA_VER1 MAKE_NVAPI_VERSION(NV_GPU_ASPM_CONTROL_DATA_V1, 1)
#define NV_GPU_ASPM_CONTROL_DATA_VER NV_GPU_ASPM_CONTROL_DATA_VER1
typedef NV_GPU_ASPM_CONTROL_DATA_V1 NV_GPU_ASPM_CONTROL_DATA;
NVAPI_INTERFACE NvAPI_GPU_ControlASPM(__in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_ASPM_CONTROL_DATA *pASPMData);
typedef struct _NV_GET_GPU_ACTIVATION_STATE_V1 {
  NvU32 version;
  NvU32 activated : 1;
  NvU32 legacy : 1;
  NvU32 reserved : 30;
} NV_GET_GPU_ACTIVATION_STATE_V1;
#define NV_GET_GPU_ACTIVATION_STATE_VER1 MAKE_NVAPI_VERSION(NV_GET_GPU_ACTIVATION_STATE_V1, 1)
#define NV_GET_GPU_ACTIVATION_STATE_VER NV_GET_GPU_ACTIVATION_STATE_VER1
typedef NV_GET_GPU_ACTIVATION_STATE_V1 NV_GET_GPU_ACTIVATION_STATE;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 460.") NVAPI_INTERFACE
    NvAPI_GPU_GetActivationState(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GET_GPU_ACTIVATION_STATE *pState);
typedef struct _NV_SET_GPU_ACTIVATION_STATE_V1 {
  NvU32 version;
  NvU32 activate : 1;
  NvU32 reserved : 31;
} NV_SET_GPU_ACTIVATION_STATE_V1;
#define NV_SET_GPU_ACTIVATION_STATE_VER1 MAKE_NVAPI_VERSION(NV_SET_GPU_ACTIVATION_STATE_V1, 1)
#define NV_SET_GPU_ACTIVATION_STATE_VER NV_SET_GPU_ACTIVATION_STATE_VER1
typedef NV_SET_GPU_ACTIVATION_STATE_V1 NV_SET_GPU_ACTIVATION_STATE;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 460.") NVAPI_INTERFACE
    NvAPI_GPU_SetActivationState(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_SET_GPU_ACTIVATION_STATE *pState);
typedef enum _NV_GPU_P2P_CAPS_VALUES {
  NV_GPU_P2P_CAPS_WRITES_SUPPORTED = 0x00000001,
  NV_GPU_P2P_CAPS_READS_SUPPORTED = 0x00000002,
  NV_GPU_P2P_CAPS_PROP_SUPPORTED = 0x00000004,
  NV_GPU_P2P_CAPS_NVLINK_SUPPORTED = 0x00000008,
  NV_GPU_P2P_CAPS_ATOMICS_SUPPORTED = 0x00000010,
  NV_GPU_P2P_CAPS_PCI_SUPPORTED = 0x00000020,
} NV_GPU_P2P_CAPS_VALUES;
typedef struct _NV_GPU_P2P_CAPS_DATA_V1 {
  NvU32 version;
  NvPhysicalGpuHandle hPhysicalGpu0;
  NvPhysicalGpuHandle hPhysicalGpu1;
  NvU32 p2pCaps;
} NV_GPU_P2P_CAPS_DATA_V1;
#define NV_GPU_P2P_CAPS_DATA_VER1 MAKE_NVAPI_VERSION(NV_GPU_P2P_CAPS_DATA_V1, 1)
typedef NV_GPU_P2P_CAPS_DATA_V1 NV_GPU_P2P_CAPS_DATA;
#define NV_GPU_P2P_CAPS_DATA_VER NV_GPU_P2P_CAPS_DATA_VER1
NVAPI_INTERFACE NvAPI_GPU_GetP2PCapsData(__inout NV_GPU_P2P_CAPS_DATA *pP2PCapsData);
#define NV_MAX_KEY_VALUES 8
#define NV_KEY_VALUE_LENGTH 256
#define NV_KEY_NAME_LENGTH 512
typedef NvU16 NvAPI_UnicodeKeyName[NV_KEY_NAME_LENGTH];
typedef NvU16 NvAPI_UnicodeKeyValues[NV_MAX_KEY_VALUES][NV_KEY_VALUE_LENGTH];
typedef struct _NV_GPU_KEY_DETAILS {
  NvU32 version;
  NvAPI_UnicodeKeyName keyName;
  NvAPI_UnicodeKeyValues keyValues;
  NvU32 keyValuesCount;
} NV_GPU_KEY_DETAILS_V1;
#define NV_GPU_KEY_DETAILS_VER1 MAKE_NVAPI_VERSION(NV_GPU_KEY_DETAILS_V1, 1)
typedef NV_GPU_KEY_DETAILS_V1 NV_GPU_KEY_DETAILS;
#define NV_GPU_KEY_DETAILS_VER NV_GPU_KEY_DETAILS_VER1
NVAPI_INTERFACE NvAPI_GPU_GetValuesFromInstalledINF(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_KEY_DETAILS *pKeyDetails);
typedef enum _NV_VPR_INFO_QUERY_TYPE {
  NV_GPU_QUERY_INVALID = 0,
  NV_GPU_QUERY_VPR_CAPS = 1,
  NV_GPU_QUERY_CUR_VPR_RANGE = 2,
} NV_VPR_INFO_QUERY_TYPE;
typedef struct _NV_GPU_VPR_INFO_DATA_V1 {
  NvU32 version;
  NV_VPR_INFO_QUERY_TYPE queryType;
  NvU64 vprStartAddressInBytes;
  NvU64 vprEndAddressInBytes;
  NvU32 bIsVprEnabled : 1;
  NvU32 reserved : 31;
  NvU32 reservedEx[8];
} NV_GPU_VPR_INFO_DATA_V1;
#define NV_GPU_VPR_INFO_DATA_VER1 MAKE_NVAPI_VERSION(NV_GPU_VPR_INFO_DATA_V1, 1)
typedef NV_GPU_VPR_INFO_DATA_V1 NV_GPU_VPR_INFO_DATA;
#define NV_GPU_VPR_INFO_DATA_VER NV_GPU_VPR_INFO_DATA_VER1
NVAPI_INTERFACE NvAPI_GPU_GetVPRInfoData(__in NvPhysicalGpuHandle hPhysicalGpu,
                                         __inout NV_GPU_VPR_INFO_DATA *pVPRInfoData);
typedef struct _NV_GPU_GET_SLI_STATE_INFO_V1 {
  NvU32 version;
  NvU32 bIsSLIStateUserModified : 1;
  NvU32 reserved : 31;
} NV_GPU_GET_SLI_STATE_INFO_V1;
typedef NV_GPU_GET_SLI_STATE_INFO_V1 NV_GPU_GET_SLI_STATE_INFO;
#define NV_GPU_GET_SLI_STATE_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_GET_SLI_STATE_INFO_V1, 1)
#define NV_GPU_GET_SLI_STATE_INFO_VER NV_GPU_GET_SLI_STATE_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetSLIStateInfo(__inout NV_GPU_GET_SLI_STATE_INFO *pGpuSLIStateInfo);
typedef struct _NV_GPU_INFO_INTERNAL_V1 {
  NvU32 version;
  NvU32 chipSkuId;
  NvU32 fuseFileVersion;
  NvU32 reserved[8];
} NV_GPU_INFO_INTERNAL_V1;
#define NV_GPU_INFO_INTERNAL_VER1 MAKE_NVAPI_VERSION(NV_GPU_INFO_INTERNAL_V1, 1)
#define NV_GPU_INFO_INTERNAL_VER NV_GPU_INFO_INTERNAL_VER1
typedef NV_GPU_INFO_INTERNAL_V1 NV_GPU_INFO_INTERNAL;
NVAPI_INTERFACE NvAPI_GPU_GetGPUInfoInternal(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_INFO_INTERNAL *pGpuInfo);
typedef struct _NV_GPU_VR_READY_V1 {
  NvU32 version;
  NvU32 isVRReady : 1;
  NvU32 reserved : 31;
} NV_GPU_VR_READY_V1;
#define NV_GPU_VR_READY_VER1 MAKE_NVAPI_VERSION(NV_GPU_VR_READY_V1, 1)
#define NV_GPU_VR_READY_VER NV_GPU_VR_READY_VER1
typedef NV_GPU_VR_READY_V1 NV_GPU_VR_READY;
NVAPI_INTERFACE NvAPI_GPU_GetVRReadyData(__in NvPhysicalGpuHandle hPhysicalGpu,
                                         __inout NV_GPU_VR_READY *pGpuVrReadyData);
typedef enum _NV_DRIVER_MODEL {
  NV_DRIVER_MODEL_UNKNOWN = 0,
  NV_DRIVER_MODEL_WDDM = 1,
  NV_DRIVER_MODEL_WDM = 2,
  NV_DRIVER_MODEL_MCDM = 3,
} NV_DRIVER_MODEL;
typedef struct _NV_DRIVER_MODEL_INFO_V1 {
  NvU32 version;
  NV_DRIVER_MODEL driverModel;
  NvU32 driverModelNumber;
} NV_DRIVER_MODEL_INFO_V1;
#define NV_DRIVER_MODEL_INFO_VER1 MAKE_NVAPI_VERSION(NV_DRIVER_MODEL_INFO_V1, 1)
#define NV_DRIVER_MODEL_INFO_VER NV_DRIVER_MODEL_INFO_VER1
typedef NV_DRIVER_MODEL_INFO_V1 NV_DRIVER_MODEL_INFO;
NVAPI_INTERFACE NvAPI_GPU_GetDriverModelEx(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_DRIVER_MODEL_INFO *pDriverModelInfo);
typedef enum {
  NV_GPU_NNE_NNE_VAR_TYPE_FREQ = 0x00000000U,
  NV_GPU_NNE_NNE_VAR_TYPE_PM,
  NV_GPU_NNE_NNE_VAR_TYPE_CHIP_CONFIG,
  NV_GPU_NNE_NNE_VAR_TYPE_POWER_DN,
  NV_GPU_NNE_NNE_VAR_TYPE_POWER_TOTAL,
} NV_GPU_NNE_NNE_VAR_TYPE;
#define NV_GPU_NNE_NNE_VAR_MAX_V1 512U
#define NV_GPU_NNE_NNE_VAR_MAX NV_GPU_NNE_NNE_VAR_MAX_V1
typedef struct {
  NvU8 clkDomainIdx;
  NvBool bAbsolute;
} NV_GPU_NNE_NNE_VAR_ID_FREQ;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_FREQ freqId;
} NV_GPU_NNE_NNE_VAR_INFO_FREQ;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_FREQ freqId;
  NvS32 freqMhz;
} NV_GPU_NNE_NNE_VAR_INPUT_FREQ;
typedef struct {
  NvU16 baIdx;
} NV_GPU_NNE_NNE_VAR_ID_PM;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_PM pmId;
  NvU32 secNorm;
} NV_GPU_NNE_NNE_VAR_INFO_PM;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_PM pmId;
  NvU64 pmCount;
} NV_GPU_NNE_NNE_VAR_INPUT_PM;
typedef enum {
  NV_GPU_NNE_NNE_VAR_CHIP_CONFIG_CONFIG_TYPE_TPC,
  NV_GPU_NNE_NNE_VAR_CHIP_CONFIG_CONFIG_TYPE_FBP,
  NV_GPU_NNE_NNE_VAR_CHIP_CONFIG_CONFIG_TYPE_LTC_SLICE,
} NV_GPU_NNE_NNE_VAR_CHIP_CONFIG_CONFIG_TYPE_ENUM;
typedef struct {
  NV_GPU_NNE_NNE_VAR_CHIP_CONFIG_CONFIG_TYPE_ENUM configType;
} NV_GPU_NNE_NNE_VAR_ID_CHIP_CONFIG;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_CHIP_CONFIG configId;
} NV_GPU_NNE_NNE_VAR_INFO_CHIP_CONFIG;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_CHIP_CONFIG configId;
  NvU32 config;
} NV_GPU_NNE_NNE_VAR_INPUT_CHIP_CONFIG;
typedef struct {
  NV_GPU_BOARDOBJ_IDX voltRailIdx;
} NV_GPU_NNE_NNE_VAR_ID_POWER_DN;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_POWER_DN id;
  NvU32 voltageuV;
} NV_GPU_NNE_NNE_VAR_INFO_POWER_DN;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_POWER_DN id;
  NvU32 powermW;
} NV_GPU_NNE_NNE_VAR_INPUT_POWER_DN;
typedef enum {
  NV_GPU_NNE_NNE_VAR_ID_POWER_TOTAL_VOLT_RAIL_NAME_FBVDD,
} NV_GPU_NNE_NNE_VAR_ID_POWER_TOTAL_VOLT_RAIL_NAME;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_POWER_TOTAL_VOLT_RAIL_NAME voltRailName;
} NV_GPU_NNE_NNE_VAR_ID_POWER_TOTAL;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_POWER_TOTAL id;
} NV_GPU_NNE_NNE_VAR_INFO_POWER_TOTAL;
typedef struct {
  NV_GPU_NNE_NNE_VAR_ID_POWER_TOTAL id;
  NvU32 powermW;
} NV_GPU_NNE_NNE_VAR_INPUT_POWER_TOTAL;
typedef union {
  NV_GPU_NNE_NNE_VAR_INFO_FREQ freq;
  NV_GPU_NNE_NNE_VAR_INFO_PM pm;
  NV_GPU_NNE_NNE_VAR_INFO_CHIP_CONFIG config;
  NV_GPU_NNE_NNE_VAR_INFO_POWER_DN powerDn;
  NV_GPU_NNE_NNE_VAR_INFO_POWER_TOTAL powerTotal;
  NvU32 rsvd[32U];
} NV_GPU_NNE_NNE_VAR_INFO_DATA_V1;
typedef struct {
  NV_GPU_NNE_NNE_VAR_TYPE type;
  NvU8 rsvd[64U];
  NV_GPU_NNE_NNE_VAR_INFO_DATA_V1 data;
} NV_GPU_NNE_NNE_VAR_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 varsMask;
  NvU8 rsvd[64U];
  NV_GPU_NNE_NNE_VAR_INFO_V1 vars[NV_GPU_NNE_NNE_VAR_MAX_V1];
} NV_GPU_NNE_NNE_VARS_INFO_V1;
typedef NV_GPU_NNE_NNE_VARS_INFO_V1 NV_GPU_NNE_NNE_VARS_INFO;
typedef NV_GPU_NNE_NNE_VAR_INFO_V1 NV_GPU_NNE_NNE_VAR_INFO;
#define NV_GPU_NNE_NNE_VARS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_NNE_NNE_VARS_INFO_V1, 1U)
#define NV_GPU_NNE_NNE_VARS_INFO_VER NV_GPU_NNE_NNE_VARS_INFO_VER1
typedef union {
  NV_GPU_NNE_NNE_VAR_INPUT_PM pm;
  NV_GPU_NNE_NNE_VAR_INPUT_FREQ freq;
  NV_GPU_NNE_NNE_VAR_INPUT_CHIP_CONFIG config;
  NV_GPU_NNE_NNE_VAR_INPUT_POWER_DN powerDn;
  NV_GPU_NNE_NNE_VAR_INPUT_POWER_TOTAL powerTotal;
  NvU8 rsvd[64U];
} NV_GPU_NNE_NNE_VAR_INPUT_DATA;
typedef struct {
  NV_GPU_NNE_NNE_VAR_TYPE type;
  NvU8 rsvd[32U];
  NV_GPU_NNE_NNE_VAR_INPUT_DATA data;
} NV_GPU_NNE_NNE_VAR_INPUT;
NVAPI_INTERFACE NvAPI_GPU_NneNneVarsGetInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_NNE_NNE_VARS_INFO *pNneVarsInfo);
typedef enum {
  NV_GPU_NNE_NNE_LAYER_TYPE_FC_10 = 0x00000000U,
} NV_GPU_NNE_NNE_LAYER_TYPE;
#define NV_GPU_NNE_NNE_LAYER_MAX_V1 255U
typedef enum {
  NV_GPU_NNE_NNE_LAYER_FC_10_ACTIVATION_FUNCTION_TYPE_IDENTITY,
  NV_GPU_NNE_NNE_LAYER_FC_10_ACTIVATION_FUNCTION_TYPE_RELU,
  NV_GPU_NNE_NNE_LAYER_FC_10_ACTIVATION_FUNCTION_TYPE_LEAKY_RELU,
} NV_GPU_NNE_NNE_LAYER_FC_10_ACTIVATION_FUNCTION_TYPE_ENUM;
typedef struct {
  NvU16 numInputs;
  NvU8 numNeurons;
  NvBool bHasBias;
  NV_GPU_NNE_NNE_LAYER_FC_10_ACTIVATION_FUNCTION_TYPE_ENUM activationFunction;
  NvU32 leakyReLUSlope;
} NV_GPU_NNE_NNE_LAYER_INFO_FC_10;
typedef union {
  NV_GPU_NNE_NNE_LAYER_INFO_FC_10 fc10;
  NvU8 rsvd[32U];
} NV_GPU_NNE_NNE_LAYER_INFO_DATA_V1;
typedef enum {
  NV_GPU_NNE_NNE_LAYER_WEIGHT_TYPE_FP16,
  NV_GPU_NNE_NNE_LAYER_WEIGHT_TYPE_FP32,
} NV_GPU_NNE_NNE_LAYER_WEIGHT_TYPE_ENUM;
#define NV_GPU_NNE_NNE_LAYER_INDEX_INVALID NV_GPU_BOARDOBJ_IDX_INVALID
typedef struct {
  NV_GPU_NNE_NNE_LAYER_TYPE type;
  NV_GPU_BOARDOBJ_IDX nextLayerIdx;
  NV_GPU_BOARDOBJ_IDX prevLayerIdx;
  NV_GPU_NNE_NNE_LAYER_WEIGHT_TYPE_ENUM weightType;
  NvU16 weightIdx;
  NvU8 rsvd[64U];
  NV_GPU_NNE_NNE_LAYER_INFO_DATA_V1 data;
} NV_GPU_NNE_NNE_LAYER_INFO_V1;
#define NV_GPU_NNE_NNE_LAYER_WEIGHTS_MAX_BYTES (0x10000U)
#define NV_GPU_NNE_NNE_LAYER_WEIGHTS_MAX_FP16 (NV_GPU_NNE_NNE_LAYER_WEIGHTS_MAX_BYTES / sizeof(NvU16))
#define NV_GPU_NNE_NNE_LAYER_WEIGHTS_MAX_FP32 (NV_GPU_NNE_NNE_LAYER_WEIGHTS_MAX_BYTES / sizeof(NvU32))
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 layersMask;
  NvU16 numFp16Weights;
  NvU16 fp16Weights[NV_GPU_NNE_NNE_LAYER_WEIGHTS_MAX_FP16];
  NvU16 numFp32Weights;
  NvU32 fp32Weights[NV_GPU_NNE_NNE_LAYER_WEIGHTS_MAX_FP32];
  NvU8 rsvd[64U];
  NV_GPU_NNE_NNE_LAYER_INFO_V1 layers[NV_GPU_NNE_NNE_LAYER_MAX_V1];
} NV_GPU_NNE_NNE_LAYERS_INFO_V1;
typedef NV_GPU_NNE_NNE_LAYERS_INFO_V1 NV_GPU_NNE_NNE_LAYERS_INFO;
typedef NV_GPU_NNE_NNE_LAYER_INFO_V1 NV_GPU_NNE_NNE_LAYER_INFO;
#define NV_GPU_NNE_NNE_LAYERS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_NNE_NNE_LAYERS_INFO_V1, 1U)
#define NV_GPU_NNE_NNE_LAYERS_INFO_VER NV_GPU_NNE_NNE_LAYERS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_NneNneLayersGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                              NV_GPU_NNE_NNE_LAYERS_INFO *pNneLayersInfo);
typedef enum {
  NV_GPU_NNE_NNE_DESC_TYPE_FC_10 = 0x00000000U,
} NV_GPU_NNE_NNE_DESC_TYPE;
#define NV_GPU_NNE_NNE_DESC_MAX_V1 32U
typedef struct {
  NvU32 rsvd;
} NV_GPU_NNE_NNE_DESC_INFO_FC_10;
typedef union {
  NV_GPU_NNE_NNE_DESC_INFO_FC_10 fc10;
  NvU8 rsvd[32U];
} NV_GPU_NNE_NNE_DESC_INFO_DATA_V1;
typedef enum {
  NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_DISABLED = 0x0,
  NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_POWER,
  NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_POWER_DN,
  NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_POWER_TOTAL,
  NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_ENERGY_DN,
  NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_ENERGY_TOTAL,
  NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_PERF,
} NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_ENUM;
typedef struct {
  NvU8 pwrChIdx;
} NV_GPU_NNE_NNE_DESC_OUTPUT_ID_POWER;
typedef struct {
  NV_GPU_BOARDOBJ_IDX voltRailIdx;
  NvU32 voltageuV;
} NV_GPU_NNE_NNE_DESC_OUTPUT_ID_POWER_DN;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_POWER powerId;
  NvU32 powerMw;
} NV_GPU_NNE_NNE_DESC_OUTPUT_POWER;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_POWER_DN id;
  NvU32 powermW;
} NV_GPU_NNE_NNE_DESC_OUTPUT_POWER_DN;
typedef enum {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_VOLT_RAIL_NAME_FBVDD = 0,
} NV_GPU_NNE_NNE_DESC_OUTPUT_ID_VOLT_RAIL_NAME_ENUM;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_VOLT_RAIL_NAME_ENUM voltRailName;
} NV_GPU_NNE_NNE_DESC_OUTPUT_ID_POWER_TOTAL;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_POWER_TOTAL id;
  NvU32 powermW;
} NV_GPU_NNE_NNE_DESC_OUTPUT_POWER_TOTAL;
typedef struct {
  NV_GPU_BOARDOBJ_IDX voltRailIdx;
  NvU32 voltageuV;
} NV_GPU_NNE_NNE_DESC_OUTPUT_ID_ENERGY_DN;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_ENERGY_DN id;
  NvU32 energymJ;
} NV_GPU_NNE_NNE_DESC_OUTPUT_ENERGY_DN;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_VOLT_RAIL_NAME_ENUM voltRailName;
} NV_GPU_NNE_NNE_DESC_OUTPUT_ID_ENERGY_TOTAL;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_ENERGY_TOTAL id;
  NvU32 energymJ;
} NV_GPU_NNE_NNE_DESC_OUTPUT_ENERGY_TOTAL;
typedef struct {
  NvU32 rsvd;
} NV_GPU_NNE_NNE_DESC_OUTPUT_ID_PERF;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_PERF perfId;
  NvU32 perf;
} NV_GPU_NNE_NNE_DESC_OUTPUT_PERF;
typedef union {
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_POWER power;
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_POWER_DN powerDn;
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_POWER_TOTAL powerTotal;
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_ENERGY_DN energyDn;
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_ENERGY_TOTAL energyTotal;
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_PERF perf;
  NvU8 rsvd[32U];
} NV_GPU_NNE_NNE_DESC_OUTPUT_ID_DATA;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_ENUM type;
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID_DATA data;
} NV_GPU_NNE_NNE_DESC_OUTPUT_ID;
typedef union {
  NV_GPU_NNE_NNE_DESC_OUTPUT_POWER power;
  NV_GPU_NNE_NNE_DESC_OUTPUT_POWER_DN powerDn;
  NV_GPU_NNE_NNE_DESC_OUTPUT_POWER_TOTAL powerTotal;
  NV_GPU_NNE_NNE_DESC_OUTPUT_ENERGY_DN energyDn;
  NV_GPU_NNE_NNE_DESC_OUTPUT_ENERGY_TOTAL energyTotal;
  NV_GPU_NNE_NNE_DESC_OUTPUT_PERF perf;
  NvU8 rsvd[64U];
} NV_GPU_NNE_NNE_DESC_OUTPUT_DATA;
typedef struct {
  NV_GPU_NNE_NNE_DESC_OUTPUT_TYPE_ENUM type;
  NvU8 rsvd[32U];
  NV_GPU_NNE_NNE_DESC_OUTPUT_DATA data;
} NV_GPU_NNE_NNE_DESC_OUTPUT;
#define NV_GPU_NNE_NNE_DESC_OUTPUT_MAX_OUTPUTS (8U)
typedef enum {
  NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_SECONDARY = 0,
  NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_SATURATION,
  NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_POISON,
  NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_RESERVED = 7,
  NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_NUM_MODES,
  NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_DEFAULT = 0xFF
} NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_ENUM;
#define NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_THRESHOLD_DISABLED (NV_U16_MAX)
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E512 violationVarMask;
  NvU16 violationCount;
  NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_ENUM appliedMode;
  NvU8 rsvd[32U];
} NV_GPU_NNE_NNE_DESC_INPUT_NORM_STATUS;
typedef struct {
  NvU16 modeThresholds[NV_GPU_NNE_NNE_DESC_INPUT_NORM_MODE_NUM_MODES];
} NV_GPU_NNE_NNE_DESC_INPUT_NORM_INFO;
typedef struct {
  NV_GPU_NNE_NNE_DESC_TYPE type;
  NV_GPU_BOARDOBJ_IDX firstLayerIdx;
  NV_GPU_BOARDOBJ_IDX lastLayerIdx;
  NvU16 firstVarIdx;
  NvU16 lastVarIdx;
  NvU16 numLayers;
  NvU16 maxLayerNumInputs;
  NvU8 numOutputs;
  NV_GPU_NNE_NNE_DESC_OUTPUT_ID outputs[NV_GPU_NNE_NNE_DESC_OUTPUT_MAX_OUTPUTS];
  NvU16 maxInterLayerNumOutputs;
  NvU8 networkVersion;
  NvU8 pad[1];
  NV_GPU_NNE_NNE_DESC_INPUT_NORM_INFO inputNormInfo;
  NvU8 rsvd[54U];
  NV_GPU_NNE_NNE_DESC_INFO_DATA_V1 data;
} NV_GPU_NNE_NNE_DESC_INFO_V1;
#define NV_GPU_NNE_NNE_DESC_NUM_VAR_IDX_MAX (512U)
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 descsMask;
  NvU16 numVarIdx;
  NV_GPU_BOARDOBJ_IDX varIdxArray[NV_GPU_NNE_NNE_DESC_NUM_VAR_IDX_MAX];
  NvU8 rsvd[64U];
  NV_GPU_NNE_NNE_DESC_INFO_V1 descs[NV_GPU_NNE_NNE_DESC_MAX_V1];
} NV_GPU_NNE_NNE_DESCS_INFO_V1;
typedef NV_GPU_NNE_NNE_DESCS_INFO_V1 NV_GPU_NNE_NNE_DESCS_INFO;
typedef NV_GPU_NNE_NNE_DESC_INFO_V1 NV_GPU_NNE_NNE_DESC_INFO;
#define NV_GPU_NNE_NNE_DESCS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_NNE_NNE_DESCS_INFO_V1, 1U)
#define NV_GPU_NNE_NNE_DESCS_INFO_VER NV_GPU_NNE_NNE_DESCS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_NneNneDescsGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                             NV_GPU_NNE_NNE_DESCS_INFO *pNneDescsInfo);
typedef enum {
  NV_GPU_NNE_NNE_DESC_INFERENCE_PROFILING_REGION_TOTAL_TIME = 0,
  NV_GPU_NNE_NNE_DESC_INFERENCE_PROFILING_REGION_INPUT_LOAD,
  NV_GPU_NNE_NNE_DESC_INFERENCE_PROFILING_REGION_SWZL_GENERATION,
  NV_GPU_NNE_NNE_DESC_INFERENCE_PROFILING_REGION_DESC_LOAD,
  NV_GPU_NNE_NNE_DESC_INFERENCE_PROFILING_REGION_DLC_EVAL,
  NV_GPU_NNE_NNE_DESC_INFERENCE_PROFILING_REGION_MAX,
} NV_GPU_NNE_NNE_DESC_INFERENCE_PROFILING_REGION_ENUM;
typedef enum {
  NV_GPU_NNE_NNE_DESC_INFERENCE_ROUNDING_MODE_TO_NEAREST_EVEN,
  NV_GPU_NNE_NNE_DESC_INFERENCE_ROUNDING_MODE_TOWARDS_ZERO,
  NV_GPU_NNE_NNE_DESC_INFERENCE_ROUNDING_MODE_TOWARDS_POSITIVE_INFINITY,
  NV_GPU_NNE_NNE_DESC_INFERENCE_ROUNDING_MODE_TOWARDS_NEGATIVE_INFINITY,
  NV_GPU_NNE_NNE_DESC_INFERENCE_ROUNDING_MODE_TO_NEAREST_UP,
  NV_GPU_NNE_NNE_DESC_INFERENCE_ROUNDING_MODE_AWAY_FROM_ZERO,
} NV_GPU_NNE_NNE_DESC_INFERENCE_ROUNDING_MODE;
typedef struct {
  NV_GPU_NNE_NNE_DESC_INFERENCE_ROUNDING_MODE roundingMode;
  NvBool bClampInfinityToNormal;
  NvU8 rsvd[35U];
} NV_GPU_NNE_NNE_DESC_INFERENCE_CONFIG;
typedef NvU32 NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_FLAGS;
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_NONE 0x00000000U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_INVALID 0U : 0U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_INVALID_NOT_PENDING 0x00000000U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_INVALID_PENDING 0x00000001U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_UNDERFLOW 1U : 1U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_UNDERFLOW_NOT_PENDING 0x00000000U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_UNDERFLOW_PENDING 0x00000001U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_OVERFLOW 2U : 2U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_OVERFLOW_NOT_PENDING 0x00000000U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_OVERFLOW_PENDING 0x00000001U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_INEXACT 3U : 3U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_INEXACT_NOT_PENDING 0x00000000U
#define NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_INEXACT_PENDING 0x00000001U
typedef struct {
  NvU16 varInputCntLoop;
  NvU16 descOutputCnt;
  NvU8 rsvd[60U];
  NV_GPU_NNE_NNE_VAR_INPUT varInputs[NV_GPU_NNE_NNE_VAR_MAX];
  NV_GPU_NNE_NNE_DESC_INFERENCE_FP_EXCEPTION_FLAGS exceptions;
  NV_GPU_NNE_NNE_DESC_OUTPUT descOutputs[NV_GPU_NNE_NNE_DESC_OUTPUT_MAX_OUTPUTS];
} NV_GPU_NNE_NNE_DESC_INFERENCE_LOOP;
typedef struct {
  NV_GPU_NNE_NNE_DESC_INFERENCE_CONFIG inferenceCfg;
  NV_GPU_BOARDOBJ_IDX descIdx;
  NvU8 descOutputCnt;
  NvU8 loopCnt;
  NvU16 varInputCntStatic;
  NvU16 varInputCntLoop;
  NvU64 elapsedTimes[NV_GPU_NNE_NNE_DESC_INFERENCE_PROFILING_REGION_MAX];
  NvU8 rsvd[64U];
} NV_GPU_NNE_NNE_DESC_INFERENCE_HEADER;
#define NV_GPU_NNE_NNE_DESC_INFERENCE_LOOPS_MAX (8U)
typedef struct {
  NvU32 version;
  NV_GPU_NNE_NNE_DESC_INFERENCE_HEADER hdr;
  NvU8 rsvd[256U];
  NV_GPU_NNE_NNE_VAR_INPUT varInputsStatic[NV_GPU_NNE_NNE_VAR_MAX];
  NV_GPU_NNE_NNE_DESC_INFERENCE_LOOP loops[NV_GPU_NNE_NNE_DESC_INFERENCE_LOOPS_MAX];
  NvAPI_Status inferenceStatus;
} NV_GPU_NNE_NNE_DESC_INFERENCE_V1;
typedef NV_GPU_NNE_NNE_DESC_INFERENCE_V1 NV_GPU_NNE_NNE_DESC_INFERENCE;
#define NV_GPU_NNE_NNE_DESC_INFERENCE_VER1 MAKE_NVAPI_VERSION(NV_GPU_NNE_NNE_DESC_INFERENCE_V1, 1U)
#define NV_GPU_NNE_NNE_DESC_INFERENCE_VER NV_GPU_NNE_NNE_DESC_INFERENCE_VER1
NVAPI_INTERFACE NvAPI_GPU_NneNneDescInference(NvPhysicalGpuHandle hPhysicalGpu,
                                              NV_GPU_NNE_NNE_DESC_INFERENCE *pNneDescsInference);
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_SUPPORTED 0x00000001
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_ENABLE 0x00000002
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_DISABLE 0x00000004
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_ACTIVE 0x00000008
#define NV_PERF_CLOCK_GPU_HYBRID_MODE_INACTIVE 0x00000010
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 375.") NVAPI_INTERFACE
    NvAPI_GPU_SetPerfHybridMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 gpuPerfFlags);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 375.") NVAPI_INTERFACE
    NvAPI_GPU_GetPerfHybridMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pGpuPerfFlags);
#define NVAPI_MAX_PERF_CLOCK_LEVELS 12
#define NVAPI_TARGET_ALL_PERF_LEVELS 0xffffffff
#define NV_PERF_CLOCK_LEVEL_STATE_DEFAULT 0x00000000
#define NV_PERF_CLOCK_LEVEL_STATE_OVERCLOCKED 0x00000001
#define NV_PERF_CLOCK_LEVEL_STATE_DESKTOP 0x00000002
#define NV_PERF_CLOCK_LEVEL_STATE_PERFORMANCE 0x00000004
#define NV_PERF_CLOCK_LEVEL_STATE_TEST 0x00000008
#define NV_PERF_CLOCK_LEVEL_STATE_TEST_SUCCESS 0x00000010
#define NV_PERF_CLOCK_GPU_STATE_DEFAULT 0x00000000
#define NV_PERF_CLOCK_GPU_STATE_DYNAMIC_SUPPORTED 0x00000001
#define NV_PERF_CLOCK_GPU_STATE_DESKTOP 0x00000002
#define NV_PERF_CLOCK_GPU_STATE_PERFORMANCE 0x00000004
#define NV_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_SUPPORTED 0x00000008
#define NV_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_ENABLE 0x00000010
#define NV_PERF_CLOCK_GPU_STATE_ACTIVE_CLOCKING_DISABLE 0x00000020
#define NV_PERF_CLOCK_GPU_STATE_MEMCLK_CONTROL_DISABLED 0x00000040
#define NV_PERF_CLOCK_GPU_STATE_GFXCLK_CONTROL_DISABLED 0x00000080
#define NV_PERF_CLOCK_GPU_STATE_SET_DEFERRED 0x00000100
#define NV_PERF_CLOCK_GPU_STATE_TESTING_CLOCKS_SUPPORTED 0x00000200
typedef struct {
  NvU32 version;
  NvU32 levelCount;
  NvU32 gpuPerflevel;
  NvU32 domainCount;
  NvU32 gpuPerfFlags;
  struct {
    NvU32 level;
    NvU32 flags;
    struct {
      NV_GPU_PUBLIC_CLOCK_ID domainId;
      NvU32 domainFlags;
      NvU32 currentFreq;
      NvU32 defaultFreq;
      NvU32 minFreq;
      NvU32 maxFreq;
      NvU32 bSetClock : 1;
    } domain[NVAPI_MAX_GPU_PERF_CLOCKS];
  } perfLevel[NVAPI_MAX_PERF_CLOCK_LEVELS];
} NV_GPU_PERF_CLOCK_TABLE;
#define NV_GPU_PERF_CLOCK_TABLE_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_CLOCK_TABLE, 1)
#define NV_GPU_PERF_CLOCK_TABLE_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_CLOCK_TABLE, 2)
#define NV_GPU_PERF_CLOCK_TABLE_VER NV_GPU_PERF_CLOCK_TABLE_VER2
NVAPI_INTERFACE NvAPI_GPU_GetPerfClocks(NvPhysicalGpuHandle hPhysicalGpu, NvU32 level,
                                        NV_GPU_PERF_CLOCK_TABLE *pPerfClkTable);
NVAPI_INTERFACE NvAPI_GPU_SetPerfClocks(NvPhysicalGpuHandle hPhysicalGpu, NvU32 level,
                                        NV_GPU_PERF_CLOCK_TABLE *pPerfClkTable);
#define NV_GPU_PERF_SET_FORCE_PSTATE_FLAGS_ASYNC 0x00000001
#define NV_GPU_PERF_INPUT_FLAGS_DEFAULT_SETTINGS 0x00000001
#define NV_GPU_PERF_INPUT_FLAGS_MAX_CLOCK_FREQ 0x00000002
#define NV_GPU_PERF_INPUT_FLAGS_MIN_CLOCK_FREQ 0x00000004
#define NV_GPU_PERF_PSTATES_FLAGS_PERFMON_ENABLED 0x00000001
#define NV_GPU_PERF_PSTATES_FLAGS_DYN_PSTATES_CAPABLE 0x00000002
#define NV_GPU_PERF_PSTATES_FLAGS_DYNAMIC_PSTATE_ENABLED 0x00000004
#define NV_GPU_PERF_PSTATES_FLAGS_MODE_INTERNAL_TEST 0x00000008
#define NV_GPU_PERF_PSTATE_FLAGS_PCIELIMIT_GEN1 0x00000001
#define NV_GPU_PERF_PSTATE_FLAGS_OVERCLOCKED_TRUE 0x00000002
#define NV_GPU_PERF_PSTATE_FLAGS_OVERCLOCKABLE 0x00000004
#define NV_GPU_PERF_PSTATE_CLOCK_FLAGS_OVERCLOCKABLE 0x00000001
#define NV_GPU_PERF_PSTATE_CLOCK_INTERNAL_FLAGS_FORCE_PLL 0x00000001
#define NV_GPU_PERF_PSTATE_CLOCK_INTERNAL_FLAGS_FORCE_BYPASS 0x00000002
#define NV_GPU_PERF_PSTATE_VOLTAGE_FLAGS_VDT 0x00000001
typedef enum _NV_GPU_PERF_VID_ENG {
  NV_GPU_PERF_VID_ENG_NVENC,
  NV_GPU_PERF_VID_ENG_NVDEC,
} NV_GPU_PERF_VID_ENG;
typedef struct _NV_GPU_GET_VID_ENG_PERF_SAMPLE {
  NvU32 version;
  NV_GPU_PERF_VID_ENG engineType;
  NvU32 clkPercentBusy;
  NvU32 samplingPeriodUs;
} NV_GPU_GET_VID_ENG_PERF_SAMPLE_V1;
typedef NV_GPU_GET_VID_ENG_PERF_SAMPLE_V1 NV_GPU_GET_VID_ENG_PERF_SAMPLE;
#define NV_GPU_GET_VID_ENG_PERF_SAMPLE_VER1 MAKE_NVAPI_VERSION(NV_GPU_GET_VID_ENG_PERF_SAMPLE_V1, 1)
#define NV_GPU_GET_VID_ENG_PERF_SAMPLE_VER NV_GPU_GET_VID_ENG_PERF_SAMPLE_VER1
NVAPI_INTERFACE NvAPI_GPU_GetVideoEnginePerfSample(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GPU_GET_VID_ENG_PERF_SAMPLE *pParams);
#define NV_CTRL_PERF_BOOST_DURATION_MAX 30
typedef enum _NV_GPU_PERF_BOOST_FLAGS_CMD {
  NV_GPU_PERF_BOOST_FLAGS_CMD_CLEAR = 0x00000000,
  NV_GPU_PERF_BOOST_FLAGS_CMD_BOOST_1LEVEL = 0x00000001,
  NV_GPU_PERF_BOOST_FLAGS_CMD_BOOST_TO_MAX = 0x00000002
} NV_GPU_PERF_BOOST_FLAGS_CMD;
typedef struct {
  NvU32 version;
  NV_GPU_PERF_BOOST_FLAGS_CMD flags;
  NvU32 duration;
} NV_GPU_PERF_BOOST_PARAMS_V1;
typedef NV_GPU_PERF_BOOST_PARAMS_V1 NV_GPU_PERF_BOOST_PARAMS;
#define NV_GPU_PERF_BOOST_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_BOOST_PARAMS_V1, 1)
#define NV_GPU_PERF_BOOST_PARAMS_VER NV_GPU_PERF_BOOST_PARAMS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfModeBoost(__in NvPhysicalGpuHandle hPhysicalGpu,
                                        __in NV_GPU_PERF_BOOST_PARAMS *boostParams);
#define NV_GPU_PERF_VF_INDEXES_TABLE_MAX_ENTRIES_V1 64
typedef struct {
  NV_GPU_PERF_PSTATE_ID pstateId;
  NV_GPU_CLOCK_DOMAIN_ID domainId;
  NvU32 entryIndexFirst;
  NvU32 entryIndexLast;
} NV_GPU_PERF_VF_INDEXES_TABLE_ENTRY_V1;
#define NV_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V1 64
#define NV_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V2 128
#define NV_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_NONE 0
#define NV_GPU_PERF_VF_ENTRIES_TABLE_STEP_SIZE_ALL 1
typedef struct {
  NvU32 maxFreqKHz;
  NvU32 freqStepSizeKHz;
  NvU32 bForcePll : 1;
  NvU32 bForceBypass : 1;
  NvU32 flags : 30;
  struct {
    NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
    NvU32 flags;
    NvU32 mvolt;
  } voltage;
} NV_GPU_PERF_VF_ENTRIES_TABLE_ENTRY_V1;
typedef struct {
  NvU32 version;
  NvU32 numIndexes;
  NV_GPU_PERF_VF_INDEXES_TABLE_ENTRY_V1 indexes[NV_GPU_PERF_VF_INDEXES_TABLE_MAX_ENTRIES_V1];
  NvU32 numEntries;
  NV_GPU_PERF_VF_ENTRIES_TABLE_ENTRY_V1 entries[NV_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V1];
} NV_GPU_PERF_VF_TABLES_V1;
typedef struct _NV_GPU_PERF_VF_TABLES_V2 {
  NvU32 version;
  NvU32 numIndexes;
  NV_GPU_PERF_VF_INDEXES_TABLE_ENTRY_V1 indexes[NV_GPU_PERF_VF_INDEXES_TABLE_MAX_ENTRIES_V1];
  NvU32 numEntries;
  NV_GPU_PERF_VF_ENTRIES_TABLE_ENTRY_V1 entries[NV_GPU_PERF_VF_ENTRIES_TABLE_MAX_ENTRIES_V2];
} NV_GPU_PERF_VF_TABLES_V2;
typedef NV_GPU_PERF_VF_TABLES_V2 NV_GPU_PERF_VF_TABLES;
#define NV_GPU_PERF_VF_TABLES_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_VF_TABLES_V1, 1)
#define NV_GPU_PERF_VF_TABLES_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_VF_TABLES_V2, 2)
#define NV_GPU_PERF_VF_TABLES_VER NV_GPU_PERF_VF_TABLES_VER2
NVAPI_INTERFACE NvAPI_GPU_PerfVfTablesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_PERF_VF_TABLES *pPerfVfTablesInfo);
typedef struct {
  NvU32 version;
  NvU8 bSupported;
} NV_GPU_PERF_RATED_TDP_INFO_V1;
typedef NV_GPU_PERF_RATED_TDP_INFO_V1 NV_GPU_PERF_RATED_TDP_INFO;
#define NV_GPU_PERF_RATED_TDP_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_RATED_TDP_INFO_V1, 1)
#define NV_GPU_PERF_RATED_TDP_INFO_VER NV_GPU_PERF_RATED_TDP_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfRatedTdpGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_PERF_RATED_TDP_INFO *pInfo);
typedef enum {
  NV_GPU_PERF_RATED_TDP_CLIENT_RM = 0x0,
  NV_GPU_PERF_RATED_TDP_CLIENT_GLOBAL,
  NV_GPU_PERF_RATED_TDP_CLIENT_OS,
  NV_GPU_PERF_RATED_TDP_CLIENT_PROFILE,
  NV_GPU_PERF_RATED_TDP_CLIENT_WAR_BUG_1785342,
  NV_GPU_PERF_RATED_TDP_CLIENT_NUM_CLIENTS,
} NV_GPU_PERF_RATED_TDP_CLIENT;
typedef enum {
  NV_GPU_PERF_RATED_TDP_ACTION_DEFAULT = 0x0,
  NV_GPU_PERF_RATED_TDP_ACTION_FORCE_EXCEED,
  NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LIMIT,
  NV_GPU_PERF_RATED_TDP_ACTION_FORCE_LOCK,
  NV_GPU_PERF_RATED_TDP_ACTION_FORCE_FLOOR,
} NV_GPU_PERF_RATED_TDP_ACTION;
typedef struct {
  NvU32 version;
  struct {
    NvU32 clientActiveMask;
    NvU8 bRegkeyLimitRatedTdp;
  } rm;
  NV_GPU_PERF_RATED_TDP_ACTION output;
  NV_GPU_PERF_RATED_TDP_ACTION
  inputs[NV_GPU_PERF_RATED_TDP_CLIENT_NUM_CLIENTS];
} NV_GPU_PERF_RATED_TDP_STATUS_V1;
typedef NV_GPU_PERF_RATED_TDP_STATUS_V1 NV_GPU_PERF_RATED_TDP_STATUS;
#define NV_GPU_PERF_RATED_TDP_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_RATED_TDP_STATUS_V1, 1)
#define NV_GPU_PERF_RATED_TDP_STATUS_VER NV_GPU_PERF_RATED_TDP_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfRatedTdpGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_GPU_PERF_RATED_TDP_STATUS *pStatus);
typedef struct {
  NvU32 version;
  NV_GPU_PERF_RATED_TDP_CLIENT client;
  NV_GPU_PERF_RATED_TDP_ACTION input;
} NV_GPU_PERF_RATED_TDP_CONTROL_V1;
typedef NV_GPU_PERF_RATED_TDP_CONTROL_V1 NV_GPU_PERF_RATED_TDP_CONTROL;
#define NV_GPU_PERF_RATED_TDP_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_RATED_TDP_CONTROL_V1, 1)
#define NV_GPU_PERF_RATED_TDP_CONTROL_VER NV_GPU_PERF_RATED_TDP_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfRatedTdpGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_PERF_RATED_TDP_CONTROL *pControl);
NVAPI_INTERFACE NvAPI_GPU_PerfRatedTdpSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_PERF_RATED_TDP_CONTROL *pControl);
typedef enum {
  NV_GPU_PERF_POLICY_ID_SW_POWER = 0,
  NV_GPU_PERF_POLICY_ID_SW_THERMAL,
  NV_GPU_PERF_POLICY_ID_SW_RELIABILITY,
  NV_GPU_PERF_POLICY_ID_SW_OPERATING,
  NV_GPU_PERF_POLICY_ID_SW_UTILIZATION,
  NV_GPU_PERF_POLICY_ID_SW_SLI_GPU_BOOST_SYNC,
} NV_GPU_PERF_POLICY_ID_SW;
#define NV_GPU_PERF_POLICY_ID_SW_NUM_V1 12
typedef enum {
  NV_GPU_PERF_POINT_ID_MAX_CLOCK = 0,
  NV_GPU_PERF_POINT_ID_BOOST_CLOCK,
  NV_GPU_PERF_POINT_ID_BASE_CLOCK,
  NV_GPU_PERF_POINT_ID_DISPLAY,
} NV_GPU_PERF_POINT_ID;
#define NV_GPU_PERF_POINT_ID_NUM_V1 6
typedef struct {
  NvU32 version;
  NvU32 supportedPointMask;
  NvU32 supportedPolicyMask;
  NvU32 rsvd[16];
} NV_GPU_PERF_POLICIES_INFO_PARAMS_V1;
#define NV_GPU_PERF_POLICIES_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_PERF_POLICIES_INFO_PARAMS_V1, 1)
#define NV_GPU_PERF_POLICIES_INFO_PARAMS_VER NV_GPU_PERF_POLICIES_INFO_PARAMS_VER_1
typedef NV_GPU_PERF_POLICIES_INFO_PARAMS_V1 NV_GPU_PERF_POLICIES_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_PerfPoliciesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_PERF_POLICIES_INFO_PARAMS *pPerfPoliciesInfo);
typedef struct {
  NvU32 perfPointMask;
  NvU64 perfPointTimeNs[NV_GPU_PERF_POINT_ID_NUM_V1];
  NvU32 rsvd[8];
} NV_GPU_PERF_POLICY_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 requestedPolicyMask;
  NvU64 referenceTimeNs;
  NvU32 limitingPoliciesMask;
  NV_GPU_PERF_POLICY_STATUS_V1 global;
  NV_GPU_PERF_POLICY_STATUS_V1 policies[NV_GPU_PERF_POLICY_ID_SW_NUM_V1];
  NvU32 rsvd[48];
} NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1;
#define NV_GPU_PERF_POLICIES_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1, 1)
#define NV_GPU_PERF_POLICIES_STATUS_PARAMS_VER NV_GPU_PERF_POLICIES_STATUS_PARAMS_VER_1
typedef NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1 NV_GPU_PERF_POLICIES_STATUS_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_PerfPoliciesGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_GPU_PERF_POLICIES_STATUS_PARAMS *pPerfPoliciesStatus);
#define NV_GPU_PERF_LIMIT_MAX (0xff)
NVAPI_INTERFACE NvAPI_GPU_SetPerfLimit(NvPhysicalGpuHandle hPhysicalGpu, NvU8 limit, NvU32 *flags);
NVAPI_INTERFACE NvAPI_GPU_GetPerfLimit(NvPhysicalGpuHandle hPhysicalGpu, NvU8 *limit, NvU32 *flags);
#define NV_GPU_PERF_PWM_PERIOD_AUTO (0x00000000)
NVAPI_INTERFACE NvAPI_GPU_SetPerfPwmPeriod(NvPhysicalGpuHandle hPhysicalGpu, NvU32 periodUs, NvU32 *flags);
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 bEnabled;
  NvU32 bRunning;
  NvU32 bStateHigh;
  NvU32 highPstate;
  NvU32 lowPstate;
  NvU32 highUs;
  NvU32 lowUs;
} NV_GPU_PERF_PWM_INFO;
NVAPI_INTERFACE NvAPI_GPU_GetPerfFstate(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *current, NvU32 *max, NvU32 *flags);
NVAPI_INTERFACE NvAPI_GPU_PerfCheckDefaultMode(NvU8 *modeCheck, NvU8 *bFactoryOverclocked);
NVAPI_INTERFACE NvAPI_GPU_PerfSetDefaultMode(NvU8 modeSelect);
typedef struct {
  NvU32 version;
  NvBool bSupported;
  NvBool bFactoryOverclocked;
  NvU8 rsvd[32];
} NV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER_V1, *PNV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER_V1;
typedef NV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER_V1 NV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER,
    *PNV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER;
#define NV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER_V1, 1)
#define NV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER_VER NV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeGetInfo_Wrapper(__out PNV_GPU_PERF_DEBUG_MODE_GET_INFO_WRAPPER pInfo);
typedef struct {
  NvU32 version;
  NvBool bEnabled;
  NvU8 rsvd[32];
} NV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER_V1, *PNV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER_V1;
typedef NV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER_V1 NV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER,
    *PNV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER;
#define NV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER_V1, 1)
#define NV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER_VER NV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeGetControl_Wrapper(__out PNV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER pControl);
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeSetControl_Wrapper(__in PNV_GPU_PERF_DEBUG_MODE_CONTROL_WRAPPER pControl);
typedef struct {
  NvU32 version;
  NvU8 bApiSupported;
  NvBool bSupported;
  NvBool bFactoryOverclocked;
  NvU8 rsvd[32];
} NV_GPU_PERF_DEBUG_MODE_GET_INFO_V1, *PNV_GPU_PERF_DEBUG_MODE_GET_INFO_V1;
typedef NV_GPU_PERF_DEBUG_MODE_GET_INFO_V1 NV_GPU_PERF_DEBUG_MODE_GET_INFO, *PNV_GPU_PERF_DEBUG_MODE_GET_INFO;
#define NV_GPU_PERF_DEBUG_MODE_GET_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_DEBUG_MODE_GET_INFO_V1, 1)
#define NV_GPU_PERF_DEBUG_MODE_GET_INFO_VER NV_GPU_PERF_DEBUG_MODE_GET_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __out PNV_GPU_PERF_DEBUG_MODE_GET_INFO pInfo);
typedef struct {
  NvU32 version;
  NvBool bOverClocked;
  NvU8 rsvd[32];
} NV_GPU_PERF_DEBUG_MODE_GET_STATUS_V1, *PNV_GPU_PERF_DEBUG_MODE_GET_STATUS_V1;
typedef NV_GPU_PERF_DEBUG_MODE_GET_STATUS_V1 NV_GPU_PERF_DEBUG_MODE_GET_STATUS, *PNV_GPU_PERF_DEBUG_MODE_GET_STATUS;
#define NV_GPU_PERF_DEBUG_MODE_GET_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_DEBUG_MODE_GET_STATUS_V1, 1)
#define NV_GPU_PERF_DEBUG_MODE_GET_STATUS_VER NV_GPU_PERF_DEBUG_MODE_GET_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __out PNV_GPU_PERF_DEBUG_MODE_GET_STATUS pStatus);
typedef struct {
  NvU32 version;
  NvBool bEnabled;
  NvU8 rsvd[32];
} NV_GPU_PERF_DEBUG_MODE_CONTROL_V1, *PNV_GPU_PERF_DEBUG_MODE_CONTROL_V1;
typedef NV_GPU_PERF_DEBUG_MODE_CONTROL_V1 NV_GPU_PERF_DEBUG_MODE_CONTROL, *PNV_GPU_PERF_DEBUG_MODE_CONTROL;
#define NV_GPU_PERF_DEBUG_MODE_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_DEBUG_MODE_CONTROL_V1, 1)
#define NV_GPU_PERF_DEBUG_MODE_CONTROL_VER NV_GPU_PERF_DEBUG_MODE_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __out PNV_GPU_PERF_DEBUG_MODE_CONTROL pControl);
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __in PNV_GPU_PERF_DEBUG_MODE_CONTROL pControl);
typedef struct {
  NvU32 version;
  NvBool bSupported;
  NvBool bMode;
  NvBool bFactoryOverclocked;
  NvU8 rsvd[32];
} NV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS_V1, *PNV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS_V1;
typedef NV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS_V1 NV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS,
    *PNV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS;
#define NV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS_V1, 1)
#define NV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS_VER NV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeGetStatus_LEGACY(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                        __out PNV_GPU_PERF_LEGACY_DEBUG_MODE_GET_STATUS pStatus);
typedef struct {
  NvU32 version;
  NvBool bEnabled;
  NvU8 rsvd[32];
} NV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL_V1, *PNV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL_V1;
typedef NV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL_V1 NV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL,
    *PNV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL;
#define NV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL_V1, 1)
#define NV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL_VER NV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeGetControl_LEGACY(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                         __out PNV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL pControl);
NVAPI_INTERFACE NvAPI_GPU_PerfDebugModeSetControl_LEGACY(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                         __in PNV_GPU_PERF_LEGACY_DEBUG_MODE_CONTROL pControl);
#define NV_GPU_PERF_PWM_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_PERF_PWM_INFO, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 470.") NVAPI_INTERFACE
    NvAPI_GPU_GetPerfPwmInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PWM_INFO *pPerfPwmInfo);
#define NVAPI_MAX_PERF_SENSOR_COUNT1 16
#define NVAPI_MAX_PERF_SENSOR_COUNT 256
typedef enum _NV_GPU_PERF_SENSOR_PCIE_TYPE {
  NVAPI_GPU_NON_PCIE_PERF_SENSOR_COUNTER = 0,
  NVAPI_GPU_PCIE_TX_PERF_SENSOR_COUNTER = 1,
  NVAPI_GPU_PCIE_RX_PERF_SENSOR_COUNTER = 2,
} NV_GPU_PERF_SENSOR_PCIE_TYPE;
typedef struct {
  NvU32 version;
  struct {
    NvU32 bIsPresent : 1;
    NvU32 pcieType : 2;
    NvU32 reserved : 29;
    NvU32 engineMask;
    NvU32 percentBusy;
    NV_GPU_CLOCK_DOMAIN_ID clkDomain;
  } utilization[NVAPI_MAX_PERF_SENSOR_COUNT1];
} NV_GPU_PERF_SENSOR_COUNTERS_INFO_V1;
typedef struct {
  NvU32 version;
  struct {
    NvU32 bIsPresent : 1;
    NvU32 pcieType : 2;
    NvU32 reserved : 29;
    NvU32 engineMask;
    NvU32 percentBusy;
    NV_GPU_CLOCK_DOMAIN_ID clkDomain;
  } utilization[NVAPI_MAX_PERF_SENSOR_COUNT];
} NV_GPU_PERF_SENSOR_COUNTERS_INFO_V2;
#define NV_GPU_PERF_SENSOR_COUNTERS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_SENSOR_COUNTERS_INFO_V1, 1)
#define NV_GPU_PERF_SENSOR_COUNTERS_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_SENSOR_COUNTERS_INFO_V2, 2)
#define NV_GPU_PERF_SENSOR_COUNTERS_INFO_VER NV_GPU_PERF_SENSOR_COUNTERS_INFO_VER2
typedef NV_GPU_PERF_SENSOR_COUNTERS_INFO_V2 NV_GPU_PERF_SENSOR_COUNTERS_INFO;
NVAPI_INTERFACE NvAPI_GPU_GetPerfSensorCounterInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GPU_PERF_SENSOR_COUNTERS_INFO *pPerfSensorCounterInfo);
NVAPI_INTERFACE NvAPI_GPU_SetPerfLevel(NvPhysicalGpuHandle hPhysicalGpu, NvU32 level);
NVAPI_INTERFACE NvAPI_GPU_SetPerfClockControl(NvPhysicalGpuHandle hPhysicalGpu, NvU32 graphicsEnable,
                                              NvU32 memoryEnable, NvU32 thermalEnable);
NVAPI_INTERFACE NvAPI_GPU_GetPerfClockControl(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *graphicsEnabled,
                                              NvU32 *memoryEnabled, NvU32 *thermalEnabled);
typedef enum _NV_GPU_PERF_LIMIT_ID {
  NVAPI_PERF_LIMIT_ID_PERFMON = 0x00000000,
  NVAPI_PERF_LIMIT_ID_NO_CLIENT,
  NVAPI_PERF_LIMIT_ID_SCREEN_SAVER,
  NVAPI_PERF_LIMIT_ID_NO_HIRES,
  NVAPI_PERF_LIMIT_ID_OS_LEVEL,
  NVAPI_PERF_LIMIT_ID_SPDIFF_GLITCH,
  NVAPI_PERF_LIMIT_ID_DISPLAY_GLITCH,
  NVAPI_PERF_LIMIT_ID_UNLOAD_DRIVER,
  NVAPI_PERF_LIMIT_ID_POWERMIZER,
  NVAPI_PERF_LIMIT_ID_STRESSTEST_FAILURE,
  NVAPI_PERF_LIMIT_ID_RC_ERROR,
  NVAPI_PERF_LIMIT_ID_MIN_FAN_LEVEL,
  NVAPI_PERF_LIMIT_ID_MCLK_CLONE,
  NVAPI_PERF_LIMIT_ID_OVERLAY,
  NVAPI_PERF_LIMIT_ID_HIGHRES,
  NVAPI_PERF_LIMIT_ID_BANDWIDTHFACTOR,
  NVAPI_PERF_LIMIT_ID_HD_FRAMEDROP_WAR,
  NVAPI_PERF_LIMIT_ID_ISMODEPOSSIBLE,
  NVAPI_PERF_LIMIT_ID_STRESSTEST_SETUP,
  NVAPI_PERF_LIMIT_ID_FORCED,
  NVAPI_PERF_LIMIT_ID_FORCED_DACPERFTEST,
  NVAPI_PERF_LIMIT_ID_FORCED_STRESSTEST,
  NVAPI_PERF_LIMIT_ID_POWERMIZER_HARD,
  NVAPI_PERF_LIMIT_ID_THERMAL,
  NVAPI_PERF_LIMIT_ID_SYSPERF,
  NVAPI_PERF_LIMIT_ID_PWR_SUPPLY_CAPACITY,
  NVAPI_PERF_LIMIT_ID_SW_BATTPOWER,
  NVAPI_PERF_LIMIT_ID_EXT_PERF_CONTROL,
  NVAPI_PERF_LIMIT_ID_MXM_ACPOWER,
  NVAPI_PERF_LIMIT_ID_AUX_POWER,
  NVAPI_PERF_LIMIT_ID_3D_WAR,
  NVAPI_PERF_LIMIT_ID_DEEP_IDLE,
  NVAPI_PERF_LIMIT_ID_CLIENT_SOFT,
  NVAPI_PERF_LIMIT_ID_CLIENT_HARD,
  NVAPI_PERF_LIMIT_ID_OVERCLOCK,
  NVAPI_PERF_LIMIT_ID_FORCED_LINKTRAIN,
  NVAPI_PERF_LIMIT_ID_POWER_BALANCE,
  NVAPI_PERF_LIMIT_ID_BUG_535734,
  NVAPI_PERF_LIMIT_ID_BOOST,
  NVAPI_PERF_LIMIT_ID_PM_DYNAMIC,
  NVAPI_PERF_LIMIT_ID_MODS_RULES,
  NVAPI_PERF_LIMIT_ID_EXCEPT_VIDEO,
  NVAPI_PERF_LIMIT_ID_SDI_INPUT_CAPTURE,
  NVAPI_PERF_LIMIT_ID_BANDWIDTH_HCLONE,
  NVAPI_PERF_LIMIT_ID_VPS_DISPLAY,
  NVAPI_PERF_LIMIT_ID_VPS,
  NVAPI_PERF_LIMIT_ID_CANOAS_MODE,
  NVAPI_PERF_LIMIT_ID_BUG_660789,
  NVAPI_PERF_LIMIT_ID_P1020_WAR,
  NVAPI_PERF_LIMIT_ID_LOCKED_DRIVER,
  NVAPI_PERF_LIMIT_ID_PMU_OVERRIDE,
  NVAPI_PERF_LIMIT_ID_CLIENT_0_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_0_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_1_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_1_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_2_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_2_MIN,
  NVAPI_PERF_LIMIT_ID_PERFMON_GROUP_1,
  NVAPI_PERF_LIMIT_ID_PERFMON_GROUP_2,
  NVAPI_PERF_LIMIT_ID_PERFMON_GROUP_3,
  NVAPI_PERF_LIMIT_ID_RATED_TDP_MAX,
  NVAPI_PERF_LIMIT_ID_OVERVOLTAGE_LOGIC,
  NVAPI_PERF_LIMIT_ID_RELIABILITY_LOGIC,
  NVAPI_PERF_LIMIT_ID_PMU_DOM_GRP_1,
  NVAPI_PERF_LIMIT_ID_AUX_PWR_STATE,
  NVAPI_PERF_LIMIT_ID_PERFORMANCE_CAP,
  NVAPI_PERF_LIMIT_ID_THERM_POLICY_DOM_GRP_0,
  NVAPI_PERF_LIMIT_ID_THERM_POLICY_DOM_GRP_1,
  NVAPI_PERF_LIMIT_ID_RELIABILITY_ALT_LOGIC,
  NVAPI_PERF_LIMIT_ID_PERFORMANCE_CAP1,
  NVAPI_PERF_LIMIT_ID_RATED_TDP_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_0_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_0_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_1_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_1_MIN,
  NVAPI_PERF_LIMIT_ID_THERM_POLICY_NVVDD,
  NVAPI_PERF_LIMIT_ID_SLI_GPU_BOOST_DOM_GRP_0,
  NVAPI_PERF_LIMIT_ID_SLI_GPU_BOOST_DOM_GRP_1,
  NVAPI_PERF_LIMIT_ID_ISMODEPOSSIBLE_DISP,
  NVAPI_PERF_LIMIT_ID_CUDA_MAX,
  NVAPI_PERF_LIMIT_ID_SUSPEND_POWER,
  NVAPI_PERF_LIMIT_ID_EDP_POLICY_DOM_GRP_1,
  NVAPI_PERF_LIMIT_ID_GPU_IS_IDLE,
  NVAPI_PERF_LIMIT_ID_GPU_IS_IDLE_GROUP1,
  NVAPI_PERF_LIMIT_ID_SLI_DOM_GRP_0_MIN,
  NVAPI_PERF_LIMIT_ID_APPLICATIONCLOCKS,
  NVAPI_PERF_LIMIT_ID_CUSTOMER_BOOST_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_DRAM_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_GPC_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_DISP_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_DRAM_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_GPC_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_DISP_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_2_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_2_MIN,
  NVAPI_PERF_LIMIT_ID_INTERSECT,
  NVAPI_PERF_LIMIT_ID_INTERSECT_LOGIC_1_MAX,
  NVAPI_PERF_LIMIT_ID_INTERSECT_LOGIC_2_MAX,
  NVAPI_PERF_LIMIT_ID_INTERSECT_SRAM_0_MAX,
  NVAPI_PERF_LIMIT_ID_INTERSECT_SRAM_1_MAX,
  NVAPI_PERF_LIMIT_ID_INTERSECT_SRAM_2_MAX,
  NVAPI_PERF_LIMIT_ID_INTERSECT_LOGIC_0_MIN,
  NVAPI_PERF_LIMIT_ID_INTERSECT_LOGIC_1_MIN,
  NVAPI_PERF_LIMIT_ID_INTERSECT_LOGIC_2_MIN,
  NVAPI_PERF_LIMIT_ID_INTERSECT_SRAM_0_MIN,
  NVAPI_PERF_LIMIT_ID_INTERSECT_SRAM_1_MIN,
  NVAPI_PERF_LIMIT_ID_INTERSECT_SRAM_2_MIN,
  NVAPI_PERF_LIMIT_ID_OVERVOLTAGE_SRAM,
  NVAPI_PERF_LIMIT_ID_RELIABILITY_ALT_SRAM,
  NVAPI_PERF_LIMIT_ID_RELIABILITY_SRAM,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOGIC,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_SRAM,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_INTERSECT,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_DRAM_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_GPC_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_DISP_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_DRAM_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_GPC_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_DISP_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_0_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_1_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_2_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_0_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_1_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_2_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_INTERSECT,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_DRAM_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_GPC_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_DISP_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_DRAM_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_GPC_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_DISP_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_0_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_1_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_2_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_0_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_1_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_2_MIN,
  NVAPI_PERF_LIMIT_ID_VMIN_LOGIC,
  NVAPI_PERF_LIMIT_ID_VMIN_SRAM,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_PSTATE_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_PSTATE_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_PSTATE_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_PSTATE_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_PSTATE_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_PSTATE_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_PCIE_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_PCIE_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_PCIE_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_PCIE_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_PCIE_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_PCIE_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_3_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_3_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_4_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_4_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_5_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_5_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_6_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_6_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_7_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_7_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_8_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_8_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_9_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_9_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_3_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_4_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_5_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_6_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_7_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_8_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_9_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_3_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_4_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_5_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_6_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_7_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_8_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOOSE_9_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_3_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_4_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_5_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_6_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_7_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_8_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_9_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_3_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_4_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_5_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_6_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_7_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_8_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOOSE_9_MIN,
  NVAPI_PERF_LIMIT_ID_PERF_CF_CONTROLLER_DRAM_MIN,
  NVAPI_PERF_LIMIT_ID_PERF_CF_CONTROLLER_GPC_MIN,
  NVAPI_PERF_LIMIT_ID_PERF_CF_CONTROLLER_NVD_MIN,
  NVAPI_PERF_LIMIT_ID_BIF_USBC_PMU_PCIE_MIN,
  NVAPI_PERF_LIMIT_ID_BIF_USBC_RM_PCIE_MIN,
  NVAPI_PERF_LIMIT_ID_PERF_CF_CONTROLLER_DRAM_MAX,
  NVAPI_PERF_LIMIT_ID_PERF_CF_CONTROLLER_GPC_MAX,
  NVAPI_PERF_LIMIT_ID_PERF_CF_CONTROLLER_NVD_MAX,
  NVAPI_PERF_LIMIT_ID_ECC_MAX,
  NVAPI_PERF_LIMIT_ID_OOB_CLOCK_LIMIT_MAX,
  NVAPI_PERF_LIMIT_ID_OOB_CLOCK_LIMIT_MIN,
  NVAPI_PERF_LIMIT_ID_PERF_CF_CONTROLLER_XBAR_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOCK_DRAM_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_XBAR_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOCK_XBAR_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOCK_DRAM_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_STRICT_XBAR_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOW_LOCK_XBAR_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOCK_DRAM_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_XBAR_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOCK_XBAR_MAX,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOCK_DRAM_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_STRICT_XBAR_MIN,
  NVAPI_PERF_LIMIT_ID_CLIENT_LOCK_XBAR_MIN,
  NVAPI_PERF_LIMIT_ID_THERM_POLICY_XBAR,
  NVAPI_PERF_LIMIT_ID_PWR_POLICY_XBAR,
  NVAPI_PERF_LIMIT_ID_SLI_GPU_BOOST_XBAR,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOCK_DRAM_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_XBAR_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOCK_XBAR_MAX,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOCK_DRAM_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_STRICT_XBAR_MIN,
  NVAPI_PERF_LIMIT_ID_MODS_RULES_LOCK_XBAR_MIN,
  NVAPI_PERF_LIMIT_ID_BOOST_LOW,
  NVAPI_PERF_LIMIT_ID_JPAC_PSTATE_MAX,
  NVAPI_PERF_LIMIT_ID_JPAC_GPC_MAX,
  NVAPI_PERF_LIMIT_ID_JPAC_PSTATE_MIN,
  NVAPI_PERF_LIMIT_ID_JPPC_PSTATE_MAX,
  NVAPI_PERF_LIMIT_ID_JPPC_GPC_MAX,
  NVAPI_PERF_LIMIT_ID_LAST,
  NVAPI_PERF_LIMIT_ID_MAX_LIMITS = 0x00000100,
  NVAPI_PERF_LIMIT_ID_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_LIMIT_ID;
#define NVAPI_PERF_LIMIT_ID_LIMIT_RATED_TDP NVAPI_PERF_LIMIT_ID_RATED_TDP_MAX
#define NVAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_0_MAX NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_0_MAX
#define NVAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_0_MIN NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_0_MIN
#define NVAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_1_MAX NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_1_MAX
#define NVAPI_PERF_LIMIT_ID_INTERNAL_CLIENT_1_MIN NVAPI_PERF_LIMIT_ID_CLIENT_LOOSE_1_MIN
#define NVAPI_PERF_LIMIT_ID_VDT_OVERVOLTAGE NVAPI_PERF_LIMIT_ID_OVERVOLTAGE_LOGIC
#define NVAPI_PERF_LIMIT_ID_VDT_RELIABILITY_ALT NVAPI_PERF_LIMIT_ID_RELIABILITY_ALT_LOGIC
#define NVAPI_PERF_LIMIT_ID_VDT_RELIABILITY NVAPI_PERF_LIMIT_ID_RELIABILITY_LOGIC
#define NVAPI_PERF_LIMIT_ID_INTERSECT_LOGIC_0_MAX NVAPI_PERF_LIMIT_ID_INTERSECT
#define NV_GPU_PERF_LIMIT_INFO_NAME_MAX_LENGTH_V1 32
#define NV_GPU_PERF_LIMIT_INFO_FLAGS_MIN 0x1
#define NV_GPU_PERF_LIMIT_INFO_FLAGS_MAX 0x2
typedef struct {
  NV_GPU_PERF_LIMIT_ID limitId;
  NvU32 rmLimitId;
  NvU32 flags;
  NvU32 priority;
  char szName[NV_GPU_PERF_LIMIT_INFO_NAME_MAX_LENGTH_V1];
} NV_GPU_PERF_LIMIT_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numLimits;
  NV_GPU_PERF_LIMIT_INFO_V1 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_INFO_V1;
typedef NV_GPU_PERF_LIMITS_INFO_V1 NV_GPU_PERF_LIMITS_INFO;
#define NV_GPU_PERF_LIMITS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_INFO_V1, 1)
#define NV_GPU_PERF_LIMITS_INFO_VER NV_GPU_PERF_LIMITS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfLimitsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __inout NV_GPU_PERF_LIMITS_INFO *pLimits);
typedef enum _NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE {
  NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_DISABLED = 0x00000000,
  NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_PSTATE,
  NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_FREQ,
  NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VPSTATE,
  NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VOLTAGE,
  NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VOLTAGE_EX,
  NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_VOLTAGE_3X,
  NVAPI_PERF_LIMIT_STATUS_INPUT_TYPE_UNSUPPORTED = 0xFFFFFFFF,
} NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE;
typedef enum {
  NV_GPU_PERF_LIMIT_INPUT_DATA_PSTATE_POINT_NOM = 0x0,
  NV_GPU_PERF_LIMIT_INPUT_DATA_PSTATE_POINT_MIN,
  NV_GPU_PERF_LIMIT_INPUT_DATA_PSTATE_POINT_MAX,
  NV_GPU_PERF_LIMIT_INPUT_DATA_PSTATE_POINT_MID,
} NV_GPU_PERF_LIMIT_INPUT_DATA_PSTATE_POINT;
typedef struct {
  NvU32 flags;
  NV_GPU_PERF_PSTATE_ID pstateId;
  NV_GPU_PERF_LIMIT_INPUT_DATA_PSTATE_POINT point;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE;
typedef struct {
  NvU32 flags;
  NvU32 freqKHz;
  NV_GPU_CLOCK_DOMAIN_ID domainId;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ;
typedef struct {
  NvU32 flags;
  NvU32 vpstate;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE;
typedef struct {
  NvU32 domGrpIdx;
  NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
  NvU32 flags;
  NvU32 voltageuV;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE;
typedef struct {
  NvU32 domGrpIdx;
  NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1 volt;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX;
typedef struct {
  NV_GPU_CLOCK_DOMAIN_ID decoupledClockId;
  NV_GPU_PSTATE20_VOLTAGE_ENTRY_V1 volt;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX2;
typedef struct {
  NV_GPU_PSTATE_VOLTAGE_ENTRY_V1 volt;
  NvU32 rsvd[32];
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX3;
typedef struct {
  NV_GPU_PSTATE_VOLTAGE_ENTRY_V2 volt;
  NvU8 rsvd[32];
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_V4;
#define NV_GPU_PERF_LIMIT_VOLTAGE_DATA_ELEMENTS_MAX 8
typedef struct {
  NV_GPU_VOLT_VOLT_DOMAIN_TYPE voltDomain;
  NvU32 numElements;
  NvS32 deltauV;
  NV_GPU_PSTATE_VOLTAGE_ENTRY_V2 volt[NV_GPU_PERF_LIMIT_VOLTAGE_DATA_ELEMENTS_MAX];
  NvU32 volt_uV;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_3X_V1;
typedef union {
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ freq;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1;
typedef union {
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ freq;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE volt;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V2;
typedef union {
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ freq;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE volt;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX voltEx;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V3;
typedef union {
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ freq;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX2 voltEx;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V4;
typedef union {
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ freq;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_EX3 voltEx;
  NvU32 rsvd[32];
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V5;
typedef union {
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_PSTATE pstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_FREQ freq;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VPSTATE vpstate;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_V4 voltEx;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_VOLTAGE_3X_V1 volt3x;
  NvU8 rsvd[1024];
} NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V6;
#define NV_GPU_PERF_LIMIT_STATUS_INPUT_FLAGS_QUANT 1 : 0
#define NV_GPU_PERF_LIMIT_STATUS_INPUT_FLAGS_QUANT_VF 0x0
#define NV_GPU_PERF_LIMIT_STATUS_INPUT_FLAGS_QUANT_COEFF 0x1
#define NV_GPU_PERF_LIMIT_STATUS_INPUT_FLAGS_QUANT_NONE 0x2
typedef struct {
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE type;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V1 data;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V1;
typedef struct {
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE type;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V2 data;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V2;
typedef struct {
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE type;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V3 data;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V3;
typedef struct {
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE type;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V4 data;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V4;
typedef struct {
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE type;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V5 data;
  NvU32 rsvd[32];
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V5;
typedef struct {
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_LIMIT_STATUS_INPUT_DATA_V6 data;
} NV_GPU_PERF_LIMIT_STATUS_INPUT_V6;
typedef struct {
  NvU32 flags;
  NvU8 bEnabled;
  NvU32 domainGroupIdx;
  NvU32 value;
} NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V1;
typedef struct {
  NvU32 flags;
  NvU8 bEnabled;
  NV_GPU_CLOCK_DOMAIN_ID decoupledClockId;
  NvU32 value;
} NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V4;
typedef struct {
  NV_GPU_PERF_LIMIT_ID limitId;
  NvU32 rmLimitId;
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_V1 input;
  NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V1 output;
} NV_GPU_PERF_LIMIT_STATUS_V1;
typedef struct {
  NV_GPU_PERF_LIMIT_ID limitId;
  NvU32 rmLimitId;
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_V2 input;
  NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V1 output;
} NV_GPU_PERF_LIMIT_STATUS_V2;
typedef struct {
  NV_GPU_PERF_LIMIT_ID limitId;
  NvU32 rmLimitId;
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_V3 input;
  NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V1 output;
} NV_GPU_PERF_LIMIT_STATUS_V3;
typedef struct {
  NV_GPU_PERF_LIMIT_ID limitId;
  NvU32 rmLimitId;
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_V4 input;
  NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V4 output;
} NV_GPU_PERF_LIMIT_STATUS_V4;
typedef struct {
  NV_GPU_PERF_LIMIT_ID limitId;
  NvU32 rmLimitId;
  NvU32 flags;
  NV_GPU_PERF_LIMIT_STATUS_INPUT_V5 input;
  NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V4 output;
  NvU32 rsvd[32];
} NV_GPU_PERF_LIMIT_STATUS_V5;
typedef struct {
  NV_GPU_PERF_LIMIT_ID limitId;
  NvU32 rmLimitId;
  NvU32 flags;
  NvU8 rsvd[32];
  NV_GPU_PERF_LIMIT_STATUS_INPUT_V6 input;
  NV_GPU_PERF_LIMIT_STATUS_OUTPUT_V4 output;
} NV_GPU_PERF_LIMIT_STATUS_V6;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numLimits;
  NV_GPU_PERF_LIMIT_STATUS_V1 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numLimits;
  NV_GPU_PERF_LIMIT_STATUS_V2 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_STATUS_V2;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numLimits;
  NV_GPU_PERF_LIMIT_STATUS_V3 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_STATUS_V3;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numLimits;
  NV_GPU_PERF_LIMIT_STATUS_V4 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_STATUS_V4;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numLimits;
  NV_GPU_PERF_LIMIT_STATUS_V5 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
  NvU32 rsvd[32];
} NV_GPU_PERF_LIMITS_STATUS_V5;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numLimits;
  NvU8 rsvd[32];
  NV_GPU_PERF_LIMIT_STATUS_V6 limits[NVAPI_PERF_LIMIT_ID_MAX_LIMITS];
} NV_GPU_PERF_LIMITS_STATUS_V6;
typedef NV_GPU_PERF_LIMITS_STATUS_V6 NV_GPU_PERF_LIMITS_STATUS;
#define NV_GPU_PERF_LIMITS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V1, 1)
#define NV_GPU_PERF_LIMITS_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V2, 2)
#define NV_GPU_PERF_LIMITS_STATUS_VER3 MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V3, 3)
#define NV_GPU_PERF_LIMITS_STATUS_VER4 MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V4, 4)
#define NV_GPU_PERF_LIMITS_STATUS_VER5 MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V5, 5)
#define NV_GPU_PERF_LIMITS_STATUS_VER6 MAKE_NVAPI_VERSION(NV_GPU_PERF_LIMITS_STATUS_V6, 6)
#define NV_GPU_PERF_LIMITS_STATUS_VER NV_GPU_PERF_LIMITS_STATUS_VER6
NVAPI_INTERFACE NvAPI_GPU_PerfLimitsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_PERF_LIMITS_STATUS *pLimits);
typedef enum _NV_PERF_CLIENT_LIMIT_ID {
  NVAPI_PERF_CLIENT_LIMIT_0_MAX = 0x00000000,
  NVAPI_PERF_CLIENT_LIMIT_GRAPHICS_MAX = NVAPI_PERF_CLIENT_LIMIT_0_MAX,
  NVAPI_PERF_CLIENT_LIMIT_0_MIN,
  NVAPI_PERF_CLIENT_LIMIT_GRAPHICS_MIN = NVAPI_PERF_CLIENT_LIMIT_0_MIN,
  NVAPI_PERF_CLIENT_LIMIT_1_MAX,
  NVAPI_PERF_CLIENT_LIMIT_MEMORY_MAX = NVAPI_PERF_CLIENT_LIMIT_1_MAX,
  NVAPI_PERF_CLIENT_LIMIT_1_MIN,
  NVAPI_PERF_CLIENT_LIMIT_MEMORY_MIN = NVAPI_PERF_CLIENT_LIMIT_1_MIN,
  NVAPI_PERF_CLIENT_LIMIT_2_MAX,
  NVAPI_PERF_CLIENT_LIMIT_PSTATE_MAX = NVAPI_PERF_CLIENT_LIMIT_2_MAX,
  NVAPI_PERF_CLIENT_LIMIT_2_MIN,
  NVAPI_PERF_CLIENT_LIMIT_PSTATE_MIN = NVAPI_PERF_CLIENT_LIMIT_2_MIN,
  NVAPI_PERF_CLIENT_LIMIT_VOLTAGE,
  NVAPI_PERF_CLIENT_LIMIT_MAX_LIMITS = 0x00000020,
} NV_GPU_PERF_CLIENT_LIMIT_ID;
typedef enum _NV_PERF_CLIENT_LIMIT_TYPE {
  NVAPI_PERF_CLIENT_LIMIT_TYPE_DISABLED = 0x00000000,
  NVAPI_PERF_CLIENT_LIMIT_TYPE_PSTATE,
  NVAPI_PERF_CLIENT_LIMIT_TYPE_FREQ,
  NVAPI_PERF_CLIENT_LIMIT_TYPE_VOLT,
} NV_GPU_PERF_CLIENT_LIMIT_TYPE;
typedef struct {
  NvU32 flags;
  NV_GPU_PERF_PSTATE_ID pstateId;
} NV_GPU_PERF_CLIENT_LIMIT_DATA_PSTATE;
typedef struct {
  NvU32 flags;
  NvU32 freqKHz;
  NV_GPU_PUBLIC_CLOCK_ID domainId;
} NV_GPU_PERF_CLIENT_LIMIT_DATA_FREQ;
typedef struct {
  NvU32 flags;
  NvU32 voltageuV;
  NV_GPU_CLIENT_VOLT_DOMAIN_ID railId;
} NV_GPU_PERF_CLIENT_LIMIT_DATA_VOLT;
typedef union {
  NV_GPU_PERF_CLIENT_LIMIT_DATA_PSTATE pstate;
  NV_GPU_PERF_CLIENT_LIMIT_DATA_FREQ freq;
  NV_GPU_PERF_CLIENT_LIMIT_DATA_VOLT volt;
} NV_GPU_PERF_CLIENT_LIMIT_DATA_V1;
typedef struct {
  NV_GPU_PERF_CLIENT_LIMIT_ID limitId;
  NvU32 flags;
  NV_GPU_PERF_CLIENT_LIMIT_TYPE type;
  NV_GPU_PERF_CLIENT_LIMIT_DATA_V1 data;
} NV_GPU_PERF_CLIENT_LIMIT_V1;
#define NV_GPU_PERF_CLIENT_LIMITS_FLAGS_ASYNC 0x1
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numLimits;
  NV_GPU_PERF_CLIENT_LIMIT_V1 limits[NVAPI_PERF_CLIENT_LIMIT_MAX_LIMITS];
} NV_GPU_PERF_CLIENT_LIMITS_V1;
typedef NV_GPU_PERF_CLIENT_LIMITS_V1 NV_GPU_PERF_CLIENT_LIMITS;
#define NV_GPU_PERF_CLIENT_LIMITS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_LIMITS_V1, 1)
#define NV_GPU_PERF_CLIENT_LIMITS_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_LIMITS_V1, 2)
#define NV_GPU_PERF_CLIENT_LIMITS_VER NV_GPU_PERF_CLIENT_LIMITS_VER2
NVAPI_INTERFACE NvAPI_GPU_PerfClientLimitsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_PERF_CLIENT_LIMITS *pLimits);
NVAPI_INTERFACE NvAPI_GPU_PerfClientLimitsSetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __in NV_GPU_PERF_CLIENT_LIMITS *pLimits);
NVAPI_INTERFACE NvAPI_GPU_PerfLimitsSetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __in NV_GPU_PERF_LIMITS_STATUS *pLimits);
typedef enum _NVAPI_GPU_PERF_DECREASE {
  NV_GPU_PERF_DECREASE_NONE = 0,
  NV_GPU_PERF_DECREASE_REASON_THERMAL_PROTECTION = 0x00000001,
  NV_GPU_PERF_DECREASE_REASON_POWER_CONTROL = 0x00000002,
  NV_GPU_PERF_DECREASE_REASON_AC_BATT = 0x00000004,
  NV_GPU_PERF_DECREASE_REASON_API_TRIGGERED = 0x00000008,
  NV_GPU_PERF_DECREASE_REASON_INSUFFICIENT_POWER = 0x00000010,
  NV_GPU_PERF_DECREASE_REASON_UNKNOWN = 0x80000000,
} NVAPI_GPU_PERF_DECREASE;
NVAPI_INTERFACE NvAPI_GPU_GetPerfDecreaseInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NvU32 *pPerfDecrInfo);
typedef struct {
  NvU32 version;
  NvU32 thermalMask;
  NvU32 pstateMask;
} NV_PERF_DECREASE_INFO_V1;
typedef NV_PERF_DECREASE_INFO_V1 NV_PERF_DECREASE_INFO;
#define NV_PERF_DECREASE_INFO_VER1 MAKE_NVAPI_VERSION(NV_PERF_DECREASE_INFO_V1, 1)
#define NV_PERF_DECREASE_INFO_VER NV_PERF_DECREASE_INFO_VER1
typedef enum _NVAPI_PVT_GPU_PERF_DECREASE {
  NV_PVT_GPU_PERF_DECREASE_NONE = 0,
  NV_PVT_GPU_PERF_DECREASE_REASON_THERMAL_SHUTDOWN = 0x00000001,
  NV_PVT_GPU_PERF_DECREASE_REASON_THERMAL_PROTECTION = 0x00000002,
  NV_PVT_GPU_PERF_DECREASE_REASON_AVERAGE_POWER = 0x00000004,
  NV_PVT_GPU_PERF_DECREASE_REASON_PEAK_POWER = 0x00000008,
  NV_PVT_GPU_PERF_DECREASE_REASON_INSUFFICIENT_POWER = 0x00000010,
  NV_PVT_GPU_PERF_DECREASE_REASON_AC_BATT = 0x00000020,
  NV_PVT_GPU_PERF_DECREASE_REASON_API_TRIGGERED = 0x00000040,
  NV_PVT_GPU_PERF_DECREASE_REASON_UNKNOWN = 0x80000000,
} NVAPI_PVT_GPU_PERF_DECREASE;
NVAPI_INTERFACE NvAPI_GPU_GetPerfDecreaseInfo_Internal(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                       __inout NV_PERF_DECREASE_INFO *pPerfInfo);
#define NV_GPU_CLOCK_INFO_FLAGS_MCLK_DDR 0 : 0
#define NV_GPU_CLOCK_INFO_FLAGS_MCLK_DDR_DISABLE (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_MCLK_DDR_ENABLE (0x00000001)
#define NV_GPU_CLOCK_INFO_FLAGS_GPUCACHE2CLK_FORCE_NVCLK 1 : 1
#define NV_GPU_CLOCK_INFO_FLAGS_GPUCACHE2CLK_FORCE_NVCLK_DISABLE (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_GPUCACHE2CLK_FORCE_NVCLK_ENABLE (0x00000001)
#define NV_GPU_CLOCK_INFO_FLAGS_PATH 3 : 2
#define NV_GPU_CLOCK_INFO_FLAGS_PATH_DEFAULT (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_PATH_PLL (0x00000001)
#define NV_GPU_CLOCK_INFO_FLAGS_PATH_BYPASS (0x00000002)
#define NV_GPU_CLOCK_INFO_FLAGS_PATH_SEMI_BYPASS (0x00000003)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_PLL 2 : 2
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_PLL_DISABLE (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_PLL_ENABLE (0x00000001)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_BYPASS 3 : 3
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_BYPASS_DISABLE (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_BYPASS_ENABLE (0x00000001)
#define NV_GPU_CLOCK_INFO_FLAGS_RESERVED 7 : 4
#define NV_GPU_CLOCK_INFO_FLAGS_MDIV_RANGE 8 : 8
#define NV_GPU_CLOCK_INFO_FLAGS_MDIV_RANGE_DEFAULT (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_MDIV_RANGE_FULL (0x00000001)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_FFR_SET 9 : 9
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_FFR_SET_NO (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_FFR_SET_YES (0x00000001)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_CLEAR 10 : 10
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_CLEAR_NO (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_CLEAR_YES (0x00000001)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_VR_SET 11 : 11
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_VR_SET_NO (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_VR_SET_YES (0x00000001)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_FR_SET 12 : 12
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_FR_SET_NO (0x00000000)
#define NV_GPU_CLOCK_INFO_FLAGS_FORCE_FR_SET_YES (0x00000001)
#define NV_GPU_PERF_VF_CHANGE_INJECT_FLAGS_ADC_OVERRIDE 0 : 0
#define NV_GPU_PERF_VF_CHANGE_INJECT_FLAGS_ADC_OVERRIDE_NO 0x00000000
#define NV_GPU_PERF_VF_CHANGE_INJECT_FLAGS_ADC_OVERRIDE_YES 0x00000001
#define NV_GPU_PERF_VF_CHANGE_INJECT_FLAGS_BYPASS_CHANGE_SEQ 1 : 1
#define NV_GPU_PERF_VF_CHANGE_INJECT_FLAGS_BYPASS_CHANGE_SEQ_NO 0x00000000
#define NV_GPU_PERF_VF_CHANGE_INJECT_FLAGS_BYPASS_CHANGE_SEQ_YES 0x00000001
typedef enum _NV_GPU_CLK_NAFLL_REGIME_ID {
  NV_GPU_CLK_NAFLL_REGIME_ID_INVALID = (0x00000000),
  NV_GPU_CLK_NAFLL_REGIME_ID_FFR = (0x00000001),
  NV_GPU_CLK_NAFLL_REGIME_ID_FR = (0x00000002),
  NV_GPU_CLK_NAFLL_REGIME_ID_VR = (0x00000003),
  NV_GPU_CLK_NAFLL_REGIME_ID_VR_ABOVE_NOISE_UNAWARE_VMIN = (0x00000004),
  NV_GPU_CLK_NAFLL_REGIME_ID_FFR_BELOW_DVCO_MIN = (0x00000005),
} NV_GPU_CLK_NAFLL_REGIME_ID;
typedef struct {
  NvU32 clkDomain;
  NvU32 clkFreqKHz;
  NvU32 rsvd1;
  NvU8 regimeId;
  NvU8 source;
  NvU8 rsvd[63];
} NV_GPU_CLOCK_CLOCK_DOMAIN_LIST_ITEM, *PNV_GPU_CLOCK_CLOCK_DOMAIN_LIST_ITEM;
typedef struct {
  NvU8 numDomains;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLOCK_DOMAIN_LIST_ITEM clkDomains[NVAPI_MAX_GPU_CLOCKS];
} NV_GPU_CLOCK_CLOCK_DOMAIN_LIST, *PNV_GPU_CLOCK_CLOCK_DOMAIN_LIST;
typedef struct {
  NvU8 voltDomain;
  NvU8 railIdx;
  NvU32 voltageuV;
  NvU32 voltageMinNoiseUnawareuV;
  NvU8 rsvd[60];
} NV_GPU_VOLT_VOLT_RAIL_LIST_ITEM, *PNV_GPU_VOLT_VOLT_RAIL_LIST_ITEM;
typedef struct {
  NvU8 numRails;
  NvU8 rsvd[64];
  NV_GPU_VOLT_VOLT_RAIL_LIST_ITEM rails[NV_GPU_VOLT_VOLT_RAILS_MAX_V1];
} NV_GPU_VOLT_VOLT_RAIL_LIST, *PNV_GPU_VOLT_VOLT_RAIL_LIST;
typedef struct {
  NvU32 version;
  NvU8 flags;
  NV_GPU_CLOCK_CLOCK_DOMAIN_LIST clkList;
  NV_GPU_VOLT_VOLT_RAIL_LIST voltList;
} NV_GPU_PERF_VF_CHANGE_INJECT_PARAMS_V1, *PNV_GPU_PERF_VF_CHANGE_INJECT_PARAMS;
typedef NV_GPU_PERF_VF_CHANGE_INJECT_PARAMS_V1 NV_GPU_PERF_VF_CHANGE_INJECT_PARAMS;
#define NV_GPU_PERF_VF_CHANGE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_VF_CHANGE_INJECT_PARAMS_V1, 1)
#define NV_GPU_PERF_VF_CHANGE_PARAMS_VER NV_GPU_PERF_VF_CHANGE_PARAMS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfVfChangeInject(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_PERF_VF_CHANGE_INJECT_PARAMS *pPerfVfChangeInject);
#define NV_GPU_PERF_CHANGE_SEQ_VERSION_UNKNOWN NV_U8_MAX
#define NV_GPU_PERF_CHANGE_SEQ_VERSION_2X 0x01
#define NV_GPU_PERF_CHANGE_SEQ_VERSION_PMU 0x02
#define NV_GPU_PERF_CHANGE_SEQ_VERSION_31 0x03
#define NV_GPU_PERF_CHANGE_SEQ_VERSION_35 0x04
typedef struct {
  NvU32 cpuAdvertisedStepIdMask;
  NvU32 cpuStepIdMask;
} NV_GPU_PERF_CHANGE_SEQ_INFO_PMU_V1, *PNV_GPU_PERF_CHANGE_SEQ_INFO_PMU_V1;
typedef union {
  NV_GPU_PERF_CHANGE_SEQ_INFO_PMU_V1 pmu;
  NvU8 rsvd[128];
} NV_GPU_PERF_CHANGE_SEQ_INFO_DATA_V1;
typedef struct {
  NvU32 version;
  NvU8 changeSeqVersion;
  NvU8 bEnabledPmuSupport;
  NvU8 rsvd[128];
  NV_GPU_PERF_CHANGE_SEQ_INFO_DATA_V1 data;
} NV_GPU_PERF_CHANGE_SEQ_INFO_V1, *PNV_GPU_PERF_CHANGE_SEQ_INFO_V1;
typedef NV_GPU_PERF_CHANGE_SEQ_INFO_V1 NV_GPU_PERF_CHANGE_SEQ_INFO;
#define NV_GPU_PERF_CHANGE_SEQ_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_CHANGE_SEQ_INFO_V1, 1)
#define NV_GPU_PERF_CHANGE_SEQ_INFO_VER NV_GPU_PERF_CHANGE_SEQ_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfChangeSeqGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_PERF_CHANGE_SEQ_INFO *pChangeSeqInfo);
#define NV_GPU_PERF_CHANGE_SEQ_CHANGE_NONE 0x00
#define NV_GPU_PERF_CHANGE_SEQ_CHANGE_FORCE NV_BIT(0)
#define NV_GPU_PERF_CHANGE_SEQ_CHANGE_FORCE_CLOCKS NV_BIT(1)
#define NV_GPU_PERF_CHANGE_SEQ_CHANGE_ASYNC NV_BIT(2)
#define NV_GPU_PERF_CHANGE_SEQ_CHANGE_DEPRECATED NV_BIT(3)
#define NV_GPU_PERF_CHANGE_SEQ_CHANGE_SKIP_VBLANK_WAIT NV_BIT(4)
#define NV_GPU_PERF_CHANGE_SEQ_FROM_WORKITEM NV_BIT(5)
typedef struct {
  NvU32 clkFreqkHz;
  NvU8 rsvd[64];
} NV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_CLK_V1, *PNV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_CLK_V1;
typedef struct {
  NvU32 voltageuV;
  NvU32 voltageMinNoiseUnawareuV;
  NvU8 rsvd[64];
} NV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_VOLT_V1, *PNV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_VOLT_V1;
typedef struct {
  NvU32 pstateIndex;
  NvU32 flags;
  NvU32 vfPointsCacheCounter;
  NvU8 rsvd[64];
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainsMask;
  NV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_CLK_V1
  clk[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
  NV_GPU_BOARDOBJGRP_MASK_E32 voltRailsMask;
  NV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_VOLT_V1
  volt[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_V1, *PNV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_V1;
typedef struct {
  NvU32 seqId;
} NV_GPU_PERF_CHANGE_SEQ_CHANGE_PMU_V1, *PNV_GPU_PERF_CHANGE_SEQ_CHANGE_PMU_V1;
typedef union {
  NV_GPU_PERF_CHANGE_SEQ_CHANGE_PMU_V1 pmu;
  NvU8 rsvd[256];
} NV_GPU_PERF_CHANGE_SEQ_CHANGE_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLOCK_DOMAIN_LIST clkList;
  NV_GPU_VOLT_VOLT_RAIL_LIST voltList;
  NvU32 pstateIndex;
  NvU32 flags;
  NvU32 vfPointsCacheCounter;
  NvU8 rsvd[128];
  NvU8 version;
  NV_GPU_PERF_CHANGE_SEQ_CHANGE_DATA_V1 data;
} NV_GPU_PERF_CHANGE_SEQ_CHANGE_V1, *PNV_GPU_PERF_CHANGE_SEQ_CHANGE_V1;
typedef struct {
  NvU32 version;
  NvU32 clkDomainExclusionMask;
  NvBool bLock;
  NvU8 rsvd[63];
} NV_GPU_PERF_CHANGE_SEQ_CONTROL_V1, *PNV_GPU_PERF_CHANGE_SEQ_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainsExclusionMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainsInclusionMask;
  NvBool bLock;
  NvBool bChangeRequested;
  NvU8 rsvd[58];
  NV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_V1 changeInput;
} NV_GPU_PERF_CHANGE_SEQ_CONTROL_V2, *PNV_GPU_PERF_CHANGE_SEQ_CONTROL_V2;
typedef NV_GPU_PERF_CHANGE_SEQ_CONTROL_V2 NV_GPU_PERF_CHANGE_SEQ_CONTROL;
#define NV_GPU_PERF_CHANGE_SEQ_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_CHANGE_SEQ_CONTROL_V1, 1)
#define NV_GPU_PERF_CHANGE_SEQ_CONTROL_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_CHANGE_SEQ_CONTROL_V2, 2)
#define NV_GPU_PERF_CHANGE_SEQ_CONTROL_VER NV_GPU_PERF_CHANGE_SEQ_CONTROL_VER2
NVAPI_INTERFACE NvAPI_GPU_PerfChangeSeqGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_PERF_CHANGE_SEQ_CONTROL *pChangeSeqControl);
NVAPI_INTERFACE NvAPI_GPU_PerfChangeSeqSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_PERF_CHANGE_SEQ_CONTROL *pChangeSeqControl);
typedef enum {
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_RM_INIT,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_PMU_INIT,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_DISP_MODESET,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_DISP_CHANNEL_ALLOC,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_MCLK_GDDR5_INIT,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_STATE_UPDATE,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_PCIE_BUS,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_BACKDOOR_API,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_API,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_FBFLCN_INIT,
  NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT_UPDATE_MCLK_WATERMARKS,
} NV_GPU_PERF_CHANGE_SEQ_LOCK_CLIENT;
typedef struct {
  NvU64 totalTimens;
  NvU64 rmThreadTimens;
  NvU64 pmuThreadTimens;
  NvU8 rsvd[24];
} NV_GPU_PERF_CHANGE_SEQ_SCRIPT_STEP_PROFILING, *PNV_GPU_PERF_CHANGE_SEQ_SCRIPT_STEP_PROFILING;
typedef struct {
  NvU32 stepMask;
  NvU64 timens;
  NvU8 rsvd[32];
} NV_GPU_PERF_CHANGE_SEQ_SCRIPT_PROFILING_THREAD, *PNV_GPU_PERF_CHANGE_SEQ_SCRIPT_PROFILING_THREAD;
#define NV_GPU_PERF_CHANGE_SEQ_SCRIPT_MAX_PROFILING_THREADS 4
typedef struct {
  NvU64 totalTimens;
  NvU8 numRmThreads;
  NV_GPU_PERF_CHANGE_SEQ_SCRIPT_PROFILING_THREAD
  rmThreads[8];
  NvU8 rsvd[128];
} NV_GPU_PERF_CHANGE_SEQ_SCRIPT_PROFILING, *PNV_GPU_PERF_CHANGE_SEQ_SCRIPT_PROFILING;
typedef enum {
  NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE_NONE,
  NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE_INITIALIZED,
  NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE_IN_PROGRESS,
  NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE_DONE,
} NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE,
    *PNV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE;
#define NV_GPU_PERF_CHANGE_SEQ_SCRIPT_STATE_NONE NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE_NONE
#define NV_GPU_PERF_CHANGE_SEQ_SCRIPT_STATE_INITIALIZED NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE_INITIALIZED
#define NV_GPU_PERF_CHANGE_SEQ_SCRIPT_STATE_IN_PROGRESS NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE_IN_PROGRESS
#define NV_GPU_PERF_CHANGE_SEQ_SCRIPT_STATE_DONE NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE_DONE
typedef NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE NV_GPU_PERF_CHANGE_SEQ_SCRIPT_STATE;
typedef NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE *PNV_GPU_PERF_CHANGE_SEQ_SCRIPT_STATE;
typedef enum {
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_NONE,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_WAIT_FOR_MODESET,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_KMD_NOTIFY,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_PRE_HW,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_NOISE_UNAWARE_CLKS,
  NV_GPU_PERF_CHANGE_SEQ_30_STEP_ID_NOISE_UNAWARE_VMIN,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_VOLT_INCREASE,
  NV_GPU_PERF_CHANGE_SEQ_30_STEP_ID_NOISE_AWARE_CLKS_INCREASE,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_LINK_SPEED,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_LINK_WIDTH,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_ASPM,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_DEEP_L1,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_RAM_SVOP,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_NVVDD_PSI,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_VOLT_DECREASE,
  NV_GPU_PERF_CHANGE_SEQ_30_STEP_ID_NOISE_AWARE_CLKS_DECREASE,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_LTR_VALUE,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_LPWR_FEATURES,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_POST_HW,
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_MAX_STEPS,
} NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID,
    *PNV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID;
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_NONE NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_NONE
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_WAIT_FOR_MODESET NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_WAIT_FOR_MODESET
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_KMD_NOTIFY NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_KMD_NOTIFY
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_PRE_HW NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_PRE_HW
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_NOISE_UNAWARE_CLKS NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_NOISE_UNAWARE_CLKS
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_NOISE_UNAWARE_VMIN NV_GPU_PERF_CHANGE_SEQ_30_STEP_ID_NOISE_UNAWARE_VMIN
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_VOLT_INCREASE NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_VOLT_INCREASE
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_NOISE_AWARE_CLKS_INCREASE                                                       \
  NV_GPU_PERF_CHANGE_SEQ_30_STEP_ID_NOISE_AWARE_CLKS_INCREASE
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_SET_LINK_SPEED NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_LINK_SPEED
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_SET_LINK_WIDTH NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_LINK_WIDTH
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_SET_ASPM NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_ASPM
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_SET_DEEP_L1 NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_DEEP_L1
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_SET_RAM_SVOP NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_RAM_SVOP
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_SET_NVVDD_PSI NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_NVVDD_PSI
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_VOLT_DECREASE NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_VOLT_DECREASE
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_NOISE_AWARE_CLKS_DECREASE                                                       \
  NV_GPU_PERF_CHANGE_SEQ_30_STEP_ID_NOISE_AWARE_CLKS_DECREASE
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_SET_LTR_VALUE NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_SET_LTR_VALUE
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_LPWR_FEATURES NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_LPWR_FEATURES
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_POST_HW NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_POST_HW
#define NV_GPU_PERF_CHANGE_SEQ_STEP_ID_MAX_STEPS NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_MAX_STEPS
typedef NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID NV_GPU_PERF_CHANGE_SEQ_STEP_ID;
typedef NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID *PNV_GPU_PERF_CHANGE_SEQ_STEP_ID;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID stepId;
  NV_GPU_PERF_CHANGE_SEQ_SCRIPT_STEP_PROFILING profiling;
  NvU8 rsvd[64];
} NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STEP, *PNV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STEP;
typedef NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STEP NV_GPU_PERF_CHANGE_SEQ_SCRIPT_STEP;
typedef NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STEP *PNV_GPU_PERF_CHANGE_SEQ_SCRIPT_STEP;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STATE state;
  NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_STEP
  steps[NV_GPU_PERF_CHANGE_SEQ_2X_STEP_ID_MAX_STEPS];
  NvU32 numSteps;
  NvU32 curStepIndex;
  NV_GPU_PERF_CHANGE_SEQ_SCRIPT_PROFILING profiling;
  NvU8 rsvd[64];
} NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_V1;
typedef NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_V1 NV_GPU_PERF_CHANGE_SEQ_SCRIPT_V1;
typedef enum {
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_NONE = 0,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_PRE_CHANGE_RM = 1,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_PRE_CHANGE_PMU = 2,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_POST_CHANGE_RM = 3,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_POST_CHANGE_PMU = 4,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_PRE_PSTATE_RM = 5,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_PRE_PSTATE_PMU = 6,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_POST_PSTATE_RM = 7,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_POST_PSTATE_PMU = 8,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_VOLT = 9,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_LPWR = 10,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_BIF = 11,
  NV_GPU_PERF_CHANGE_SEQ_31_STEP_ID_NOISE_UNAWARE_CLKS = 12,
  NV_GPU_PERF_CHANGE_SEQ_31_STEP_ID_NOISE_AWARE_CLKS = 13,
  NV_GPU_PERF_CHANGE_SEQ_35_STEP_ID_PRE_VOLT_CLKS = 14,
  NV_GPU_PERF_CHANGE_SEQ_35_STEP_ID_POST_VOLT_CLKS = 15,
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_MAX_STEPS = 32,
} NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID,
    *PNV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID;
typedef enum {
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STATE_NONE,
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STATE_LOCKED,
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STATE_IN_PROGRESS,
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STATE,
    *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STATE;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID stepId;
  NV_GPU_PERF_CHANGE_SEQ_SCRIPT_STEP_PROFILING profiling;
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_SUPER_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_SUPER_V1;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_SUPER_V1 super;
  NvU32 pstateIndex;
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_CHANGE_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_CHANGE_V1;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_SUPER_V1 super;
  NvU32 pstateIndex;
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_PSTATE_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_PSTATE_V1;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_SUPER_V1 super;
  NvU32 pstateIndex;
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_LPWR_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_LPWR_V1;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_SUPER_V1 super;
  NV_GPU_VOLT_VOLT_RAIL_LIST _UNUSED_RSVD;
  NV_GPU_CLOCK_CLOCK_DOMAIN_LIST clkList;
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_CLKS_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_CLKS_V1;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_SUPER_V1 super;
  NV_GPU_VOLT_VOLT_RAIL_LIST voltList;
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_VOLT_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_VOLT_V1;
typedef union {
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_SUPER_V1 super;
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_CHANGE_V1 change;
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_PSTATE_V1 pstate;
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_LPWR_V1 lpwr;
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_CLKS_V1 clk;
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_VOLT_V1 volt;
  NvU8 rsvd[1024];
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_DATA_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_DATA_V1;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID stepId;
  NvU8 rsvd[128];
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_DATA_V1 data;
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_V1;
typedef struct {
  NvBool bIncrease;
  NvU8 numSteps;
  NvU8 curStepIndex;
  NV_GPU_PERF_CHANGE_SEQ_SCRIPT_PROFILING profiling;
  NvU8 rsvd[256];
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_HEADER_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_HEADER_V1;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_HEADER_V1 hdr;
  NV_GPU_PERF_CHANGE_SEQ_CHANGE_V1 changeCurr;
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STEP_V1
  steps[NV_GPU_PERF_CHANGE_SEQ_PMU_STEP_ID_MAX_STEPS];
} NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_V1;
#define NV_GPU_PERF_CHANGE_SEQ_COMPLETION_SYNC_CHANGE 0 : 0
#define NV_GPU_PERF_CHANGE_SEQ_COMPLETION_SYNC_CHANGE_FALSE 0x00
#define NV_GPU_PERF_CHANGE_SEQ_COMPLETION_SYNC_CHANGE_TRUE 0x01
#define NV_GPU_PERF_CHANGE_SEQ_COMPLETION_LOCK_ACQUIRED 1 : 1
#define NV_GPU_PERF_CHANGE_SEQ_COMPLETION_LOCK_ACQUIRED_FALSE 0x00
#define NV_GPU_PERF_CHANGE_SEQ_COMPLETION_LOCK_ACQUIRED_TRUE 0x01
#define NV_GPU_PERF_CHANGE_SEQ_SYNC_CHANGE_QUEUE_SIZE 2
typedef enum {
  NV_GPU_PERF_CHANGE_SEQ_SYNC_CHANGE_CLIENT_INVALID = 0x00,
  NV_GPU_PERF_CHANGE_SEQ_SYNC_CHANGE_CLIENT_RM = 0x01,
} NV_GPU_PERF_CHANGE_SEQ_SYNC_CHANGE_CLIENT;
typedef struct {
  NvU32 seqId;
  NvU32 clientSeqId;
  NV_GPU_PERF_CHANGE_SEQ_SYNC_CHANGE_CLIENT clientId;
  NvU8 rsvd[128];
} NV_GPU_PERF_CHANGE_SEQ_SYNC_CHANGE_CLIENT_QUEUE_V1, *PNV_GPU_PERF_CHANGE_SEQ_SYNC_CHANGE_CLIENT_QUEUE_V1;
typedef struct {
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_STATE state;
  NvBool bLockWaiting;
  NvU32 seqIdCounter;
  NV_GPU_PERF_CHANGE_SEQ_SYNC_CHANGE_CLIENT_QUEUE_V1
  syncChangeQueue[32];
  NvU8 rsvd[256];
} NV_GPU_PERF_CHANGE_SEQ_PMU_V1, *PNV_GPU_PERF_CHANGE_SEQ_PMU_V1;
typedef struct {
  NvBool bLock;
  NvU32 eventMaskPending;
  NvU32 eventMaskReceived;
  NvU32 seqId;
  NV_GPU_PERF_CHANGE_SEQ_PMU_V1 pmu;
  NV_GPU_PERF_CHANGE_SEQ_PMU_SCRIPT_V1 scriptLast;
  NvU8 rsvd[256];
} NV_GPU_PERF_CHANGE_SEQ_STATUS_PMU_V1, *PNV_GPU_PERF_CHANGE_SEQ_STATUS_PMU_V1;
typedef struct {
  NvU8 rsvd[64];
  NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_V1 scriptLast;
} NV_GPU_PERF_CHANGE_SEQ_STATUS_2X_V1, *PNV_GPU_PERF_CHANGE_SEQ_STATUS_2X_V1;
typedef union {
  NV_GPU_PERF_CHANGE_SEQ_STATUS_2X_V1 v2x;
  NV_GPU_PERF_CHANGE_SEQ_STATUS_PMU_V1 pmu;
  NvU8 rsvd[4096];
} NV_GPU_PERF_CHANGE_SEQ_STATUS_DATA_V1;
typedef struct {
  NvU32 version;
  NV_GPU_PERF_CHANGE_SEQ_2X_SCRIPT_V1 scriptLast;
} NV_GPU_PERF_CHANGE_SEQ_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU8 changeSeqVersion;
  NvU32 clientLockMask;
  NvU8 rsvd[128];
  NV_GPU_PERF_CHANGE_SEQ_STATUS_DATA_V1 data;
} NV_GPU_PERF_CHANGE_SEQ_STATUS_V2;
typedef NV_GPU_PERF_CHANGE_SEQ_STATUS_V2 NV_GPU_PERF_CHANGE_SEQ_STATUS;
#define NV_GPU_PERF_CHANGE_SEQ_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_CHANGE_SEQ_STATUS_V1, 1)
#define NV_GPU_PERF_CHANGE_SEQ_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_CHANGE_SEQ_STATUS_V2, 2)
#define NV_GPU_PERF_CHANGE_SEQ_STATUS_VER NV_GPU_PERF_CHANGE_SEQ_STATUS_VER2
NVAPI_INTERFACE NvAPI_GPU_PerfChangeSeqGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                 NV_GPU_PERF_CHANGE_SEQ_STATUS *pChangeSeqStatus);
#define NV_GPU_PERF_PERF_LIMITS_VERSION_2X 0x20
#define NV_GPU_PERF_PERF_LIMITS_VERSION_35 0x35
#define NV_GPU_PERF_PERF_LIMITS_VERSION_PMU 0xFE
#define NV_GPU_PERF_PERF_LIMITS_VERSION_SUPER 0x0
#define NV_GPU_PERF_PERF_LIMITS_VERSION_35_10 0x3
#define NV_GPU_PERF_PERF_LIMITS_VERSION_40 0x5
#define NV_GPU_PERF_PERF_LIMITS_VERSION_UNKNOWN 0xFF
typedef enum _NV_GPU_PERF_PERF_LIMIT_TYPE {
  NV_GPU_PERF_PERF_LIMIT_TYPE_2X = 0x00,
  NV_GPU_PERF_PERF_LIMIT_TYPE_35 = 0x01,
  NV_GPU_PERF_PERF_LIMIT_TYPE_PMU = 0x02,
  NV_GPU_PERF_PERF_LIMIT_TYPE_35_10 = 0x03,
  NV_GPU_PERF_PERF_LIMIT_TYPE_40 = 0x04,
  NV_GPU_PERF_PERF_LIMIT_TYPE_UNKNOWN = 0xFFFFFFFF
} NV_GPU_PERF_PERF_LIMIT_TYPE;
typedef struct _NV_GPU_PERF_PERF_LIMIT_INFO_PMU_V1 {
  NvU32 rsvd[16];
} NV_GPU_PERF_PERF_LIMIT_INFO_PMU_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_INFO_35_V1 {
  NV_GPU_PERF_PERF_LIMIT_INFO_PMU_V1 pmu;
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainStrictPropagationMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainsMaskForceVminNoiseUnaware;
} NV_GPU_PERF_PERF_LIMIT_INFO_35_V1;
typedef union _NV_GPU_PERF_PERF_LIMIT_INFO_DATA_V1 {
  NV_GPU_PERF_PERF_LIMIT_INFO_PMU_V1 pmu;
  NV_GPU_PERF_PERF_LIMIT_INFO_35_V1 v35;
  NvU8 rsvd[32];
} NV_GPU_PERF_PERF_LIMIT_INFO_DATA_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_INFO_V1 {
  NV_GPU_PERF_PERF_LIMIT_TYPE type;
  NvU32 flags;
  char szName[NV_GPU_PERF_LIMIT_INFO_NAME_MAX_LENGTH_V1];
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_LIMIT_INFO_DATA_V1 data;
} NV_GPU_PERF_PERF_LIMIT_INFO_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_INFO_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 limitMask;
  NvU8 rsvd[16];
  NV_GPU_PERF_PERF_LIMIT_INFO_V1 limits[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_PERF_PERF_LIMITS_INFO_V1;
typedef NV_GPU_PERF_PERF_LIMITS_INFO_V1 NV_GPU_PERF_PERF_LIMITS_INFO;
#define NV_GPU_PERF_PERF_LIMITS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_LIMITS_INFO_V1, 1)
#define NV_GPU_PERF_PERF_LIMITS_INFO_VER NV_GPU_PERF_PERF_LIMITS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfLimitsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_GPU_PERF_PERF_LIMITS_INFO *pLimits);
#define NV_GPU_PERF_PERF_LIMIT_CLK_DOMAINS_MAX 32
#define NV_GPU_PERF_PERF_LIMIT_VOLT_RAILS_MAX 32
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VALUE_V1 {
  NvU32 value;
  NV_GPU_PERF_LIMIT_ID limitIdx;
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VALUE_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_CLK_DOMAIN_V1 {
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VALUE_V1 freqkHz;
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_CLK_DOMAIN_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VOLT_RAIL_V1 {
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VALUE_V1 voltageuV;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VALUE_V1 voltageNoiseUnawareMinuV;
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VOLT_RAIL_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_DEFAULT_TUPLE_V1 {
  NvU32 pstateIdx;
  NvU32 clkDomains[NV_GPU_PERF_PERF_LIMIT_CLK_DOMAINS_MAX];
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_DEFAULT_TUPLE_V1;
typedef enum {
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_IDX_MIN = 0,
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_IDX_MAX,
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_IDX_NUM_IDXS,
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_IDX,
    *PNV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_IDX;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_DEFAULT_V1 {
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainsMask;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_DEFAULT_TUPLE_V1
      tuples[NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_IDX_NUM_IDXS];
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_DEFAULT_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_STATUS_PMU_V1 {
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_DEFAULT_V1 arbOutputDefault;
  NV_GPU_PERF_CHANGE_SEQ_CHANGE_INPUT_V1 changeSeqChange;
} NV_GPU_PERF_PERF_LIMITS_STATUS_PMU_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_CACHE_DATA_V1 {
  NvU32 arbSeqId;
  NV_GPU_BOARDOBJGRP_MASK_E255 limitMaskExclude;
  NvBool bDirty;
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_CACHE_DATA_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_V1 {
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_CACHE_DATA_V1 cacheData;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VALUE_V1 pstateIdx;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_CLK_DOMAIN_V1
  clkDomains[NV_GPU_PERF_PERF_LIMIT_CLK_DOMAINS_MAX];
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VOLT_RAIL_V1
  voltRails[NV_GPU_PERF_PERF_LIMIT_VOLT_RAILS_MAX];
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_V1 {
  NvU8 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainsMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 voltRailsMask;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_V1 tuple;
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_CLK_DOMAIN_35_V1 {
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_CLK_DOMAIN_V1 super;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VALUE_V1 freqNoiseUnawareMinkHz;
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_CLK_DOMAIN_35_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VOLT_RAIL_35_V1 {
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VOLT_RAIL_V1 super;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VALUE_V1 voltageMinLooseuV;
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VOLT_RAIL_35_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_35_V1 {
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VALUE_V1 pstateIdx;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_CLK_DOMAIN_35_V1
  clkDomains[NV_GPU_PERF_PERF_LIMIT_CLK_DOMAINS_MAX];
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_VOLT_RAIL_35_V1
  voltRails[NV_GPU_PERF_PERF_LIMIT_VOLT_RAILS_MAX];
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_35_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_35_V1 {
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_V1 super;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_35_V1
      tuples[NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_IDX_NUM_IDXS];
} NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_35_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_STATUS_35_V1 {
  NV_GPU_PERF_PERF_LIMITS_STATUS_PMU_V1 super;
  NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_35_V1 arbOutput35Apply;
} NV_GPU_PERF_PERF_LIMITS_STATUS_35_V1;
typedef union _NV_GPU_PERF_PERF_LIMITS_STATUS_DATA_V1 {
  NV_GPU_PERF_PERF_LIMITS_STATUS_PMU_V1 pmu;
  NV_GPU_PERF_PERF_LIMITS_STATUS_35_V1 v35;
} NV_GPU_PERF_PERF_LIMITS_STATUS_DATA_V1;
typedef enum _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_TYPE {
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_TYPE_DISABLED = 0,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_TYPE_PSTATE,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_TYPE_FREQUENCY,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_TYPE_VPSTATE,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_TYPE_VOLTAGE,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_TYPE_COUNT
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_TYPE;
typedef enum _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_POINT {
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_POINT_NOM = 0,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_POINT_MIN,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_POINT_MAX,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_POINT_MID,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_POINT_LAST
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_POINT;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_V1 {
  NvU32 pstateIdx;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_POINT point;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_FREQUENCY_V1 {
  NvU8 clkDomainIdx;
  NvU32 freqKHz;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_FREQUENCY_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VPSTATE_V1 {
  NvU32 vpstateIdx;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VPSTATE_V1;
typedef enum _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_TYPE {
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_TYPE_LOGICAL,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_TYPE_VFE,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_TYPE_PSTATE,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_TYPE_VPSTATE,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_TYPE_FREQUENCY,
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_TYPE_COUNT
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_TYPE;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_LOGICAL_V1 {
  NvU32 voltageuV;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_LOGICAL_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_VFE_V1 {
  NvU8 vfeEquIdx;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_VFE_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_PSTATE_V1 {
  NvU8 pstateIdx;
  NvU8 freqType;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_PSTATE_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_VPSTATE_V1 {
  NvU32 vpstateIdx;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_VPSTATE_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_FREQUENCY_V1 {
  NvU8 clkDomainIdx;
  NvU32 freqKHz;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_FREQUENCY_V1;
typedef union _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_DATA_V1 {
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_LOGICAL_V1 logical;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_VFE_V1 vfe;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_PSTATE_V1 pstate;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_VPSTATE_V1 vpstate;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_FREQUENCY_V1 frequency;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_DATA_ELEMENT {
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_TYPE type;
  NvS32 deltauV;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_ELEMENT_DATA_V1 data;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_DATA_ELEMENT_V1;
#define NV_GPU_PERF_PERF_LIMIT_VOLTAGE_DATA_ELEMENTS_MAX 16
typedef struct _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_V1 {
  NvU8 voltRailIdx;
  NvU8 numElements;
  NvS32 deltauV;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_DATA_ELEMENT_V1
  elements[NV_GPU_PERF_PERF_LIMIT_VOLTAGE_DATA_ELEMENTS_MAX];
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_V1;
typedef union _NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA {
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_PSTATE_V1 pstate;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_FREQUENCY_V1 freq;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VPSTATE_V1 vpstate;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA_VOLTAGE_V1 voltage;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA;
typedef struct _NV_GPU_PERF_LIMIT_CLIENT_INPUT_V1 {
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_TYPE type;
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_DATA data;
} NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_STATUS_PMU_V1 {
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_V1 clientInput;
} NV_GPU_PERF_PERF_LIMIT_STATUS_PMU_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_ARBITRATION_INPUT_35_TUPLE_V1 {
  NvU32 pstateIdx;
  NvU32 clkDomains[NV_GPU_PERF_PERF_LIMIT_CLK_DOMAINS_MAX];
  NvU32 voltRails[NV_GPU_PERF_PERF_LIMIT_VOLT_RAILS_MAX];
} NV_GPU_PERF_PERF_LIMIT_ARBITRATION_INPUT_35_TUPLE_V1, *PNV_GPU_PERF_PERF_LIMIT_ARBITRATION_INPUT_35_TUPLE_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_ARBITRATION_INPUT_35_V1 {
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainsMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 voltRailsMask;
  NV_GPU_PERF_PERF_LIMIT_ARBITRATION_INPUT_35_TUPLE_V1
      tuples[NV_GPU_PERF_PERF_LIMITS_ARBITRATION_OUTPUT_TUPLE_IDX_NUM_IDXS];
} NV_GPU_PERF_PERF_LIMIT_ARBITRATION_INPUT_35_V1, *PNV_GPU_PERF_PERF_LIMIT_ARBITRATION_INPUT_35_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_STATUS_3X_V1 {
  NV_GPU_PERF_PERF_LIMIT_STATUS_PMU_V1 super;
  NV_GPU_PERF_PERF_LIMIT_ARBITRATION_INPUT_35_V1 arbInput;
} NV_GPU_PERF_PERF_LIMIT_STATUS_35_V1;
typedef union _NV_GPU_PERF_PERF_LIMIT_STATUS_DATA {
  NV_GPU_PERF_PERF_LIMIT_STATUS_PMU_V1 pmu;
  NV_GPU_PERF_PERF_LIMIT_STATUS_35_V1 v35;
  NvU8 rsvd[64];
} NV_GPU_PERF_PERF_LIMIT_STATUS_DATA_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_STATUS_V1 {
  NV_GPU_PERF_PERF_LIMIT_TYPE type;
  NV_GPU_PERF_PERF_LIMIT_STATUS_DATA_V1 data;
} NV_GPU_PERF_PERF_LIMIT_STATUS_V1;
typedef struct _NV_GPU_PERF_LIMITS_STATUS_V1 {
  NvU32 version;
  NvU32 limitsVersion;
  NV_GPU_BOARDOBJGRP_MASK_E255 limitMask;
  NV_GPU_PERF_PERF_LIMITS_STATUS_DATA_V1 data;
  NV_GPU_PERF_PERF_LIMIT_STATUS_V1 limits[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_PERF_PERF_LIMITS_STATUS_V1;
typedef NV_GPU_PERF_PERF_LIMITS_STATUS_V1 NV_GPU_PERF_PERF_LIMITS_STATUS;
#define NV_GPU_PERF_PERF_LIMITS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_LIMITS_STATUS_V1, 1)
#define NV_GPU_PERF_PERF_LIMITS_STATUS_VER NV_GPU_PERF_PERF_LIMITS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfLimitsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_PERF_PERF_LIMITS_STATUS *pLimits);
typedef struct _NV_GPU_PERF_PERF_LIMIT_CONTROL_PMU_V1 {
  NV_GPU_PERF_PERF_LIMIT_CLIENT_INPUT_V1 rmClientInput;
  NvU8 rsvd[16];
} NV_GPU_PERF_PERF_LIMIT_CONTROL_PMU_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CONTROL_35_V1 {
  NV_GPU_PERF_PERF_LIMIT_CONTROL_PMU_V1 super;
  NvU8 rsvd[16];
} NV_GPU_PERF_PERF_LIMIT_CONTROL_35_V1;
typedef union _NV_GPU_PERF_PERF_LIMIT_CONTROL_DATA_V1 {
  NV_GPU_PERF_PERF_LIMIT_CONTROL_PMU_V1 pmu;
  NV_GPU_PERF_PERF_LIMIT_CONTROL_35_V1 v35;
  NvU8 rsvd[64];
} NV_GPU_PERF_PERF_LIMIT_CONTROL_DATA_V1;
typedef struct _NV_GPU_PERF_PERF_LIMIT_CONTROL_V1 {
  NV_GPU_PERF_PERF_LIMIT_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_LIMIT_CONTROL_DATA_V1 data;
} NV_GPU_PERF_PERF_LIMIT_CONTROL_V1;
typedef struct _NV_GPU_PERF_PERF_LIMITS_CONTROL_V1 {
  NvU32 version;
  NvBool bArbitrateAndApplyLock;
  NvBool bCachingEnabled;
  NV_GPU_BOARDOBJGRP_MASK_E255 limitMask;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_LIMIT_CONTROL_V1 limits[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_PERF_PERF_LIMITS_CONTROL_V1;
typedef NV_GPU_PERF_PERF_LIMITS_CONTROL_V1 NV_GPU_PERF_PERF_LIMITS_CONTROL;
#define NV_GPU_PERF_PERF_LIMITS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_LIMITS_CONTROL_V1, 1)
#define NV_GPU_PERF_PERF_LIMITS_CONTROL_VER NV_GPU_PERF_PERF_LIMITS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfLimitsGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GPU_PERF_PERF_LIMITS_CONTROL *pLimits);
NVAPI_INTERFACE NvAPI_GPU_PerfPerfLimitsSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GPU_PERF_PERF_LIMITS_CONTROL *pLimits);
#define NV_GPU_PERF_VPSTATE_MAX_V1 255
#define NV_GPU_PERF_VPSTATE_2X_DOMAIN_GROUP_NUM 0x03
#define NV_GPU_PERF_VPSTATE_VERSION_2X 0x20
#define NV_GPU_PERF_VPSTATE_VERSION_3X 0x30
typedef enum {
  NV_GPU_PERF_VPSTATE_TYPE_2X = 0x0,
  NV_GPU_PERF_VPSTATE_TYPE_3X = 0x1,
  NV_GPU_PERF_VPSTATE_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_VPSTATE_TYPE;
typedef enum {
  NV_GPU_PERF_VPSTATES_IDX_D2 = 0x00,
  NV_GPU_PERF_VPSTATES_IDX_D3 = 0x01,
  NV_GPU_PERF_VPSTATES_IDX_D4 = 0x02,
  NV_GPU_PERF_VPSTATES_IDX_D5 = 0x03,
  NV_GPU_PERF_VPSTATES_IDX_OVERCUR = 0x04,
  NV_GPU_PERF_VPSTATES_IDX_VRHOT = 0x05,
  NV_GPU_PERF_VPSTATES_IDX_MAXBATT = 0x06,
  NV_GPU_PERF_VPSTATES_IDX_MAXSLI = 0x07,
  NV_GPU_PERF_VPSTATES_IDX_MAXTHERMSUS = 0x08,
  NV_GPU_PERF_VPSTATES_IDX_SLOWDOWNPWR = 0x09,
  NV_GPU_PERF_VPSTATES_IDX_MIDPOINT = 0x0a,
  NV_GPU_PERF_VPSTATES_IDX_FLAGS = 0x0b,
  NV_GPU_PERF_VPSTATES_IDX_INFLECTION0 = 0x0c,
  NV_GPU_PERF_VPSTATES_IDX_INFLECTION = NV_GPU_PERF_VPSTATES_IDX_INFLECTION0,
  NV_GPU_PERF_VPSTATES_IDX_FULLDEFLECT = 0x0d,
  NV_GPU_PERF_VPSTATES_IDX_IMPFIRST = 0x0e,
  NV_GPU_PERF_VPSTATES_IDX_IMPLAST = 0x0f,
  NV_GPU_PERF_VPSTATES_IDX_RATEDTDP = 0x10,
  NV_GPU_PERF_VPSTATES_IDX_BOOST = 0x11,
  NV_GPU_PERF_VPSTATES_IDX_TURBOBOOST = 0x12,
  NV_GPU_PERF_VPSTATES_IDX_MAXCUSTOMERBOOST = 0x13,
  NV_GPU_PERF_VPSTATES_IDX_INFLECTION1 = 0x14,
  NV_GPU_PERF_VPSTATES_IDX_INFLECTION2 = 0x15,
  NV_GPU_PERF_VPSTATES_IDX_WHISPER_MODE = 0x16,
  NV_GPU_PERF_VPSTATES_IDX_DLPPM_1X_ESTIMATION_MINIMUM = 0x17,
  NV_GPU_PERF_VPSTATES_IDX_DLPPC_1X_SEARCH_MINIMUM = 0x18,
  NV_GPU_PERF_VPSTATES_IDX_NUM_INDEXES = 0x19,
  NV_GPU_PERF_VPSTATES_IDX_NUM_INDEXES_V1 = 0x30,
  NV_GPU_PERF_VPSTATES_IDX_INVALID = 0xFF,
} NV_GPU_PERF_VPSTATES_IDX;
typedef struct {
  NvU8 vPstateNum;
  NvU32 reqPower10mW;
  NvU32 reqSlowdownPower10mW;
  NvU32 value[NV_GPU_PERF_VPSTATE_2X_DOMAIN_GROUP_NUM];
  NvU8 rsvd[8];
} NV_GPU_PERF_VPSTATE_INFO_2X;
typedef struct {
  NvU16 targetFreqMHz;
  NvU16 minEffFreqMHz;
  NvU8 rsvd[8];
} NV_GPU_PERF_VPSTATE_3X_CLOCK_ENTRY;
typedef struct {
  NvU8 pstateIdx;
  NV_GPU_PERF_VPSTATE_3X_CLOCK_ENTRY
  clocks[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NvU8 rsvd[8];
} NV_GPU_PERF_VPSTATE_INFO_3X;
typedef union {
  NV_GPU_PERF_VPSTATE_INFO_2X v2x;
  NV_GPU_PERF_VPSTATE_INFO_3X v3x;
  NvU8 rsvd[32];
} NV_GPU_PERF_VPSTATE_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_VPSTATE_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_VPSTATE_INFO_DATA_V1 data;
} NV_GPU_PERF_VPSTATE_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vpstatesMask;
  NvU8 vpstateVersion;
  NvU32 nDomainGroups;
  NvU8 vpstateIdx[NV_GPU_PERF_VPSTATES_IDX_NUM_INDEXES_V1];
  NvU8 rsvd[39];
  NV_GPU_PERF_VPSTATE_INFO_V1 vpstates[NV_GPU_PERF_VPSTATE_MAX_V1];
} NV_GPU_PERF_VPSTATES_INFO_V1;
typedef NV_GPU_PERF_VPSTATES_INFO_V1 NV_GPU_PERF_VPSTATES_INFO;
#define NV_GPU_PERF_VPSTATES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_VPSTATES_INFO_V1, 1)
#define NV_GPU_PERF_VPSTATES_INFO_VER NV_GPU_PERF_VPSTATES_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfVpstatesGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                              NV_GPU_PERF_VPSTATES_INFO *pVpstatesInfo);
typedef struct {
  NvU32 value[NV_GPU_PERF_VPSTATE_2X_DOMAIN_GROUP_NUM];
  NvU8 rsvd[8];
} NV_GPU_PERF_VPSTATE_CONTROL_2X;
typedef struct {
  NvU8 pstateIdx;
  NV_GPU_PERF_VPSTATE_3X_CLOCK_ENTRY
  clocks[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NvU8 rsvd[8];
} NV_GPU_PERF_VPSTATE_CONTROL_3X;
typedef union {
  NV_GPU_PERF_VPSTATE_CONTROL_2X v2x;
  NV_GPU_PERF_VPSTATE_CONTROL_3X v3x;
  NvU8 rsvd[32];
} NV_GPU_PERF_VPSTATE_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_PERF_VPSTATE_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_VPSTATE_CONTROL_DATA_V1 data;
} NV_GPU_PERF_VPSTATE_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vpstatesMask;
  NvU8 bOriginal;
  NvU8 rsvd[64];
  NV_GPU_PERF_VPSTATE_CONTROL_V1 vpstates[NV_GPU_PERF_VPSTATE_MAX_V1];
} NV_GPU_PERF_VPSTATES_CONTROL_V1;
typedef NV_GPU_PERF_VPSTATES_CONTROL_V1 NV_GPU_PERF_VPSTATES_CONTROL;
#define NV_GPU_PERF_VPSTATES_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_VPSTATES_CONTROL_V1, 1)
#define NV_GPU_PERF_VPSTATES_CONTROL_VER NV_GPU_PERF_VPSTATES_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfVpstatesGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                 NV_GPU_PERF_VPSTATES_CONTROL *pVpstatesControl);
NVAPI_INTERFACE NvAPI_GPU_PerfVpstatesSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                 NV_GPU_PERF_VPSTATES_CONTROL *pVpstatesControl);
#define NV_GPU_PERF_VFE_VAR_MAX_V1 32
#define NV_GPU_PERF_VFE_VAR_MAX_V2 NV_GPU_PERF_VFE_VAR_MAX_V1
#define NV_GPU_PERF_VFE_VAR_MAX_V3 NV_GPU_PERF_VFE_VAR_MAX_V2
#define NV_GPU_PERF_VFE_VAR_IDX_INVALID NV_U8_MAX
typedef enum {
  NV_GPU_PERF_VFE_VAR_TYPE_INVALID = 0x0,
  NV_GPU_PERF_VFE_VAR_TYPE_DERIVED,
  NV_GPU_PERF_VFE_VAR_TYPE_DERIVED_PRODUCT,
  NV_GPU_PERF_VFE_VAR_TYPE_DERIVED_SUM,
  NV_GPU_PERF_VFE_VAR_TYPE_SINGLE,
  NV_GPU_PERF_VFE_VAR_TYPE_SINGLE_FREQUENCY,
  NV_GPU_PERF_VFE_VAR_TYPE_SINGLE_SENSED,
  NV_GPU_PERF_VFE_VAR_TYPE_SINGLE_SENSED_FUSE,
  NV_GPU_PERF_VFE_VAR_TYPE_SINGLE_SENSED_TEMP,
  NV_GPU_PERF_VFE_VAR_TYPE_SINGLE_VOLTAGE,
  NV_GPU_PERF_VFE_VAR_TYPE_SINGLE_SENSED_FUSE_BASE = 0x0c,
  NV_GPU_PERF_VFE_VAR_TYPE_SINGLE_SENSED_FUSE_20,
  NV_GPU_PERF_VFE_VAR_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_VFE_VAR_TYPE;
typedef struct {
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_DERIVED;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED super;
  NvU8 varIdx0;
  NvU8 varIdx1;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_DERIVED_PRODUCT;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED super;
  NvU8 varIdx0;
  NvU8 varIdx1;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_DERIVED_SUM;
typedef struct {
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE super;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE_FREQUENCY;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE super;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED;
#define NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE_INVALID 0x00000000
#define NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE_REG 0x00000001
#define NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE_INDEX_REG 0x00000002
#define NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE_IO_REG 0x00000003
#define NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE_IO_INDEX_REG 0x00000004
#define NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE_IO_INDEX_A_REG 0x00000005
#define NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE_IO_INDEX_B_REG 0x00000006
#define NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE_MAX 0x00000007
#define NV_GPU_BIOS_VFIELD_ID_STRAP_CRYSTAL 0x00
#define NV_GPU_BIOS_VFIELD_ID_STRAP_TV_MODE 0x01
#define NV_GPU_BIOS_VFIELD_ID_STRAP_FP_IFACE 0x02
#define NV_GPU_BIOS_VFIELD_ID_STRAP_PANEL 0x03
#define NV_GPU_BIOS_VFIELD_ID_STRAP_RAMCFG 0x04
#define NV_GPU_BIOS_VFIELD_ID_STRAP_MEMSEL 0x05
#define NV_GPU_BIOS_VFIELD_ID_STRAP_UNUSED_0 0x06
#define NV_GPU_BIOS_VFIELD_ID_STRAP_SPEEDO 0x07
#define NV_GPU_BIOS_VFIELD_ID_STRAP_SPEEDO_VERSION 0x08
#define NV_GPU_BIOS_VFIELD_ID_STRAP_IDDQ 0x09
#define NV_GPU_BIOS_VFIELD_ID_STRAP_IDDQ_VERSION 0x0A
#define NV_GPU_BIOS_VFIELD_ID_STRAP_IDDQ_1 0x0B
#define NV_GPU_BIOS_VFIELD_ID_STRAP_BOARD_BINNING 0x0C
#define NV_GPU_BIOS_VFIELD_ID_STRAP_BOARD_BINNING_VERSION 0x0D
#define NV_GPU_BIOS_VFIELD_ID_STRAP_SRAM_VMIN 0x0E
#define NV_GPU_BIOS_VFIELD_ID_STRAP_SRAM_VMIN_VERSION 0x0F
#define NV_GPU_BIOS_VFIELD_ID_IDDQ_NVVDD 0x10
#define NV_GPU_BIOS_VFIELD_ID_IDDQ_MSVDD 0x11
#define NV_GPU_BIOS_VFIELD_ID_STRAP_BOOT_VMIN_NVVDD 0x12
#define NV_GPU_BIOS_VFIELD_ID_ISENSE_VCM_OFFSET 0x13
#define NV_GPU_BIOS_VFIELD_ID_ISENSE_DIFF_GAIN 0x14
#define NV_GPU_BIOS_VFIELD_ID_ISENSE_DIFF_OFFSET 0x15
#define NV_GPU_BIOS_VFIELD_ID_ISENSE_CALIBRATION_VERSION 0x16
#define NV_GPU_BIOS_VFIELD_ID_KAPPA 0x17
#define NV_GPU_BIOS_VFIELD_ID_KAPPA_VERSION 0x18
#define NV_GPU_BIOS_VFIELD_ID_STRAP_SPEEDO_1 0x19
#define NV_GPU_BIOS_VFIELD_ID_CPM_VERSION 0x1A
#define NV_GPU_BIOS_VFIELD_ID_CPM_0 0x1B
#define NV_GPU_BIOS_VFIELD_ID_CPM_1 0x1C
#define NV_GPU_BIOS_VFIELD_ID_CPM_2 0x1D
#define NV_GPU_BIOS_VFIELD_ID_ISENSE_VCM_COARSE_OFFSET 0x1E
#define NV_GPU_BIOS_VFIELD_ID_STRAP_BOOT_VMIN_MSVDD 0x1F
#define NV_GPU_BIOS_VFIELD_ID_KAPPA_VALID 0x20
#define NV_GPU_BIOS_VFIELD_ID_STRAP_SPEEDO_2 0x21
#define NV_GPU_BIOS_VFIELD_ID_OC_BIN 0x22
#define NV_GPU_BIOS_VFIELD_ID_LV_FMAX_KNOB 0x23
#define NV_GPU_BIOS_VFIELD_ID_MV_FMAX_KNOB 0x24
#define NV_GPU_BIOS_VFIELD_ID_HV_FMAX_KNOB 0x25
#define NV_GPU_BIOS_VFIELD_ID_PSTATE_VMIN_KNOB 0x26
#define NV_GPU_BIOS_VFIELD_ID_INVALID 0xFF
typedef struct {
  NvU8 lowBit;
  NvU8 highBit;
} NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_SUPER, *PNV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_SUPER;
typedef struct {
  NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_SUPER super;
  NvU32 addr;
} NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_REG, *PNV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_REG;
typedef struct {
  NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_SUPER super;
  NvU32 addr;
  NvU32 regIndex;
  NvU32 index;
} NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_INDEX_REG, *PNV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_INDEX_REG;
typedef union {
  NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_REG reg;
  NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_INDEX_REG indexReg;
} NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE, *PNV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE;
typedef struct {
  NvU8 type;
  NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT_TYPE data;
} NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT, *PNV_GPU_BIOS_VFIELD_REGISTER_SEGMENT;
#define NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_SEGMENTS_MAX_V1 1
typedef struct {
  NvU8 segmentCount;
  NV_GPU_BIOS_VFIELD_REGISTER_SEGMENT
  segments[NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_SEGMENTS_MAX_V1];
} NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_INFO, *PNV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_INFO;
typedef struct {
  NvU32 fuseValOverride;
  NvU8 bFuseRegkeyOverride;
} NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_OVERRIDE_INFO;
typedef union {
  NvS32 signedValue;
  NvU32 unsignedValue;
} NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE_DATA, *PNV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE_DATA;
typedef struct {
  NvBool bSigned;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE_DATA data;
} NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE, *PNV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE;
#define NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE_SET(pDest, pSrc)                                                  \
  do {                                                                                                                 \
    if ((pSrc)->bSigned) {                                                                                             \
      ((pDest)->data.signedValue) = ((pSrc)->data.signedValue);                                                        \
    } else {                                                                                                           \
      ((pDest)->data.unsignedValue) = ((pSrc)->data.unsignedValue);                                                    \
    }                                                                                                                  \
    ((pDest)->bSigned) = ((pSrc)->bSigned);                                                                            \
  } while (0)
typedef struct {
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_INFO fuse;
  NvU32 fuseValDefault;
  NvS32 hwCorrectionScale;
  NvS32 hwCorrectionOffset;
  NvU8 vFieldId;
} NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VFIELD_INFO;
typedef struct {
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_INFO fuse;
  NvU8 verExpected;
  NvU8 bVerCheck;
  NvU8 bUseDefaultOnVerCheckFail;
  NvU8 vFieldIdVer;
} NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VER_VFIELD_INFO;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED super;
  NvU32 fuseValueInteger;
  NvU32 fuseValueHwInteger;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_OVERRIDE_INFO overrideInfo;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VFIELD_INFO vfieldInfo;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VER_VFIELD_INFO vfieldVerInfo;
  NvU8 bVersionCheckDone;
  NvU8 fuseVersion;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_V1;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED super;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE fuseValue;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE fuseValueHw;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_OVERRIDE_INFO overrideInfo;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VFIELD_INFO vfieldInfo;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VER_VFIELD_INFO vfieldVerInfo;
  NvU8 bVersionCheckDone;
  NvU8 fuseVersion;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_V2;
typedef struct {
  NvU8 verExpected;
  NvBool bVerExpectedIsMask;
  NvBool bVerCheck;
  NvBool bVerCheckIgnore;
  NvBool bUseDefaultOnVerCheckFail;
  NvU8 rsvd[256];
} NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VER_INFO_V1;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED super;
  NvU8 fuseVersion;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE fuseValue;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE fuseValueHw;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VALUE fuseValDefault;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_OVERRIDE_INFO overrideInfo;
  NvU8 bVersionCheckDone;
  NvU32 fuseValueInteger;
  NvU32 fuseValueHwInteger;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_VER_INFO_V1 verInfo;
  NvS32 hwCorrectionScale;
  NvS32 hwCorrectionOffset;
  NvU8 rsvd[1024];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_BASE_V1;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_BASE_V1 super;
  NvU8 vFieldId;
  NvU8 vFieldIdVer;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_INFO fuse;
  NV_GPU_PERF_VFE_VAR_SINGLE_SENSED_FUSE_INFO fuseVer;
  NvU8 rsvd[1024];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_V3;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_BASE_V1 super;
  NvU8 fuseId;
  NvU8 fuseIdVer;
  NvU8 rsvd[1024];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_20_V1;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED super;
  NvU8 thermChannelIndex;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_TEMP;
typedef struct {
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED super;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_INFO_SINGLE_VOLTAGE;
typedef union {
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED derived;
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED_PRODUCT derivedProd;
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED_SUM derivedSum;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE single;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_FREQUENCY singleFreq;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED sensed;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_V1 sensedFuse;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_TEMP sensedTemp;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_VOLTAGE singleVolt;
  NvU8 rsvd[32];
} NV_GPU_PERF_VFE_VAR_INFO_DATA_V1;
typedef union {
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED derived;
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED_PRODUCT derivedProd;
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED_SUM derivedSum;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE single;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_FREQUENCY singleFreq;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED sensed;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_V2 sensedFuse;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_TEMP sensedTemp;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_VOLTAGE singleVolt;
  NvU8 rsvd[32];
} NV_GPU_PERF_VFE_VAR_INFO_DATA_V2;
typedef union {
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED derived;
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED_PRODUCT derivedProd;
  NV_GPU_PERF_VFE_VAR_INFO_DERIVED_SUM derivedSum;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE single;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_FREQUENCY singleFreq;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED sensed;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_BASE_V1 sensedFuseBase;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_V3 sensedFuse;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_20_V1 sensedFuse20;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_TEMP sensedTemp;
  NV_GPU_PERF_VFE_VAR_INFO_SINGLE_VOLTAGE singleVolt;
  NvU8 rsvd[10940];
} NV_GPU_PERF_VFE_VAR_INFO_DATA_V3;
typedef struct {
  NV_GPU_PERF_VFE_VAR_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_VFE_VAR_INFO_DATA_V1 data;
} NV_GPU_PERF_VFE_VAR_INFO_V1;
typedef struct {
  NV_GPU_PERF_VFE_VAR_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_VFE_VAR_INFO_DATA_V2 data;
} NV_GPU_PERF_VFE_VAR_INFO_V2;
typedef struct {
  NV_GPU_PERF_VFE_VAR_TYPE type;
  NvU8 rsvd[256];
  NV_GPU_PERF_VFE_VAR_INFO_DATA_V3 data;
} NV_GPU_PERF_VFE_VAR_INFO_V3;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 varsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_VFE_VAR_INFO_V1 vars[NV_GPU_PERF_VFE_VAR_MAX_V1];
} NV_GPU_PERF_VFE_VARS_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 varsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_VFE_VAR_INFO_V2 vars[NV_GPU_PERF_VFE_VAR_MAX_V2];
} NV_GPU_PERF_VFE_VARS_INFO_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 varsMask;
  NvU8 rsvd[256];
  NV_GPU_PERF_VFE_VAR_INFO_V3 vars[NV_GPU_PERF_VFE_VAR_MAX_V3];
} NV_GPU_PERF_VFE_VARS_INFO_V3;
typedef NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_BASE_V1 NV_GPU_PERF_VFE_VAR_INFO_SINGLE_SENSED_FUSE_BASE;
typedef NV_GPU_PERF_VFE_VARS_INFO_V3 NV_GPU_PERF_VFE_VARS_INFO;
typedef NV_GPU_PERF_VFE_VAR_INFO_V3 NV_GPU_PERF_VFE_VAR_INFO;
#define NV_GPU_PERF_VFE_VARS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_VFE_VARS_INFO_V1, 1)
#define NV_GPU_PERF_VFE_VARS_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_VFE_VARS_INFO_V2, 1)
#define NV_GPU_PERF_VFE_VARS_INFO_VER3 MAKE_NVAPI_VERSION(NV_GPU_PERF_VFE_VARS_INFO_V3, 3)
#define NV_GPU_PERF_VFE_VARS_INFO_VER NV_GPU_PERF_VFE_VARS_INFO_VER3
NVAPI_INTERFACE NvAPI_GPU_PerfVfeVarGetInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_VFE_VARS_INFO *pVfeVarsInfo);
#define NV_GPU_PERF_VFE_VAR_SINGLE_OVERRIDE_TYPE_NONE 0x00
#define NV_GPU_PERF_VFE_VAR_SINGLE_OVERRIDE_TYPE_VALUE 0x01
#define NV_GPU_PERF_VFE_VAR_SINGLE_OVERRIDE_TYPE_OFFSET 0x02
#define NV_GPU_PERF_VFE_VAR_SINGLE_OVERRIDE_TYPE_SCALE 0x03
typedef struct {
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_CONTROL_DERIVED;
typedef struct {
  NV_GPU_PERF_VFE_VAR_CONTROL_DERIVED super;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_CONTROL_DERIVED_PRODUCT;
typedef struct {
  NV_GPU_PERF_VFE_VAR_CONTROL_DERIVED super;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_CONTROL_DERIVED_SUM;
typedef struct {
  NvU8 overrideType;
  NvF32 overrideValue;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE;
typedef struct {
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE super;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_FREQUENCY;
typedef struct {
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE super;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_SENSED;
typedef struct {
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_SENSED super;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_SENSED_FUSE;
typedef struct {
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_SENSED super;
  NvS32 tempHysteresisPositive;
  NvS32 tempHysteresisNegative;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_SENSED_TEMP;
typedef struct {
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_SENSED super;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_VOLTAGE;
typedef union {
  NV_GPU_PERF_VFE_VAR_CONTROL_DERIVED derived;
  NV_GPU_PERF_VFE_VAR_CONTROL_DERIVED_PRODUCT derivedProd;
  NV_GPU_PERF_VFE_VAR_CONTROL_DERIVED_SUM derivedSum;
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE single;
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_FREQUENCY singleFreq;
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_SENSED sensed;
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_SENSED_FUSE sensedFuse;
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_SENSED_TEMP sensedTemp;
  NV_GPU_PERF_VFE_VAR_CONTROL_SINGLE_VOLTAGE singleVolt;
  NvU8 rsvd[32];
} NV_GPU_PERF_VFE_VAR_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_PERF_VFE_VAR_TYPE type;
  NvF32 outRangeMin;
  NvF32 outRangeMax;
  NvU8 rsvd[32];
  NV_GPU_PERF_VFE_VAR_CONTROL_DATA_V1 data;
} NV_GPU_PERF_VFE_VAR_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 varsMask;
  NvU8 pollingPeriodms;
  NvU8 rsvd[64];
  NV_GPU_PERF_VFE_VAR_CONTROL_V1 vars[NV_GPU_PERF_VFE_VAR_MAX_V1];
} NV_GPU_PERF_VFE_VARS_CONTROL_V1;
typedef NV_GPU_PERF_VFE_VARS_CONTROL_V1 NV_GPU_PERF_VFE_VARS_CONTROL;
#define NV_GPU_PERF_VFE_VARS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_VFE_VARS_CONTROL_V1, 1)
#define NV_GPU_PERF_VFE_VARS_CONTROL_VER NV_GPU_PERF_VFE_VARS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfVfeVarGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_PERF_VFE_VARS_CONTROL *pVfeVarsControl);
NVAPI_INTERFACE NvAPI_GPU_PerfVfeVarSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_PERF_VFE_VARS_CONTROL *pVfeVarsControl);
#define NV_GPU_PERF_VFE_EQU_MAX_V1 255
#define NV_GPU_PERF_VFE_EQU_IDX_INVALID NV_U8_MAX
typedef enum {
  NV_GPU_PERF_VFE_EQU_TYPE_INVALID = 0x0,
  NV_GPU_PERF_VFE_EQU_TYPE_COMPARE = 0x1,
  NV_GPU_PERF_VFE_EQU_TYPE_MINMAX = 0x2,
  NV_GPU_PERF_VFE_EQU_TYPE_QUADRATIC = 0x3,
  NV_GPU_PERF_VFE_EQU_TYPE_EQUATION_SCALAR = 0x4,
  NV_GPU_PERF_VFE_EQU_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_VFE_EQU_TYPE;
#define NV_GPU_PERF_VFE_EQU_OUTPUT_TYPE_UNITLESS 0x00
#define NV_GPU_PERF_VFE_EQU_OUTPUT_TYPE_FREQ_MHZ 0x01
#define NV_GPU_PERF_VFE_EQU_OUTPUT_TYPE_VOLT_UV 0x02
#define NV_GPU_PERF_VFE_EQU_OUTPUT_TYPE_VF_GAIN 0x03
#define NV_GPU_PERF_VFE_EQU_OUTPUT_TYPE_VOLT_DELTA_UV 0x04
#define NV_GPU_PERF_VFE_EQU_OUTPUT_TYPE_INVALID 0xFF
typedef struct {
  NvU8 equIdxTrue;
  NvU8 equIdxFalse;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_EQU_INFO_COMPARE;
typedef struct {
  NvU8 equIdx0;
  NvU8 equIdx1;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_EQU_INFO_MINMAX;
typedef struct {
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_EQU_INFO_QUADRATIC;
typedef struct {
  NvU8 equIdxToScale;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_EQU_INFO_EQUATION_SCALAR;
typedef union {
  NV_GPU_PERF_VFE_EQU_INFO_COMPARE compare;
  NV_GPU_PERF_VFE_EQU_INFO_MINMAX minmax;
  NV_GPU_PERF_VFE_EQU_INFO_QUADRATIC quadratic;
  NV_GPU_PERF_VFE_EQU_INFO_EQUATION_SCALAR equScalar;
  NvU8 rsvd[32];
} NV_GPU_PERF_VFE_EQU_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_VFE_EQU_TYPE type;
  NvU8 varIdx;
  NvU8 equIdxNext;
  NvU8 outputType;
  NvU8 rsvd[32];
  NV_GPU_PERF_VFE_EQU_INFO_DATA_V1 data;
} NV_GPU_PERF_VFE_EQU_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 equsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_VFE_EQU_INFO_V1 equs[NV_GPU_PERF_VFE_EQU_MAX_V1];
} NV_GPU_PERF_VFE_EQUS_INFO_V1;
typedef NV_GPU_PERF_VFE_EQUS_INFO_V1 NV_GPU_PERF_VFE_EQUS_INFO;
#define NV_GPU_PERF_VFE_EQUS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_VFE_EQUS_INFO_V1, 1)
#define NV_GPU_PERF_VFE_EQUS_INFO_VER NV_GPU_PERF_VFE_EQUS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfVfeEquGetInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_VFE_EQUS_INFO *pVfeEqusInfo);
#define NV_GPU_PERF_VFE_EQU_QUADRATIC_COEFF_COUNT 0x03
#define NV_GPU_PERF_VFE_EQU_COMPARE_FUNCTION_EQUAL 0x00
#define NV_GPU_PERF_VFE_EQU_COMPARE_FUNCTION_GREATER_EQ 0x01
#define NV_GPU_PERF_VFE_EQU_COMPARE_FUNCTION_GREATER 0x02
#define NV_GPU_PERF_VFE_EQU_COMPARE_FUNCTION_INVALID 0xFF
typedef struct {
  NvU8 funcId;
  NvF32 criteria;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_EQU_CONTROL_COMPARE;
typedef struct {
  NvU8 bMax;
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_EQU_CONTROL_MINMAX;
typedef struct {
  NvF32 coeffs[NV_GPU_PERF_VFE_EQU_QUADRATIC_COEFF_COUNT];
  NvU8 rsvd[8];
} NV_GPU_PERF_VFE_EQU_CONTROL_QUADRATIC;
typedef union {
  NV_GPU_PERF_VFE_EQU_CONTROL_COMPARE compare;
  NV_GPU_PERF_VFE_EQU_CONTROL_MINMAX minmax;
  NV_GPU_PERF_VFE_EQU_CONTROL_QUADRATIC quadratic;
  NvU8 rsvd[32];
} NV_GPU_PERF_VFE_EQU_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_PERF_VFE_EQU_TYPE type;
  NvF32 outRangeMin;
  NvF32 outRangeMax;
  NvU8 rsvd[32];
  NV_GPU_PERF_VFE_EQU_CONTROL_DATA_V1 data;
} NV_GPU_PERF_VFE_EQU_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 equsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_VFE_EQU_CONTROL_V1 equs[NV_GPU_PERF_VFE_EQU_MAX_V1];
} NV_GPU_PERF_VFE_EQUS_CONTROL_V1;
typedef NV_GPU_PERF_VFE_EQUS_CONTROL_V1 NV_GPU_PERF_VFE_EQUS_CONTROL;
#define NV_GPU_PERF_VFE_EQUS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_VFE_EQUS_CONTROL_V1, 1)
#define NV_GPU_PERF_VFE_EQUS_CONTROL_VER NV_GPU_PERF_VFE_EQUS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfVfeEquGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_PERF_VFE_EQUS_CONTROL *pVfeEqusControl);
NVAPI_INTERFACE NvAPI_GPU_PerfVfeEquSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_PERF_VFE_EQUS_CONTROL *pVfeEqusControl);
#define NV_GPU_PERF_OPTP_CLIENT_MAX_V1 32
typedef struct {
  NvU32 hClient;
  NvU32 perfVal;
  NvBool bFullScreen;
  NvBool bVideo;
  NvBool bVr;
  NvBool bVrApp;
  NvU32 processId;
  NvU8 rsvd[28];
} NV_GPU_PERF_OPTP_STATUS_CLIENT_V1, *PNV_GPU_PERF_OPTP_STATUS_CLIENT_V1;
typedef struct {
  NvU32 version;
  NvU8 numClient;
  NvU8 rsvd[64];
  NV_GPU_PERF_OPTP_STATUS_CLIENT_V1 client[NV_GPU_PERF_OPTP_CLIENT_MAX_V1];
} NV_GPU_PERF_OPTP_STATUS_V1, *PNV_GPU_PERF_OPTP_STATUS_V1;
typedef NV_GPU_PERF_OPTP_STATUS_V1 NV_GPU_PERF_OPTP_STATUS, *PNV_GPU_PERF_OPTP_STATUS;
typedef NV_GPU_PERF_OPTP_STATUS_CLIENT_V1 NV_GPU_PERF_OPTP_STATUS_CLIENT, *PNV_GPU_PERF_OPTP_STATUS_CLIENT;
#define NV_GPU_PERF_OPTP_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_OPTP_STATUS_V1, 1)
#define NV_GPU_PERF_OPTP_STATUS_VER NV_GPU_PERF_OPTP_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfGetOptpStatus(NvPhysicalGpuHandle hPhysicalGpu, PNV_GPU_PERF_OPTP_STATUS pPerfOptpStatus);
typedef struct {
  NvU32 version;
  NvU32 streamCount4k;
  NvU32 streamCount1080p;
  NvU8 rsvd[64];
} NV_GPU_PERF_VIDEO_STATUS_V1, *PNV_GPU_PERF_VIDEO_STATUS_V1;
typedef NV_GPU_PERF_VIDEO_STATUS_V1 NV_GPU_PERF_VIDEO_STATUS, *PNV_GPU_PERF_VIDEO_STATUS;
#define NV_GPU_PERF_VIDEO_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_VIDEO_STATUS_V1, 1)
#define NV_GPU_PERF_VIDEO_STATUS_VER NV_GPU_PERF_VIDEO_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfVideoGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                             PNV_GPU_PERF_VIDEO_STATUS pPerfVideoStatus);
#define NV_GPU_PERF_PERF_CF_SENSOR_MAX_V1 32
#define NV_GPU_PERF_PERF_CF_SENSOR_IDX_INVALID NV_U8_MAX
typedef enum {
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE_PMU = 0x0,
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE_PMU_FB,
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE_PEX,
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE_PTIMER,
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE_PTIMER_CLK,
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE_CLKCNTR,
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE_PGTIME,
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_SENSOR_TYPE,
    *PNV_GPU_PERF_PERF_CF_SENSOR_TYPE;
typedef struct {
  NvU32 idleMask0;
  NvU32 idleMask1;
  NvU32 idleMask2;
  NvU8 counterIdx;
} NV_GPU_PERF_PERF_CF_SENSOR_INFO_PMU, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO_PMU;
typedef struct {
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_PMU super;
  NvU32 scale;
  NvU8 clkDomIdxMulti;
  NvU8 clkDomIdxDiv;
} NV_GPU_PERF_PERF_CF_SENSOR_INFO_PMU_FB, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO_PMU_FB;
typedef struct {
  NvBool bRx;
} NV_GPU_PERF_PERF_CF_SENSOR_INFO_PEX, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO_PEX;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_SENSOR_INFO_PTIMER, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO_PTIMER;
typedef struct {
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_PTIMER super;
  NvU32 clkFreqKHz;
} NV_GPU_PERF_PERF_CF_SENSOR_INFO_PTIMER_CLK, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO_PTIMER_CLK;
typedef struct {
  NvU8 clkDomIdx;
} NV_GPU_PERF_PERF_CF_SENSOR_INFO_CLKCNTR, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO_CLKCNTR;
typedef struct {
  NvU8 pgEngineId;
} NV_GPU_PERF_PERF_CF_SENSOR_INFO_PGTIME, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO_PGTIME;
typedef union {
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_PMU pmu;
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_PMU_FB pmuFb;
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_PEX pex;
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_PTIMER ptimer;
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_PTIMER_CLK ptimerClk;
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_CLKCNTR clkcntr;
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_PGTIME pgtime;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_SENSOR_INFO_DATA_V1, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_SENSOR_INFO_V1, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 sensorsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_SENSOR_INFO_V1 sensors[NV_GPU_PERF_PERF_CF_SENSOR_MAX_V1];
} NV_GPU_PERF_PERF_CF_SENSORS_INFO_V1, *PNV_GPU_PERF_PERF_CF_SENSORS_INFO_V1;
typedef NV_GPU_PERF_PERF_CF_SENSORS_INFO_V1 NV_GPU_PERF_PERF_CF_SENSORS_INFO, *PNV_GPU_PERF_PERF_CF_SENSORS_INFO;
typedef NV_GPU_PERF_PERF_CF_SENSOR_INFO_V1 NV_GPU_PERF_PERF_CF_SENSOR_INFO, *PNV_GPU_PERF_PERF_CF_SENSOR_INFO;
#define NV_GPU_PERF_PERF_CF_SENSORS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_SENSORS_INFO, 1)
#define NV_GPU_PERF_PERF_CF_SENSORS_INFO_VER NV_GPU_PERF_PERF_CF_SENSORS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfSensorGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                  PNV_GPU_PERF_PERF_CF_SENSORS_INFO pPerfCfSensorsInfo);
typedef struct {
  NvU32 last;
} NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PMU, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS_PMU;
typedef struct {
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PMU super;
  NvU64 lastMulti;
  NvU64 lastDiv;
} NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PMU_FB, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS_PMU_FB;
typedef struct {
  NvU32 last;
} NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PEX, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS_PEX;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PTIMER, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS_PTIMER;
typedef struct {
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PTIMER super;
} NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PTIMER_CLK, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS_PTIMER_CLK;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_SENSOR_STATUS_CLKCNTR, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS_CLKCNTR;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PGTIME, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS_PGTIME;
typedef union {
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PMU pmu;
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PMU_FB pmuFb;
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PEX pex;
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PTIMER ptimer;
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PTIMER_CLK ptimerClk;
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_CLKCNTR clkcntr;
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_PGTIME pgtime;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_SENSOR_STATUS_DATA_V1, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE type;
  NvU64 reading;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_SENSOR_STATUS_V1, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 sensorsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_SENSOR_STATUS_V1 sensors[NV_GPU_PERF_PERF_CF_SENSOR_MAX_V1];
} NV_GPU_PERF_PERF_CF_SENSORS_STATUS_V1, *PNV_GPU_PERF_PERF_CF_SENSORS_STATUS_V1;
typedef NV_GPU_PERF_PERF_CF_SENSORS_STATUS_V1 NV_GPU_PERF_PERF_CF_SENSORS_STATUS, *PNV_GPU_PERF_PERF_CF_SENSORS_STATUS;
typedef NV_GPU_PERF_PERF_CF_SENSOR_STATUS_V1 NV_GPU_PERF_PERF_CF_SENSOR_STATUS, *PNV_GPU_PERF_PERF_CF_SENSOR_STATUS;
#define NV_GPU_PERF_PERF_CF_SENSORS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_SENSORS_STATUS, 1)
#define NV_GPU_PERF_PERF_CF_SENSORS_STATUS_VER NV_GPU_PERF_PERF_CF_SENSORS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfSensorGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                    PNV_GPU_PERF_PERF_CF_SENSORS_STATUS pPerfCfSensorsStatus);
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PMU, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PMU;
typedef struct {
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PMU super;
} NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PMU_FB, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PMU_FB;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PEX, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PEX;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PTIMER, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PTIMER;
typedef struct {
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PTIMER super;
} NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PTIMER_CLK, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PTIMER_CLK;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_CLKCNTR, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL_CLKCNTR;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PGTIME, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PGTIME;
typedef union {
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PMU pmu;
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PMU_FB pmuFb;
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PEX pex;
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PTIMER ptimer;
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PTIMER_CLK ptimerClk;
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_CLKCNTR clkcntr;
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_PGTIME pgtime;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_DATA_V1, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_SENSOR_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_V1, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 sensorsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_V1 sensors[NV_GPU_PERF_PERF_CF_SENSOR_MAX_V1];
} NV_GPU_PERF_PERF_CF_SENSORS_CONTROL_V1, *PNV_GPU_PERF_PERF_CF_SENSORS_CONTROL_V1;
typedef NV_GPU_PERF_PERF_CF_SENSORS_CONTROL_V1 NV_GPU_PERF_PERF_CF_SENSORS_CONTROL,
    *PNV_GPU_PERF_PERF_CF_SENSORS_CONTROL;
typedef NV_GPU_PERF_PERF_CF_SENSOR_CONTROL_V1 NV_GPU_PERF_PERF_CF_SENSOR_CONTROL, *PNV_GPU_PERF_PERF_CF_SENSOR_CONTROL;
;
#define NV_GPU_PERF_PERF_CF_SENSORS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_SENSORS_CONTROL, 1)
#define NV_GPU_PERF_PERF_CF_SENSORS_CONTROL_VER NV_GPU_PERF_PERF_CF_SENSORS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfSensorGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                     PNV_GPU_PERF_PERF_CF_SENSORS_CONTROL pPerfCfSensorsControl);
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfSensorSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                     PNV_GPU_PERF_PERF_CF_SENSORS_CONTROL pPerfCfSensorsControl);
#define NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_V1 32
#define NV_GPU_PERF_PERF_CF_PM_SENSOR_IDX_INVALID NV_U8_MAX
#define NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS_V1 NV_GPU_BOARDOBJGRP_E512_MAX_OBJECTS
#define NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS_V2 NV_GPU_BOARDOBJGRP_E1024_MAX_OBJECTS
#define NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS_V1
typedef enum {
  NV_GPU_PERF_PERF_CF_PM_SENSOR_TYPE_V00 = 0x0,
  NV_GPU_PERF_PERF_CF_PM_SENSOR_TYPE_V10,
  NV_GPU_PERF_PERF_CF_PM_SENSOR_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_PM_SENSOR_TYPE,
    *PNV_GPU_PERF_PERF_CF_PM_SENSOR_TYPE;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V00, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V00;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V10, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V10;
typedef union {
  NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V00 v00;
  NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V10 v10;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_DATA_V1, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PM_SENSOR_TYPE type;
  NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_DATA_V1 data;
  NV_GPU_BOARDOBJGRP_MASK_E512 signalsSupportedMask;
  NvU8 rsvd[32];
} NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V1, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PM_SENSOR_TYPE type;
  NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_DATA_V1 data;
  NV_GPU_BOARDOBJGRP_MASK_E1024 signalsSupportedMask;
  NvU8 rsvd[256];
} NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V2, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pmSensorsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V1 pmSensors[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_V1];
} NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_V1, *PNV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pmSensorsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V2 pmSensors[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_V1];
} NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_V2, *PNV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_V2;
typedef NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_V2 NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO,
    *PNV_GPU_PERF_PERF_CF_PM_SENSORS_INFO;
typedef NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO_V2 NV_GPU_PERF_PERF_CF_PM_SENSOR_INFO, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_INFO;
#define NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_V1, 1)
#define NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_V2, 2)
#define NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_VER NV_GPU_PERF_PERF_CF_PM_SENSORS_INFO_VER2
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfPmSensorGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                    PNV_GPU_PERF_PERF_CF_PM_SENSORS_INFO pPerfCfPmSensorsInfo);
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V00, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V00;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V10, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V10;
typedef union {
  NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V00 v00;
  NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V10 v10;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_DATA_V1, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_DATA_V1;
typedef struct {
  NvU64 cntLast;
  NvU64 cntDiff;
} NV_GPU_PERF_PERF_CF_PM_SENSOR_SIGNAL_STATUS, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_SIGNAL_STATUS;
typedef struct {
  NV_GPU_PERF_PERF_CF_PM_SENSOR_TYPE type;
  NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_DATA_V1 data;
  NV_GPU_BOARDOBJGRP_MASK_E512 signalsMask;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_PM_SENSOR_SIGNAL_STATUS signals[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS_V1];
} NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V1, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PM_SENSOR_TYPE type;
  NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_DATA_V1 data;
  NV_GPU_BOARDOBJGRP_MASK_E1024 signalsMask;
  NvU8 rsvd[256];
  NV_GPU_PERF_PERF_CF_PM_SENSOR_SIGNAL_STATUS signals[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS_V2];
} NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V2, *PNV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pmSensorsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V1 pmSensors[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_V1];
} NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_V1, *PNV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pmSensorsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V2 pmSensors[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_V1];
} NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_V2, *PNV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_V2;
typedef NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_V2 NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS,
    *PNV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS;
typedef NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS_V2 NV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS,
    *PNV_GPU_PERF_PERF_CF_PM_SENSOR_STATUS;
#define NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_V1, 1)
#define NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_V2, 2)
#define NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_VER NV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS_VER2
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfPmSensorGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                      PNV_GPU_PERF_PERF_CF_PM_SENSORS_STATUS pPerfCfPmSensorsStatus);
#define NV_GPU_PERF_PERF_CF_TOPOLOGY_MAX_V1 32
#define NV_GPU_PERF_PERF_CF_TOPOLOGY_IDX_INVALID NV_U8_MAX
typedef enum {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_TYPE_SENSED_BASE = 0x0,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_TYPE_MIN_MAX,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_TYPE_SENSED,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_TOPOLOGY_TYPE,
    *PNV_GPU_PERF_PERF_CF_TOPOLOGY_TYPE;
typedef enum {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_UNIT_PERCENTAGE = 0x0,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_UNIT_BYTES_PER_NSEC,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_UNIT_GHZ,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_UNIT_NS,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_UNIT_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_TOPOLOGY_UNIT,
    *PNV_GPU_PERF_PERF_CF_TOPOLOGY_UNIT;
typedef enum {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_GR = 0x0,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_FB,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_VID,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_PCIE_TX,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_PCIE_RX,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_DEC0,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_ENC0,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_ENC1,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_ENC2,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_DEC1,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_DEC2,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_DEC3,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_DEC4,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_JPG0,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_OFA,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL_NONE = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL,
    *PNV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL;
typedef enum {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_GPUMON_TAG_FB = 0x0,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_GPUMON_TAG_GR,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_GPUMON_TAG_NVENC,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_GPUMON_TAG_NVDEC,
  NV_GPU_PERF_PERF_CF_TOPOLOGY_GPUMON_TAG_NONE = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_TOPOLOGY_GPUMON_TAG,
    *PNV_GPU_PERF_PERF_CF_TOPOLOGY_GPUMON_TAG;
typedef struct {
  NvU8 sensorIdx;
  NvU8 baseSensorIdx;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_SENSED_BASE, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_SENSED_BASE;
typedef struct {
  NvU8 topologyIdx1;
  NvU8 topologyIdx2;
  NvBool bMax;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_MIN_MAX, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_MIN_MAX;
typedef struct {
  NvBoardObjIdx sensorIdx;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_SENSED;
typedef union {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_SENSED_BASE sensedBase;
  NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_MIN_MAX minMax;
  NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_SENSED sensed;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_DATA_V1, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_TYPE type;
  NV_GPU_PERF_PERF_CF_TOPOLOGY_UNIT unit;
  NV_GPU_PERF_PERF_CF_TOPOLOGY_LABEL label;
  NV_GPU_PERF_PERF_CF_TOPOLOGY_GPUMON_TAG gpumonTag;
  NvBool bNotAvailable;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_V1, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 topologysMask;
  NvU16 pollingPeriodms;
  NvU8 halVal;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_V1 topologys[NV_GPU_PERF_PERF_CF_TOPOLOGY_MAX_V1];
} NV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO_V1, *PNV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO_V1;
typedef NV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO_V1 NV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO, *PNV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO;
typedef NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO_V1 NV_GPU_PERF_PERF_CF_TOPOLOGY_INFO, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_INFO;
#define NV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO, 1)
#define NV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO_VER NV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfTopologyGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                    PNV_GPU_PERF_PERF_CF_TOPOLOGYS_INFO pPerfCfTopologysInfo);
typedef struct {
  NvU64 lastSensorReading;
  NvU64 lastBaseSensorReading;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_SENSED_BASE, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_SENSED_BASE;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_MIN_MAX, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_MIN_MAX;
typedef struct {
  NvU64 lastSensorReading;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_SENSED;
typedef union {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_SENSED_BASE sensedBase;
  NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_MIN_MAX minMax;
  NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_SENSED sensed;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_DATA_V1, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_TYPE type;
  NvU64 reading;
  NvU64 lastPolledReading;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_V1, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 topologysMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_V1 topologys[NV_GPU_PERF_PERF_CF_TOPOLOGY_MAX_V1];
} NV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS_V1, *PNV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS_V1;
typedef NV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS_V1 NV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS,
    *PNV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS;
typedef NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS_V1 NV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS,
    *PNV_GPU_PERF_PERF_CF_TOPOLOGY_STATUS;
#define NV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS, 1)
#define NV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS_VER NV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfTopologyGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                      PNV_GPU_PERF_PERF_CF_TOPOLOGYS_STATUS pPerfCfTopologysStatus);
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_SENSED_BASE, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_SENSED_BASE;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_MIN_MAX, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_MIN_MAX;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_SENSED;
typedef union {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_SENSED_BASE sensedBase;
  NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_MIN_MAX minMax;
  NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_SENSED sensed;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_DATA_V1, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_TOPOLOGY_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_V1, *PNV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 topologysMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_V1 topologys[NV_GPU_PERF_PERF_CF_TOPOLOGY_MAX_V1];
} NV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL_V1, *PNV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL_V1;
typedef NV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL_V1 NV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL,
    *PNV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL;
typedef NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL_V1 NV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL,
    *PNV_GPU_PERF_PERF_CF_TOPOLOGY_CONTROL;
;
#define NV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL, 1)
#define NV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL_VER NV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfTopologyGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                       PNV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL pPerfCfTopologysControl);
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfTopologySetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                       PNV_GPU_PERF_PERF_CF_TOPOLOGYS_CONTROL pPerfCfTopologysControl);
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_MAX_V1 32
typedef enum {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_TYPE_RPPM_1X = 0x0,
  NV_GPU_PERF_PERF_CF_PWR_MODEL_TYPE_DLPPM_1X = 0x1,
  NV_GPU_PERF_PERF_CF_PWR_MODEL_TYPE_TGP_1X = 0x2,
  NV_GPU_PERF_PERF_CF_PWR_MODEL_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_PWR_MODEL_TYPE,
    *PNV_GPU_PERF_PERF_CF_PWR_MODEL_TYPE;
typedef struct {
  NvU8 grUtilPctIdx;
  NvU8 grClkValIdx;
  NvU8 fbUtilPctIdx;
  NvU8 fbClkValIdx;
  NvU8 mscgResPctIdx;
  NvU8 tgpPwrPolicyIdx;
  NvU8 workTypeEquIdx;
  NvU8 utilRatioEquIdx;
  NvU8 workFbNormEquIdx;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_RPPM_1X, *PNV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_RPPM_1X;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E32 independentClkDomMask;
  NV_GPU_BOARDOBJ_IDX voltRailIdx;
  NV_GPU_BOARDOBJ_IDX clkDomIdx;
  NV_GPU_BOARDOBJ_IDX clkDomTopIdx;
  NV_GPU_BOARDOBJ_IDX inPwrChIdx;
  NV_GPU_BOARDOBJ_IDX outPwrChIdx;
  NvU8 rsvd0[2];
  NV_GPU_BOARDOBJ_IDX vrEfficiencyChRelIdx;
  NvBoardObjIdx clkDomUtilTopIdx;
  NV_GPU_VOLT_VOLT_RAIL_SENSED_VOLTAGE_MODE_ENUM voltMode;
  NvU8 rsvd1[26];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_RAIL;
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_MAX_CORE_RAILS (2)
typedef struct {
  NvU8 rsvd0[2];
  NvU8 numRails;
  NvU8 rsvd1[32];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_RAIL
  rails[NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_MAX_CORE_RAILS];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CORE_RAIL;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_RAIL super;
  NV_GPU_NNE_NNE_VAR_ID_POWER_TOTAL_VOLT_RAIL_NAME voltRailName;
  NvU8 rsvd[32];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_FBVDD_RAIL;
typedef struct {
  NvU32 minPct;
  NvU32 maxPct;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CORRECTION_BOUND;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CORRECTION_BOUND perf;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CORRECTION_BOUND
      coreRailPwr[NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_MAX_CORE_RAILS];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CORRECTION_BOUND fbPwr;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CORRECTION_BOUNDS;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CORE_RAIL coreRail;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_FBVDD_RAIL fbRail;
  NvU32 coreRailPwrFitTolerance;
  NV_GPU_BOARDOBJ_IDX nneDescIdx;
  NV_GPU_BOARDOBJ_IDX pmSensorIdx;
  NV_GPU_BOARDOBJGRP_MASK_E512 pmSensorSignalMask;
  NvU32 dramclkMatchTolerance;
  NV_GPU_BOARDOBJ_IDX smallRailPwrChIdx;
  NV_GPU_BOARDOBJ_IDX tgpPwrChIdx;
  NvBoardObjIdx ptimerTopologyIdx;
  NvU8 vfInferenceBatchSize;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CORRECTION_BOUNDS correctionBounds;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_DLPPM_1X;
typedef struct {
  NvBoardObjIdx workloadPwrPolicyIdx;
  NvU8 rsvd[510];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_TGP_1X_V1;
typedef union {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_RPPM_1X rppm1x;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_DLPPM_1X dlppm1x;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_TGP_1X_V1 tgp1x;
  NvU8 rsvd[512];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_DATA_V1, *PNV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_V1, *PNV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pwrModelsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_V1 pwrModels[NV_GPU_PERF_PERF_CF_PWR_MODEL_MAX_V1];
} NV_GPU_PERF_PERF_CF_PWR_MODELS_INFO_V1, *PNV_GPU_PERF_PERF_CF_PWR_MODELS_INFO_V1;
typedef NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO_V1 NV_GPU_PERF_PERF_CF_PWR_MODEL_INFO, *PNV_GPU_PERF_PERF_CF_PWR_MODEL_INFO;
typedef NV_GPU_PERF_PERF_CF_PWR_MODELS_INFO_V1 NV_GPU_PERF_PERF_CF_PWR_MODELS_INFO,
    *PNV_GPU_PERF_PERF_CF_PWR_MODELS_INFO;
#define NV_GPU_PERF_PERF_CF_PWR_MODELS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_PWR_MODELS_INFO, 1)
#define NV_GPU_PERF_PERF_CF_PWR_MODELS_INFO_VER NV_GPU_PERF_PERF_CF_PWR_MODELS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfPwrModelGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                    PNV_GPU_PERF_PERF_CF_PWR_MODELS_INFO pPerfCfPwrModelsInfo);
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE type;
  NvBool bValid;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS;
typedef struct {
  NvU32 grPct;
  NvU32 fbPct;
  NvU32 utilRatio;
  NvU32 workType;
  NvU32 workFb;
  NvU32 workFbNorm;
  NvU32 workGr;
  NvU32 perf;
  NvU32 rt;
  NvU32 tFb;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PERF_RPPM_1X_DATA_V1,
    *PNV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PERF_RPPM_1X_DATA_V1;
typedef struct {
  NvU32 value;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY super;
  NV_GPU_POWER_POLICY_STATUS_RPPM_TGP_1X rppmTgp1x;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY_TGP_1X,
    *PNV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY_TGP_1X;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY super;
  NV_GPU_POWER_POLICY_STATUS_RPPM_FB_1X rppmFb1x;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY_FB_1X,
    *PNV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY_FB_1X;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY super;
  NvU32 workloadScale;
  NV_GPU_POWER_POLICY_STATUS_RPPM_CWC_1X rppmCwc1x;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY_CWC_1X,
    *PNV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY_CWC_1X;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY_TGP_1X metricsTgp1x;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY_FB_1X metricsFb1x;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_POLICY_CWC_1X metricsCwc1x;
  NvBool bMeetReq;
  NvU8 rsvd[112];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_DATA_V1,
    *PNV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PERF_RPPM_1X_DATA_V1 perf;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_PWR_RPPM_1X_DATA_V1 pwr;
  NvU32 grMHz;
  NvU32 fbMHz;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_RPPM_1X_DATA_V1, *PNV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_RPPM_1X_DATA_V1;
typedef struct {
  NvU16 numTpc;
  NvU16 numLtc;
  NvU8 numFbp;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CHIP_CONFIG;
typedef struct {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE pwrInTuple;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE pwrOutTuple;
  NvU32 freqkHz;
  NvU32 pwrOutDynamicNormalizedmW;
  NvU32 voltuV;
  NvU32 leakagePwrmW;
  NvU32 voltMinuV;
  NvU64 utilPct;
  NvU8 rsvd[24];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_RAIL;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_RAIL super;
  NvU32 maxIndependentClkDomVoltMinuV;
  NvU32 vminLimituV;
  NV_GPU_VOLT_RAIL_SENSED_VOLTAGE_DATA voltData;
  NvU8 rsvd[32];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_OBSERVED_METRICS_DLPPM_1X_RAIL;
typedef struct {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE pwrInTuple;
  NvU8 rsvd[56];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_RAIL
  rails[NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_MAX_CORE_RAILS];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_CORE_RAIL;
typedef struct {
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE pwrInTuple;
  NvU8 rsvd[56];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_OBSERVED_METRICS_DLPPM_1X_RAIL
  rails[NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_MAX_CORE_RAILS];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_OBSERVED_METRICS_DLPPM_1X_CORE_RAIL;
typedef struct {
  NvU32 perfms;
  NvU32 perfRatio;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_PERF;
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_PERF_PERFMS_INVALID (0U)
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_PERF_PERF_RATIO_INVALID (NV_U32_MAX)
typedef NvU32 NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_METRIC;
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_METRIC_PERF 0U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_METRIC_CORE_RAIL_PWR 1U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_METRIC_FB_PWR 2U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_METRIC_NUM 3U
typedef NvU32 NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL;
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_ENDPOINT_PRIMARY_CLK 0U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_ADJACENT_PRIMARY_CLK 1U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_LINEAR_MINIMUM_PRIMARY_CLK 2U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_LINEAR_MAXIMUM_PRIMARY_CLK 3U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_LINEAR_FIT 4U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_ADJACENT_DRAMCLK 5U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_LINEAR_DRAMCLK 6U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_NUM 7U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_RSVD0 7U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_RSVD1 8U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_RSVD2 9U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_NUM_RSVD 10U
typedef NV_GPU_BOARDOBJGRP_MASK_E32 NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS;
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS_NUM                                            \
  (NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_METRIC_NUM *                                                         \
   NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_NUM_RSVD)
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS_INIT(pFlags)                                   \
  NV_GPU_BOARDOBJGRP_MASK_E32_INIT(&(pFlags)->super)
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS_GUARD_RAIL_INDEX(metric, guardRail)            \
  ((metric) * NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_NUM_RSVD + (guardRail))
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS_GET(pFlags, metric, guardRail)                 \
  NV_GPU_BOARDOBJGRP_MASK_BIT_IS_SET(                                                                                  \
      NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS_GUARD_RAIL_INDEX((metric), (guardRail)),         \
      &(pFlags)->super)
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS_SET(pFlags, metric, guardRail)                 \
  NV_GPU_BOARDOBJGRP_MASK_BIT_SET(                                                                                     \
      &(pFlags)->super,                                                                                                \
      NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS_GUARD_RAIL_INDEX((metric), (guardRail)))
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS super;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_CORE_RAIL coreRail;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_RAIL fbRail;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE smallRailPwrTuple;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE tgpPwrTuple;
  NvU32 perf;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_PERF perfMetrics;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS guardRailFlags;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X;
typedef struct {
  NvU32 slopemWPerRatio;
  NvU32 interceptmW;
  NvBool bValid;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_CORE_RAIL_POWER_FIT;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X estimatedMetrics[NV_GPU_NNE_NNE_DESC_INFERENCE_LOOPS_MAX];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_CORE_RAIL_POWER_FIT coreRailPwrFit;
  NvU8 numEstimatedMetrics;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_DRAMCLK_ESTIMATES;
typedef struct {
  NvU32 perfPct;
  NvU32 coreRailPwrPct[NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_MAX_CORE_RAILS];
  NvU32 fbPwrPct;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_CORRECTION;
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_OBSERVED_INITIAL_DRAMCLK_ESTIMATES_MAX 3U
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_INVALID_METRICS_REASON_NONE 0x00
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_INVALID_METRICS_REASON_LOW_MEMCLK 0x01
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_INVALID_METRICS_REASON_LOW_GPCCLK 0x02
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_INVALID_METRICS_REASON_LOW_OBS_PERFMS 0x03
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_INVALID_METRICS_REASON_POISON_NORMALIZATION 0x04
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_INVALID_METRICS_REASON_OUT_OF_BOUNDS_CORRECTION 0x05
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_INVALID_METRICS_REASON_BAD_INITIAL_ESTIMATES 0x06
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_INVALID_METRICS_REASON_BAD_FREQUENCY_FOR_CORRECTION 0x07
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_INVALID_METRICS_REASON_FLCN_ERROR 0xFF
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS super;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_OBSERVED_METRICS_DLPPM_1X_CORE_RAIL coreRail;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_OBSERVED_METRICS_DLPPM_1X_RAIL fbRail;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE smallRailPwrTuple;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE tgpPwrTuple;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CHIP_CONFIG chipConfig;
  NvU64 pmSensorDiff[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS_V1];
  NvU32 perf;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_PERF perfMetrics;
  NvU32 normRatio;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_DRAMCLK_ESTIMATES
      initialDramclkEstimates[NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_OBSERVED_INITIAL_DRAMCLK_ESTIMATES_MAX];
  NvU8 numInitialDramclkEstimates;
  NvU8 currDramclkInitialEstimatesIdx;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X observedEstimated;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_CORRECTION correction;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_OBSERVED_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS super;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_OBSERVED_METRICS_DLPPM_1X_CORE_RAIL coreRail;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_OBSERVED_METRICS_DLPPM_1X_RAIL fbRail;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE smallRailPwrTuple;
  NV_GPU_POWER_MONITOR_POWER_CHANNEL_TUPLE tgpPwrTuple;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_CHIP_CONFIG chipConfig;
  NvU64 pmSensorDiff[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS_V1];
  NvU32 rsvd0;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_PERF perfMetrics;
  NvU32 normRatio;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_DRAMCLK_ESTIMATES
      initialDramclkEstimates[NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_OBSERVED_INITIAL_DRAMCLK_ESTIMATES_MAX];
  NvU8 numInitialDramclkEstimates;
  NvU8 currDramclkInitialEstimatesIdx;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X observedEstimated;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_CORRECTION correction;
  NvU8 invalidMetricsReason;
  NV_GPU_NNE_NNE_DESC_INPUT_NORM_STATUS inputNormStatus;
  NvU8 rsvd[8636];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_OBSERVED_V2;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS_RPPM_1X;
typedef struct {
  NvU64 guardRailCounts[NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_GUARD_RAIL_FLAGS_NUM];
  NvU64 isoDramclkGuardRailCount;
  NvU64 isoPrimaryClkGuardRailCount;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_GUARD_RAILS_STATUS;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_GUARD_RAILS_STATUS guardRailsStatus;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS_DLPPM_1X;
typedef union {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS_RPPM_1X rppm1x;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS_DLPPM_1X dlppm1x;
  NvU8 rsvd[512];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pwrModelsMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS_V1 pwrModels[NV_GPU_PERF_PERF_CF_PWR_MODEL_MAX_V1];
} NV_GPU_PERF_PERF_CF_PWR_MODELS_STATUS_V1;
typedef NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS_V1 NV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS,
    *PNV_GPU_PERF_PERF_CF_PWR_MODEL_STATUS;
typedef NV_GPU_PERF_PERF_CF_PWR_MODELS_STATUS_V1 NV_GPU_PERF_PERF_CF_PWR_MODELS_STATUS,
    *PNV_GPU_PERF_PERF_CF_PWR_MODELS_STATUS;
#define NV_GPU_PERF_PERF_CF_PWR_MODELS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_PWR_MODELS_STATUS, 1)
#define NV_GPU_PERF_PERF_CF_PWR_MODELS_STATUS_VER NV_GPU_PERF_PERF_CF_PWR_MODELS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfPwrModelsGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                       NV_GPU_PERF_PERF_CF_PWR_MODELS_STATUS *pPerfCfPwrModelsStatus);
typedef struct {
  NvU32 workload[NV_GPU_VOLT_VOLT_RAIL_CLIENT_MAX_RAILS];
  NvU8 rsvd[256];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TGP_1X_WORKLOAD_PARAMETERS_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS super;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TGP_1X_WORKLOAD_PARAMETERS_V1 workloadParameters;
  NvU32 fbPwrmW;
  NvU32 otherPwrmW;
  NvU8 rsvd[256];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TGP_1X_OBSERVED_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS super;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_COMBINED_1X_V2 workloadCombined1x;
  NvU32 fbPwrmW;
  NvU32 otherPwrmW;
  NvU32 tgpPwrmW;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TGP_1X_V1;
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_METRICS_INPUT_MAX 16U
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E32 domainsMask;
  NvU32 freqkHz[NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_METRICS_INPUT_MAX];
  NvU8 rsvd[256];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_METRICS_INPUT_V1;
typedef union {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_RPPM_1X_DATA_V1 rppm1x;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_SINGLE_1X_V1 single1x;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_OBSERVED_METRICS_WORKLOAD_COMBINED_1X_V1 combined1x;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_OBSERVED_V2 dlppm1x;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TGP_1X_OBSERVED_V1 tgp1x;
  NvU8 rsvd[32768];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_OBSERVED_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE type;
  NvU8 rsvd[128];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_OBSERVED_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_OBSERVED_V1;
typedef union {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_RPPM_1X_DATA_V1 rppm1x;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_SINGLE_1X_V1 single1x;
  NV_GPU_POWER_POLICY_PERF_CF_PWR_MODEL_ESTIMATED_METRICS_WORKLOAD_COMBINED_1X_V1 combined1x;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X dlppm1x;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TGP_1X_V1 tgp1x;
  NvU8 rsvd[32768];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_ESTIMATED_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE type;
  NvU8 rsvd[128];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_ESTIMATED_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_ESTIMATED_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X endpointLo;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X endpointHi;
  NvBool bGuardRailsApply;
  NvBool bEndpointsValid;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_BOUNDS_DLPPM_1X;
typedef union {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_BOUNDS_DLPPM_1X dlppm1x;
  NvU8 rsvd[4096];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_BOUNDS_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_TYPE type;
  NvU8 rsvd[512];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_BOUNDS_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_BOUNDS_V1;
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_ESTIMATED_METRICS_MAX 16U
typedef struct {
  NvU32 version;
  NvBoardObjIdx pwrModelIdx;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_OBSERVED_V1 observedMetrics;
  NvU8 numEstimatedMetrics;
  NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_BOUNDS_V1 bounds;
  NvU8 rsvd[128];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_METRICS_INPUT_V1
  inputs[NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_ESTIMATED_METRICS_MAX];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_ESTIMATED_V1
  estimatedMetrics[NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_ESTIMATED_METRICS_MAX];
} NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_V1;
typedef NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_V1 NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE;
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_V1, 1U)
#define NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_VER NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfPwrModelScale(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_PERF_PERF_CF_PWR_MODEL_SCALE *pPerfCfPwrModelScale);
#define NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_MAX_V1 32
typedef enum {
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_TYPE_TGP_1X = 0x0,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_TYPE;
typedef enum {
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_DMMA_PERF = 0x00,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_DMMA_HIGH_K = 0x01,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_DMMA_LOW_K = 0x02,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_HMMA = 0x03,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_IMMA = 0x04,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_SGEMM = 0x05,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_TRANSFORMER = 0x06,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID__RSVD_LOW = 0x07,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID__RSVD_HIGH = 0xF7,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_CUSTOMER_CUSTOM_7 = 0xF8,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_CUSTOMER_CUSTOM_6 = 0xF9,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_CUSTOMER_CUSTOM_5 = 0xFA,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_CUSTOMER_CUSTOM_4 = 0xFB,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_CUSTOMER_CUSTOM_3 = 0xFC,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_CUSTOMER_CUSTOM_2 = 0xFD,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_CUSTOMER_CUSTOM_1 = 0xFE,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_CUSTOMER_CUSTOM_0 = 0xFF,
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID;
typedef struct {
  NvU32 workload[NV_GPU_VOLT_VOLT_RAIL_CLIENT_MAX_RAILS];
  NvU8 rsvd[256];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_TGP_1X_WORKLOAD_PARAMETERS_V1;
typedef struct {
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_TGP_1X_WORKLOAD_PARAMETERS_V1 workloadParameters;
  NvU32 fbPwrmW;
  NvU32 otherPwrmW;
  NvU8 rsvd[500];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_INFO_TGP_1X_V1;
typedef union {
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_INFO_TGP_1X_V1 tgp1x;
  NvU8 rsvd[512];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_TYPE type;
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID profileId;
  NvU8 rsvd[128];
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_INFO_DATA_V1 data;
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 clientPwrModelProfilesMask;
  NvU8 rsvd[512];
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_INFO_V1
      clientPwrModelProfiles[NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_MAX_V1];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILES_INFO_V1;
typedef NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_INFO_V1 NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_INFO;
typedef NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILES_INFO_V1 NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILES_INFO;
#define NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILES_INFO_VER1                                                        \
  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILES_INFO, 1)
#define NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILES_INFO_VER NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILES_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfClientPerfCfPwrModelProfileGetInfo(
    NvPhysicalGpuHandle hPhysicalGpu,
    NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILES_INFO *pClientPerfCfPwrModelProfilesInfo);
#define NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_METRICS_INPUT_MAX_V1 16U
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E32 clientDomainsMask;
  NvU32 freqkHz[NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_METRICS_INPUT_MAX_V1];
  NvU8 rsvd[512];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_INPUT_V1;
typedef struct {
  NvU32 totalGpuPwrmW;
  NvU8 rsvd[512];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_OUTPUT_V1;
typedef struct {
  NvU32 version;
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_ID profileId;
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_INPUT_V1 input;
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_OUTPUT_V1 output;
  NvU8 rsvd[512];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_V1;
typedef NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_V1 NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE;
#define NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_VER1                                                        \
  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_V1, 1U)
#define NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_VER NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfClientPerfCfPwrModelProfileScale(
    NvPhysicalGpuHandle hPhysicalGpu,
    NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE *pClientPerfCfPwrModelProfileScale);
typedef enum {
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_TYPE_GPU_TEMPERATURE = 0x0,
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_TYPE;
typedef struct {
  NvS32 temperature;
  NvU8 rsvd[508];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_DATA_GPU_TEMPERATURE_V1;
typedef union {
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_DATA_GPU_TEMPERATURE_V1 gpuTemperature;
  NvU8 rsvd[512];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_DATA_V1;
typedef struct {
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_TYPE type;
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_DATA_V1 data;
  NvU8 rsvd[128];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_V1;
#define NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_MAX_SETTINGS_V1 (8U)
typedef struct {
  NvU32 version;
  NvBool bSetup;
  NvU8 numSettings;
  NvU8 rsvd[512];
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_V1
  settings[NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_MAX_SETTINGS_V1];
} NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_V1;
typedef NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_V1
    NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP;
typedef NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING_V1
    NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_SETTING;
#define NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_VER1                                                  \
  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_V1, 1U)
#define NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_VER                                                   \
  NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfClientPerfCfPwrModelProfileScaleSetup(
    NvPhysicalGpuHandle hPhysicalGpu,
    NV_GPU_PERF_CLIENT_PERF_CF_PWR_MODEL_PROFILE_SCALE_SETUP *pClientPerfCfPwrModelProfileScaleSetup);
#define NV_GPU_PERF_PERF_CF_CONTROLLER_MAX_V1 32
#define NV_GPU_PERF_PERF_CF_CONTROLLER_IDX_INVALID NV_U8_MAX
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT_MAX_LIMITS 8
typedef enum {
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE_UTIL = 0x0,
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE_RPPC_1X,
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE_OPTP_2X,
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE_DLPPC_1X,
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE_MEM_TUNE_1X,
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE_UTIL_2X,
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE,
    *PNV_GPU_PERF_PERF_CF_CONTROLLER_TYPE;
typedef struct {
  NvU8 clkDomIdx;
  NvU8 clkTopologyIdx;
  NvU8 pgTopologyIdx;
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_UTIL, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_UTIL;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_UTIL super;
  NvU8 IIRCountInc;
  NvU8 IIRCountDec;
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_UTIL_2X, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_UTIL_2X;
#define NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_TOTAL_ACTIVATES 0
#define NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_READ_ACCESS 1
#define NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_WRITE_ACCESS 2
#define NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_READ_PER_TOTAL_ACTIVATES 3
#define NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_MAX 8
#define NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_PM_SIGNAL_MAX 4
typedef struct {
  NvU8 numSignals;
  NvBoardObjIdx signalIdx[NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_PM_SIGNAL_MAX];
  NvU32 rsvd[32];
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_MEM_TUNE_TARGET, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_MEM_TUNE_TARGET;
typedef struct {
  NvU8 numTargets;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_MEM_TUNE_TARGET
  target[NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_MAX];
  NvU32 rsvd[32];
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_MEM_TUNE_TARGETS, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_MEM_TUNE_TARGETS;
typedef struct {
  NvBoardObjIdx pmSensorIdx;
  NvBoardObjIdx timerTopologyIdx;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_MEM_TUNE_TARGETS targets;
  NvU32 rsvd[32];
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_MEM_TUNE, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_MEM_TUNE;
typedef struct {
  NvU8 rppmIdx;
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_RPPC_1X, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_RPPC_1X;
typedef struct {
  NvU32 freqFloorkHz;
  NvU8 grClkTopologyIdx;
  NvU8 vidClkTopologyIdx;
  NvU8 pgTopologyIdx;
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_OPTP_2X, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_OPTP_2X;
typedef struct {
  NV_GPU_BOARDOBJ_IDX clkDomIdx;
  NV_GPU_BOARDOBJ_IDX voltRailIdx;
  NV_GPU_POWER_POWER_POLICY_RELATIONSHIP_SET pwrInRelSet;
  NV_GPU_POWER_POWER_POLICY_RELATIONSHIP_SET pwrOutRelSet;
  NV_GPU_BOARDOBJ_IDX maxLimitIdx;
} NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_RAIL;
#define NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_MAX_CORE_RAILS (2U)
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_RAIL
  rails[NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_MAX_CORE_RAILS];
  NvU8 numRails;
  NV_GPU_POWER_POWER_POLICY_RELATIONSHIP_SET pwrInRelSet;
  NvU8 rsvd[4];
} NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_CORE_RAIL;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_CORE_RAIL coreRail;
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_RAIL fbRail;
  NV_GPU_POWER_POWER_POLICY_RELATIONSHIP_SET tgpPolRelSet;
  NV_GPU_BOARDOBJ_IDX dlppmIdx;
  NvU8 vfInferenceBatchSize;
  NvBool bOptpSupported;
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_DLPPC_1X;
typedef union {
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_UTIL util;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_RPPC_1X rppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_OPTP_2X optp2x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_DLPPC_1X dlppc1x;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_DATA_V1, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_DATA_V1;
typedef union {
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_UTIL util;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_RPPC_1X rppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_OPTP_2X optp2x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_DLPPC_1X dlppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_MEM_TUNE memTune;
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_UTIL_2X util2x;
  NvU8 rsvd[10240];
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_DATA_V2, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_DATA_V2;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE type;
  NvU8 samplingMultiplier;
  NvU8 topologyIdx;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_V1, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE type;
  NvU8 samplingMultiplier;
  NvU8 topologyIdx;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_DATA_V2 data;
} NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_V2, *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 controllersMask;
  NvU16 baseSamplingPeriodms;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_V1 controllers[NV_GPU_PERF_PERF_CF_CONTROLLER_MAX_V1];
} NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_V1, *PNV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 controllersMask;
  NvU16 baseSamplingPeriodms;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_V2 controllers[NV_GPU_PERF_PERF_CF_CONTROLLER_MAX_V1];
} NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_V2, *PNV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_V2;
typedef NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_V2 NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO,
    *PNV_GPU_PERF_PERF_CF_CONTROLLERS_INFO;
typedef NV_GPU_PERF_PERF_CF_CONTROLLER_INFO_V2 NV_GPU_PERF_PERF_CF_CONTROLLER_INFO,
    *PNV_GPU_PERF_PERF_CF_CONTROLLER_INFO;
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_V1, 1)
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_V2, 2)
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_VER NV_GPU_PERF_PERF_CF_CONTROLLERS_INFO_VER2
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfControllerGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                      PNV_GPU_PERF_PERF_CF_CONTROLLERS_INFO pPerfCfControllersInfo);
#define NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X_DRAMCLK_NUM_ENTRIES 3
#define NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X_DRAMCLK_METRICS_NUM_ENTRIES 2
typedef struct {
  NvU32 pct;
  NvU32 currentkHz;
  NvU32 targetkHz;
  NvU32 avgTargetkHz;
  NvU8 hysteresisCountCurr;
  NvU8 limitIdx;
  NvBool bIncLast;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_UTIL, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_UTIL;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_UTIL super;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_UTIL_2X, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_UTIL_2X;
typedef struct {
  NvBoardObjIdx index;
  NvU64 cntDiff;
  NvU32 rsvd[32];
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_PM_SIGNAL, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_PM_SIGNAL;
typedef struct {
  NvU32 observed;
  NvU64 cntDiffTotal;
  NvU8 numSignals;
  NvU32 rsvd[32];
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_PM_SIGNAL
  signal[NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_PM_SIGNAL_MAX];
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_TARGET, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_TARGET;
typedef struct {
  NvU8 numTargets;
  NvU32 rsvd[32];
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_TARGET
  target[NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_MAX];
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_TARGETS, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_TARGETS;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_TARGETS targets;
  NvU8 hysteresisCountIncCurr;
  NvU8 hysteresisCountDecCurr;
  NvU64 mclkkHz52_12;
  NvU64 perfms52_12;
  NvU64 activateRateSol52_12;
  NvU64 accessRateSol52_12;
  NvBool bTrrdWarEngage;
  NvU32 trrdWarEngageCounter;
  NvU32 rsvd[32];
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_RPPM_1X_DATA_V1
  metrics[NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X_DRAMCLK_METRICS_NUM_ENTRIES];
  NvU32 freqkHz;
  NvU8 bestMetricsIdx;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X_DRAMCLK_DATA_V1,
    *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X_DRAMCLK_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X_DRAMCLK_DATA_V1
  dramclk[NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X_DRAMCLK_NUM_ENTRIES];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_RPPM_1X_DATA_V1 observedMetrics;
  NvU32 perfTarget;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X;
typedef struct {
  NvU32 perfTarget;
  NvU32 grkHz;
  NvU32 vidkHz;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_OPTP_2X, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_OPTP_2X;
#define NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS_MAX 4U
#define NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS_MAX_RSVD 32U
typedef struct {
  NvU32 policyLimits[NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS_MAX_RSVD];
} NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS;
#define NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS_IDX_FROM_POLICY_REL_IDX(            \
    pRelSet, policyRelIdx)                                                                                             \
  ((policyRelIdx) - (pRelSet)->policyRelStart)
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS pwrInLimits;
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS pwrOutLimits;
  NvU8 rsvd[128U];
} NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_RAIL_LIMITS;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_RAIL_LIMITS limits;
  NvU8 rsvd[128U];
} NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_RAIL_STATUS;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_RAIL_STATUS rails[NV_GPU_PERF_PERF_CF_PWR_MODEL_DLPPM_1X_MAX_CORE_RAILS];
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS pwrInLimits;
  NvU8 rsvd[256U];
} NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_CORE_RAIL_STATUS;
typedef NvU8 NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_METRICS_IDX_ENUM;
#define NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_METRICS_IDX_POWER_CEILING (0)
#define NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_METRICS_IDX_PERF_FLOOR (1)
#define NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_METRICS_NUM (2)
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X metrics;
  NvBool bSaturated;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_METRICS;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_METRICS
  dramclkMetrics[NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_METRICS_NUM];
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X primaryClkMinEstimated;
  NvU8 rsvd0[3248U];
  NvU8 compMetricsIdx;
  NvU8 rsvd1;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK;
#define NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_NUM                                                     \
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_OBSERVED_INITIAL_DRAMCLK_ESTIMATES_MAX
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_OBSERVED_V1
  observedMetrics;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK
  dramclk[NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_NUM];
  NvU32 perfTarget;
  NvU8 numDramclk;
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_CORE_RAIL_STATUS coreRailStatus;
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_RAIL_STATUS fbRailStatus;
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS tgpLimits;
  NvBool bInInflectionZone;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_PWR_MODEL_METRICS_DLPPM_1X_OBSERVED_V2
  observedMetrics;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK
  dramclk[NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_DRAMCLK_NUM];
  NvU32 perfTarget;
  NvU8 numDramclk;
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_CORE_RAIL_STATUS coreRailStatus;
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_RAIL_STATUS fbRailStatus;
  NV_GPU_PERF_PERF_CF_CONTROLLER_DLPPC_1X_PWR_POLICY_RELATIONSHIP_SET_LIMITS tgpLimits;
  NvBool bInInflectionZone;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_V2;
typedef union {
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_UTIL util;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X rppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_OPTP_2X optp2x;
  NvU8 rsvd[3992];
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DATA_V1, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DATA_V1;
typedef union {
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_UTIL util;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X rppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_OPTP_2X optp2x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_V1 dlppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE memTune;
  NvU8 rsvd[49152];
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DATA_V2;
typedef union {
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_UTIL util;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_RPPC_1X rppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_OPTP_2X optp2x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DLPPC_1X_V2 dlppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_MEM_TUNE memTune;
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_UTIL_2X util2x;
  NvU8 rsvd[49152];
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DATA_V3;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE type;
  NvU32 limitFreqkHz[NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT_MAX_LIMITS];
  NvU32 iteration;
  NvBool bReset;
  NvBool bActive;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_V1, *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE type;
  NvU32 limitFreqkHz[NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT_MAX_LIMITS];
  NvU32 iteration;
  NvBool bReset;
  NvBool bActive;
  NvBool bInflectionPointsDisable;
  NvU8 rsvd[31];
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DATA_V2 data;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_V2;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE type;
  NvU32 limitFreqkHz[NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT_MAX_LIMITS];
  NvU32 iteration;
  NvBool bReset;
  NvBool bActive;
  NV_GPU_POWER_PWR_POLICIES_INFLECTION_POINTS_DISABLE_REQUEST inflectionPointsDisableRequest;
  NvU8 rsvd[2048];
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_DATA_V3 data;
} NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_V3;
typedef struct {
  NvU32 freqkHz;
  NvU8 clkDomIdx;
  NvU8 rsvd[16];
} NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT, *PNV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT;
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_OPTP_PERF_RATIO_INACTIVE NV_U32_MAX
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 controllersMask;
  NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT limits[NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT_MAX_LIMITS];
  NV_GPU_BOARDOBJGRP_MASK_E32 maskActive;
  NvU32 limitsArbErrCount;
  NvU8 limitsArbErrLast;
  NvU32 optpPerfRatio;
  NvU8 rsvd[60];
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_V1 controllers[NV_GPU_PERF_PERF_CF_CONTROLLER_MAX_V1];
} NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_V1, *PNV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 controllersMask;
  NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT limits[NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT_MAX_LIMITS];
  NV_GPU_BOARDOBJGRP_MASK_E32 maskActive;
  NvU32 limitsArbErrCount;
  NvU8 limitsArbErrLast;
  NvU32 optpPerfRatio;
  NvBool bInflectionPointsDisable;
  NvU8 rsvd[59];
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_V2 controllers[NV_GPU_PERF_PERF_CF_CONTROLLER_MAX_V1];
} NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 controllersMask;
  NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT limits[NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_LIMIT_MAX_LIMITS];
  NV_GPU_BOARDOBJGRP_MASK_E32 maskActive;
  NvU32 limitsArbErrCount;
  NvU8 limitsArbErrLast;
  NvU32 optpPerfRatio;
  NvU8 rsvd[2048];
  NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_V3 controllers[NV_GPU_PERF_PERF_CF_CONTROLLER_MAX_V1];
} NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_V3;
typedef NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_V3 NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS,
    *PNV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS;
typedef NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS_V3 NV_GPU_PERF_PERF_CF_CONTROLLER_STATUS,
    *PNV_GPU_PERF_PERF_CF_CONTROLLER_STATUS;
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_V1, 1)
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_V2, 2)
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_VER3 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_V3, 3)
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_VER NV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS_VER3
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfControllerGetStatus(
    NvPhysicalGpuHandle hPhysicalGpu, PNV_GPU_PERF_PERF_CF_CONTROLLERS_STATUS pPerfCfControllersStatus);
typedef struct {
  NvU32 target;
  NvU32 jumpThreshold;
  NvU32 gainInc;
  NvU32 gainDec;
  NvU8 hysteresisCountInc;
  NvU8 hysteresisCountDec;
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_UTIL, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_UTIL;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_UTIL super;
  NvU8 IIRCountInc;
  NvU8 IIRCountDec;
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_UTIL_2X, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_UTIL_2X;
typedef struct {
  NvU32 high;
  NvU32 low;
  NvU32 rsvd[32];
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_MEM_TUNE_TARGET, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_MEM_TUNE_TARGET;
typedef struct {
  NvU8 numTargets;
  NvU32 rsvd[32];
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_MEM_TUNE_TARGET
  target[NV_GPU_PERF_PERF_CF_CONTROLLER_MEM_TUNE_TARGET_MAX];
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_MEM_TUNE_TARGETS, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_MEM_TUNE_TARGETS;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_MEM_TUNE_TARGETS targets;
  NvU8 hysteresisCountInc;
  NvU8 hysteresisCountDec;
  NvU32 rsvd[32];
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_MEM_TUNE, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_MEM_TUNE;
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_RPPC_1X, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_RPPC_1X;
typedef struct {
  NvU32 highThreshold;
  NvU32 lowThreshold;
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_OPTP_2X, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_OPTP_2X;
typedef struct {
  NvU8 dramHysteresisCountDec;
  NvU8 dramHysteresisCountInc;
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_DLPPC_1X;
typedef union {
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_UTIL util;
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_RPPC_1X rppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_OPTP_2X optp2x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_DLPPC_1X dlppc1x;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_DATA_V1, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_DATA_V1;
typedef union {
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_UTIL util;
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_RPPC_1X rppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_OPTP_2X optp2x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_DLPPC_1X dlppc1x;
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_MEM_TUNE memTune;
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_UTIL_2X util2x;
  NvU8 rsvd[10240];
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_DATA_V2, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_DATA_V2;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_V1, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_CONTROLLER_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_DATA_V2 data;
} NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_V2, *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 controllersMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_V1 controllers[NV_GPU_PERF_PERF_CF_CONTROLLER_MAX_V1];
} NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_V1, *PNV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 controllersMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_V2 controllers[NV_GPU_PERF_PERF_CF_CONTROLLER_MAX_V1];
} NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_V2, *PNV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_V2;
typedef NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_V2 NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL,
    *PNV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL;
typedef NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL_V2 NV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL,
    *PNV_GPU_PERF_PERF_CF_CONTROLLER_CONTROL;
;
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_V1, 1)
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_V2, 2)
#define NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_VER NV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL_VER2
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfControllerGetControl(
    NvPhysicalGpuHandle hPhysicalGpu, PNV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL pPerfCfControllersControl);
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfControllerSetControl(
    NvPhysicalGpuHandle hPhysicalGpu, PNV_GPU_PERF_PERF_CF_CONTROLLERS_CONTROL pPerfCfControllersControl);
#define NV_GPU_PERF_PERF_CF_POLICY_MAX_V1 32
#define NV_GPU_PERF_PERF_CF_POLICY_IDX_INVALID NV_U8_MAX
typedef enum {
  NV_GPU_PERF_PERF_CF_POLICY_TYPE_CTRL_MASK = 0x0,
  NV_GPU_PERF_PERF_CF_POLICY_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_POLICY_TYPE,
    *PNV_GPU_PERF_PERF_CF_POLICY_TYPE;
typedef enum {
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_UTIL_DEFAULT = 0x0,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_UTIL_VIDEO_PLAYBACK,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_OPTP_2X,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_RPPC_1X,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_UTIL_SLI,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_UTIL_GSP,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_MEM_TUNE,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_DLPPC_1X,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_UTIL_2X,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_NUM,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_NUM_V1 = 0x10,
  NV_GPU_PERF_PERF_CF_POLICY_LABEL_NONE = 0xFFFFFFFF,
} NV_GPU_PERF_PERF_CF_POLICY_LABEL,
    *PNV_GPU_PERF_PERF_CF_POLICY_LABEL;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E32 maskControllers;
} NV_GPU_PERF_PERF_CF_POLICY_INFO_CTRL_MASK, *PNV_GPU_PERF_PERF_CF_POLICY_INFO_CTRL_MASK;
typedef union {
  NV_GPU_PERF_PERF_CF_POLICY_INFO_CTRL_MASK ctrlMask;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_POLICY_INFO_DATA_V1, *PNV_GPU_PERF_PERF_CF_POLICY_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_POLICY_TYPE type;
  NvU8 priority;
  NV_GPU_PERF_PERF_CF_POLICY_LABEL label;
  NV_GPU_BOARDOBJGRP_MASK_E32 conflictMask;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_POLICY_INFO_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_POLICY_INFO_V1, *PNV_GPU_PERF_PERF_CF_POLICY_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 policysMask;
  NvU8 halVal;
  NvBoardObjIdx labelToIdxMap[NV_GPU_PERF_PERF_CF_POLICY_LABEL_NUM_V1];
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_POLICY_INFO_V1 policys[NV_GPU_PERF_PERF_CF_POLICY_MAX_V1];
} NV_GPU_PERF_PERF_CF_POLICYS_INFO_V1, *PNV_GPU_PERF_PERF_CF_POLICYS_INFO_V1;
typedef NV_GPU_PERF_PERF_CF_POLICYS_INFO_V1 NV_GPU_PERF_PERF_CF_POLICYS_INFO, *PNV_GPU_PERF_PERF_CF_POLICYS_INFO;
typedef NV_GPU_PERF_PERF_CF_POLICY_INFO_V1 NV_GPU_PERF_PERF_CF_POLICY_INFO, *PNV_GPU_PERF_PERF_CF_POLICY_INFO;
#define NV_GPU_PERF_PERF_CF_POLICYS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_POLICYS_INFO, 1)
#define NV_GPU_PERF_PERF_CF_POLICYS_INFO_VER NV_GPU_PERF_PERF_CF_POLICYS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfPolicyGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                  PNV_GPU_PERF_PERF_CF_POLICYS_INFO pPerfCfPolicysInfo);
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_POLICY_STATUS_CTRL_MASK, *PNV_GPU_PERF_PERF_CF_POLICY_STATUS_CTRL_MASK;
typedef union {
  NV_GPU_PERF_PERF_CF_POLICY_STATUS_CTRL_MASK ctrlMask;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_POLICY_STATUS_DATA_V1, *PNV_GPU_PERF_PERF_CF_POLICY_STATUS_DATA_V1;
typedef NV_GPU_BOARDOBJGRP_MASK_E32 NV_GPU_PERF_PERF_CF_POLICY_DEACTIVATE_REQUEST_ID_MASK;
#define NV_GPU_PERF_PERF_CF_POLICY_DEACTIVATE_REQUEST_ID_MASK_SET(pDeactivate, requestId)                              \
  NV_GPU_BOARDOBJGRP_MASK_BIT_SET(&(pDeactivate)->super, (requestId))
typedef NvBoardObjIdx NV_GPU_PERF_PERF_CF_POLICY_DEACTIVATE_REQUEST_ID;
#define NV_GPU_PERF_PERF_CF_POLICY_DEACTIVATE_REQUEST_ID_RM_CUDA_CONFLICT 0U
#define NV_GPU_PERF_PERF_CF_POLICY_DEACTIVATE_REQUEST_ID_RM_4K_VIDEO_CONFLICT 1U
#define NV_GPU_PERF_PERF_CF_POLICY_DEACTIVATE_REQUEST_ID_RM_BATTERY_CONFLICT 2U
#define NV_GPU_PERF_PERF_CF_POLICY_DEACTIVATE_REQUEST_ID_PMU_OPTP_CONFLICT 3U
#define NV_GPU_PERF_PERF_CF_POLICY_DEACTIVATE_REQUEST_ID__NUM 4U
typedef struct {
  NV_GPU_PERF_PERF_CF_POLICY_TYPE type;
  NvBool bActiveCurr;
  NvU8 rsvd0[3];
  NV_GPU_PERF_PERF_CF_POLICY_DEACTIVATE_REQUEST_ID_MASK deactivateMask;
  NvU8 rsvd1[25];
  NV_GPU_PERF_PERF_CF_POLICY_STATUS_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_POLICY_STATUS_V1, *PNV_GPU_PERF_PERF_CF_POLICY_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 policysMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 activeMaskRequested;
  NV_GPU_BOARDOBJGRP_MASK_E32 activeMaskArbitrated;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_POLICY_STATUS_V1 policys[NV_GPU_PERF_PERF_CF_POLICY_MAX_V1];
} NV_GPU_PERF_PERF_CF_POLICYS_STATUS_V1, *PNV_GPU_PERF_PERF_CF_POLICYS_STATUS_V1;
typedef NV_GPU_PERF_PERF_CF_POLICYS_STATUS_V1 NV_GPU_PERF_PERF_CF_POLICYS_STATUS, *PNV_GPU_PERF_PERF_CF_POLICYS_STATUS;
typedef NV_GPU_PERF_PERF_CF_POLICY_STATUS_V1 NV_GPU_PERF_PERF_CF_POLICY_STATUS, *PNV_GPU_PERF_PERF_CF_POLICY_STATUS;
#define NV_GPU_PERF_PERF_CF_POLICYS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_POLICYS_STATUS, 1)
#define NV_GPU_PERF_PERF_CF_POLICYS_STATUS_VER NV_GPU_PERF_PERF_CF_POLICYS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfPolicyGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                    PNV_GPU_PERF_PERF_CF_POLICYS_STATUS pPerfCfPolicysStatus);
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_PERF_CF_POLICY_CONTROL_CTRL_MASK, *PNV_GPU_PERF_PERF_CF_POLICY_CONTROL_CTRL_MASK;
typedef union {
  NV_GPU_PERF_PERF_CF_POLICY_CONTROL_CTRL_MASK ctrlMask;
  NvU8 rsvd[128];
} NV_GPU_PERF_PERF_CF_POLICY_CONTROL_DATA_V1, *PNV_GPU_PERF_PERF_CF_POLICY_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_PERF_PERF_CF_POLICY_TYPE type;
  NvBool bActivate;
  NvU8 rsvd[32];
  NV_GPU_PERF_PERF_CF_POLICY_CONTROL_DATA_V1 data;
} NV_GPU_PERF_PERF_CF_POLICY_CONTROL_V1, *PNV_GPU_PERF_PERF_CF_POLICY_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 policysMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PERF_CF_POLICY_CONTROL_V1 policys[NV_GPU_PERF_PERF_CF_POLICY_MAX_V1];
} NV_GPU_PERF_PERF_CF_POLICYS_CONTROL_V1, *PNV_GPU_PERF_PERF_CF_POLICYS_CONTROL_V1;
typedef NV_GPU_PERF_PERF_CF_POLICYS_CONTROL_V1 NV_GPU_PERF_PERF_CF_POLICYS_CONTROL,
    *PNV_GPU_PERF_PERF_CF_POLICYS_CONTROL;
typedef NV_GPU_PERF_PERF_CF_POLICY_CONTROL_V1 NV_GPU_PERF_PERF_CF_POLICY_CONTROL, *PNV_GPU_PERF_PERF_CF_POLICY_CONTROL;
;
#define NV_GPU_PERF_PERF_CF_POLICYS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PERF_CF_POLICYS_CONTROL, 1)
#define NV_GPU_PERF_PERF_CF_POLICYS_CONTROL_VER NV_GPU_PERF_PERF_CF_POLICYS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfPolicyGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                     PNV_GPU_PERF_PERF_CF_POLICYS_CONTROL pPerfCfPolicysControl);
NVAPI_INTERFACE NvAPI_GPU_PerfPerfCfPolicySetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                     PNV_GPU_PERF_PERF_CF_POLICYS_CONTROL pPerfCfPolicysControl);
#define NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_MAX_V1 32
#define NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_IDX_INVALID NV_U8_MAX
typedef enum {
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_TYPE_MEM_TUNE_1X = 0x0,
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_TYPE,
    *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_TYPE;
typedef struct {
  NvU32 rsvd;
} NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_MEM_TUNE_1X, *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_MEM_TUNE_1X;
typedef union {
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_MEM_TUNE_1X memTune1x;
  NvU8 rsvd[512];
} NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_DATA_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_DATA_V1 data;
} NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 controllersMask;
  NvU8 rsvd[128];
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_V1 controllers[NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_MAX_V1];
} NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO_V1;
typedef NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO_V1 NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO,
    *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO;
typedef NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO_V1 NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO,
    *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_INFO;
#define NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO_VER1                                                               \
  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO_V1, 1)
#define NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO_VER NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfClientPerfCfControllerGetInfo(
    NvPhysicalGpuHandle hPhysicalGpu, PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_INFO pClientPerfCfControllersInfo);
typedef struct {
  NvBool bEngaged;
  NvU32 engageCounter;
} NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_1X, *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_1X;
typedef union {
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_MEM_TUNE_1X memTune1x;
  NvU8 rsvd[512];
} NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_DATA_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_DATA_V1;
typedef struct {
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_TYPE type;
  NvU8 rsvd[128];
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_DATA_V1 data;
} NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 controllersMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 maskActive;
  NvU8 rsvd[128];
  NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_V1 controllers[NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_MAX_V1];
} NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS_V1;
typedef NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS_V1 NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS,
    *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS;
typedef NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS_V1 NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS,
    *PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLER_STATUS;
#define NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS_VER1                                                             \
  MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS_V1, 1)
#define NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS_VER NV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfClientPerfCfControllerGetStatus(
    NvPhysicalGpuHandle hPhysicalGpu, PNV_GPU_PERF_CLIENT_PERF_CF_CONTROLLERS_STATUS pClientPerfCfControllersStatus);
#define NV_GPU_PERF_CLIENT_PERF_CF_POLICY_MAX_V1 32
#define NV_GPU_PERF_CLIENT_PERF_CF_POLICY_IDX_INVALID NV_U8_MAX
typedef enum {
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_TYPE_CTRL_MASK = 0x0,
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_CLIENT_PERF_CF_POLICY_TYPE,
    *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_TYPE;
typedef enum {
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_LABEL_MEM_TUNE = 0x0,
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_LABEL_NUM_V1 = 0x10,
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_LABEL_NONE = 0xFFFFFFFF,
} NV_GPU_PERF_CLIENT_PERF_CF_POLICY_LABEL,
    *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_LABEL;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E32 maskControllers;
} NV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_CTRL_MASK, *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_CTRL_MASK;
typedef union {
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_CTRL_MASK ctrlMask;
  NvU8 rsvd[512];
} NV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_DATA_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_DATA_V1;
typedef struct {
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_TYPE type;
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_LABEL label;
  NvU8 rsvd[128];
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_DATA_V1 data;
} NV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 policysMask;
  NvBoardObjIdx labelToIdxMap[NV_GPU_PERF_CLIENT_PERF_CF_POLICY_LABEL_NUM_V1];
  NvU8 rsvd[32];
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_V1 policys[NV_GPU_PERF_CLIENT_PERF_CF_POLICY_MAX_V1];
} NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO_V1;
typedef NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO_V1 NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO,
    *PNV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO;
typedef NV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO_V1 NV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO,
    *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_INFO;
#define NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO, 1)
#define NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO_VER NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfClientPerfCfPolicyGetInfo(
    NvPhysicalGpuHandle hPhysicalGpu, PNV_GPU_PERF_CLIENT_PERF_CF_POLICYS_INFO pClientPerfCfPolicysInfo);
typedef struct {
  NvU8 rsvd;
} NV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_CTRL_MASK, *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_CTRL_MASK;
typedef union {
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_CTRL_MASK ctrlMask;
  NvU8 rsvd[512];
} NV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_DATA_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_DATA_V1;
typedef struct {
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_TYPE type;
  NvU8 rsvd[128];
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_DATA_V1 data;
} NV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 policysMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 activeMask;
  NvU8 rsvd[128];
  NV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_V1 policys[NV_GPU_PERF_CLIENT_PERF_CF_POLICY_MAX_V1];
} NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS_V1, *PNV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS_V1;
typedef NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS_V1 NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS,
    *PNV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS;
typedef NV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS_V1 NV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS,
    *PNV_GPU_PERF_CLIENT_PERF_CF_POLICY_STATUS;
#define NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS, 1)
#define NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS_VER NV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfClientPerfCfPolicyGetStatus(
    NvPhysicalGpuHandle hPhysicalGpu, PNV_GPU_PERF_CLIENT_PERF_CF_POLICYS_STATUS pClientPerfCfPolicysStatus);
#define NV_GPU_PERF_PSTATE_MAX_V1 32
#define NV_GPU_PERF_PSTATE_VERSION_2X 0x20
#define NV_GPU_PERF_PSTATE_VERSION_3X 0x30
#define NV_GPU_PERF_PSTATE_VERSION_30 0x30
#define NV_GPU_PERF_PSTATE_VERSION_35 0x35
#define NV_GPU_PERF_PSTATE_VERSION_40 0x40
typedef enum {
  NV_GPU_PERF_PSTATE_TYPE_2X = 0x0,
  NV_GPU_PERF_PSTATE_TYPE_30 = 0x1,
  NV_GPU_PERF_PSTATE_TYPE_35 = 0x2,
  NV_GPU_PERF_PSTATE_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_PERF_PSTATE_TYPE;
#define NV_GPU_PERF_PSTATE_TYPE_3X NV_GPU_PERF_PSTATE_TYPE_30
typedef struct {
  NvU32 rsvd[64];
} NV_GPU_PERF_PSTATE_INFO_2X;
typedef struct {
  NvU32 freqkHz;
  NvU8 rsvd[8];
} NV_GPU_PERF_PSTATE_CLK_DOM_INFO_FIXED;
typedef struct {
  NvU32 targetFreqKHz;
  NvU32 freqRangeMinKHz;
  NvU32 freqRangeMaxKHz;
  NvU8 rsvd[8];
} NV_GPU_PERF_PSTATE_CLK_DOM_INFO_DECOUPLED;
typedef union {
  NV_GPU_PERF_PSTATE_CLK_DOM_INFO_FIXED fixed;
  NV_GPU_PERF_PSTATE_CLK_DOM_INFO_DECOUPLED master;
  NV_GPU_PERF_PSTATE_CLK_DOM_INFO_DECOUPLED slave;
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_CLK_DOM_INFO_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_CLK_DOM_INFO_DATA_V1 data;
} NV_GPU_PERF_PSTATE_CLK_DOM_INFO_V1;
typedef struct {
  NvU32 origFreqkHz;
  NvU32 porFreqkHz;
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_INFO;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_INFO min;
  NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_INFO max;
  NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_INFO nom;
} NV_GPU_PERF_PSTATE_CLOCK_ENTRY_INFO_V1;
typedef struct {
  NV_GPU_PERF_PSTATE_CLK_DOM_INFO_V1 clkEntries[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_INFO_3X_V1;
typedef NV_GPU_PERF_PSTATE_INFO_3X_V1 NV_GPU_PERF_PSTATE_INFO_3X;
typedef struct {
  NV_GPU_PERF_PSTATE_CLOCK_ENTRY_INFO_V1 clkEntries[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_INFO_3X_V2;
typedef union {
  NV_GPU_PERF_PSTATE_INFO_2X v2x;
  NV_GPU_PERF_PSTATE_INFO_3X_V1 v3x;
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_INFO_DATA_V1;
typedef union {
  NV_GPU_PERF_PSTATE_INFO_2X v2x;
  NV_GPU_PERF_PSTATE_INFO_3X_V2 v3x;
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_INFO_DATA_V3;
typedef struct {
  NV_GPU_PERF_PSTATE_TYPE type;
  NV_GPU_PERF_PSTATE_ID pstateID;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NvU8 level;
  NvU8 rsvd[31];
  NV_GPU_PERF_PSTATE_INFO_DATA_V1 data;
} NV_GPU_PERF_PSTATE_INFO_V1;
typedef struct {
  NV_GPU_PERF_PSTATE_TYPE type;
  NV_GPU_PERF_PSTATE_ID pstateID;
  NvU32 bIsEditable : 1;
  NvU32 reserved : 31;
  NvU8 level;
  NvU8 rsvd[31];
  NV_GPU_PERF_PSTATE_INFO_DATA_V3 data;
} NV_GPU_PERF_PSTATE_INFO_V3;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pstatesMask;
  NvU8 pstateVersion;
  NvU8 rsvd[63];
  NV_GPU_PERF_PSTATE_INFO_V1 pstates[NV_GPU_PERF_PSTATE_MAX_V1];
} NV_GPU_PERF_PSTATES_GRP_INFO_V1;
typedef NV_GPU_PERF_PSTATES_GRP_INFO_V1 NV_GPU_PERF_PSTATES30_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pstatesMask;
  NvU8 pstateVersion;
  NvU8 rsvd[63];
  NV_GPU_PERF_PSTATE_INFO_V3 pstates[NV_GPU_PERF_PSTATE_MAX_V1];
} NV_GPU_PERF_PSTATES_GRP_INFO_V3;
typedef NV_GPU_PERF_PSTATE_INFO_DATA_V1 NV_GPU_PERF_PSTATE_INFO_DATA_V2;
typedef NV_GPU_PERF_PSTATE_INFO_V1 NV_GPU_PERF_PSTATE_INFO_V2;
typedef NV_GPU_PERF_PSTATES_GRP_INFO_V1 NV_GPU_PERF_PSTATES_GRP_INFO_V2;
typedef NV_GPU_PERF_PSTATES_GRP_INFO_V2 NV_GPU_PERF_PSTATES30_INFO_V2;
typedef NV_GPU_PERF_PSTATE_INFO_V3 NV_GPU_PERF_PSTATE_INFO;
typedef NV_GPU_PERF_PSTATE_CLOCK_ENTRY_INFO_V1 NV_GPU_PERF_PSTATE_CLOCK_ENTRY_INFO;
typedef NV_GPU_PERF_PSTATES_GRP_INFO_V3 NV_GPU_PERF_PSTATES_GRP_INFO;
typedef NV_GPU_PERF_PSTATES_GRP_INFO NV_GPU_PERF_PSTATES30_INFO;
#define NV_GPU_PERF_PSTATES_GRP_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_INFO_V1, 1)
#define NV_GPU_PERF_PSTATES_GRP_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_INFO_V2, 2)
#define NV_GPU_PERF_PSTATES_GRP_INFO_VER3 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_INFO_V3, 1)
#define NV_GPU_PERF_PSTATES30_INFO_VER1 NV_GPU_PERF_PSTATES_GRP_INFO_VER1
#define NV_GPU_PERF_PSTATES30_INFO_VER2 NV_GPU_PERF_PSTATES_GRP_INFO_VER2
#define NV_GPU_PERF_PSTATES_GRP_INFO_VER NV_GPU_PERF_PSTATES_GRP_INFO_VER3
#define NV_GPU_PERF_PSTATES30_INFO_VER NV_GPU_PERF_PSTATES_GRP_INFO_VER
NVAPI_INTERFACE NvAPI_GPU_PerfPstatesGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                             NV_GPU_PERF_PSTATES_GRP_INFO *pPstatesInfo);
typedef struct {
  NvU32 rsvd[64];
} NV_GPU_PERF_PSTATE_STATUS_2X;
typedef NV_GPU_PERF_PSTATE_CLK_DOM_INFO_V1 NV_GPU_PERF_PSTATE_CLK_DOM_STATUS_V1;
typedef struct {
  NvU32 freqkHz;
  NvU32 freqVFMaxkHz;
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_STATUS;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE type;
  NvU32 freqMaxAtVminkHz;
  NvU8 rsvd[28];
  NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_STATUS min;
  NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_STATUS max;
  NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_STATUS nom;
} NV_GPU_PERF_PSTATE_CLOCK_ENTRY_STATUS_V1;
typedef struct {
  NV_GPU_PERF_PSTATE_CLK_DOM_STATUS_V1 clkEntries[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_STATUS_3X_V1;
typedef NV_GPU_PERF_PSTATE_STATUS_3X_V1 NV_GPU_PERF_PSTATE_STATUS_3X;
typedef struct {
  NV_GPU_PERF_PSTATE_CLOCK_ENTRY_STATUS_V1 clkEntries[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_STATUS_3X_V2;
typedef union {
  NV_GPU_PERF_PSTATE_STATUS_2X v2x;
  NV_GPU_PERF_PSTATE_STATUS_3X_V1 v3x;
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_STATUS_DATA_V1;
typedef union {
  NV_GPU_PERF_PSTATE_STATUS_2X v2x;
  NV_GPU_PERF_PSTATE_STATUS_3X_V2 v3x;
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_STATUS_DATA_V2;
typedef struct {
  NV_GPU_PERF_PSTATE_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_STATUS_DATA_V1 data;
} NV_GPU_PERF_PSTATE_STATUS_V1;
typedef struct {
  NV_GPU_PERF_PSTATE_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_STATUS_DATA_V2 data;
} NV_GPU_PERF_PSTATE_STATUS_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pstatesMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PSTATE_STATUS_V1 pstates[NV_GPU_PERF_PSTATE_MAX_V1];
} NV_GPU_PERF_PSTATES_GRP_STATUS_V1;
typedef NV_GPU_PERF_PSTATES_GRP_STATUS_V1 NV_GPU_PERF_PSTATES30_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pstatesMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PSTATE_STATUS_V2 pstates[NV_GPU_PERF_PSTATE_MAX_V1];
} NV_GPU_PERF_PSTATES_GRP_STATUS_V3;
typedef NV_GPU_PERF_PSTATES_GRP_STATUS_V1 NV_GPU_PERF_PSTATES_GRP_STATUS_V2;
typedef NV_GPU_PERF_PSTATES_GRP_STATUS_V2 NV_GPU_PERF_PSTATES30_STATUS_V2;
typedef NV_GPU_PERF_PSTATE_STATUS_V2 NV_GPU_PERF_PSTATE_STATUS;
typedef NV_GPU_PERF_PSTATE_CLOCK_ENTRY_STATUS_V1 NV_GPU_PERF_PSTATE_CLOCK_ENTRY_STATUS;
typedef NV_GPU_PERF_PSTATES_GRP_STATUS_V3 NV_GPU_PERF_PSTATES_GRP_STATUS;
typedef NV_GPU_PERF_PSTATES_GRP_STATUS NV_GPU_PERF_PSTATES30_STATUS;
#define NV_GPU_PERF_PSTATES_GRP_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_STATUS_V1, 1)
#define NV_GPU_PERF_PSTATES_GRP_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_STATUS_V2, 2)
#define NV_GPU_PERF_PSTATES_GRP_STATUS_VER3 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_STATUS_V3, 1)
#define NV_GPU_PERF_PSTATES30_STATUS_VER1 NV_GPU_PERF_PSTATES_GRP_STATUS_VER1
#define NV_GPU_PERF_PSTATES30_STATUS_VER2 NV_GPU_PERF_PSTATES_GRP_STATUS_VER2
#define NV_GPU_PERF_PSTATES_GRP_STATUS_VER NV_GPU_PERF_PSTATES_GRP_STATUS_VER3
#define NV_GPU_PERF_PSTATES30_STATUS_VER NV_GPU_PERF_PSTATES_GRP_STATUS_VER
NVAPI_INTERFACE NvAPI_GPU_PerfPstatesGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_PERF_PSTATES_GRP_STATUS *pPstatesStatus);
typedef struct {
  NvU32 rsvd[64];
} NV_GPU_PERF_PSTATE_CONTROL_2X;
typedef NV_GPU_PERF_PSTATE_CLK_DOM_INFO_V1 NV_GPU_PERF_PSTATE_CLK_DOM_CONTROL_V1;
typedef struct {
  NvU32 baseFreqkHz;
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_CONTROL;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_CONTROL min;
  NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_CONTROL max;
  NV_GPU_PERF_PSTATE_CLOCK_FREQUENCY_CONTROL nom;
} NV_GPU_PERF_PSTATE_CLOCK_ENTRY_CONTROL_V1;
typedef struct {
  NV_GPU_PERF_PSTATE_CLK_DOM_CONTROL_V1 clkEntries[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_CONTROL_3X_V1;
typedef NV_GPU_PERF_PSTATE_CONTROL_3X_V1 NV_GPU_PERF_PSTATE_CONTROL_3X;
typedef struct {
  NV_GPU_PERF_PSTATE_CLK_DOM_CONTROL_V1 clkEntries[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NV_GPU_PSTATE_VOLTAGE_ENTRY_V1
  voltageInfo[NV_GPU_CLK_CLK_DELTA_MAX_VOLT_RAILS];
  NvU8 rsvd[64];
} NV_GPU_PERF_PSTATE_CONTROL_3X_V2;
typedef struct {
  NV_GPU_PERF_PSTATE_CLK_DOM_CONTROL_V1 clkEntries[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NV_GPU_PSTATE_VOLTAGE_ENTRY_V2
  voltageInfo[NV_GPU_CLK_CLK_DELTA_MAX_VOLT_RAILS];
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_CONTROL_3X_V3;
typedef struct {
  NV_GPU_PERF_PSTATE_CLOCK_ENTRY_CONTROL_V1 clkEntries[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
  NV_GPU_PSTATE_VOLTAGE_ENTRY_V2
  voltageInfo[NV_GPU_CLK_CLK_DELTA_MAX_VOLT_RAILS];
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_CONTROL_3X_V4;
typedef union {
  NV_GPU_PERF_PSTATE_CONTROL_2X v2x;
  NV_GPU_PERF_PSTATE_CONTROL_3X_V1 v3x;
  NvU8 rsvd[32];
} NV_GPU_PERF_PSTATE_CONTROL_DATA_V1;
typedef union {
  NV_GPU_PERF_PSTATE_CONTROL_2X v2x;
  NV_GPU_PERF_PSTATE_CONTROL_3X_V2 v3x;
  NvU8 rsvd[64];
} NV_GPU_PERF_PSTATE_CONTROL_DATA_V2;
typedef union {
  NV_GPU_PERF_PSTATE_CONTROL_2X v2x;
  NV_GPU_PERF_PSTATE_CONTROL_3X_V3 v3x;
  NvU8 rsvd[2800];
} NV_GPU_PERF_PSTATE_CONTROL_DATA_V3;
typedef union {
  NV_GPU_PERF_PSTATE_CONTROL_2X v2x;
  NV_GPU_PERF_PSTATE_CONTROL_3X_V4 v3x;
  NvU8 rsvd[2800];
} NV_GPU_PERF_PSTATE_CONTROL_DATA_V4;
typedef struct {
  NV_GPU_PERF_PSTATE_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_CONTROL_DATA_V1 data;
} NV_GPU_PERF_PSTATE_CONTROL_V1;
typedef struct {
  NV_GPU_PERF_PSTATE_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_CONTROL_DATA_V2 data;
} NV_GPU_PERF_PSTATE_CONTROL_V2;
typedef struct {
  NV_GPU_PERF_PSTATE_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_CONTROL_DATA_V3 data;
} NV_GPU_PERF_PSTATE_CONTROL_V3;
typedef struct {
  NV_GPU_PERF_PSTATE_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_CONTROL_DATA_V4 data;
} NV_GPU_PERF_PSTATE_CONTROL_V4;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pstatesMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PSTATE_CONTROL_V1 pstates[NV_GPU_PERF_PSTATE_MAX_V1];
} NV_GPU_PERF_PSTATES_GRP_CONTROL_V1;
typedef NV_GPU_PERF_PSTATES_GRP_CONTROL_V1 NV_GPU_PERF_PSTATES30_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pstatesMask;
  NvU8 rsvd[64];
  NV_GPU_PERF_PSTATE_CONTROL_V2 pstates[NV_GPU_PERF_PSTATE_MAX_V1];
} NV_GPU_PERF_PSTATES_GRP_CONTROL_V2;
typedef NV_GPU_PERF_PSTATES_GRP_CONTROL_V2 NV_GPU_PERF_PSTATES30_CONTROL_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pstatesMask;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_CONTROL_V3 pstates[NV_GPU_PERF_PSTATE_MAX_V1];
} NV_GPU_PERF_PSTATES_GRP_CONTROL_V3;
typedef NV_GPU_PERF_PSTATES_GRP_CONTROL_V3 NV_GPU_PERF_PSTATES30_CONTROL_V3;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pstatesMask;
  NvU8 rsvd[32];
  NV_GPU_PERF_PSTATE_CONTROL_V4 pstates[NV_GPU_PERF_PSTATE_MAX_V1];
} NV_GPU_PERF_PSTATES_GRP_CONTROL_V5;
typedef NV_GPU_PERF_PSTATES_GRP_CONTROL_V3 NV_GPU_PERF_PSTATES_GRP_CONTROL_V4;
typedef NV_GPU_PERF_PSTATES_GRP_CONTROL_V4 NV_GPU_PERF_PSTATES30_CONTROL_V4;
typedef NV_GPU_PERF_PSTATE_CONTROL_V4 NV_GPU_PERF_PSTATE_CONTROL;
typedef NV_GPU_PERF_PSTATE_CLOCK_ENTRY_CONTROL_V1 NV_GPU_PERF_PSTATE_CLOCK_ENTRY_CONTROL;
typedef NV_GPU_PERF_PSTATES_GRP_CONTROL_V5 NV_GPU_PERF_PSTATES_GRP_CONTROL;
typedef NV_GPU_PERF_PSTATES_GRP_CONTROL NV_GPU_PERF_PSTATES30_CONTROL;
#define NV_GPU_PERF_PSTATES_GRP_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_CONTROL_V1, 1)
#define NV_GPU_PERF_PSTATES_GRP_CONTROL_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_CONTROL_V2, 1)
#define NV_GPU_PERF_PSTATES_GRP_CONTROL_VER3 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_CONTROL_V3, 1)
#define NV_GPU_PERF_PSTATES_GRP_CONTROL_VER4 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_CONTROL_V4, 2)
#define NV_GPU_PERF_PSTATES_GRP_CONTROL_VER5 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_GRP_CONTROL_V5, 1)
#define NV_GPU_PERF_PSTATES30_CONTROL_VER1 NV_GPU_PERF_PSTATES_GRP_CONTROL_VER1
#define NV_GPU_PERF_PSTATES30_CONTROL_VER2 NV_GPU_PERF_PSTATES_GRP_CONTROL_VER2
#define NV_GPU_PERF_PSTATES30_CONTROL_VER3 NV_GPU_PERF_PSTATES_GRP_CONTROL_VER3
#define NV_GPU_PERF_PSTATES30_CONTROL_VER4 NV_GPU_PERF_PSTATES_GRP_CONTROL_VER4
#define NV_GPU_PERF_PSTATES_GRP_CONTROL_VER NV_GPU_PERF_PSTATES_GRP_CONTROL_VER5
#define NV_GPU_PERF_PSTATES30_CONTROL_VER NV_GPU_PERF_PSTATES_GRP_CONTROL_VER
NVAPI_INTERFACE NvAPI_GPU_PerfPstatesGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_PERF_PSTATES_GRP_CONTROL *pPstatesControl);
NVAPI_INTERFACE NvAPI_GPU_PerfPstatesSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_PERF_PSTATES_GRP_CONTROL *pPstatesControl);
#define NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_SAMPLE_INVALID (NV_U32_MAX)
typedef struct _NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_SAMPLE_V1 {
  NV_GPU_PMUMON_SAMPLE_SUPER_V1 super;
  NvU32 grUtil;
  NvU32 fbUtil;
  NvU32 vidUtil;
  NvU32 nvencUtil;
  NvU32 nvdecUtil;
  NvU8 rsvd[64];
} NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_SAMPLE_V1;
#define NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_SAMPLE_COUNT_V1 (50U)
typedef struct _NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_GET_SAMPLES_V1 {
  NvU32 version;
  NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 super;
  NvU8 rsvd[64];
  NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_SAMPLE_V1 samples[NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_SAMPLE_COUNT_V1];
} NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_GET_SAMPLES_V1;
typedef NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_GET_SAMPLES_V1 NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_GET_SAMPLES;
#define NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_GET_SAMPLES_VER1                                                         \
  MAKE_NVAPI_VERSION(NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_GET_SAMPLES_V1, 1)
#define NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_GET_SAMPLES_VER NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_GET_SAMPLES_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPmumonPerfCfTopologiesGetSamples(
    __in NvPhysicalGpuHandle hPhysicalGpu,
    __inout NV_GPU_PERF_PMUMON_PERF_CF_TOPOLOGIES_GET_SAMPLES *pGetSamplesParams);
#define NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_INVALID (NV_U32_MAX)
typedef struct _NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_V1 {
  NV_GPU_PMUMON_SAMPLE_SUPER_V1 super;
  NV_GPU_PERF_PERF_CF_PM_SENSOR_SIGNAL_STATUS signals[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS_V1];
  NvU8 rsvd[64];
} NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_V1;
typedef struct _NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_V2 {
  NV_GPU_PMUMON_SAMPLE_SUPER_V1 super;
  NV_GPU_PERF_PERF_CF_PM_SENSOR_SIGNAL_STATUS signals[NV_GPU_PERF_PERF_CF_PM_SENSOR_MAX_SIGNALS_V2];
  NvU8 rsvd[64];
} NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_V2;
#define NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_COUNT_V1 (100U)
typedef struct _NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_V1 {
  NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 super;
  NvU8 rsvd[64];
  NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_V1 samples[NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_COUNT_V1];
} NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_V1;
typedef struct _NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_V2 {
  NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 super;
  NvU8 rsvd[64];
  NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_V2 samples[NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_COUNT_V1];
} NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_V2;
#define NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_BOARDOBJ_SUPPORTED_COUNT_V1 (32U)
typedef struct _NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pmSensorsQueryMask;
  NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_V1
      samplesArray[NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_BOARDOBJ_SUPPORTED_COUNT_V1];
} NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_V1;
typedef struct _NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_V2 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 pmSensorsQueryMask;
  NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_V2
      samplesArray[NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_BOARDOBJ_SUPPORTED_COUNT_V1];
} NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_V2;
typedef NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_V2
    NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY;
typedef NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_V2
    NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS;
typedef NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE_V2 NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_SAMPLE;
#define NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_VER1                                            \
  MAKE_NVAPI_VERSION(NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_V1, 1)
#define NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_VER2                                            \
  MAKE_NVAPI_VERSION(NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_V2, 2)
#define NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_VER                                             \
  NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY_VER2
NVAPI_INTERFACE NvAPI_GPU_PerfPmumonPerfCfPmSensorsGetSamples(
    __in NvPhysicalGpuHandle hPhysicalGpu,
    __inout NV_GPU_PERF_PMUMON_PERF_CF_PM_SENSORS_GET_SAMPLES_PARAMS_ARRAY *pGetSamplesParams);
typedef struct _NV_GPU_PERF_PMUMON_PERF_POLICIES_SAMPLE_V1 {
  NV_GPU_PMUMON_SAMPLE_SUPER_V1 super;
  NV_GPU_PERF_POLICIES_STATUS_PARAMS_V1 data;
  NvU8 rsvd[64];
} NV_GPU_PERF_PMUMON_PERF_POLICIES_SAMPLE_V1;
#define NV_GPU_PERF_PMUMON_PERF_POLICIES_SAMPLE_COUNT_V1 (50U)
typedef struct _NV_GPU_PERF_PMUMON_PERF_POLICIES_GET_SAMPLES_V1 {
  NvU32 version;
  NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 super;
  NvU8 rsvd[64];
  NV_GPU_PERF_PMUMON_PERF_POLICIES_SAMPLE_V1 samples[NV_GPU_PERF_PMUMON_PERF_POLICIES_SAMPLE_COUNT_V1];
} NV_GPU_PERF_PMUMON_PERF_POLICIES_GET_SAMPLES_V1;
typedef NV_GPU_PERF_PMUMON_PERF_POLICIES_GET_SAMPLES_V1 NV_GPU_PERF_PMUMON_PERF_POLICIES_GET_SAMPLES;
#define NV_GPU_PERF_PMUMON_PERF_POLICIES_GET_SAMPLES_VER1                                                              \
  MAKE_NVAPI_VERSION(NV_GPU_PERF_PMUMON_PERF_POLICIES_GET_SAMPLES_V1, 1)
#define NV_GPU_PERF_PMUMON_PERF_POLICIES_GET_SAMPLES_VER NV_GPU_PERF_PMUMON_PERF_POLICIES_GET_SAMPLES_VER1
NVAPI_INTERFACE NvAPI_GPU_PerfPmumonPerfPoliciesGetSamples(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_PERF_PMUMON_PERF_POLICIES_GET_SAMPLES *pGetSamplesParams);
NVAPI_INTERFACE NvAPI_GPU_GetCoreVoltage(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *voltage);
NVAPI_INTERFACE NvAPI_GPU_SetCoreVoltageControl(NvPhysicalGpuHandle hPhysicalGpu, NvU32 enable);
NVAPI_INTERFACE NvAPI_GPU_GetCoreVoltageControl(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *enabled);
typedef struct _NV_GPU_VOLTAGE_DOMAIN_INFO_V1 {
  NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;
  NvU32 stepSizeuV;
} NV_GPU_VOLTAGE_DOMAIN_INFO_V1;
typedef struct _NV_GPU_VOLTAGE_DOMAINS_INFO_V1 {
  NvU32 version;
  NvU32 flags;
  NvU32 numDomains;
  NV_GPU_VOLTAGE_DOMAIN_INFO_V1 domains[NVAPI_MAX_GPU_PERF_VOLTAGES];
} NV_GPU_VOLTAGE_DOMAINS_INFO_V1;
typedef NV_GPU_VOLTAGE_DOMAINS_INFO_V1 NV_GPU_VOLTAGE_DOMAINS_INFO;
#define NV_GPU_VOLTAGE_DOMAINS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLTAGE_DOMAINS_INFO_V1, 1)
#define NV_GPU_VOLTAGE_DOMAINS_INFO_VER NV_GPU_VOLTAGE_DOMAINS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_GetVoltageDomainsInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_GPU_VOLTAGE_DOMAINS_INFO *pVoltageDomainsInfo);
typedef struct {
  NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;
  NvU32 voltageuV;
} NV_GPU_VOLTAGE_DOMAIN_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numDomains;
  NV_GPU_VOLTAGE_DOMAIN_STATUS_V1 domains[NVAPI_MAX_GPU_PERF_VOLTAGES];
} NV_GPU_VOLTAGE_DOMAINS_STATUS_V1;
typedef NV_GPU_VOLTAGE_DOMAINS_STATUS_V1 NV_GPU_VOLTAGE_DOMAINS_STATUS;
#define NV_GPU_VOLTAGE_DOMAINS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLTAGE_DOMAINS_STATUS_V1, 1)
#define NV_GPU_VOLTAGE_DOMAINS_STATUS_VER NV_GPU_VOLTAGE_DOMAINS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_GetVoltageDomainsStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_VOLTAGE_DOMAINS_STATUS *pVoltageDomainsStatus);
#define NVAPI_MAX_GPU_PERF_DOMAIN_VOLTAGES 128
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numDomains;
  struct {
    NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;
    NvU32 flags;
    NvU32 numVoltages;
    struct {
      NvU32 flags;
      NvU32 mvolt;
    } voltages[NVAPI_MAX_GPU_PERF_DOMAIN_VOLTAGES];
  } domains[NVAPI_MAX_GPU_PERF_VOLTAGES];
} NV_GPU_PERF_VOLTAGES;
#define NV_GPU_PERF_VOLTAGES_VER MAKE_NVAPI_VERSION(NV_GPU_PERF_VOLTAGES, 1)
NVAPI_INTERFACE NvAPI_GPU_GetVoltages(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_VOLTAGES *pPerfVoltages);
#define NV_GPU_VOLTAGES_FLAGS_INTERNAL 0x00000001
NVAPI_INTERFACE NvAPI_GPU_GetVoltagesInternal(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_VOLTAGES *pPerfVoltages,
                                              NvU32 flags);
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_PSTATE 0x00
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_GPC2CLK 0x01
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_PEX 0x02
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR0 0x03
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR1 0x04
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR2 0x05
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR3 0x06
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DISPCLK 0x07
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_PIXELCLK 0x08
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DEBUG 0x09
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_EXISTING 0xFF
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V1 (NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DP_HBR2_WAR_SOR3 + 1)
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V2 (NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_DEBUG + 1)
#define NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V2
typedef struct _NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1 {
  NvU32 version;
  NvS32 globalVoltageOffsetuV;
  NvS32 clientVoltageOffsetsuV[NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V1];
} NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1;
typedef struct _NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V2 {
  NvU32 version;
  NvS32 globalVoltageOffsetuV;
  NvS32 clientVoltageOffsetsuV[NVAPI_PMGR_VOLTAGE_REQUEST_CLIENT_NUM_CLIENTS_V2];
} NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V2;
#define NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER1 MAKE_NVAPI_VERSION(NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V1, 1)
#define NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER2 MAKE_NVAPI_VERSION(NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V2, 2)
#define NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_VER2
typedef NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA_V2 NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA;
NVAPI_INTERFACE NvAPI_GPU_GetPMGRVoltageRequestArbiterValues(
    __in NvPhysicalGpuHandle hPhysicalGpu,
    __inout NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA *pVoltageRequestArbiterData);
NVAPI_INTERFACE NvAPI_GPU_SetPMGRVoltageRequestArbiterValues(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_PMGR_VOLTAGE_REQUEST_ARBITER_DATA *pVoltageRequestArbiterData);
typedef struct {
  NV_GPU_VOLT_VOLT_DOMAIN_TYPE type;
  NvU8 voltDevIdxDefault;
  NvU32 bootVoltageuV;
  NvU8 relLimitVfeEquIdx;
  NvU8 altRelLimitVfeEquIdx;
  NvU8 ovLimitVfeEquIdx;
  NvU32 voltDevMask;
  NvU8 bootVoltVfeEquIdx;
  NvU8 vminLimitVfeEquIdx;
  NvU8 voltMarginLimitVfeEquIdx;
  NvU8 voltScaleExpPwrEquIdx;
  NvU8 voltDevIdxIPCVmin;
  NvU8 adcDevIdx;
  NvU32 adcDevMask;
  NvU8 bootVoltVfieldId;
  NvU32 vbiosBootVoltageuV;
  NvU32 clkDomainsProgMask;
  NvU8 rsvd[40];
} NV_GPU_VOLT_VOLT_RAIL_INFO_V1, *PNV_GPU_VOLT_VOLT_RAIL_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 voltRailMask;
  NvU8 voltDomainHAL;
  NvU8 rsvd[64];
  NV_GPU_VOLT_VOLT_RAIL_INFO_V1 rails[NV_GPU_VOLT_VOLT_RAILS_MAX_V1];
} NV_GPU_VOLT_VOLT_RAILS_INFO_V1;
typedef NV_GPU_VOLT_VOLT_RAILS_INFO_V1 NV_GPU_VOLT_VOLT_RAILS_INFO;
#define NV_GPU_VOLT_VOLT_RAILS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLT_VOLT_RAILS_INFO_V1, 1)
#define NV_GPU_VOLT_VOLT_RAILS_INFO_VER NV_GPU_VOLT_VOLT_RAILS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_VoltVoltRailsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_GPU_VOLT_VOLT_RAILS_INFO *pVoltRailsInfo);
#define NV_GPU_VOLT_VOLT_RAIL_VOLT_DELTA_REL_IDX 0x00
#define NV_GPU_VOLT_VOLT_RAIL_VOLT_DELTA_ALT_REL_IDX 0x01
#define NV_GPU_VOLT_VOLT_RAIL_VOLT_DELTA_OV_IDX 0x02
#define NV_GPU_VOLT_VOLT_RAIL_VOLT_DELTA_VMIN_IDX 0x03
#define NV_GPU_VOLT_VOLT_RAIL_VOLT_DELTA_MAX_ENTRIES 0x04
#define NV_GPU_VOLT_VOLT_RAIL_ACTION_VF_SWITCH 0x00U
#define NV_GPU_VOLT_VOLT_RAIL_ACTION_GATE 0x01U
#define NV_GPU_VOLT_VOLT_RAIL_ACTION_UNGATE 0x02U
#define NV_GPU_VOLT_VOLT_RAIL_ACTION_INVALID 0xFFU
typedef struct {
  NV_GPU_VOLT_VOLT_DOMAIN_TYPE type;
  NvU32 currVoltDefaultuV;
  NvU32 relLimituV;
  NvU32 altRelLimituV;
  NvU32 ovLimituV;
  NvU32 maxLimituV;
  NvU32 vminLimituV;
  NvS32 voltMarginLimituV;
  NvU32 voltMinNoiseUnawareuV;
  NvU32 currVoltSenseduV;
  NvU8 railAction;
  NvU8 rsvd[43];
} NV_GPU_VOLT_VOLT_RAIL_STATUS_V1, *PNV_GPU_VOLT_VOLT_RAIL_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 voltRailMask;
  NvU32 extRelDeltauV[NV_GPU_VOLT_VOLT_RAIL_VOLT_DELTA_MAX_ENTRIES];
  NvU8 rsvd[48];
  NV_GPU_VOLT_VOLT_RAIL_STATUS_V1 rails[NV_GPU_VOLT_VOLT_RAILS_MAX_V1];
} NV_GPU_VOLT_VOLT_RAILS_STATUS_V1;
typedef NV_GPU_VOLT_VOLT_RAILS_STATUS_V1 NV_GPU_VOLT_VOLT_RAILS_STATUS;
#define NV_GPU_VOLT_VOLT_RAILS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLT_VOLT_RAILS_STATUS_V1, 1)
#define NV_GPU_VOLT_VOLT_RAILS_STATUS_VER NV_GPU_VOLT_VOLT_RAILS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_VoltVoltRailsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_VOLT_VOLT_RAILS_STATUS *pVoltRailsStatus);
typedef struct {
  NV_GPU_VOLT_VOLT_DOMAIN_TYPE type;
  NvS32 voltDeltauV[NV_GPU_VOLT_VOLT_RAIL_VOLT_DELTA_MAX_ENTRIES];
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_RAIL_CONTROL_V1;
typedef struct {
  NvU32 version;
  NvU32 voltRailMask;
  NvU8 pctDelta;
  NvU8 rsvd[63];
  NV_GPU_VOLT_VOLT_RAIL_CONTROL_V1 rails[NV_GPU_VOLT_VOLT_RAILS_MAX_V1];
} NV_GPU_VOLT_VOLT_RAILS_CONTROL_V1;
typedef NV_GPU_VOLT_VOLT_RAILS_CONTROL_V1 NV_GPU_VOLT_VOLT_RAILS_CONTROL;
#define NV_GPU_VOLT_VOLT_RAILS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLT_VOLT_RAILS_CONTROL_V1, 1)
#define NV_GPU_VOLT_VOLT_RAILS_CONTROL_VER NV_GPU_VOLT_VOLT_RAILS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_VoltVoltRailsGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_VOLT_VOLT_RAILS_CONTROL *pVoltRailsControl);
NVAPI_INTERFACE NvAPI_GPU_VoltVoltRailsSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __in NV_GPU_VOLT_VOLT_RAILS_CONTROL *pVoltRailsControl);
#define NV_GPU_VOLT_DEVICES_MAX_V1 (32)
#define NV_GPU_VOLT_DEV_VID_VSEL_MAX_ENTRIES (8)
typedef enum {
  NV_GPU_VOLT_VOLT_DEVICE_TYPE_PWM = 0x0,
  NV_GPU_VOLT_VOLT_DEVICE_TYPE_VID,
  NV_GPU_VOLT_VOLT_DEVICE_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_VOLT_VOLT_DEVICE_TYPE;
typedef struct {
  NvS32 voltageBaseuV;
  NvS32 voltageOffsetScaleuV;
  NvU8 source;
  NvU32 rawPeriod;
  NvU8 voltEnGpioPin;
  NvU8 rsvd[63];
} NV_GPU_VOLT_VOLT_DEVICE_INFO_PWM;
typedef struct {
  NvU8 vselMask;
  NvU8 vidMin;
  NvU8 vidMax;
  NvS32 voltageBaseuV;
  NvS32 voltageOffsetScaleuV;
  NvU8 vidToVselMapping[NV_GPU_VOLT_DEV_VID_VSEL_MAX_ENTRIES];
  NvU8 gpioPin[NV_GPU_VOLT_DEV_VID_VSEL_MAX_ENTRIES];
  NvU8 vselFunctionTable[NV_GPU_VOLT_DEV_VID_VSEL_MAX_ENTRIES];
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_DEVICE_INFO_VID;
typedef union {
  NV_GPU_VOLT_VOLT_DEVICE_INFO_PWM pwm;
  NV_GPU_VOLT_VOLT_DEVICE_INFO_VID vid;
} NV_GPU_VOLT_VOLT_DEVICE_INFO_DATA_V1;
typedef struct {
  NV_GPU_VOLT_VOLT_DEVICE_TYPE type;
  NvU8 voltDomain;
  NvU8 i2cDevIdx;
  NvU8 operationType;
  NvU32 voltageMinuV;
  NvU32 voltageMaxuV;
  NvU32 voltStepuV;
  NV_GPU_VOLT_VOLT_DEVICE_INFO_DATA_V1 data;
} NV_GPU_VOLT_VOLT_DEVICE_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 voltDeviceMask;
  NvU8 rsvd[64];
  NV_GPU_VOLT_VOLT_DEVICE_INFO_V1 devices[NV_GPU_VOLT_DEVICES_MAX_V1];
} NV_GPU_VOLT_VOLT_DEVICES_INFO_V1;
typedef NV_GPU_VOLT_VOLT_DEVICES_INFO_V1 NV_GPU_VOLT_VOLT_DEVICES_INFO;
#define NV_GPU_VOLT_VOLT_DEVICES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLT_VOLT_DEVICES_INFO_V1, 1)
#define NV_GPU_VOLT_VOLT_DEVICES_INFO_VER NV_GPU_VOLT_VOLT_DEVICES_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_VoltVoltDevicesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_VOLT_VOLT_DEVICES_INFO *pVoltDevicesInfo);
typedef struct {
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_DEVICE_CONTROL_PWM;
typedef struct {
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_DEVICE_CONTROL_VID;
typedef union {
  NV_GPU_VOLT_VOLT_DEVICE_CONTROL_PWM pwm;
  NV_GPU_VOLT_VOLT_DEVICE_CONTROL_VID vid;
} NV_GPU_VOLT_VOLT_DEVICE_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_VOLT_VOLT_DEVICE_TYPE type;
  NvU32 switchDelayus;
  NV_GPU_VOLT_VOLT_DEVICE_CONTROL_DATA_V1 data;
} NV_GPU_VOLT_VOLT_DEVICE_CONTROL_V1;
typedef struct {
  NvU32 version;
  NvU32 voltDeviceMask;
  NvU8 rsvd[64];
  NV_GPU_VOLT_VOLT_DEVICE_CONTROL_V1 devices[NV_GPU_VOLT_DEVICES_MAX_V1];
} NV_GPU_VOLT_VOLT_DEVICES_CONTROL_V1;
typedef NV_GPU_VOLT_VOLT_DEVICES_CONTROL_V1 NV_GPU_VOLT_VOLT_DEVICES_CONTROL;
#define NV_GPU_VOLT_VOLT_DEVICES_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLT_VOLT_DEVICES_CONTROL_V1, 1)
#define NV_GPU_VOLT_VOLT_DEVICES_CONTROL_VER NV_GPU_VOLT_VOLT_DEVICES_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_VoltVoltDevicesGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_VOLT_VOLT_DEVICES_CONTROL *pVoltDevicesCtrl);
NVAPI_INTERFACE NvAPI_GPU_VoltVoltDevicesSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_VOLT_VOLT_DEVICES_CONTROL *pVoltDevicesCtrl);
#define NV_GPU_VOLT_POLICIES_MAX_V1 (32)
typedef enum {
  NV_GPU_VOLT_VOLT_POLICY_TYPE_SINGLE_RAIL = 0x0,
  NV_GPU_VOLT_VOLT_POLICY_TYPE_SPLIT_RAIL_MULTI_STEP,
  NV_GPU_VOLT_VOLT_POLICY_TYPE_SPLIT_RAIL_SINGLE_STEP,
  NV_GPU_VOLT_VOLT_POLICY_TYPE_SINGLE_RAIL_MULTI_STEP,
  NV_GPU_VOLT_VOLT_POLICY_TYPE_MULTI_RAIL,
  NV_GPU_VOLT_VOLT_POLICY_TYPE_INVALID = 0xFFFFFFFF,
} NV_GPU_VOLT_VOLT_POLICY_TYPE;
typedef struct {
  NvU32 railIdx;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_INFO_SINGLE_RAIL;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_INFO_SINGLE_RAIL super;
  NvU32 rampUpStepSizeuV;
  NvU32 rampDownStepSizeuV;
  NvU8 rsvd[56];
} NV_GPU_VOLT_VOLT_POLICY_INFO_SINGLE_RAIL_MULTI_STEP;
typedef struct {
  NvU8 railIdxMaster;
  NvU8 railIdxSlave;
  NvU8 deltaMinVfeEquIdx;
  NvU8 deltaMaxVfeEquIdx;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_INFO_SPLIT_RAIL;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_INFO_SPLIT_RAIL super;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_INFO_SPLIT_RAIL_MULTI_STEP;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_INFO_SPLIT_RAIL super;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_INFO_SPLIT_RAIL_SINGLE_STEP;
typedef struct {
  NvU32 voltRailMask;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_INFO_MULTI_RAIL;
typedef union {
  NV_GPU_VOLT_VOLT_POLICY_INFO_SINGLE_RAIL singleRail;
  NV_GPU_VOLT_VOLT_POLICY_INFO_SINGLE_RAIL_MULTI_STEP singleRailMS;
  NV_GPU_VOLT_VOLT_POLICY_INFO_SPLIT_RAIL splitRail;
  NV_GPU_VOLT_VOLT_POLICY_INFO_SPLIT_RAIL_MULTI_STEP splitRailMS;
  NV_GPU_VOLT_VOLT_POLICY_INFO_SPLIT_RAIL_SINGLE_STEP splitRailSS;
  NV_GPU_VOLT_VOLT_POLICY_INFO_MULTI_RAIL multiRail;
} NV_GPU_VOLT_VOLT_POLICY_INFO_DATA_V1;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_TYPE type;
  NV_GPU_VOLT_VOLT_POLICY_INFO_DATA_V1 data;
} NV_GPU_VOLT_VOLT_POLICY_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 voltPolicyMask;
  NvU8 perfCoreVFSeqPolicyIdx;
  NvU8 rsvd[64];
  NV_GPU_VOLT_VOLT_POLICY_INFO_V1 policies[NV_GPU_VOLT_POLICIES_MAX_V1];
} NV_GPU_VOLT_VOLT_POLICIES_INFO_V1;
typedef NV_GPU_VOLT_VOLT_POLICIES_INFO_V1 NV_GPU_VOLT_VOLT_POLICIES_INFO;
#define NV_GPU_VOLT_VOLT_POLICIES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLT_VOLT_POLICIES_INFO_V1, 1)
#define NV_GPU_VOLT_VOLT_POLICIES_INFO_VER NV_GPU_VOLT_VOLT_POLICIES_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_VoltVoltPoliciesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_VOLT_VOLT_POLICIES_INFO *pVoltPoliciesInfo);
typedef struct {
  NvU32 currVoltuV;
  NvU8 rsvd[60];
} NV_GPU_VOLT_VOLT_POLICY_STATUS_SINGLE_RAIL;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_STATUS_SINGLE_RAIL super;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_STATUS_SINGLE_RAIL_MULTI_STEP;
typedef struct {
  NvS32 deltaMinuV;
  NvS32 deltaMaxuV;
  NvS32 origDeltaMinuV;
  NvS32 origDeltaMaxuV;
  NvU8 bViolation;
  NvU32 currVoltMasteruV;
  NvU32 currVoltSlaveuV;
  NvU8 rsvd[47];
} NV_GPU_VOLT_VOLT_POLICY_STATUS_SPLIT_RAIL;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_STATUS_SPLIT_RAIL super;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_STATUS_SPLIT_RAIL_MULTI_STEP;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_STATUS_SPLIT_RAIL super;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_STATUS_SPLIT_RAIL_SINGLE_STEP;
typedef struct {
  NvU8 railIdx;
  NvU32 currVoltuV;
} NV_GPU_VOLT_VOLT_POLICY_STATUS_MULTI_RAIL_ITEM, *PNV_GPU_VOLT_VOLT_POLICY_STATUS_MULTI_RAIL_ITEM;
typedef struct {
  NvU8 numRails;
  NV_GPU_VOLT_VOLT_POLICY_STATUS_MULTI_RAIL_ITEM
  railItems[NV_GPU_VOLT_VOLT_RAIL_CLIENT_MAX_RAILS];
} NV_GPU_VOLT_VOLT_POLICY_STATUS_MULTI_RAIL, *PNV_GPU_VOLT_VOLT_POLICY_STATUS_MULTI_RAIL;
typedef union {
  NV_GPU_VOLT_VOLT_POLICY_STATUS_SINGLE_RAIL singleRail;
  NV_GPU_VOLT_VOLT_POLICY_STATUS_SINGLE_RAIL_MULTI_STEP singleRailMS;
  NV_GPU_VOLT_VOLT_POLICY_STATUS_SPLIT_RAIL splitRail;
  NV_GPU_VOLT_VOLT_POLICY_STATUS_SPLIT_RAIL_MULTI_STEP splitRailMS;
  NV_GPU_VOLT_VOLT_POLICY_STATUS_SPLIT_RAIL_SINGLE_STEP splitRailSS;
  NV_GPU_VOLT_VOLT_POLICY_STATUS_MULTI_RAIL multiRail;
} NV_GPU_VOLT_VOLT_POLICY_STATUS_DATA_V1;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_TYPE type;
  NV_GPU_VOLT_VOLT_POLICY_STATUS_DATA_V1 data;
} NV_GPU_VOLT_VOLT_POLICY_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 voltPolicyMask;
  NvU8 rsvd[64];
  NV_GPU_VOLT_VOLT_POLICY_STATUS_V1 policies[NV_GPU_VOLT_POLICIES_MAX_V1];
} NV_GPU_VOLT_VOLT_POLICIES_STATUS_V1;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_STATUS_V1 v1;
  NvS32 offsetVoltRequV;
  NvS32 offsetVoltCurruV;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_STATUS_V2;
typedef struct {
  NvU32 version;
  NvU32 voltPolicyMask;
  NvU8 rsvd[64];
  NV_GPU_VOLT_VOLT_POLICY_STATUS_V2 policies[NV_GPU_VOLT_POLICIES_MAX_V1];
} NV_GPU_VOLT_VOLT_POLICIES_STATUS_V2;
typedef NV_GPU_VOLT_VOLT_POLICIES_STATUS_V2 NV_GPU_VOLT_VOLT_POLICIES_STATUS;
#define NV_GPU_VOLT_VOLT_POLICIES_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLT_VOLT_POLICIES_STATUS_V1, 1)
#define NV_GPU_VOLT_VOLT_POLICIES_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_VOLT_VOLT_POLICIES_STATUS_V2, 2)
#define NV_GPU_VOLT_VOLT_POLICIES_STATUS_VER NV_GPU_VOLT_VOLT_POLICIES_STATUS_VER2
NVAPI_INTERFACE NvAPI_GPU_VoltVoltPoliciesGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_VOLT_VOLT_POLICIES_STATUS *pVoltPoliciesStatus);
typedef struct {
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_CONTROL_SINGLE_RAIL;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_SINGLE_RAIL super;
  NvU16 interSwitchDelayus;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_CONTROL_SINGLE_RAIL_MULTI_STEP;
typedef struct {
  NvS32 offsetDeltaMinuV;
  NvS32 offsetDeltaMaxuV;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_CONTROL_SPLIT_RAIL;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_SPLIT_RAIL super;
  NvU16 interSwitchDelayus;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_CONTROL_SPLIT_RAIL_MULTI_STEP;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_SPLIT_RAIL super;
  NvU8 rsvd[64];
} NV_GPU_VOLT_VOLT_POLICY_CONTROL_SPLIT_RAIL_SINGLE_STEP;
typedef union {
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_SINGLE_RAIL singleRail;
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_SINGLE_RAIL_MULTI_STEP singleRailMS;
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_SPLIT_RAIL splitRail;
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_SPLIT_RAIL_MULTI_STEP splitRailMS;
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_SPLIT_RAIL_SINGLE_STEP splitRailSS;
} NV_GPU_VOLT_VOLT_POLICY_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_VOLT_VOLT_POLICY_TYPE type;
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_DATA_V1 data;
} NV_GPU_VOLT_VOLT_POLICY_CONTROL_V1;
typedef struct {
  NvU32 version;
  NvU32 voltPolicyMask;
  NvU8 rsvd[64];
  NV_GPU_VOLT_VOLT_POLICY_CONTROL_V1 policies[NV_GPU_VOLT_POLICIES_MAX_V1];
} NV_GPU_VOLT_VOLT_POLICIES_CONTROL_V1;
typedef NV_GPU_VOLT_VOLT_POLICIES_CONTROL_V1 NV_GPU_VOLT_VOLT_POLICIES_CONTROL;
#define NV_GPU_VOLT_VOLT_POLICIES_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_VOLT_VOLT_POLICIES_CONTROL_V1, 1)
#define NV_GPU_VOLT_VOLT_POLICIES_CONTROL_VER NV_GPU_VOLT_VOLT_POLICIES_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_VoltVoltPoliciesGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __inout NV_GPU_VOLT_VOLT_POLICIES_CONTROL *pVoltPoliciesControl);
NVAPI_INTERFACE NvAPI_GPU_VoltVoltPoliciesSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __inout NV_GPU_VOLT_VOLT_POLICIES_CONTROL *pVoltPoliciesControl);
typedef struct _NV_GPU_CLIENT_VOLT_RAIL_STATUS_V1 {
  NV_GPU_CLIENT_VOLT_DOMAIN_ID railId;
  NvU32 currVoltuV;
  NvU8 reserved[32];
} NV_GPU_CLIENT_VOLT_RAIL_STATUS_V1;
typedef struct _NV_GPU_CLIENT_VOLT_RAILS_STATUS_V1 {
  NvU32 version;
  NvU8 reserved[32];
  NV_GPU_CLIENT_VOLT_RAIL_STATUS_V1 rails[NV_GPU_CLIENT_VOLT_DOMAIN_MAX_ENTRIES];
} NV_GPU_CLIENT_VOLT_RAILS_STATUS_V1;
typedef NV_GPU_CLIENT_VOLT_RAILS_STATUS_V1 NV_GPU_CLIENT_VOLT_RAILS_STATUS;
#define NV_GPU_CLIENT_VOLT_RAILS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_VOLT_RAILS_STATUS_V1, 1)
#define NV_GPU_CLIENT_VOLT_RAILS_STATUS_VER NV_GPU_CLIENT_VOLT_RAILS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientVoltRailsGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                   NV_GPU_CLIENT_VOLT_RAILS_STATUS *pClientRailsStatus);
typedef struct {
  NvU32 version;
  NvU8 pctDelta;
  NvU8 reserved[32];
} NV_GPU_CLIENT_VOLT_RAILS_CONTROL_V1;
typedef NV_GPU_CLIENT_VOLT_RAILS_CONTROL_V1 NV_GPU_CLIENT_VOLT_RAILS_CONTROL;
#define NV_GPU_CLIENT_VOLT_RAILS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_VOLT_RAILS_CONTROL_V1, 1)
#define NV_GPU_CLIENT_VOLT_RAILS_CONTROL_VER NV_GPU_CLIENT_VOLT_RAILS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientVoltRailsGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_CLIENT_VOLT_RAILS_CONTROL *pClientRailsControl);
NVAPI_INTERFACE NvAPI_GPU_ClientVoltRailsSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __in NV_GPU_CLIENT_VOLT_RAILS_CONTROL *pClientRailsControl);
#define NV_GPU_VOLT_PMUMON_VOLT_RAILS_SAMPLE_INVALID (NV_U32_MAX)
typedef struct _NV_GPU_VOLT_PMUMON_VOLT_RAILS_SAMPLE_V1 {
  NV_GPU_PMUMON_SAMPLE_SUPER_V1 super;
  NvU32 nvvddVoltageuV;
  NvU32 msvddVoltageuV;
  NvU8 rsvd[64];
} NV_GPU_VOLT_PMUMON_VOLT_RAILS_SAMPLE_V1;
#define NV_GPU_VOLT_PMUMON_VOLT_RAILS_SAMPLE_COUNT_V1 (50U)
typedef struct _NV_GPU_VOLT_PMUMON_VOLT_RAILS_GET_SAMPLES_V1 {
  NvU32 version;
  NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 super;
  NvU8 rsvd[64];
  NV_GPU_VOLT_PMUMON_VOLT_RAILS_SAMPLE_V1 samples[NV_GPU_VOLT_PMUMON_VOLT_RAILS_SAMPLE_COUNT_V1];
} NV_GPU_VOLT_PMUMON_VOLT_RAILS_GET_SAMPLES_V1;
typedef NV_GPU_VOLT_PMUMON_VOLT_RAILS_GET_SAMPLES_V1 NV_GPU_VOLT_PMUMON_VOLT_RAILS_GET_SAMPLES;
#define NV_GPU_VOLT_PMUMON_VOLT_RAILS_GET_SAMPLES_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_VOLT_PMUMON_VOLT_RAILS_GET_SAMPLES_V1, 1)
#define NV_GPU_VOLT_PMUMON_VOLT_RAILS_GET_SAMPLES_VER NV_GPU_VOLT_PMUMON_VOLT_RAILS_GET_SAMPLES_VER1
NVAPI_INTERFACE NvAPI_GPU_VoltPmumonVoltRailsGetSamples(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_VOLT_PMUMON_VOLT_RAILS_GET_SAMPLES *pGetSamplesParams);
typedef enum _NV_GPU_PERF_PSTATE_FALLBACK {
  NVAPI_GPU_PERF_PSTATE_FALLBACK_RETURN_ERROR = 0,
  NVAPI_GPU_PERF_PSTATE_FALLBACK_HIGHER_PERF = 1,
  NVAPI_GPU_PERF_PSTATE_FALLBACK_LOWER_PERF = 2,
} NV_GPU_PERF_PSTATE_FALLBACK;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numPstates;
  NvU32 numClocks;
  NvU32 numVoltages;
  struct {
    NV_GPU_PERF_PSTATE_ID pstateId;
    NvU32 flags;
    struct {
      NV_GPU_CLOCK_DOMAIN_ID domainId;
      NvU32 flags : 2;
      NvU32 reserved : 29;
      NvU32 bApplyRatio : 1;
      NvU32 freq;
    } clocks[NVAPI_MAX_GPU_PERF_CLOCKS];
    struct {
      NV_GPU_PERF_VOLTAGE_DOMAIN_ID domainId;
      NvU32 flags;
      NvU32 mvolt;
    } voltages[NVAPI_MAX_GPU_PERF_VOLTAGES];
  } pstates[NVAPI_MAX_GPU_PERF_PSTATES];
} NV_GPU_PERF_PSTATES_V1;
typedef NV_GPU_PERF_PSTATES_V1 NV_GPU_PERF_PSTATES;
#define NV_GPU_PERF_PSTATES_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_V1, 1)
#define NV_GPU_PERF_PSTATES_VER NV_GPU_PERF_PSTATES_VER1
NVAPI_INTERFACE NvAPI_GPU_GetPstates(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES *pPerfPstates);
NVAPI_INTERFACE NvAPI_GPU_GetPstatesEx(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES *pPerfPstates,
                                       NvU32 inputFlags);
NVAPI_INTERFACE NvAPI_GPU_SetPstates(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES *pPerfPstates);
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numPstates;
  NvU32 numClocks;
  struct {
    NV_GPU_PERF_PSTATE_ID pstateId;
    NvU32 flags;
    struct {
      NV_GPU_PUBLIC_CLOCK_ID domainId;
      NvU32 flags;
      NvU32 freq;
    } clocks[NVAPI_MAX_GPU_PERF_CLOCKS];
  } pstates[NVAPI_MAX_GPU_PERF_PSTATES];
} NV_GPU_PERF_PSTATES_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 numPstates;
  NvU32 numClocks;
  NvU32 numVoltages;
  struct {
    NV_GPU_PERF_PSTATE_ID pstateId;
    NvU32 flags;
    struct {
      NV_GPU_PUBLIC_CLOCK_ID domainId;
      NvU32 flags;
      NvU32 freq;
    } clocks[NVAPI_MAX_GPU_PERF_CLOCKS];
    struct {
      NV_GPU_PERF_VOLTAGE_INFO_DOMAIN_ID domainId;
      NvU32 flags;
      NvU32 mvolt;
    } voltages[NVAPI_MAX_GPU_PERF_VOLTAGES];
  } pstates[NVAPI_MAX_GPU_PERF_PSTATES];
} NV_GPU_PERF_PSTATES_INFO_V2;
typedef NV_GPU_PERF_PSTATES_INFO_V2 NV_GPU_PERF_PSTATES_INFO;
#define NV_GPU_PERF_PSTATES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_INFO_V1, 1)
#define NV_GPU_PERF_PSTATES_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_INFO_V2, 2)
#define NV_GPU_PERF_PSTATES_INFO_VER3 MAKE_NVAPI_VERSION(NV_GPU_PERF_PSTATES_INFO_V2, 3)
#define NV_GPU_PERF_PSTATES_INFO_VER NV_GPU_PERF_PSTATES_INFO_VER3
NVAPI_INTERFACE NvAPI_GPU_GetPstatesInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 304. Instead, use NvAPI_GPU_GetPstates20.") NVAPI_INTERFACE
    NvAPI_GPU_GetPstatesInfoEx(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo,
                               NvU32 inputFlags);
NVAPI_INTERFACE NvAPI_GPU_SetPstatesInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATES_INFO *pPerfPstatesInfo);
NVAPI_INTERFACE NvAPI_GPU_GetPstates20(__in NvPhysicalGpuHandle hPhysicalGpu,
                                       __inout NV_GPU_PERF_PSTATES20_INFO *pPstatesInfo);
NVAPI_INTERFACE NvAPI_GPU_SetPstates20(__in NvPhysicalGpuHandle hPhysicalGpu,
                                       __in NV_GPU_PERF_PSTATES20_INFO *pPstatesInfo);
NVAPI_INTERFACE NvAPI_GPU_GetPstates20Private(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_PERF_PSTATES20_PRIVATE_INFO *pPstatesInfo);
NVAPI_INTERFACE NvAPI_GPU_SetPstates20Private(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __in NV_GPU_PERF_PSTATES20_PRIVATE_INFO *pPstatesInfo);
NVAPI_INTERFACE NvAPI_GPU_SetForcePstate(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATE_ID forcePstate,
                                         NV_GPU_PERF_PSTATE_FALLBACK fallback);
NVAPI_INTERFACE NvAPI_GPU_SetForcePstateEx(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATE_ID forcePstate,
                                           NV_GPU_PERF_PSTATE_FALLBACK fallback, NvU32 flags);
#define NVAPI_MAX_PSTATE_LIMITS 64
typedef enum {
  NVAPI_PSTATE_LIMIT_PERFMON,
  NVAPI_PSTATE_LIMIT_NO_CLIENT,
  NVAPI_PSTATE_LIMIT_SCREEN_SAVER,
  NVAPI_PSTATE_LIMIT_NO_HIRES,
  NVAPI_PSTATE_LIMIT_OS_LEVEL,
  NVAPI_PSTATE_LIMIT_SPDIFF_GLITCH,
  NVAPI_PSTATE_LIMIT_DISPLAY_GLITCH,
  NVAPI_PSTATE_LIMIT_UNLOAD_DRIVER,
  NVAPI_PSTATE_LIMIT_POWERMIZER,
  NVAPI_PSTATE_LIMIT_STRESSTEST_FAILURE,
  NVAPI_PSTATE_LIMIT_RC_ERROR,
  NVAPI_PSTATE_LIMIT_MIN_FAN_LEVEL,
  NVAPI_PSTATE_LIMIT_MCLK_CLONE,
  NVAPI_PSTATE_LIMIT_OVERLAY,
  NVAPI_PSTATE_LIMIT_HIGHRES,
  NVAPI_PSTATE_LIMIT_BANDWIDTHFACTOR,
  NVAPI_PSTATE_LIMIT_HD_FRAMEDROP_WAR,
  NVAPI_PSTATE_LIMIT_ISMODEPOSSIBLE,
  NVAPI_PSTATE_LIMIT_HYBRID,
  NVAPI_PSTATE_LIMIT_INVALID_SYSCON,
  NVAPI_PSTATE_LIMIT_STRESSTEST_SETUP,
  NVAPI_PSTATE_LIMIT_FORCED,
  NVAPI_PSTATE_LIMIT_FORCED_DACPERFTEST,
  NVAPI_PSTATE_LIMIT_FORCED_ACSHMOO,
  NVAPI_PSTATE_LIMIT_FORCED_STRESSTEST,
  NVAPI_PSTATE_LIMIT_POWERMIZER_HARD,
  NVAPI_PSTATE_LIMIT_THERMAL,
  NVAPI_PSTATE_LIMIT_SYSPERF,
  NVAPI_PSTATE_LIMIT_PWR_SUPPLY_CAPACITY,
  NVAPI_PSTATE_LIMIT_SW_BATTPOWER,
  NVAPI_PSTATE_LIMIT_EXT_PERF_CONTROL,
  NVAPI_PSTATE_LIMIT_MXM_ACPOWER,
  NVAPI_PSTATE_LIMIT_AUX_POWER,
  NVAPI_PSTATE_LIMIT_SHORT_VBLANK,
  NVAPI_PSTATE_LIMIT_POWER_BALANCE,
  NVAPI_PSTATE_LIMIT_BANDWIDTH_HCLONE,
  NVAPI_PSTATE_LIMIT_AUX_PWR_STATE,
} NVAPI_PSTATE_LIMIT;
#define NVAPI_PSTATE_LIMIT_UNDEFINED 0xff
#define NVAPI_PSTATE_LIMIT_TYPE_MIN 1
#define NVAPI_PSTATE_LIMIT_TYPE_MAX 2
#define NVAPI_PSTATE_LIMIT_TYPE_BOTH 3
typedef struct {
  NvU8 limitId;
  NvU8 limitType;
} NV_GPU_PSTATE_LIMIT_INFO;
typedef struct {
  NvU32 version;
  NvU32 numLimits;
  NV_GPU_PSTATE_LIMIT_INFO limitInfoList[NVAPI_MAX_PSTATE_LIMITS];
} NV_GPU_PSTATE_LIMITS_INFO;
#define NV_GPU_PSTATE_LIMITS_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_PSTATE_LIMITS_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetPstateLimitsInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PSTATE_LIMITS_INFO *pLimitsInfo);
typedef struct {
  NvU8 limitId;
  NvU8 pstate;
} NV_GPU_PSTATE_LIMIT_STATUS;
typedef struct {
  NvU32 version;
  NvU32 numLimits;
  NV_GPU_PSTATE_LIMIT_STATUS limitStatusList[NVAPI_MAX_PSTATE_LIMITS];
} NV_GPU_PSTATE_ACTIVE_LIMITS;
#define NV_GPU_PSTATE_ACTIVE_LIMITS_VER MAKE_NVAPI_VERSION(NV_GPU_PSTATE_ACTIVE_LIMITS, 1)
NVAPI_INTERFACE NvAPI_GPU_GetPstateActiveLimits(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_PSTATE_ACTIVE_LIMITS *pActiveLimits);
NVAPI_INTERFACE NvAPI_GPU_GetCurrentPstate(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_PERF_PSTATE_ID *pCurrentPstate);
typedef enum _NV_PERF_PSTATE_CLIENT_LIMIT_ID {
  NVAPI_PERF_PSTATE_CLIENT_LIMIT_HARD = 0x00000001,
  NVAPI_PERF_PSTATE_CLIENT_LIMIT_SOFT = 0x00000002,
  NVAPI_PERF_PSTATE_CLIENT_LIMIT_BOTH = 0x00000003
} NV_GPU_PERF_PSTATE_CLIENT_LIMIT_ID;
NVAPI_INTERFACE NvAPI_GPU_GetPstateClientLimits(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_PERF_PSTATE_CLIENT_LIMIT_ID limitId,
                                                NV_GPU_PERF_PSTATE_ID *PstateLimit);
NVAPI_INTERFACE NvAPI_GPU_SetPstateClientLimits(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_PERF_PSTATE_CLIENT_LIMIT_ID limitId,
                                                NV_GPU_PERF_PSTATE_ID PstateLimit);
NVAPI_INTERFACE NvAPI_GPU_EnableOverclockedPstates(NvPhysicalGpuHandle hPhysicalGpu, NvU8 bEnable);
NVAPI_INTERFACE NvAPI_GPU_EnableDynamicPstates(NvPhysicalGpuHandle hPhysicalGpu, NvU8 bEnable);
#define NVAPI_MAX_GPU_UTILIZATIONS 8
typedef enum _NV_GPU_UTILIZATION_DOMAIN_ID {
  NVAPI_GPU_UTILIZATION_DOMAIN_GPU = 0,
  NVAPI_GPU_UTILIZATION_DOMAIN_FB = 1,
  NVAPI_GPU_UTILIZATION_DOMAIN_VID = 2,
  NVAPI_GPU_UTILIZATION_DOMAIN_BUS = 3,
} NV_GPU_UTILIZATION_DOMAIN_ID;
typedef struct {
  NvU32 version;
  NvU32 flags;
  struct {
    NvU32 bIsPresent : 1;
    NvU32 percentage;
    NvU32 incThreshold;
    NvU32 decThreshold;
  } utilization[NVAPI_MAX_GPU_UTILIZATIONS];
} NV_GPU_DYNAMIC_PSTATES_INFO;
#define NV_GPU_DYNAMIC_PSTATES_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_DYNAMIC_PSTATES_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetDynamicPstatesInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_GPU_DYNAMIC_PSTATES_INFO *pDynamicPstatesInfo);
#define NVAPI_MAX_GPU_UTILIZATIONS 8
typedef struct {
  NvU32 version;
  NvU32 flags;
  struct {
    NvU32 bIsPresent : 1;
    NvU32 percentage;
  } utilization[NVAPI_MAX_GPU_UTILIZATIONS];
} NV_GPU_DYNAMIC_PSTATES_INFO_EX;
#define NV_GPU_DYNAMIC_PSTATES_INFO_EX_VER MAKE_NVAPI_VERSION(NV_GPU_DYNAMIC_PSTATES_INFO_EX, 1)
NVAPI_INTERFACE NvAPI_GPU_GetDynamicPstatesInfoEx(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_DYNAMIC_PSTATES_INFO_EX *pDynamicPstatesInfoEx);
#define NVAPI_MAX_THERMAL_SENSORS_PER_GPU 3
typedef enum {
  NVAPI_THERMAL_TARGET_NONE = 0,
  NVAPI_THERMAL_TARGET_GPU = 1,
  NVAPI_THERMAL_TARGET_MEMORY = 2,
  NVAPI_THERMAL_TARGET_POWER_SUPPLY = 4,
  NVAPI_THERMAL_TARGET_BOARD = 8,
  NVAPI_THERMAL_TARGET_VCD_BOARD = 9,
  NVAPI_THERMAL_TARGET_VCD_INLET = 10,
  NVAPI_THERMAL_TARGET_VCD_OUTLET = 11,
  NVAPI_THERMAL_TARGET_ALL = 15,
  NVAPI_THERMAL_TARGET_UNKNOWN = -1,
} NV_THERMAL_TARGET;
typedef enum {
  NVAPI_THERMAL_CONTROLLER_NONE = 0,
  NVAPI_THERMAL_CONTROLLER_GPU_INTERNAL,
  NVAPI_THERMAL_CONTROLLER_ADM1032,
  NVAPI_THERMAL_CONTROLLER_MAX6649,
  NVAPI_THERMAL_CONTROLLER_MAX1617,
  NVAPI_THERMAL_CONTROLLER_LM99,
  NVAPI_THERMAL_CONTROLLER_LM89,
  NVAPI_THERMAL_CONTROLLER_LM64,
  NVAPI_THERMAL_CONTROLLER_ADT7473,
  NVAPI_THERMAL_CONTROLLER_SBMAX6649,
  NVAPI_THERMAL_CONTROLLER_VBIOSEVT,
  NVAPI_THERMAL_CONTROLLER_OS,
  NVAPI_THERMAL_CONTROLLER_UNKNOWN = -1,
} NV_THERMAL_CONTROLLER;
typedef struct {
  NvU32 version;
  NvU32 count;
  struct {
    NV_THERMAL_CONTROLLER controller;
    NvU32 defaultMinTemp;
    NvU32 defaultMaxTemp;
    NvU32 currentTemp;
    NV_THERMAL_TARGET target;
  } sensor[NVAPI_MAX_THERMAL_SENSORS_PER_GPU];
} NV_GPU_THERMAL_SETTINGS_V1;
typedef struct {
  NvU32 version;
  NvU32 count;
  struct {
    NV_THERMAL_CONTROLLER controller;
    NvS32 defaultMinTemp;
    NvS32 defaultMaxTemp;
    NvS32 currentTemp;
    NV_THERMAL_TARGET target;
  } sensor[NVAPI_MAX_THERMAL_SENSORS_PER_GPU];
} NV_GPU_THERMAL_SETTINGS_V2;
typedef NV_GPU_THERMAL_SETTINGS_V2 NV_GPU_THERMAL_SETTINGS;
#define NV_GPU_THERMAL_SETTINGS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_SETTINGS_V1, 1)
#define NV_GPU_THERMAL_SETTINGS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_SETTINGS_V2, 2)
#define NV_GPU_THERMAL_SETTINGS_VER NV_GPU_THERMAL_SETTINGS_VER_2
NVAPI_INTERFACE NvAPI_GPU_GetThermalSettings(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensorIndex,
                                             NV_GPU_THERMAL_SETTINGS *pThermalSettings);
typedef enum {
  NVAPI_GPU_THERMAL_SLOWDOWN_ENABLED = 0x0000,
  NVAPI_GPU_THERMAL_SLOWDOWN_DISABLED_ALL = 0xFFFF,
} NV_GPU_THERMAL_SLOWDOWN;
NVAPI_INTERFACE NvAPI_GPU_SetThermalSlowdownState(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_THERMAL_SLOWDOWN slowdownState);
NVAPI_INTERFACE NvAPI_GPU_GetThermalSlowdownState(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_THERMAL_SLOWDOWN *slowdownState);
typedef enum {
  NVAPI_GPU_THERMAL_SIMULATION_DISABLED = 0x0000,
  NVAPI_GPU_THERMAL_SIMULATION_ENABLED = 0x0001,
} NV_GPU_THERMAL_SIMULATION_MODE;
NVAPI_INTERFACE NvAPI_GPU_SetThermalSimulationMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensor,
                                                   NV_GPU_THERMAL_SIMULATION_MODE tempSimMode, NvU32 temperature);
NVAPI_INTERFACE NvAPI_GPU_SetExtendedThermalSimulationMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensor,
                                                           NV_GPU_THERMAL_SIMULATION_MODE tempSimMode,
                                                           NvS32 temperature);
NVAPI_INTERFACE NvAPI_GPU_GetThermalSimulationMode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 sensor,
                                                   NV_GPU_THERMAL_SIMULATION_MODE *tempSimMode);
#define NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1 16
#define NV_GPU_THERMAL_POLICY_MAX_CHANNELS_V1 32
#define NV_GPU_THERMAL_POLICY_MAX_CHANNELS NV_GPU_THERMAL_POLICY_MAX_CHANNELS_V1
typedef enum _NV_GPU_THERMAL_POLICY_TYPE {
  NV_GPU_THERMAL_POLICY_TYPE_DTC_VPSTATE = 0x00000001,
  NV_GPU_THERMAL_POLICY_TYPE_DTC_VF,
  NV_GPU_THERMAL_POLICY_TYPE_DTC_VOLT,
  NV_GPU_THERMAL_POLICY_TYPE_DTC_PWR,
  NV_GPU_THERMAL_POLICY_TYPE_DTC = 0xFFFFFFFD,
  NV_GPU_THERMAL_POLICY_TYPE_DOMGRP = 0xFFFFFFFE,
  NV_GPU_THERMAL_POLICY_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_THERMAL_POLICY_TYPE;
typedef struct _NV_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1 {
  NvU32 vpstateNum;
  NvU32 vpstateTdp;
} NV_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1;
typedef struct _NV_GPU_THERMAL_POLICY_INFO_DTC_VF_V1 {
  NvU32 limitFreqMaxKHz;
  NvU32 limitFreqMinKHz;
  NvU32 ratedTdpFreqKHz;
} NV_GPU_THERMAL_POLICY_INFO_DTC_VF_V1;
typedef struct _NV_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1 {
  NvU32 ratedTdpFreqKHz;
  NvU32 pstateIdxTdp;
  NvU32 voltageMaxuV;
  NvU32 voltageMinuV;
  NvU32 voltageStepuV;
} NV_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1;
typedef struct _NV_GPU_THERMAL_POLICY_INFO_DTC_PWR_V1 {
  NvU32 powerStepmW;
} NV_GPU_THERMAL_POLICY_INFO_DTC_PWR_V1;
typedef struct _NV_GPU_THERMAL_POLICY_INFO_V1 {
  NV_GPU_THERMAL_POLICY_TYPE type;
  NvU8 chIdx;
  NvS32 limitMin;
  NvS32 limitRated;
  NvS32 limitMax;
  union {
    NV_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1 dtcVpstate;
    NV_GPU_THERMAL_POLICY_INFO_DTC_VF_V1 dtcVf;
    NV_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1 dtcVolt;
    NV_GPU_THERMAL_POLICY_INFO_DTC_PWR_V1 dtcPwr;
    NvU8 rsvd[32];
  } data;
} NV_GPU_THERMAL_POLICY_INFO_V1;
typedef struct {
  NvBool bEnable;
  NvU8 pad[3];
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICY_DIAGNOSTICS_INFO_LIMIT_COUNTDOWN_V1;
typedef struct {
  NvBool bEnable;
  NvU8 pad[3];
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICY_DIAGNOSTICS_INFO_CAPPED_V1;
typedef struct {
  NV_GPU_THERMAL_POLICY_DIAGNOSTICS_INFO_LIMIT_COUNTDOWN_V1 limitCountdown;
  NV_GPU_THERMAL_POLICY_DIAGNOSTICS_INFO_CAPPED_V1 capped;
  NvU8 rsvd[256];
} NV_GPU_THERMAL_POLICY_DIAGNOSTICS_INFO_V1;
typedef struct _NV_GPU_THERMAL_POLICY_INFO_V2 {
  NV_GPU_THERMAL_POLICY_TYPE type;
  NvU8 chIdx;
  NvS32 limitMin;
  NvS32 limitRated;
  NvS32 limitMax;
  NV_GPU_THERMAL_POLICY_DIAGNOSTICS_INFO_V1 diagnostics;
  NvU8 rsvd[256];
  union {
    NV_GPU_THERMAL_POLICY_INFO_DTC_VPSTATE_V1 dtcVpstate;
    NV_GPU_THERMAL_POLICY_INFO_DTC_VF_V1 dtcVf;
    NV_GPU_THERMAL_POLICY_INFO_DTC_VOLT_V1 dtcVolt;
    NV_GPU_THERMAL_POLICY_INFO_DTC_PWR_V1 dtcPwr;
    NvU8 rsvd[256];
  } data;
} NV_GPU_THERMAL_POLICY_INFO_V2;
typedef struct _NV_GPU_THERMAL_POLICY_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 policyMask;
  NvU8 gpsPolicyIdx;
  NvU8 acousticPolicyIdx;
  NV_GPU_THERMAL_POLICY_INFO_V1 policies[NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} NV_GPU_THERMAL_POLICY_INFO_PARAMS_V1;
typedef struct _NV_GPU_THERMAL_POLICY_INFO_PARAMS_V2 {
  NvU32 version;
  NvU32 policyMask;
  NvU8 gpsPolicyIdx;
  NvU8 acousticPolicyIdx;
  NvU8 memPolicyIdx;
  NvU8 gpuSwSlowdownPolicyIdx;
  NvU8 rsvd[63];
  NV_GPU_THERMAL_POLICY_INFO_V1 policies[NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} NV_GPU_THERMAL_POLICY_INFO_PARAMS_V2;
typedef struct {
  NvBool bEnable;
  NvU8 pad[3];
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_INFO_LIMIT_COUNTDOWN_V1;
typedef struct {
  NvBool bEnable;
  NvU8 pad[3];
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_INFO_CAPPED_V1;
typedef struct {
  NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_INFO_LIMIT_COUNTDOWN_V1 limitCountdown;
  NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_INFO_CAPPED_V1 capped;
  NvU8 rsvd[256];
} NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_INFO_V1;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E32 activeChannelMask;
  NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_INFO_V1 global;
  NvU8 rsvd[256];
} NV_GPU_THERMAL_POLICYS_DIAGNOSTICS_INFO_V1;
typedef struct _NV_GPU_THERMAL_POLICY_INFO_PARAMS_V3 {
  NvU32 version;
  NvU32 policyMask;
  NvU8 gpsPolicyIdx;
  NvU8 acousticPolicyIdx;
  NvU8 memPolicyIdx;
  NvU8 gpuSwSlowdownPolicyIdx;
  NV_GPU_THERMAL_POLICYS_DIAGNOSTICS_INFO_V1 diagnostics;
  NvU8 rsvd[256];
  NV_GPU_THERMAL_POLICY_INFO_V2 policies[NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} NV_GPU_THERMAL_POLICY_INFO_PARAMS_V3;
#define NV_GPU_THERMAL_POLICY_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_INFO_PARAMS_V1, 1)
#define NV_GPU_THERMAL_POLICY_INFO_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_INFO_PARAMS_V2, 2)
#define NV_GPU_THERMAL_POLICY_INFO_PARAMS_VER_3 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_INFO_PARAMS_V3, 3)
#define NV_GPU_THERMAL_POLICY_INFO_PARAMS_VER NV_GPU_THERMAL_POLICY_INFO_PARAMS_VER_3
#define NV_GPU_THERMAL_POLICY_INFO_PARAMS NV_GPU_THERMAL_POLICY_INFO_PARAMS_V3
NVAPI_INTERFACE NvAPI_GPU_ThermalPolicyGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_GPU_THERMAL_POLICY_INFO_PARAMS *pPolicyInfo);
#define NV_GPU_THERMAL_POLICY_DOMAIN_GROUPS_LIMITS_MAX_DOMAIN_GROUPS 3
#define NV_GPU_THERMAL_POLICY_DOMAIN_GROUP_LIMIT_VALUE_DISABLED 0xFFFFFFFF
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DOMGRP {
  NvU32 limits[NV_GPU_THERMAL_POLICY_DOMAIN_GROUPS_LIMITS_MAX_DOMAIN_GROUPS];
} NV_GPU_THERMAL_POLICY_STATUS_DOMGRP;
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DTC {
  NvU8 sampleCount;
} NV_GPU_THERMAL_POLICY_STATUS_DTC;
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE {
  NV_GPU_THERMAL_POLICY_STATUS_DOMGRP domgrp;
  NV_GPU_THERMAL_POLICY_STATUS_DTC dtc;
  NvU32 vpstateLimitCurr;
} NV_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE;
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DTC_VF {
  NV_GPU_THERMAL_POLICY_STATUS_DOMGRP domgrp;
  NV_GPU_THERMAL_POLICY_STATUS_DTC dtc;
} NV_GPU_THERMAL_POLICY_STATUS_DTC_VF;
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DTC_VOLT {
  NV_GPU_THERMAL_POLICY_STATUS_DOMGRP domgrp;
  NV_GPU_THERMAL_POLICY_STATUS_DTC dtc;
} NV_GPU_THERMAL_POLICY_STATUS_DTC_VOLT;
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_DTC_PWR {
  NV_GPU_THERMAL_POLICY_STATUS_DTC dtc;
  NvU32 limitCurrmW;
  NvU8 powerPolicyIdx;
} NV_GPU_THERMAL_POLICY_STATUS_DTC_PWR;
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_V1 {
  NV_GPU_THERMAL_POLICY_TYPE type;
  NvS32 valueCurr;
  NvU8 rsvd[16];
  union {
    NV_GPU_THERMAL_POLICY_STATUS_DOMGRP domGrp;
    NV_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE dtcVpstate;
    NV_GPU_THERMAL_POLICY_STATUS_DTC_VF dtcVf;
    NV_GPU_THERMAL_POLICY_STATUS_DTC_VOLT dtcVolt;
    NV_GPU_THERMAL_POLICY_STATUS_DTC_PWR dtcPwr;
  } data;
} NV_GPU_THERMAL_POLICY_STATUS_V1;
typedef struct {
  NvS32 limitCountdown;
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICY_DIAGNOSTICS_STATUS_LIMIT_COUNTDOWN_V1;
typedef struct {
  NvBool bIsCapped;
  NvU8 pad[3];
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICY_DIAGNOSTICS_STATUS_CAPPED_V1;
typedef struct {
  NV_GPU_THERMAL_POLICY_DIAGNOSTICS_STATUS_LIMIT_COUNTDOWN_V1 limitCountdown;
  NV_GPU_THERMAL_POLICY_DIAGNOSTICS_STATUS_CAPPED_V1 capped;
  NvU8 rsvd[256];
} NV_GPU_THERMAL_POLICY_DIAGNOSTICS_STATUS_V1;
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_V3 {
  NV_GPU_THERMAL_POLICY_TYPE type;
  NvS32 valueCurr;
  NV_GPU_THERMAL_POLICY_DIAGNOSTICS_STATUS_V1 diagnostics;
  NvU8 rsvd[256];
  union {
    NV_GPU_THERMAL_POLICY_STATUS_DOMGRP domGrp;
    NV_GPU_THERMAL_POLICY_STATUS_DTC_VPSTATE dtcVpstate;
    NV_GPU_THERMAL_POLICY_STATUS_DTC_VF dtcVf;
    NV_GPU_THERMAL_POLICY_STATUS_DTC_VOLT dtcVolt;
    NV_GPU_THERMAL_POLICY_STATUS_DTC_PWR dtcPwr;
    NvU8 rsvd[256];
  } data;
} NV_GPU_THERMAL_POLICY_STATUS_V3;
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V1 {
  NvU32 version;
  NvU32 policyMask;
  NvU8 rsvd[16];
  NV_GPU_THERMAL_POLICY_STATUS_V1 policies[NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V1;
typedef struct {
  NvS32 limitCountdown;
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICYS_CHANNEL_DIAGNOSTICS_STATUS_LIMIT_COUNTDOWN_V1;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E32 thermalCappingPolicyMask;
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICYS_CHANNEL_DIAGNOSTICS_STATUS_CAPPED_V1;
typedef struct {
  NV_GPU_THERMAL_POLICYS_CHANNEL_DIAGNOSTICS_STATUS_LIMIT_COUNTDOWN_V1 limitCountdown;
  NV_GPU_THERMAL_POLICYS_CHANNEL_DIAGNOSTICS_STATUS_CAPPED_V1 capped;
  NvU8 rsvd[256];
} NV_GPU_THERMAL_POLICYS_CHANNEL_DIAGNOSTICS_STATUS_V1;
typedef struct {
  NvS32 limitCountdown;
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_STATUS_LIMIT_COUNTDOWN_V1;
typedef struct {
  NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_STATUS_LIMIT_COUNTDOWN_V1 limitCountdown;
  NvU8 rsvd[64];
} NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_STATUS_V1;
typedef struct {
  NvU8 numChannels;
  NV_GPU_THERMAL_POLICYS_CHANNEL_DIAGNOSTICS_STATUS_V1 channels[NV_GPU_THERMAL_POLICY_MAX_CHANNELS_V1];
  NV_GPU_THERMAL_POLICYS_GLOBAL_DIAGNOSTICS_STATUS_V1 global;
  NvU8 rsvd[256];
} NV_GPU_THERMAL_POLICYS_DIAGNOSTICS_STATUS_V1;
typedef struct _NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V3 {
  NvU32 version;
  NvU32 policyMask;
  NV_GPU_THERMAL_POLICYS_DIAGNOSTICS_STATUS_V1 diagnostics;
  NvU8 rsvd[256];
  NV_GPU_THERMAL_POLICY_STATUS_V3 policies[NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V3;
typedef NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V1 NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V2;
#define NV_GPU_THERMAL_POLICY_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V1, 1)
#define NV_GPU_THERMAL_POLICY_STATUS_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V2, 2)
#define NV_GPU_THERMAL_POLICY_STATUS_PARAMS_VER_3 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V3, 3)
#define NV_GPU_THERMAL_POLICY_STATUS_PARAMS_VER NV_GPU_THERMAL_POLICY_STATUS_PARAMS_VER_3
#define NV_GPU_THERMAL_POLICY_STATUS_PARAMS NV_GPU_THERMAL_POLICY_STATUS_PARAMS_V3
NVAPI_INTERFACE NvAPI_GPU_ThermalPolicyGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_THERMAL_POLICY_STATUS_PARAMS *pPolicyStatus);
typedef struct _NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 {
  NvU8 hasRatedTdpVpstateFloor : 1;
  NvU8 rsvd : 7;
} NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1;
typedef struct _NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1 {
  NvU8 aggressiveStep;
  NvU8 releaseStep;
  NvU8 holdSampleThreshold;
  NvU8 stepSampleThreshold;
  NvS32 thresholdCritical;
  NvS32 thresholdAggressive;
  NvS32 thresholdModerate;
  NvS32 thresholdRelease;
  NvS32 thresholdDisengage;
} NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1;
typedef struct _NV_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL_V1 {
  NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 super;
  NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
} NV_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL_V1;
typedef struct _NV_GPU_THERMAL_POLICY_DTC_VF_CONTROL_V1 {
  NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 super;
  NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
} NV_GPU_THERMAL_POLICY_DTC_VF_CONTROL_V1;
typedef struct _NV_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL_V1 {
  NV_GPU_THERMAL_POLICY_DOMGRP_CONTROL_V1 super;
  NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
} NV_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL_V1;
typedef struct _NV_GPU_THERMAL_POLICY_DTC_PWR_CONTROL_V1 {
  NV_GPU_THERMAL_POLICY_DTC_CONTROL_V1 dtc;
  NvU8 hasBaseClocksFloor : 1;
  NvU8 rsvd : 7;
} NV_GPU_THERMAL_POLICY_DTC_PWR_CONTROL_V1;
typedef struct _NV_GPU_THERMAL_POLICY_CONTROL_V1 {
  NV_GPU_THERMAL_POLICY_TYPE type;
  NvS32 limitCurr;
  NvU32 pollingPeriodms;
  NvU8 rsvd[16];
  union {
    NV_GPU_THERMAL_POLICY_DTC_VPSTATE_CONTROL_V1 dtcVpstate;
    NV_GPU_THERMAL_POLICY_DTC_VF_CONTROL_V1 dtcVf;
    NV_GPU_THERMAL_POLICY_DTC_VOLT_CONTROL_V1 dtcVolt;
    NV_GPU_THERMAL_POLICY_DTC_PWR_CONTROL_V1 dtcPwr;
    NvU8 rsvd[32];
  } data;
} NV_GPU_THERMAL_POLICY_CONTROL_V1;
typedef struct {
  NvU32 version;
  NvU32 policyMask;
  NvU8 rsvd[16];
  NV_GPU_THERMAL_POLICY_CONTROL_V1 policies[NV_GPU_THERMAL_POLICY_MAX_POLICIES_V1];
} NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1;
#define NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1, 1)
#define NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1, 2)
#define NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_VER_2
#define NV_GPU_THERMAL_POLICY_CONTROL_PARAMS NV_GPU_THERMAL_POLICY_CONTROL_PARAMS_V1
NVAPI_INTERFACE NvAPI_GPU_ThermalPolicyGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_THERMAL_POLICY_CONTROL_PARAMS *pPolicyControl);
NVAPI_INTERFACE NvAPI_GPU_ThermalPolicySetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __in NV_GPU_THERMAL_POLICY_CONTROL_PARAMS *pPolicyControl);
typedef enum {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_GPS,
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ACOUSTIC,
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID;
typedef enum {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_BASE,
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_PFF,
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS;
typedef enum {
  NV_GPU_CLIENT_THERMAL_READING_ID_GPU_AVG,
  NV_GPU_CLIENT_THERMAL_READING_ID_GPU_MAX,
  NV_GPU_CLIENT_THERMAL_READING_ID_BOARD,
  NV_GPU_CLIENT_THERMAL_READING_ID_MEMORY,
  NV_GPU_CLIENT_THERMAL_READING_ID_PWR_SUPPLY
} NV_GPU_CLIENT_THERMAL_READING_ID;
typedef struct {
  NV_GPU_CLIENT_PFF_CURVE_V1 curve;
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_INFO_PFF_V1;
typedef union {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_INFO_PFF_V1 pff;
  NvU8 rsvd[256];
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_INFO_UNION_V1;
#define NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX 4
typedef struct {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;
  NV_GPU_CLIENT_THERMAL_READING_ID channelId;
  NvS32 thermalLimitMin;
  NvS32 thermalLimitDefault;
  NvS32 thermalLimitMax;
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V1;
typedef struct {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;
  NV_GPU_CLIENT_THERMAL_READING_ID channelId;
  NvS32 thermalLimitMin;
  NvS32 thermalLimitDefault;
  NvS32 thermalLimitMax;
  NvU8 acousticPreferenceAvailable : 1;
  NvU8 reserved : 7;
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V2;
typedef struct {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS policyClass;
  NV_GPU_CLIENT_THERMAL_READING_ID channelId;
  NvS32 thermalLimitMin;
  NvS32 thermalLimitDefault;
  NvS32 thermalLimitMax;
  NvU8 acousticPreferenceAvailable : 1;
  NvU8 reserved : 7;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_INFO_UNION_V1 classInfo;
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V3;
typedef struct {
  NvU32 version;
  NvU8 isSupported : 1;
  NvU8 reserved : 7;
  NvU8 numPolicies;
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V1
  policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V1;
typedef struct _NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V2 {
  NvU32 version;
  NvU8 isSupported : 1;
  NvU8 reserved : 7;
  NvU8 numPolicies;
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V2
  policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V2;
typedef struct _NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V3 {
  NvU32 version;
  NvU8 isSupported : 1;
  NvU8 reserved : 7;
  NvU8 numPolicies;
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V3
  policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V3;
#define NV_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V1, 1)
#define NV_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_2 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V2, 2)
#define NV_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_3 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V3, 3)
#define NV_GPU_CLIENT_THERMAL_POLICIES_INFO_VER NV_GPU_CLIENT_THERMAL_POLICIES_INFO_VER_3
typedef NV_GPU_CLIENT_THERMAL_POLICIES_INFO_V3 NV_GPU_CLIENT_THERMAL_POLICIES_INFO;
typedef NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO_V3 NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_INFO;
NVAPI_INTERFACE NvAPI_GPU_ClientThermalPoliciesGetInfo(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_THERMAL_POLICIES_INFO *pClientThermalPoliciesInfo);
typedef struct {
  NvBool bPffCurveChanged;
  NV_GPU_CLIENT_PFF_CURVE_V1 curve;
  NV_GPU_CLIENT_PFF_CURVE_STATUS_V1 curveRuntimeStatus;
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_STATUS_PFF_V1;
typedef union {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_STATUS_PFF_V1 pff;
  NvU8 rsvd[256];
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_STATUS_UNION_V1;
typedef struct {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;
  NvS32 thermalLimit;
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V1;
typedef struct _NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V2 {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;
  NvS32 thermalLimit;
  NvU8 preferAcoustics : 1;
  NvU8 reserved : 7;
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V2;
typedef struct _NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V3 {
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_ID policyId;
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS policyClass;
  NvS32 thermalLimit;
  NvU8 preferAcoustics : 1;
  NvU8 reserved : 7;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_CLASS_STATUS_UNION_V1 classStatus;
} NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V3;
typedef struct {
  NvU32 version;
  NvU8 numPolicies;
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V1
  policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1;
typedef struct _NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2 {
  NvU32 version;
  NvU8 numPolicies;
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V2
  policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2;
typedef struct _NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V3 {
  NvU32 version;
  NvU8 numPolicies;
  NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V3
  policies[NV_GPU_CLIENT_THERMAL_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V3;
#define NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V1, 1)
#define NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V2, 2)
#define NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_3 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V3, 3)
#define NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_VER_3
typedef NV_GPU_CLIENT_THERMAL_POLICIES_STATUS_V3 NV_GPU_CLIENT_THERMAL_POLICIES_STATUS;
typedef NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS_V3 NV_GPU_CLIENT_THERMAL_POLICIES_POLICY_STATUS;
NVAPI_INTERFACE NvAPI_GPU_ClientThermalPoliciesGetStatus(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_THERMAL_POLICIES_STATUS *pClientThermalPoliciesStatus);
NVAPI_INTERFACE NvAPI_GPU_ClientThermalPoliciesSetStatus(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_THERMAL_POLICIES_STATUS *pClientThermalPoliciesStatus);
#define NVAPI_GPU_THERMAL_TABLE_MAX_ENTRIES (256)
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 ttVersion;
  NvU32 numEntries;
  NvU32 entryList[NVAPI_GPU_THERMAL_TABLE_MAX_ENTRIES];
} NV_GPU_THERMAL_TABLE;
#define NV_GPU_THERMAL_TABLE_VER MAKE_NVAPI_VERSION(NV_GPU_THERMAL_TABLE, 1)
NVAPI_INTERFACE NvAPI_GPU_GetThermalTable(NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_THERMAL_TABLE *pThermalTable);
#define NV_GPU_THERMAL_THERM_DEVICE_MAX_V1 32
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_CLASS {
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_INVALID = 0x00,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_GPU = 0x01,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_GPU_GPC_TSOSC = 0x02,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_GPU_SCI = 0x03,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_GPU_GPC_COMBINED = 0x04,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_GDDR6_X_COMBINED = 0x05,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_ADM1032 = 0x41,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_MAX6649 = 0x43,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_TMP411 = 0x44,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_ADT7461 = 0x45,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_I2C_TMP451 = 0x46,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_HBM2_SITE = 0x70,
  NV_GPU_THERMAL_THERM_DEVICE_CLASS_HBM2_COMBINED = 0x71
} NV_GPU_THERMAL_THERM_DEVICE_CLASS;
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV {
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_TSENSE = 0x00,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_TSENSE_OFFSET = 0x01,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_CONST = 0x02,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_MAX = 0x03,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_GPU_MAX = 0x04,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_GPU_AVG = 0x05,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_GPU_OFFSET_MAX = 0x06,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_GPU_OFFSET_AVG = 0x07,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_DYNAMIC_HOTSPOT = 0x08,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV_DYNAMIC_HOTSPOT_OFFSET = 0x09
} NV_GPU_THERMAL_THERM_DEVICE_GPU_PROV;
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_GPU_GPC_TSOSC_PROV {
  NV_GPU_THERMAL_THERM_DEVICE_GPU_GPC_TSOSC_PROV_TSOSC = 0x00,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_GPC_TSOSC_PROV_TSOSC_OFFSET = 0x01
} NV_GPU_THERMAL_THERM_DEVICE_GPU_GPC_TSOSC_PROV;
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_GPU_SCI_PROV {
  NV_GPU_THERMAL_THERM_DEVICE_GPU_SCI_PROV_MINI_TSENSE = 0x00
} NV_GPU_THERMAL_THERM_DEVICE_GPU_SCI_PROV;
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_GPU_GPC_COMBINED_PROV {
  NV_GPU_THERMAL_THERM_DEVICE_GPU_GPC_COMBINED_PROV_GPC_AVG_UNMUNGED = 0x00,
  NV_GPU_THERMAL_THERM_DEVICE_GPU_GPC_COMBINED_PROV_GPC_AVG_MUNGED = 0x01,
} NV_GPU_THERMAL_THERM_DEVICE_GPU_GPC_COMBINED_PROV;
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_I2C_TMP411_PROV {
  NV_GPU_THERMAL_THERM_DEVICE_I2C_TMP411_PROV_LOW_PRECISION_EXT = 0x00,
  NV_GPU_THERMAL_THERM_DEVICE_I2C_TMP411_PROV_LOW_PRECISION_INT = 0x01
} NV_GPU_THERMAL_THERM_DEVICE_I2C_TMP411_PROV;
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_HBM2_SITE_PROV {
  NV_GPU_THERMAL_THERM_DEVICE_HBM2_SITE_PROV_DEFAULT = 0x00,
} NV_GPU_THERMAL_THERM_DEVICE_HBM2_SITE_PROV;
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_HBM2_COMBINED_PROV {
  NV_GPU_THERMAL_THERM_DEVICE_HBM2_COMBINED_PROV_MAX = 0x00,
} NV_GPU_THERMAL_THERM_DEVICE_HBM2_COMBINED_PROV;
typedef enum _NV_GPU_THERMAL_THERM_DEVICE_GDDR6_X_COMBINED_PROV {
  NV_GPU_THERMAL_THERM_DEVICE_GDDR6_X_COMBINED_PROV_MAX = 0x00,
} NV_GPU_THERMAL_THERM_DEVICE_GDDR6_X_COMBINED_PROV;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C {
  NvU8 i2cDevIdx;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADT7461 {
  NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C i2c;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADT7461;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP411 {
  NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C i2c;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP411;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_MAX6649 {
  NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C i2c;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_MAX6649;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADM1032 {
  NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C i2c;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADM1032;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP451 {
  NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C i2c;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP451;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_GPU_GPC_TSOSC {
  NvU8 gpcTsoscIdx;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_GPU_GPC_TSOSC;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_HBM2_SITE {
  NvU8 siteIdx;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_HBM2_SITE;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_V1 {
  NV_GPU_THERMAL_THERM_DEVICE_CLASS devClass;
  NvU8 rsvd[32];
  union {
    NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADM1032 adm1032;
    NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_MAX6649 max6649;
    NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP411 tmp411;
    NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_ADT7461 adt7461;
    NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_I2C_TMP451 tmp451;
    NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_GPU_GPC_TSOSC gpuGpcTsosc;
    NV_GPU_THERMAL_THERM_DEVICE_INFO_DATA_HBM2_SITE hbm2Site;
    NvU8 rsvd[16];
  } data;
} NV_GPU_THERMAL_THERM_DEVICE_INFO_V1;
typedef struct _NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 deviceMask;
  NvU8 rsvd[32];
  NV_GPU_THERMAL_THERM_DEVICE_INFO_V1
  device[NV_GPU_THERMAL_THERM_DEVICE_MAX_V1];
} NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1;
#define NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1, 1)
#define NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_VER NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_VER_1
typedef NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS_V1 NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_ThermDeviceGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_THERMAL_THERM_DEVICE_INFO_PARAMS *pThermDeviceInfo);
#define NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1 0x05
#define NV_GPU_THERMAL_THERM_CHANNEL_MAX_V2 32
typedef enum _NV_GPU_THERMAL_CHANNEL_CLASS {
  NV_GPU_THERMAL_THERM_CHANNEL_CLASS_INVALID = 0x00,
  NV_GPU_THERMAL_THERM_CHANNEL_CLASS_DEVICE
} NV_GPU_THERMAL_THERM_CHANNEL_CLASS;
typedef enum _NV_GPU_THERMAL_THERM_CHANNEL_TYPE {
  NV_GPU_THERMAL_THERM_CHANNEL_TYPE_GPU_AVG = 0x00,
  NV_GPU_THERMAL_THERM_CHANNEL_TYPE_GPU_MAX,
  NV_GPU_THERMAL_THERM_CHANNEL_TYPE_BOARD,
  NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MEMORY,
  NV_GPU_THERMAL_THERM_CHANNEL_TYPE_PWR_SUPPLY,
  NV_GPU_THERMAL_THERM_CHANNEL_TYPE_INVALID = 0xFF
} NV_GPU_THERMAL_THERM_CHANNEL_TYPE;
typedef enum _NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC {
  NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC_INT = 0x00,
  NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC_EXT
} NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC;
typedef enum _NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU {
  NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_0 = 0x00,
  NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_1,
  NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_2,
  NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU_3
} NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU;
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_INFO_DATA_DEVICE {
  NvU8 thermDevIdx;
  NvU8 thermDevProvIdx;
} NV_GPU_THERMAL_THERM_CHANNEL_INFO_DATA_DEVICE;
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_INFO_V1 {
  NV_GPU_THERMAL_THERM_CHANNEL_CLASS chClass;
  NV_GPU_THERMAL_THERM_CHANNEL_TYPE chType;
  NV_GPU_THERMAL_THERM_CHANNEL_REL_LOC relLoc;
  NV_GPU_THERMAL_THERM_CHANNEL_TGT_GPU tgtGPU;
  NvS32 scaling;
  NvS32 offsetSw;
  NvS32 minTemp;
  NvS32 maxTemp;
  NvU8 bIsTempSimSupported;
  NvU8 flags;
  NvS32 offsetHw;
  NvU8 rsvd[28];
  union {
    NV_GPU_THERMAL_THERM_CHANNEL_INFO_DATA_DEVICE device;
    NvU8 rsvd[16];
  } data;
} NV_GPU_THERMAL_THERM_CHANNEL_INFO_V1;
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 channelMask;
  NvU8 rsvd[32];
  NV_GPU_THERMAL_THERM_CHANNEL_INFO_V1
  channel[NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1;
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V2 {
  NvU32 version;
  NvU32 channelMask;
  NvU8 rsvd[32];
  NV_GPU_THERMAL_THERM_CHANNEL_INFO_V1
  channel[NV_GPU_THERMAL_THERM_CHANNEL_MAX_V2];
  NvU8 priChIdx[NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V2;
#define NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER_1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V1, 1)
#define NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER_2                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V2, 2)
#define NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_VER_2
typedef NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS_V2 NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_ThermChannelGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_THERMAL_THERM_CHANNEL_INFO_PARAMS *pThermChannelInfo);
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_STATUS_V1 {
  NvS32 currentTemp;
} NV_GPU_THERMAL_THERM_CHANNEL_STATUS_V1;
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1 {
  NvU32 version;
  NvU32 channelMask;
  NvU8 rsvd[32];
  NV_GPU_THERMAL_THERM_CHANNEL_STATUS_V1
  channel[NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1;
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V2 {
  NvU32 version;
  NvU32 channelMask;
  NvU8 rsvd[32];
  NV_GPU_THERMAL_THERM_CHANNEL_STATUS_V1
  channel[NV_GPU_THERMAL_THERM_CHANNEL_MAX_V2];
} NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V2;
#define NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER_1                                                               \
  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V1, 1)
#define NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER_2                                                               \
  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V2, 2)
#define NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_VER_2
typedef NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS_V2 NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_ThermChannelGetStatus(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_THERM_CHANNEL_STATUS_PARAMS *pThermChannelStatus);
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1 {
  NvU8 bTempSimEnable;
  NvS32 targetTemp;
  NvU8 rsvd[32];
} NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1;
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1 {
  NvU32 version;
  NvU32 channelMask;
  NvU8 rsvd[32];
  NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1
  channel[NV_GPU_THERMAL_THERM_CHANNEL_TYPE_MAX_TYPE_V1];
} NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1;
typedef struct _NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V2 {
  NvU32 version;
  NvU32 channelMask;
  NvU8 rsvd[32];
  NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_V1
  channel[NV_GPU_THERMAL_THERM_CHANNEL_MAX_V2];
} NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V2;
#define NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER_1                                                              \
  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V1, 1)
#define NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER_2                                                              \
  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V2, 2)
#define NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_VER_2
typedef NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS_V2 NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_ThermChannelGetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS *pThermChannelControl);
NVAPI_INTERFACE NvAPI_GPU_ThermChannelSetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_THERMAL_THERM_CHANNEL_CONTROL_PARAMS *pThermChannelControl);
#define NV_GPU_THERMAL_THERM_MONITORS_MAX_V1 (32)
typedef enum {
  NV_GPU_THERMAL_THERM_MONITOR_CLASS_INVALID = 0,
  NV_GPU_THERMAL_THERM_MONITOR_CLASS_VOLTAGE_REGULATOR = 1,
  NV_GPU_THERMAL_THERM_MONITOR_CLASS_BLOCK_ACTIVITY = 2,
  NV_GPU_THERMAL_THERM_MONITOR_CLASS_EDPP_VMIN = 3,
  NV_GPU_THERMAL_THERM_MONITOR_CLASS_EDPP_FONLY = 4,
  NV_GPU_THERMAL_THERM_MONITOR_CLASS_ADC_IPC = 5,
  NV_GPU_THERMAL_THERM_MONITOR_CLASS_ADC_VID = 6,
} NV_GPU_THERMAL_THERM_MONITOR_CLASS;
typedef struct {
  NV_GPU_THERMAL_THERM_MONITOR_CLASS monitorClass;
  NvU8 phyInstIdx;
  NvU8 rsvd[64];
} NV_GPU_THERMAL_THERM_MONITOR_INFO_V1, *PNV_GPU_THERMAL_THERM_MONITOR_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 monitorMask;
  NvU32 utilsClkFreqKhz;
  NvU8 rsvd[64];
  NV_GPU_THERMAL_THERM_MONITOR_INFO_V1 monitors[NV_GPU_THERMAL_THERM_MONITORS_MAX_V1];
} NV_GPU_THERMAL_THERM_MONITORS_INFO_V1, *PNV_GPU_THERMAL_THERM_MONITORS_INFO_V1;
typedef NV_GPU_THERMAL_THERM_MONITORS_INFO_V1 NV_GPU_THERMAL_THERM_MONITORS_INFO;
#define NV_GPU_THERMAL_THERM_MONITORS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_MONITORS_INFO_V1, 1)
#define NV_GPU_THERMAL_THERM_MONITORS_INFO_VER NV_GPU_THERMAL_THERM_MONITORS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ThermMonitorsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_GPU_THERMAL_THERM_MONITORS_INFO *pThermMonitorInfo);
typedef struct {
  NV_GPU_THERMAL_THERM_MONITOR_CLASS monitorClass;
  NvU64 counter;
  NvU8 rsvd[64];
} NV_GPU_THERMAL_THERM_MONITOR_STATUS_V1, *PNV_GPU_THERMAL_THERM_MONITOR_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 monitorMask;
  NvU8 rsvd[64];
  NV_GPU_THERMAL_THERM_MONITOR_STATUS_V1 monitors[NV_GPU_THERMAL_THERM_MONITORS_MAX_V1];
} NV_GPU_THERMAL_THERM_MONITORS_STATUS_V1, *PNV_GPU_THERMAL_THERM_MONITORS_STATUS_V1;
typedef NV_GPU_THERMAL_THERM_MONITORS_STATUS_V1 NV_GPU_THERMAL_THERM_MONITORS_STATUS;
#define NV_GPU_THERMAL_THERM_MONITORS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_THERMAL_THERM_MONITORS_STATUS_V1, 1)
#define NV_GPU_THERMAL_THERM_MONITORS_STATUS_VER NV_GPU_THERMAL_THERM_MONITORS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_ThermMonitorsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_THERMAL_THERM_MONITORS_STATUS *pThermMonitorStatus);
#define NV_GPU_THERM_EVENT_MASK_EXTERNAL                                                                               \
  (NV_BIT(NV_GPU_THERMAL_HWFS_EVENT_EXT_OVERT) | NV_BIT(NV_GPU_THERMAL_HWFS_EVENT_EXT_ALERT) |                         \
   NV_BIT(NV_GPU_THERMAL_HWFS_EVENT_EXT_POWER) | NV_BIT(NV_GPU_THERMAL_HWFS_EVENT_EXT_ALERT_0) |                       \
   NV_BIT(NV_GPU_THERMAL_HWFS_EVENT_EXT_ALERT_1))
typedef struct _NV_GPU_SLOWDOWN_AMOUNT {
  NvU32 num;
  NvU32 denom;
} NV_GPU_THERMAL_SLOWDOWN_AMOUNT;
typedef enum _NV_GPU_THERMAL_HWFS_EVENT {
  NV_GPU_THERMAL_HWFS_EVENT_EXT_OVERT,
  NV_GPU_THERMAL_HWFS_EVENT_EXT_ALERT,
  NV_GPU_THERMAL_HWFS_EVENT_EXT_POWER,
  NV_GPU_THERMAL_HWFS_EVENT_OVERT,
  NV_GPU_THERMAL_HWFS_EVENT_ALERT_0H,
  NV_GPU_THERMAL_HWFS_EVENT_ALERT_1H,
  NV_GPU_THERMAL_HWFS_EVENT_ALERT_2H,
  NV_GPU_THERMAL_HWFS_EVENT_ALERT_3H,
  NV_GPU_THERMAL_HWFS_EVENT_ALERT_4H,
  NV_GPU_THERMAL_HWFS_EVENT_ALERT_NEG1H,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_0,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_1,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_2,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_3,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_4,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_5,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_6,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_7,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_8,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_9,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_10,
  NV_GPU_THERMAL_HWFS_EVENT_THERMAL_11,
  NV_GPU_THERMAL_HWFS_EVENT_DEDICATED_OVERT,
  NV_GPU_THERMAL_HWFS_EVENT_SCI_FS_OVERT,
  NV_GPU_THERMAL_HWFS_EVENT_EXT_ALERT_0,
  NV_GPU_THERMAL_HWFS_EVENT_EXT_ALERT_1,
  NV_GPU_THERMAL_HWFS_EVENT_COUNT,
} NV_GPU_THERMAL_HWFS_EVENT_ID;
typedef struct _NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1 {
  NvU32 version;
  NvBool bIncludeHotspotOffset;
  NvU8 sensorId;
  NvU8 rsvd[30];
  NV_GPU_THERMAL_HWFS_EVENT_ID eventId;
  NvS32 temperature;
  NV_GPU_THERMAL_SLOWDOWN_AMOUNT slowdown;
} NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1;
#define NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1, 1)
#define NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_VER NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_VER1
typedef NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS_V1 NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_ThermalHwFsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS *pthermalHwFsEventInfo);
NVAPI_INTERFACE NvAPI_GPU_ThermalHwFsSetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_THERMAL_HWFS_EVENT_SETTINGS_PARAMS *pthermalHwFsEventInfo);
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_DOMAIN_ID clkDomain;
  NvU32 numerator;
  NvU32 denominator;
  NvU8 rsvd[32];
} NV_GPU_THERMAL_HWFS_SLOWDOWN_AMOUNT_GET_PARAMS_V1, *PNV_GPU_THERMAL_HWFS_SLOWDOWN_AMOUNT_GET_PARAMS_V1;
typedef NV_GPU_THERMAL_HWFS_SLOWDOWN_AMOUNT_GET_PARAMS_V1 NV_GPU_THERMAL_HWFS_SLOWDOWN_AMOUNT_GET_PARAMS;
#define NV_GPU_THERMAL_HWFS_SLOWDOWN_AMOUNT_GET_PARAMS_VER1                                                            \
  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_HWFS_SLOWDOWN_AMOUNT_GET_PARAMS_V1, 1)
#define NV_GPU_THERMAL_HWFS_SLOWDOWN_AMOUNT_GET_PARAMS_VER NV_GPU_THERMAL_HWFS_SLOWDOWN_AMOUNT_GET_PARAMS_VER1
NVAPI_INTERFACE NvAPI_GPU_ThermHwFsSlowdownAmountGet(
    __in NvPhysicalGpuHandle hPhysicalGpu,
    __inout NV_GPU_THERMAL_HWFS_SLOWDOWN_AMOUNT_GET_PARAMS *pThermSlowdownParams);
NVAPI_INTERFACE NvAPI_GPU_GetCurrentThermalLevel(NvPhysicalGpuHandle nvGPUHandle, NV_EVENT_LEVEL *pThermalLevel);
typedef struct _NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_SAMPLE_V1 {
  NV_GPU_PMUMON_SAMPLE_SUPER_V1 super;
  NvS32 temperature[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
  NvU8 rsvd[64];
} NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_SAMPLE_V1;
#define NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_SAMPLE_COUNT_V1 (50U)
typedef struct _NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_GET_SAMPLES_V1 {
  NvU32 version;
  NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 super;
  NvU8 rsvd[64];
  NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_SAMPLE_V1 samples[NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_SAMPLE_COUNT_V1];
} NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_GET_SAMPLES_V1;
typedef NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_GET_SAMPLES_V1 NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_GET_SAMPLES;
#define NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_GET_SAMPLES_VER1                                                          \
  MAKE_NVAPI_VERSION(NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_GET_SAMPLES_V1, 1)
#define NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_GET_SAMPLES_VER NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_GET_SAMPLES_VER1
NVAPI_INTERFACE NvAPI_GPU_ThermalPmumonThermChannelsGetSamples(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_THERMAL_PMUMON_THERM_CHANNELS_GET_SAMPLES *pGetSamplesParams);
#define NVAPI_MAX_COOLERS_PER_GPU_VER1 3
#define NVAPI_MAX_COOLERS_PER_GPU_VER2 20
#define NVAPI_MAX_COOLERS_PER_GPU_VER3 NVAPI_MAX_COOLERS_PER_GPU_VER2
#define NVAPI_MAX_COOLERS_PER_GPU_VER4 NVAPI_MAX_COOLERS_PER_GPU_VER2
#define NVAPI_MAX_COOLERS_PER_GPU NVAPI_MAX_COOLERS_PER_GPU_VER3
#define NVAPI_MIN_COOLER_LEVEL 0
#define NVAPI_MAX_COOLER_LEVEL 100
#define NVAPI_MAX_COOLER_LEVELS 24
typedef enum {
  NVAPI_COOLER_TYPE_NONE = 0,
  NVAPI_COOLER_TYPE_FAN,
  NVAPI_COOLER_TYPE_WATER,
  NVAPI_COOLER_TYPE_LIQUID_NO2,
} NV_COOLER_TYPE;
typedef enum {
  NVAPI_COOLER_CONTROLLER_NONE = 0,
  NVAPI_COOLER_CONTROLLER_ADI,
  NVAPI_COOLER_CONTROLLER_INTERNAL,
} NV_COOLER_CONTROLLER;
typedef enum {
  NVAPI_COOLER_POLICY_NONE = 0x00000000,
  NVAPI_COOLER_POLICY_MANUAL = 0x00000001,
  NVAPI_COOLER_POLICY_PERF = 0x00000002,
  NVAPI_COOLER_POLICY_TEMPERATURE_DISCRETE = 0x00000004,
  NVAPI_COOLER_POLICY_TEMPERATURE_CONTINUOUS = 0x00000008,
  NVAPI_COOLER_POLICY_TEMPERATURE_CONTINUOUS_SW = 0x00000010,
  NVAPI_COOLER_POLICY_DEFAULT = 0x00000020,
} NV_COOLER_POLICY;
typedef enum {
  NVAPI_COOLER_TARGET_NONE = 0,
  NVAPI_COOLER_TARGET_GPU,
  NVAPI_COOLER_TARGET_MEMORY,
  NVAPI_COOLER_TARGET_POWER_SUPPLY = 4,
  NVAPI_COOLER_TARGET_ALL = 7,
  NVAPI_COOLER_TARGET_VCD_COOLER1 = 8,
  NVAPI_COOLER_TARGET_VCD_COOLER2,
  NVAPI_COOLER_TARGET_VCD_COOLER3,
  NVAPI_COOLER_TARGET_VCD_COOLER4,
  NVAPI_COOLER_TARGET_VCD_COOLER5,
  NVAPI_COOLER_TARGET_VCD_COOLER6,
  NVAPI_COOLER_TARGET_VCD_COOLER7,
  NVAPI_COOLER_TARGET_VCD_COOLER8,
  NVAPI_COOLER_TARGET_VCD_COOLER9,
  NVAPI_COOLER_TARGET_VCD_COOLER10,
  NVAPI_COOLER_TARGET_VCD_COOLER11,
  NVAPI_COOLER_TARGET_VCD_COOLER12,
  NVAPI_COOLER_TARGET_VCD_COOLER13,
  NVAPI_COOLER_TARGET_VCD_COOLER14,
  NVAPI_COOLER_TARGET_VCD_COOLER15,
  NVAPI_COOLER_TARGET_VCD_COOLER16,
  NVAPI_COOLER_TARGET_VCD_COOLER17,
  NVAPI_COOLER_TARGET_VCD_COOLER18,
  NVAPI_COOLER_TARGET_VCD_COOLER19,
  NVAPI_COOLER_TARGET_VCD_COOLER20,
} NV_COOLER_TARGET;
typedef enum {
  NVAPI_COOLER_CONTROL_NONE = 0,
  NVAPI_COOLER_CONTROL_TOGGLE,
  NVAPI_COOLER_CONTROL_VARIABLE,
} NV_COOLER_CONTROL;
typedef enum {
  NVAPI_INACTIVE = 0,
  NVAPI_ACTIVE = 1,
} NV_COOLER_ACTIVITY_LEVEL;
typedef struct {
  NvU32 speedRPM;
  NvU8 bSupported;
  NvU32 maxSpeedRPM;
  NvU32 minSpeedRPM;
} NV_COOLER_TACHOMETER;
typedef struct {
  NvU32 version;
  NvU32 count;
  struct {
    NV_COOLER_TYPE type;
    NV_COOLER_CONTROLLER controller;
    NvU32 defaultMinLevel;
    NvU32 defaultMaxLevel;
    NvU32 currentMinLevel;
    NvU32 currentMaxLevel;
    NvU32 currentLevel;
    NV_COOLER_POLICY defaultPolicy;
    NV_COOLER_POLICY currentPolicy;
    NV_COOLER_TARGET target;
    NV_COOLER_CONTROL controlType;
    NV_COOLER_ACTIVITY_LEVEL active;
  } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER1];
} NV_GPU_GETCOOLER_SETTINGS_V1;
typedef struct {
  NvU32 version;
  NvU32 count;
  struct {
    NV_COOLER_TYPE type;
    NV_COOLER_CONTROLLER controller;
    NvU32 defaultMinLevel;
    NvU32 defaultMaxLevel;
    NvU32 currentMinLevel;
    NvU32 currentMaxLevel;
    NvU32 currentLevel;
    NV_COOLER_POLICY defaultPolicy;
    NV_COOLER_POLICY currentPolicy;
    NV_COOLER_TARGET target;
    NV_COOLER_CONTROL controlType;
    NV_COOLER_ACTIVITY_LEVEL active;
  } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER2];
} NV_GPU_GETCOOLER_SETTINGS_V2;
typedef struct {
  NvU32 version;
  NvU32 count;
  struct {
    NV_COOLER_TYPE type;
    NV_COOLER_CONTROLLER controller;
    NvU32 defaultMinLevel;
    NvU32 defaultMaxLevel;
    NvU32 currentMinLevel;
    NvU32 currentMaxLevel;
    NvU32 currentLevel;
    NV_COOLER_POLICY defaultPolicy;
    NV_COOLER_POLICY currentPolicy;
    NV_COOLER_TARGET target;
    NV_COOLER_CONTROL controlType;
    NV_COOLER_ACTIVITY_LEVEL active;
    NV_COOLER_TACHOMETER tachometer;
  } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER3];
} NV_GPU_GETCOOLER_SETTINGS_V3;
typedef struct {
  NvU32 version;
  NvU32 count;
  struct {
    NV_COOLER_TYPE type;
    NV_COOLER_CONTROLLER controller;
    NvU32 defaultMinLevel;
    NvU32 defaultMaxLevel;
    NvU32 currentMinLevel;
    NvU32 currentMaxLevel;
    NvU32 currentLevel;
    NV_COOLER_POLICY defaultPolicy;
    NV_COOLER_POLICY currentPolicy;
    NV_COOLER_TARGET target;
    NV_COOLER_CONTROL controlType;
    NV_COOLER_ACTIVITY_LEVEL active;
    NV_COOLER_TACHOMETER tachometer;
    NvU32 supportedPolicies;
  } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER4];
} NV_GPU_GETCOOLER_SETTINGS_V4;
#define NV_GPU_GETCOOLER_SETTINGS NV_GPU_GETCOOLER_SETTINGS_V4
#define NV_GPU_GETCOOLER_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V1, 1)
#define NV_GPU_GETCOOLER_SETTINGS_VER2A MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V2, 1)
#define NV_GPU_GETCOOLER_SETTINGS_VER2 MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V2, 2)
#define NV_GPU_GETCOOLER_SETTINGS_VER3 MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V3, 3)
#define NV_GPU_GETCOOLER_SETTINGS_VER4 MAKE_NVAPI_VERSION(NV_GPU_GETCOOLER_SETTINGS_V4, 4)
#define NV_GPU_GETCOOLER_SETTINGS_VER NV_GPU_GETCOOLER_SETTINGS_VER4
typedef struct {
  NvU32 version;
  struct {
    NvU32 currentLevel;
    NV_COOLER_POLICY currentPolicy;
  } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER1];
} NV_GPU_SETCOOLER_LEVEL_V1;
typedef struct {
  NvU32 version;
  struct {
    NvU32 currentLevel;
    NV_COOLER_POLICY currentPolicy;
  } cooler[NVAPI_MAX_COOLERS_PER_GPU_VER2];
} NV_GPU_SETCOOLER_LEVEL_V2;
#define NV_GPU_SETCOOLER_LEVEL NV_GPU_SETCOOLER_LEVEL_V2
#define NV_GPU_SETCOOLER_LEVEL_VER1 MAKE_NVAPI_VERSION(NV_GPU_SETCOOLER_LEVEL_V1, 1)
#define NV_GPU_SETCOOLER_LEVEL_VER2 MAKE_NVAPI_VERSION(NV_GPU_SETCOOLER_LEVEL_V2, 1)
#define NV_GPU_SETCOOLER_LEVEL_VER NV_GPU_SETCOOLER_LEVEL_VER2
typedef struct {
  NvU32 version;
  NV_COOLER_POLICY policy;
  struct {
    NvU32 levelId;
    NvU32 currentLevel;
    NvU32 defaultLevel;
  } policyCoolerLevel[NVAPI_MAX_COOLER_LEVELS];
} NV_GPU_COOLER_POLICY_TABLE;
#define NV_GPU_COOLER_POLICY_TABLE_VER MAKE_NVAPI_VERSION(NV_GPU_COOLER_POLICY_TABLE, 1)
NVAPI_INTERFACE NvAPI_GPU_GetCoolerSettings(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex,
                                            NV_GPU_GETCOOLER_SETTINGS *pCoolerInfo);
NVAPI_INTERFACE NvAPI_GPU_SetCoolerLevels(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex,
                                          NV_GPU_SETCOOLER_LEVEL *pCoolerLevels);
NVAPI_INTERFACE NvAPI_GPU_RestoreCoolerSettings(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCoolerIndex,
                                                NvU32 coolerCount);
NVAPI_INTERFACE NvAPI_GPU_GetCoolerPolicyTable(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex,
                                               NV_GPU_COOLER_POLICY_TABLE *pCoolerTable, NvU32 *count);
NVAPI_INTERFACE NvAPI_GPU_SetCoolerPolicyTable(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex,
                                               NV_GPU_COOLER_POLICY_TABLE *pCoolerTable, NvU32 count);
NVAPI_INTERFACE NvAPI_GPU_RestoreCoolerPolicyTable(NvPhysicalGpuHandle hPhysicalGpu, NvU32 *pCoolerIndex,
                                                   NvU32 coolerCount, NV_COOLER_POLICY policy);
#define NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MAJOR_REVISION 7 : 4
#define NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MAJOR_REVISION_1X 0x00000001
#define NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MINOR_REVISION 3 : 0
#define NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER_REVISION_MINOR_REVISION_0 0x00000000
typedef struct {
  NvU8 revision;
  NvU8 size;
} NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER;
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ENABLE 0 : 0
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ENABLE_DISABLED (0x00000000)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ENABLE_ENABLED (0x00000001)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_MODE 2 : 1
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_MODE_AUTOMATIC (0x00000000)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_MODE_MANUAL (0x00000001)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI 4 : 3
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_DISABLED (0x00000000)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_MASTER (0x00000001)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_SLAVE (0x00000002)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_GEMINI_SHARING (0x00000003)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ALGORITHM 7 : 5
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ALGORITHM_LINEAR (0x00000000)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_1X_CONTROL_FIELD_ALGORITHM_2_SEG (0x00000001)
typedef struct {
  NvS16 m;
  NvS16 b;
  NvS16 accelGain;
  NvS16 midpointGain;
  NvU8 historyCount;
  NvU8 lookback;
  NvU16 controlField;
  NvS16 slopeLimit0;
  NvS16 slope1;
  NvS16 gravity;
} NV_GPU_PMU_FAN_PRIVATE_DATA_1X;
typedef struct {
  NvU32 version;
  NV_GPU_PMU_FAN_PRIVATE_DATA_HEADER header;
  NV_GPU_PMU_FAN_PRIVATE_DATA_1X pvtData1X;
} NV_GPU_PMU_FAN_PRIVATE_DATA_V1;
#define NV_GPU_PMU_FAN_PRIVATE_DATA_VER1 MAKE_NVAPI_VERSION(NV_GPU_PMU_FAN_PRIVATE_DATA_V1, 1)
#define NV_GPU_PMU_FAN_PRIVATE_DATA_VER NV_GPU_PMU_FAN_PRIVATE_DATA_VER1
typedef NV_GPU_PMU_FAN_PRIVATE_DATA_V1 NV_GPU_PMU_FAN_PRIVATE_DATA;
#define NV_GPU_PMU_FAN_PWM_SOURCE 2 : 0
#define NV_GPU_PMU_FAN_PWM_SOURCE_INVALID 0x00000000
#define NV_GPU_PMU_FAN_PWM_SOURCE_PMGR_FAN 0x00000001
#define NV_GPU_PMU_FAN_PWM_SOURCE_PMGR_PWM 0x00000002
#define NV_GPU_PMU_FAN_PWM_SOURCE_THERM_PWM 0x00000003
#define NV_GPU_PMU_FAN_PWM_INVERT 3 : 3
#define NV_GPU_PMU_FAN_PWM_INVERT_DISABLED 0x00000000
#define NV_GPU_PMU_FAN_PWM_INVERT_ENABLED 0x00000001
#define NV_GPU_PMU_FAN_RAMP_SLOPE_NOT_USED 0
typedef struct {
  NvU32 version;
  NvU8 pwmPctMin;
  NvU8 pwmPctMax;
  NvU8 pwmPctManual;
  NvU8 pwmSource;
  NvS16 pwmScaleSlope;
  NvS16 pwmScaleOffset;
  NvU32 pwmRawPeriod;
  NvU16 pwmRampUpSlope;
  NvU16 pwmRampDownSlope;
} NV_GPU_PMU_FAN_FAN_DESCRIPTION_V1;
#define NV_GPU_PMU_FAN_FAN_DESCRIPTION_VER1 MAKE_NVAPI_VERSION(NV_GPU_PMU_FAN_FAN_DESCRIPTION_V1, 1)
#define NV_GPU_PMU_FAN_FAN_DESCRIPTION_VER NV_GPU_PMU_FAN_FAN_DESCRIPTION_VER1
typedef NV_GPU_PMU_FAN_FAN_DESCRIPTION_V1 NV_GPU_PMU_FAN_FAN_DESCRIPTION;
typedef struct {
  NvU32 version;
  struct {
    NV_GPU_PMU_FAN_FAN_DESCRIPTION_V1 fanDesc;
    NV_GPU_PMU_FAN_PRIVATE_DATA_V1 pvtData;
  } ctrlBlk;
} NV_GPU_PMU_FAN_CONTROL_BLOCK_V1;
#define NV_GPU_PMU_FAN_CONTROL_BLOCK_VER1 MAKE_NVAPI_VERSION(NV_GPU_PMU_FAN_CONTROL_BLOCK_V1, 1)
#define NV_GPU_PMU_FAN_CONTROL_BLOCK_VER NV_GPU_PMU_FAN_CONTROL_BLOCK_VER1
typedef NV_GPU_PMU_FAN_CONTROL_BLOCK_V1 NV_GPU_PMU_FAN_CONTROL_BLOCK;
NVAPI_INTERFACE NvAPI_GPU_GetPmuFanControlBlock(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex,
                                                NV_GPU_PMU_FAN_CONTROL_BLOCK *pPmuFanControlBlock);
NVAPI_INTERFACE NvAPI_GPU_SetPmuFanControlBlock(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndex,
                                                NV_GPU_PMU_FAN_CONTROL_BLOCK *pPmuFanControlBlock);
#define NV_GPU_FAN_COOLER_MAX_COOLERS_V1 32
typedef enum _NV_GPU_FAN_COOLER_TYPE {
  NV_GPU_FAN_COOLER_TYPE_ACTIVE,
  NV_GPU_FAN_COOLER_TYPE_ACTIVE_PWM,
  NV_GPU_FAN_COOLER_TYPE_ACTIVE_PWM_TACH_CORR,
} NV_GPU_FAN_COOLER_TYPE;
typedef enum _NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE {
  NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE_NONE,
  NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE_PWM,
  NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE_RPM,
} NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE;
typedef struct _NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE {
  NvU32 gpioFuncTach;
  NvU8 tachRate;
  NvU32 bTachSupported : 1;
  NvU32 tachPin : 8;
  NvU32 rsvd : 23;
  NV_GPU_FAN_COOLER_CONTROL_UNIT_TYPE controlUnit;
} NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE;
typedef struct _NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM {
  NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE active;
  NvU32 gpioFuncFan;
  NvU32 freq;
  NvU32 maxFanEvtMask;
  NvU16 maxFanMinTimems;
} NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM;
typedef struct _NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM_TACH_CORR {
  NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM activePwm;
} NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM_TACH_CORR;
typedef struct _NV_GPU_FAN_COOLER_INFO_V1 {
  NV_GPU_FAN_COOLER_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE active;
    NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM activePwm;
    NV_GPU_FAN_COOLER_INFO_DATA_ACTIVE_PWM_TACH_CORR activePwmTachCorr;
    NvU8 rsvd[32];
  } data;
} NV_GPU_FAN_COOLER_INFO_V1;
typedef struct _NV_GPU_FAN_COOLER_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 coolerMask;
  NvU8 rsvd[32];
  NV_GPU_FAN_COOLER_INFO_V1 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_INFO_PARAMS_V1;
#define NV_GPU_FAN_COOLER_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_INFO_PARAMS_V1, 1)
#define NV_GPU_FAN_COOLER_INFO_PARAMS_VER NV_GPU_FAN_COOLER_INFO_PARAMS_VER_1
typedef NV_GPU_FAN_COOLER_INFO_PARAMS_V1 NV_GPU_FAN_COOLER_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_FanCoolerGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_GPU_FAN_COOLER_INFO_PARAMS *pFanCoolerInfo);
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1 {
  NvU32 rpmCurr;
  NvU32 levelMin;
  NvU32 levelMax;
  NvU32 levelCurrent;
  NvU32 levelTarget;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1;
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V1 {
  NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1 active;
  NvU32 pwmCurr;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V1;
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V1 {
  NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V1 activePwm;
  NvU32 rpmLast;
  NvU32 rpmTarget;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V1;
typedef struct _NV_GPU_FAN_COOLER_STATUS_V1 {
  NV_GPU_FAN_COOLER_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1 active;
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V1 activePwm;
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V1 activePwmTachCorr;
    NvU8 rsvd[32];
  } data;
} NV_GPU_FAN_COOLER_STATUS_V1;
typedef struct _NV_GPU_FAN_COOLER_STATUS_PARAMS_V1 {
  NvU32 version;
  NvU32 coolerMask;
  NvU8 rsvd[32];
  NV_GPU_FAN_COOLER_STATUS_V1 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_STATUS_PARAMS_V1;
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V2 {
  NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1 active;
  NvU32 pwmCurr;
  NvU32 pwmRequested;
  NvU8 bMaxFanActive;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V2;
typedef struct _NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V2 {
  NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V2 activePwm;
  NvU32 rpmLast;
  NvU32 rpmTarget;
  NvU32 pwmActual;
} NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V2;
typedef struct _NV_GPU_FAN_COOLER_STATUS_V2 {
  NV_GPU_FAN_COOLER_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_V1 active;
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_V2 activePwm;
    NV_GPU_FAN_COOLER_STATUS_DATA_ACTIVE_PWM_TACH_CORR_V2 activePwmTachCorr;
    NvU8 rsvd[96];
  } data;
} NV_GPU_FAN_COOLER_STATUS_V2;
typedef struct _NV_GPU_FAN_COOLER_STATUS_PARAMS_V2 {
  NvU32 version;
  NvU32 coolerMask;
  NvU8 rsvd[32];
  NV_GPU_FAN_COOLER_STATUS_V2 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_STATUS_PARAMS_V2;
#define NV_GPU_FAN_COOLER_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_STATUS_PARAMS_V1, 1)
#define NV_GPU_FAN_COOLER_STATUS_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_STATUS_PARAMS_V2, 2)
#define NV_GPU_FAN_COOLER_STATUS_PARAMS_VER NV_GPU_FAN_COOLER_STATUS_PARAMS_VER_2
typedef NV_GPU_FAN_COOLER_STATUS_PARAMS_V2 NV_GPU_FAN_COOLER_STATUS_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_FanCoolerGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_FAN_COOLER_STATUS_PARAMS *pFanCoolerStatus);
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1 {
  NvU32 rpmMin;
  NvU32 rpmMax;
  NvU32 bLevelSimActive : 1;
  NvU32 rsvd : 31;
  NvU32 levelSim;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1;
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V1 {
  NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1 active;
  NvU32 pwmMin;
  NvU32 pwmMax;
  NvU32 bPwmSimActive : 1;
  NvU32 rsvd : 31;
  NvU32 pwmSim;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V1;
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V1 {
  NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V1 activePwm;
  NvS32 propGain;
  NvU32 bRpmSimActive : 1;
  NvU32 rsvd : 31;
  NvU32 rpmSim;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V1;
typedef struct _NV_GPU_FAN_COOLER_CONTROL_V1 {
  NV_GPU_FAN_COOLER_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1 active;
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V1 activePwm;
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V1 activePwmTachCorr;
    NvU8 rsvd[32];
  } data;
} NV_GPU_FAN_COOLER_CONTROL_V1;
typedef struct _NV_GPU_FAN_COOLER_CONTROL_PARAMS_V1 {
  NvU32 version;
  NvU32 coolerMask;
  NvU32 retrieveDefault : 1;
  NvU32 reservedField : 31;
  NvU8 rsvd[32];
  NV_GPU_FAN_COOLER_CONTROL_V1 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_CONTROL_PARAMS_V1;
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V2 {
  NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1 active;
  NvU32 pwmMin;
  NvU32 pwmMax;
  NvU32 bPwmSimActive : 1;
  NvU32 rsvd : 31;
  NvU32 pwmSim;
  NvU32 maxFanPwm;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V2;
typedef struct _NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V2 {
  NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V2 activePwm;
  NvS32 propGain;
  NvU32 bRpmSimActive : 1;
  NvU32 rsvd : 31;
  NvU32 rpmSim;
  NvU32 pwmFloorLimitOffset;
} NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V2;
typedef struct _NV_GPU_FAN_COOLER_CONTROL_V2 {
  NV_GPU_FAN_COOLER_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_V1 active;
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_V2 activePwm;
    NV_GPU_FAN_COOLER_CONTROL_DATA_ACTIVE_PWM_TACH_CORR_V2 activePwmTachCorr;
    NvU8 rsvd[96];
  } data;
} NV_GPU_FAN_COOLER_CONTROL_V2;
typedef struct _NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2 {
  NvU32 version;
  NvU32 coolerMask;
  NvU32 retrieveDefault : 1;
  NvU32 reservedField : 31;
  NvU8 rsvd[32];
  NV_GPU_FAN_COOLER_CONTROL_V2 coolers[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
} NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2;
#define NV_GPU_FAN_COOLER_CONTROL_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_CONTROL_PARAMS_V1, 1)
#define NV_GPU_FAN_COOLER_CONTROL_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2, 2)
#define NV_GPU_FAN_COOLER_CONTROL_PARAMS_VER NV_GPU_FAN_COOLER_CONTROL_PARAMS_VER_2
typedef NV_GPU_FAN_COOLER_CONTROL_PARAMS_V2 NV_GPU_FAN_COOLER_CONTROL_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_FanCoolerGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_FAN_COOLER_CONTROL_PARAMS *pFanCoolerControl);
NVAPI_INTERFACE NvAPI_GPU_FanCoolerSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __in NV_GPU_FAN_COOLER_CONTROL_PARAMS *pFanCoolerControl);
#define NV_GPU_FAN_POLICY_MAX_POLICIES_V1 32
typedef enum _NV_GPU_FAN_POLICY_TYPE {
  NV_GPU_FAN_POLICY_TYPE_IIR_TJ_FIXED_DUAL_SLOPE_PWM = 0x00000000,
  NV_GPU_FAN_POLICY_TYPE_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V20 = 0x00000002,
  NV_GPU_FAN_POLICY_TYPE_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V30 = 0x00000003,
} NV_GPU_FAN_POLICY_TYPE;
typedef struct _NV_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM {
  NvU8 bUsePwm;
  NvU8 bFanStopSupported;
  NvU16 fanStartMinHoldTimems;
  NvU8 fanStopPowerTopologyIdx;
  NvU8 bFanStopEnableDefault;
} NV_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM;
typedef struct _NV_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V30 {
  NvU8 bUsePwm;
  NvU8 bFanStopSupported;
  NvU16 fanStartMinHoldTimems;
  NvU8 fanStopPowerTopologyIdx;
  NvU8 bFanStopEnableDefault;
  NvBool bFanCurvePt2TjOverride;
  NvBool bFanCurveAdjSupported;
} NV_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V30;
typedef struct _NV_GPU_FAN_POLICY_INFO_V1 {
  NV_GPU_FAN_POLICY_TYPE type;
  NvU8 fanCoolerIndex;
  NvU16 fanSamplingPeriodms;
  NvU8 thermChannelIndex;
  NvU8 rsvd[31];
  union {
    NV_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM fanIIRTFDSP;
    NV_GPU_FAN_POLICY_INFO_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V30 fanIIRTFDSPV30;
    NvU8 rsvd[32];
  } data;
} NV_GPU_FAN_POLICY_INFO_V1;
typedef struct _NV_GPU_FAN_POLICIY_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 policyMask;
  NvU8 gpuPolicyIdx0;
  NvU8 gpuPolicyIdx1;
  NvU8 rsvd[30];
  NV_GPU_FAN_POLICY_INFO_V1
  policies[NV_GPU_FAN_POLICY_MAX_POLICIES_V1];
} NV_GPU_FAN_POLICIY_INFO_PARAMS_V1;
#define NV_GPU_FAN_POLICY_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_POLICIY_INFO_PARAMS_V1, 1)
#define NV_GPU_FAN_POLICY_INFO_PARAMS_VER NV_GPU_FAN_POLICY_INFO_PARAMS_VER_1
typedef NV_GPU_FAN_POLICIY_INFO_PARAMS_V1 NV_GPU_FAN_POLICY_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_FanPolicyGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_GPU_FAN_POLICY_INFO_PARAMS *pFanPolicyInfo);
typedef struct _NV_GPU_FAN_POLICY_STATUS_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM {
  NvS32 fanTjAvgShortTerm;
  NvS32 fanTjAvgLongTerm;
  NvU32 targetPwm;
  NvU32 targetRpm;
  NvS32 tjCurrent;
  NvU32 filteredPwrmW;
  NvU8 bFanStopActive;
} NV_GPU_FAN_POLICY_STATUS_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM;
typedef struct _NV_GPU_FAN_POLICY_STATUS_V1 {
  NV_GPU_FAN_POLICY_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_POLICY_STATUS_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM fanIIRTFDSP;
    NvU8 rsvd[32];
  } data;
} NV_GPU_FAN_POLICY_STATUS_V1;
typedef struct _NV_GPU_FAN_POLICY_STATUS_PARAMS_V1 {
  NvU32 version;
  NvU32 policyMask;
  NvU8 rsvd[32];
  NV_GPU_FAN_POLICY_STATUS_V1
  policies[NV_GPU_FAN_POLICY_MAX_POLICIES_V1];
} NV_GPU_FAN_POLICY_STATUS_PARAMS_V1;
#define NV_GPU_FAN_POLICY_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_POLICY_STATUS_PARAMS_V1, 1)
#define NV_GPU_FAN_POLICY_STATUS_PARAMS_VER NV_GPU_FAN_POLICY_STATUS_PARAMS_VER_1
typedef NV_GPU_FAN_POLICY_STATUS_PARAMS_V1 NV_GPU_FAN_POLICY_STATUS_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_FanPolicyGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_GPU_FAN_POLICY_STATUS_PARAMS *pFanPoliciesStatus);
#define NV_GPU_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_CURVE_PTS 3
typedef struct _NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V1 {
  NvS32 fanIIRGainMin;
  NvS32 fanIIRGainMax;
  NvS32 fanIIRGainShortTerm;
  NvU8 fanIIRFilterPower;
  NvU8 fanIIRLongTermSamplingRatio;
  NvS32 fanIIRFilterWidthUpper;
  NvS32 fanIIRFilterWidthLower;
  struct {
    NvS32 fanTj;
    NvU32 fanPwm;
    NvU32 fanRpm;
  } fanCurvePts[NV_GPU_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_CURVE_PTS];
} NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V1;
typedef struct _NV_GPU_FAN_POLICY_CONTROL_V1 {
  NV_GPU_FAN_POLICY_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V1 fanIIRTFDSP;
    NvU8 rsvd[80];
  } data;
} NV_GPU_FAN_POLICY_CONTROL_V1;
typedef struct _NV_GPU_FAN_POLICY_CONTROL_PARAMS_V1 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 retrieveDefault : 1;
  NvU32 reservedField : 31;
  NvU8 rsvd[32];
  NV_GPU_FAN_POLICY_CONTROL_V1
  policies[NV_GPU_FAN_POLICY_MAX_POLICIES_V1];
} NV_GPU_FAN_POLICY_CONTROL_PARAMS_V1;
typedef struct _NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V2 {
  NvS32 fanIIRGainMin;
  NvS32 fanIIRGainMax;
  NvS32 fanIIRGainShortTerm;
  NvU8 fanIIRFilterPower;
  NvU8 fanIIRLongTermSamplingRatio;
  NvS32 fanIIRFilterWidthUpper;
  NvS32 fanIIRFilterWidthLower;
  struct {
    NvS32 fanTj;
    NvU32 fanPwm;
    NvU32 fanRpm;
  } fanCurvePts[NV_GPU_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_CURVE_PTS];
  NvU8 bFanStopEnable;
  NvS32 fanStopTempLimitLower;
  NvS32 fanStartTempLimitUpper;
  NvU32 fanStopPowerLimitLowermW;
  NvU32 fanStartPowerLimitUppermW;
  NvS32 fanStopIIRGainPower;
} NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V2;
typedef struct _NV_GPU_FAN_POLICY_CONTROL_V2 {
  NV_GPU_FAN_POLICY_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_POLICY_CONTROL_DATA_IIR_TJ_FIXED_DUAL_SLOPE_PWM_V2 fanIIRTFDSP;
    NvU8 rsvd[128];
  } data;
} NV_GPU_FAN_POLICY_CONTROL_V2;
typedef struct _NV_GPU_FAN_POLICY_CONTROL_PARAMS_V2 {
  NvU32 version;
  NvU32 policyMask;
  NvU32 retrieveDefault : 1;
  NvU32 reservedField : 31;
  NvU8 rsvd[32];
  NV_GPU_FAN_POLICY_CONTROL_V2
  policies[NV_GPU_FAN_POLICY_MAX_POLICIES_V1];
} NV_GPU_FAN_POLICY_CONTROL_PARAMS_V2;
#define NV_GPU_FAN_POLICY_CONTROL_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_POLICY_CONTROL_PARAMS_V1, 1)
#define NV_GPU_FAN_POLICY_CONTROL_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_GPU_FAN_POLICY_CONTROL_PARAMS_V2, 2)
#define NV_GPU_FAN_POLICY_CONTROL_PARAMS_VER NV_GPU_FAN_POLICY_CONTROL_PARAMS_VER_2
typedef NV_GPU_FAN_POLICY_CONTROL_PARAMS_V2 NV_GPU_FAN_POLICY_CONTROL_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_FanPolicyGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_FAN_POLICY_CONTROL_PARAMS *pFanPolicyControl);
NVAPI_INTERFACE NvAPI_GPU_FanPolicySetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __in NV_GPU_FAN_POLICY_CONTROL_PARAMS *pFanPolicyControl);
#define NV_GPU_FAN_TEST_MAX_TESTS_V1 32
typedef enum _NV_GPU_FAN_TEST_TYPE {
  NV_GPU_FAN_TEST_TYPE_INVALID = 0x00000000,
  NV_GPU_FAN_TEST_TYPE_COOLER_SANITY = 0x00000001,
} NV_GPU_FAN_TEST_TYPE;
typedef struct _NV_GPU_FAN_TEST_INFO_DATA_COOLER_SANITY {
  NvU8 coolerTableIdx;
  NvU8 measurementTolerancePct;
  NvU16 convergenceTimems;
} NV_GPU_FAN_TEST_INFO_DATA_COOLER_SANITY;
typedef struct _NV_GPU_FAN_TEST_INFO_V1 {
  NV_GPU_FAN_TEST_TYPE type;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_TEST_INFO_DATA_COOLER_SANITY coolerSanity;
    NvU8 rsvd[32];
  } data;
} NV_GPU_FAN_TEST_INFO_V1;
typedef struct _NV_GPU_FAN_TEST_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 testMask;
  NvU8 rsvd[32];
  NV_GPU_FAN_TEST_INFO_V1
  test[NV_GPU_FAN_TEST_MAX_TESTS_V1];
} NV_GPU_FAN_TEST_INFO_PARAMS_V1;
#define NV_GPU_FAN_TEST_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_TEST_INFO_PARAMS_V1, 1)
#define NV_GPU_FAN_TEST_INFO_PARAMS_VER NV_GPU_FAN_TEST_INFO_PARAMS_VER_1
typedef NV_GPU_FAN_TEST_INFO_PARAMS_V1 NV_GPU_FAN_TEST_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_FanTestGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                         __inout NV_GPU_FAN_TEST_INFO_PARAMS *pFanTestInfo);
typedef enum {
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_NONE,
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_GPU,
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_GPU_1,
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID;
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_GPU_0 NV_GPU_CLIENT_FAN_POLICIES_POLICY_GPU
#define NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX 4
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V1 {
  NvU32 version;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID policyId;
  NvU32 fanStopFeatureSupported : 1;
  NvU32 fanStopFeatureEnableDefault : 1;
  NvU32 reserved : 30;
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V1;
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V2 {
  NvU32 version;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID policyId;
  NvU32 fanStopFeatureSupported : 1;
  NvU32 fanStopFeatureEnableDefault : 1;
  NvU32 fanCurveAdjSupported : 1;
  NvU32 reserved : 29;
  NvU8 arbiterMask;
  NvU8 policyIdx;
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V2;
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V1, 1)
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V2, 2)
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_VER NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_VER2
typedef NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V2 NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO;
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_INFO_V1 {
  NvU32 version;
  NvU32 isSupported : 1;
  NvU32 reserved : 31;
  NvU8 numPolicies;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V1 policies[NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_FAN_POLICIES_INFO_V1;
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_INFO_V2 {
  NvU32 version;
  NvU32 isSupported : 1;
  NvU32 reserved : 31;
  NvU8 numPolicies;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_INFO_V2 policies[NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_FAN_POLICIES_INFO_V2;
#define NV_GPU_CLIENT_FAN_POLICIES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_INFO_V1, 1)
#define NV_GPU_CLIENT_FAN_POLICIES_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_INFO_V2, 2)
#define NV_GPU_CLIENT_FAN_POLICIES_INFO_VER NV_GPU_CLIENT_FAN_POLICIES_INFO_VER2
typedef NV_GPU_CLIENT_FAN_POLICIES_INFO_V2 NV_GPU_CLIENT_FAN_POLICIES_INFO;
NVAPI_INTERFACE NvAPI_GPU_ClientFanPoliciesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GPU_CLIENT_FAN_POLICIES_INFO *pClientFanPoliciesInfo);
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID policyId;
  NvU32 fanStopFeatureActive : 1;
  NvU32 reserved : 31;
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1;
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1, 1)
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_VER NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_VER1
typedef NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1 NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS;
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_STATUS_V1 {
  NvU32 version;
  NvU8 numPolicies;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_STATUS_V1 policies[NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_FAN_POLICIES_STATUS_V1;
#define NV_GPU_CLIENT_FAN_POLICIES_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_STATUS_V1, 1)
#define NV_GPU_CLIENT_FAN_POLICIES_STATUS_VER NV_GPU_CLIENT_FAN_POLICIES_STATUS_VER1
typedef NV_GPU_CLIENT_FAN_POLICIES_STATUS_V1 NV_GPU_CLIENT_FAN_POLICIES_STATUS;
NVAPI_INTERFACE NvAPI_GPU_ClientFanPoliciesGetStatus(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_POLICIES_STATUS *pClientFanPoliciesStatus);
#define NV_GPU_CLIENT_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_CURVE_PTS 3
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V1 {
  NvU32 version;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID policyId;
  NvU32 fanStopFeatureEnable : 1;
  NvU32 reserved : 31;
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V1;
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V2 {
  NvU32 version;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_ID policyId;
  NvU32 fanStopFeatureEnable : 1;
  NvU32 reserved : 31;
  NvU8 policyIdx;
  struct {
    NvS32 fanTj;
    NvU32 fanPwm;
    NvU32 fanRpm;
  } fanCurvePts[NV_GPU_CLIENT_FAN_POLICY_IIR_TJ_FIXED_DUAL_SLOPE_PWM_FAN_CURVE_PTS];
} NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V2;
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V1, 1)
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_VER2                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V2, 2)
#define NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_VER NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_VER2
typedef NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V2 NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL;
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V1 {
  NvU32 version;
  NvU8 numPolicies;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V1 policies[NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX];
} NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V1;
typedef struct _NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V2 {
  NvU32 version;
  NvU8 numPolicies;
  NV_GPU_CLIENT_FAN_POLICIES_POLICY_CONTROL_V2 policies[NV_GPU_CLIENT_FAN_POLICIES_NUM_POLICIES_MAX];
  NvU32 bDefault : 1;
  NvU32 reservedBits : 31;
} NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V2;
#define NV_GPU_CLIENT_FAN_POLICIES_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V1, 1)
#define NV_GPU_CLIENT_FAN_POLICIES_CONTROL_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V2, 2)
#define NV_GPU_CLIENT_FAN_POLICIES_CONTROL_VER NV_GPU_CLIENT_FAN_POLICIES_CONTROL_VER2
typedef NV_GPU_CLIENT_FAN_POLICIES_CONTROL_V2 NV_GPU_CLIENT_FAN_POLICIES_CONTROL;
NVAPI_INTERFACE NvAPI_GPU_ClientFanPoliciesGetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_POLICIES_CONTROL *pClientFanPoliciesControl);
NVAPI_INTERFACE NvAPI_GPU_ClientFanPoliciesSetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_POLICIES_CONTROL *pClientFanPoliciesControl);
typedef enum _NV_GPU_CLIENT_FAN_COOLERS_COOLER_ID {
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_NONE,
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_GPU_0,
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_GPU_1,
} NV_GPU_CLIENT_FAN_COOLERS_COOLER_ID;
#define NV_GPU_CLIENT_FAN_COOLERS_NUM_COOLERS_MAX 32
typedef struct _NV_GPU_CLIENT_FAN_COOLERS_COOLER_INFO_V1 {
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_ID coolerId;
  NvU32 bTachSupported : 1;
  NvU32 reservedBits : 31;
  NvU32 rpmMin;
  NvU32 rpmMax;
  NvU8 reserved[32];
} NV_GPU_CLIENT_FAN_COOLERS_COOLER_INFO_V1;
typedef struct _NV_GPU_CLIENT_FAN_COOLERS_INFO_V1 {
  NvU32 version;
  NvU32 bIsSupported : 1;
  NvU32 reservedBits : 31;
  NvU8 numCoolers;
  NvU8 reserved[32];
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_INFO_V1
  coolers[NV_GPU_CLIENT_FAN_COOLERS_NUM_COOLERS_MAX];
} NV_GPU_CLIENT_FAN_COOLERS_INFO_V1;
#define NV_GPU_CLIENT_FAN_COOLERS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_COOLERS_INFO_V1, 1)
#define NV_GPU_CLIENT_FAN_COOLERS_INFO_VER NV_GPU_CLIENT_FAN_COOLERS_INFO_VER1
typedef NV_GPU_CLIENT_FAN_COOLERS_INFO_V1 NV_GPU_CLIENT_FAN_COOLERS_INFO;
NVAPI_INTERFACE NvAPI_GPU_ClientFanCoolersGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_CLIENT_FAN_COOLERS_INFO *pClientFanCoolersInfo);
typedef struct _NV_GPU_CLIENT_FAN_COOLERS_COOLER_STATUS_V1 {
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_ID coolerId;
  NvU32 rpmCurr;
  NvU32 levelMin;
  NvU32 levelMax;
  NvU32 levelTarget;
  NvU8 reserved[32];
} NV_GPU_CLIENT_FAN_COOLERS_COOLER_STATUS_V1;
typedef struct _NV_GPU_CLIENT_FAN_COOLERS_STATUS_V1 {
  NvU32 version;
  NvU8 numCoolers;
  NvU8 reserved[32];
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_STATUS_V1
  coolers[NV_GPU_CLIENT_FAN_COOLERS_NUM_COOLERS_MAX];
} NV_GPU_CLIENT_FAN_COOLERS_STATUS_V1;
#define NV_GPU_CLIENT_FAN_COOLERS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_COOLERS_STATUS_V1, 1)
#define NV_GPU_CLIENT_FAN_COOLERS_STATUS_VER NV_GPU_CLIENT_FAN_COOLERS_STATUS_VER1
typedef NV_GPU_CLIENT_FAN_COOLERS_STATUS_V1 NV_GPU_CLIENT_FAN_COOLERS_STATUS;
NVAPI_INTERFACE NvAPI_GPU_ClientFanCoolersGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_CLIENT_FAN_COOLERS_STATUS *pClientFanCoolersStatus);
typedef struct _NV_GPU_CLIENT_FAN_COOLERS_COOLER_CONTROL_V1 {
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_ID coolerId;
  NvU32 levelSim;
  NvU32 bLevelSimActive : 1;
  NvU32 reservedBits : 31;
  NvU8 reserved[32];
} NV_GPU_CLIENT_FAN_COOLERS_COOLER_CONTROL_V1;
typedef struct _NV_GPU_CLIENT_FAN_COOLERS_CONTROL_V1 {
  NvU32 version;
  NvU32 bDefault : 1;
  NvU32 reservedBits : 31;
  NvU8 numCoolers;
  NvU8 reserved[32];
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_CONTROL_V1
  coolers[NV_GPU_CLIENT_FAN_COOLERS_NUM_COOLERS_MAX];
} NV_GPU_CLIENT_FAN_COOLERS_CONTROL_V1;
#define NV_GPU_CLIENT_FAN_COOLERS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_COOLERS_CONTROL_V1, 1)
#define NV_GPU_CLIENT_FAN_COOLERS_CONTROL_VER NV_GPU_CLIENT_FAN_COOLERS_CONTROL_VER1
typedef NV_GPU_CLIENT_FAN_COOLERS_CONTROL_V1 NV_GPU_CLIENT_FAN_COOLERS_CONTROL;
NVAPI_INTERFACE NvAPI_GPU_ClientFanCoolersGetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_COOLERS_CONTROL *pClientFanCoolersControl);
NVAPI_INTERFACE NvAPI_GPU_ClientFanCoolersSetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_COOLERS_CONTROL *pClientFanCoolersControl);
typedef enum {
  NV_FAN_SENSE_NOTSUPPORTED = 0,
  NV_FAN_SENSE_SUPPORTED = 1,
} NV_FAN_SENSE;
typedef struct {
  NvU32 version;
  NvU32 coolerCount;
  NV_FAN_SENSE supportFlag[NVAPI_MAX_COOLERS_PER_GPU];
} NV_GPU_FAN_SPIN_SENSE;
#define NV_GPU_FAN_SPIN_SENSE_VER MAKE_NVAPI_VERSION(NV_GPU_FAN_SPIN_SENSE, 1)
NVAPI_INTERFACE NvAPI_GPU_QueryFanSpinSenseSupport(NvPhysicalGpuHandle hPhysicalGpu, NvU32 coolerIndexRequest,
                                                   NV_GPU_FAN_SPIN_SENSE *pSpinSense);
NVAPI_INTERFACE NvAPI_GPU_GetCurrentFanSpeedLevel(NvPhysicalGpuHandle nvGPUHandle, NV_EVENT_LEVEL *pFanSpeedLevel);
#define NV_GPU_FAN_ARBITER_MAX_ARBITERS_V1 32
typedef enum _NV_GPU_FAN_ARBITER_TYPE {
  NV_GPU_FAN_ARBITER_TYPE_V10,
} NV_GPU_FAN_ARBITER_TYPE;
typedef enum _NV_GPU_FAN_ARBITER_MODE_TYPE {
  NV_GPU_FAN_ARBITER_MODE_TYPE_MAX,
} NV_GPU_FAN_ARBITER_MODE_TYPE;
typedef enum _NV_GPU_FAN_CTRL_ACTION {
  NV_GPU_FAN_CTRL_ACTION_SPEED_CTRL,
  NV_GPU_FAN_CTRL_ACTION_STOP,
  NV_GPU_FAN_CTRL_ACTION_RESTART,
  NV_GPU_FAN_CTRL_ACTION_INVALID,
} NV_GPU_FAN_CTRL_ACTION;
typedef struct _NV_GPU_FAN_ARBITER_INFO_DATA_V10 {
  NvU8 rsvd[32];
} NV_GPU_FAN_ARBITER_INFO_DATA_V10;
typedef struct _NV_GPU_FAN_ARBITER_INFO_V1 {
  NV_GPU_FAN_ARBITER_TYPE type;
  NV_GPU_FAN_ARBITER_MODE_TYPE
  mode;
  NvU8 coolerIdx;
  NvU16 samplingPeriodms;
  NvU32 fanPoliciesMask;
  NvU32 vbiosFanPoliciesMask;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_ARBITER_INFO_DATA_V10 v10;
    NvU8 rsvd[32];
  } data;
} NV_GPU_FAN_ARBITER_INFO_V1;
typedef struct _NV_GPU_FAN_ARBITER_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 arbiterMask;
  NvU8 rsvd[32];
  NV_GPU_FAN_ARBITER_INFO_V1 arbiters[NV_GPU_FAN_ARBITER_MAX_ARBITERS_V1];
} NV_GPU_FAN_ARBITER_INFO_PARAMS_V1;
#define NV_GPU_FAN_ARBITER_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_ARBITER_INFO_PARAMS_V1, 1)
#define NV_GPU_FAN_ARBITER_INFO_PARAMS_VER NV_GPU_FAN_ARBITER_INFO_PARAMS_VER_1
typedef NV_GPU_FAN_ARBITER_INFO_PARAMS_V1 NV_GPU_FAN_ARBITER_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_FanArbiterGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __inout NV_GPU_FAN_ARBITER_INFO_PARAMS *pFanArbiterInfo);
typedef struct _NV_GPU_FAN_ARBITER_STATUS_DATA_V10 {
  NvU8 rsvd[32];
} NV_GPU_FAN_ARBITER_STATUS_DATA_V10;
typedef struct _NV_GPU_FAN_ARBITER_STATUS_V1 {
  NV_GPU_FAN_ARBITER_TYPE type;
  NV_GPU_FAN_CTRL_ACTION fanCtrlAction;
  NvU16 drivingPolicyIdx;
  NvU32 targetPwm;
  NvU32 targetRpm;
  NvU8 rsvd[32];
  union {
    NV_GPU_FAN_ARBITER_STATUS_DATA_V10 v10;
    NvU8 rsvd[32];
  } data;
} NV_GPU_FAN_ARBITER_STATUS_V1;
typedef struct _NV_GPU_FAN_ARBITER_STATUS_PARAMS_V1 {
  NvU32 version;
  NvU32 arbiterMask;
  NvU8 rsvd[32];
  NV_GPU_FAN_ARBITER_STATUS_V1 arbiters[NV_GPU_FAN_ARBITER_MAX_ARBITERS_V1];
} NV_GPU_FAN_ARBITER_STATUS_PARAMS_V1;
#define NV_GPU_FAN_ARBITER_STATUS_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_FAN_ARBITER_STATUS_PARAMS_V1, 1)
#define NV_GPU_FAN_ARBITER_STATUS_PARAMS_VER NV_GPU_FAN_ARBITER_STATUS_PARAMS_VER_1
typedef NV_GPU_FAN_ARBITER_STATUS_PARAMS_V1 NV_GPU_FAN_ARBITER_STATUS_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_FanArbiterGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_FAN_ARBITER_STATUS_PARAMS *pFanArbiterStatus);
typedef struct _NV_GPU_FAN_PMUMON_FAN_COOLER_SAMPLE_V1 {
  NvU32 rpm;
  NvU32 level;
  NvU8 rsvd[64];
} NV_GPU_FAN_PMUMON_FAN_COOLER_SAMPLE_V1;
typedef struct _NV_GPU_FAN_PMUMON_FAN_COOLERS_SAMPLE_V1 {
  NV_GPU_PMUMON_SAMPLE_SUPER_V1 super;
  NV_GPU_FAN_PMUMON_FAN_COOLER_SAMPLE_V1 cooler[NV_GPU_FAN_COOLER_MAX_COOLERS_V1];
  NvU8 rsvd[64];
} NV_GPU_FAN_PMUMON_FAN_COOLERS_SAMPLE_V1;
#define NV_GPU_FAN_PMUMON_FAN_COOLERS_SAMPLE_COUNT_V1 (50U)
typedef struct _NV_GPU_FAN_PMUMON_FAN_COOLERS_GET_SAMPLES_V1 {
  NvU32 version;
  NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 super;
  NvU8 rsvd[64];
  NV_GPU_FAN_PMUMON_FAN_COOLERS_SAMPLE_V1 samples[NV_GPU_FAN_PMUMON_FAN_COOLERS_SAMPLE_COUNT_V1];
} NV_GPU_FAN_PMUMON_FAN_COOLERS_GET_SAMPLES_V1;
typedef NV_GPU_FAN_PMUMON_FAN_COOLERS_GET_SAMPLES_V1 NV_GPU_FAN_PMUMON_FAN_COOLERS_GET_SAMPLES;
#define NV_GPU_FAN_PMUMON_FAN_COOLERS_GET_SAMPLES_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_FAN_PMUMON_FAN_COOLERS_GET_SAMPLES_V1, 1)
#define NV_GPU_FAN_PMUMON_FAN_COOLERS_GET_SAMPLES_VER NV_GPU_FAN_PMUMON_FAN_COOLERS_GET_SAMPLES_VER1
NVAPI_INTERFACE NvAPI_GPU_FanPmumonFanCoolersGetSamples(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_FAN_PMUMON_FAN_COOLERS_GET_SAMPLES *pGetSamplesParams);
#define NV_GPU_CLIENT_FAN_ARBITERS_NUM_ARBITERS_MAX 32
typedef struct _NV_GPU_CLIENT_FAN_ARBITER_INFO_V1 {
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_ID coolerId;
  NvU32 fanStopFeatureSupported : 1;
  NvU32 fanStopFeatureEnableDefault : 1;
  NvU32 rsvd : 30;
  NvU8 arbiterIdx;
  NvU8 reserved[31];
} NV_GPU_CLIENT_FAN_ARBITER_INFO_V1;
#define NV_GPU_CLIENT_FAN_ARBITER_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_ARBITER_INFO_V1, 1)
#define NV_GPU_CLIENT_FAN_ARBITER_INFO_VER NV_GPU_CLIENT_FAN_ARBITER_INFO_VER1
typedef NV_GPU_CLIENT_FAN_ARBITER_INFO_V1 NV_GPU_CLIENT_FAN_ARBITER_INFO;
typedef struct _NV_GPU_CLIENT_FAN_ARBITERS_INFO_V1 {
  NvU32 version;
  NvU8 numArbiters;
  NvU8 reserved[31];
  NV_GPU_CLIENT_FAN_ARBITER_INFO_V1
  arbiters[NV_GPU_CLIENT_FAN_ARBITERS_NUM_ARBITERS_MAX];
} NV_GPU_CLIENT_FAN_ARBITERS_INFO_V1;
#define NV_GPU_CLIENT_FAN_ARBITERS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_ARBITERS_INFO_V1, 1)
#define NV_GPU_CLIENT_FAN_ARBITERS_INFO_VER NV_GPU_CLIENT_FAN_ARBITERS_INFO_VER1
typedef NV_GPU_CLIENT_FAN_ARBITERS_INFO_V1 NV_GPU_CLIENT_FAN_ARBITERS_INFO;
NVAPI_INTERFACE NvAPI_GPU_ClientFanArbitersGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GPU_CLIENT_FAN_ARBITERS_INFO *pClientFanArbitersInfo);
typedef struct _NV_GPU_CLIENT_FAN_ARBITER_STATUS_V1 {
  NvU8 arbiterIdx;
  NvU32 fanStopFeatureActive : 1;
  NvU32 reserved : 31;
} NV_GPU_CLIENT_FAN_ARBITER_STATUS_V1;
#define NV_GPU_CLIENT_FAN_ARBITER_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_ARBITER_STATUS_V1, 1)
#define NV_GPU_CLIENT_FAN_ARBITER_STATUS_VER NV_GPU_CLIENT_FAN_ARBITER_STATUS_VER1
typedef NV_GPU_CLIENT_FAN_ARBITER_STATUS_V1 NV_GPU_CLIENT_FAN_ARBITER_STATUS;
typedef struct _NV_GPU_CLIENT_FAN_ARBITERS_STATUS_V1 {
  NvU32 version;
  NvU8 numArbiters;
  NvU8 reserved[31];
  NV_GPU_CLIENT_FAN_ARBITER_STATUS_V1
  arbiters[NV_GPU_CLIENT_FAN_ARBITERS_NUM_ARBITERS_MAX];
} NV_GPU_CLIENT_FAN_ARBITERS_STATUS_V1;
#define NV_GPU_CLIENT_FAN_ARBITERS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_ARBITERS_STATUS_V1, 1)
#define NV_GPU_CLIENT_FAN_ARBITERS_STATUS_VER NV_GPU_CLIENT_FAN_ARBITERS_STATUS_VER1
typedef NV_GPU_CLIENT_FAN_ARBITERS_STATUS_V1 NV_GPU_CLIENT_FAN_ARBITERS_STATUS;
NVAPI_INTERFACE NvAPI_GPU_ClientFanArbitersGetStatus(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_ARBITERS_STATUS *pClientFanArbitersStatus);
typedef struct _NV_GPU_CLIENT_FAN_ARBITER_CONTROL_V1 {
  NvU8 arbiterIdx;
  NvU32 fanStopFeatureEnable : 1;
  NvU32 reserved : 31;
} NV_GPU_CLIENT_FAN_ARBITER_CONTROL_V1;
#define NV_GPU_CLIENT_FAN_ARBITER_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_ARBITER_CONTROL_V1, 1)
#define NV_GPU_CLIENT_FAN_ARBITER_CONTROL_VER NV_GPU_CLIENT_FAN_ARBITER_CONTROL_VER1
typedef NV_GPU_CLIENT_FAN_ARBITER_CONTROL_V1 NV_GPU_CLIENT_FAN_ARBITER_CONTROL;
typedef struct _NV_GPU_CLIENT_FAN_ARBITERS_CONTROL_V1 {
  NvU32 version;
  NvU8 numArbiters;
  NvU8 reserved[31];
  NV_GPU_CLIENT_FAN_ARBITER_CONTROL_V1
  arbiters[NV_GPU_CLIENT_FAN_ARBITERS_NUM_ARBITERS_MAX];
} NV_GPU_CLIENT_FAN_ARBITERS_CONTROL_V1;
#define NV_GPU_CLIENT_FAN_ARBITERS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_ARBITERS_CONTROL_V1, 1)
#define NV_GPU_CLIENT_FAN_ARBITERS_CONTROL_VER NV_GPU_CLIENT_FAN_ARBITERS_CONTROL_VER1
typedef NV_GPU_CLIENT_FAN_ARBITERS_CONTROL_V1 NV_GPU_CLIENT_FAN_ARBITERS_CONTROL;
NVAPI_INTERFACE NvAPI_GPU_ClientFanArbitersGetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_ARBITERS_CONTROL *pClientFanArbitersControl);
NVAPI_INTERFACE NvAPI_GPU_ClientFanArbitersSetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_FAN_ARBITERS_CONTROL *pClientFanArbitersControl);
typedef enum _NV_GPU_CLOCK_INFO_DOMAIN_ID {
  NVAPI_GPU_CLOCK_INFO_DOMAIN_NV = 0,
  NVAPI_GPU_CLOCK_INFO_DOMAIN_M = 4,
  NVAPI_GPU_CLOCK_INFO_DOMAIN_HOTCLK = 7,
  NVAPI_GPU_CLOCK_INFO_DOMAIN_UNDEFINED = NVAPI_MAX_GPU_CLOCKS,
} NV_GPU_CLOCK_INFO_DOMAIN_ID;
typedef enum _NV_GPU_PERF_CLOCK_DOMAIN_ID {
  NVAPI_GPU_PERF_CLOCK_DOMAIN_GRAPHICS_CLK = 0,
  NVAPI_GPU_PERF_CLOCK_DOMAIN_MEMORY_CLK = 4,
  NVAPI_GPU_PERF_CLOCK_DOMAIN_PROCESSOR_CLK = 7,
} NV_GPU_PERF_CLOCK_DOMAIN_ID;
NVAPI_INTERFACE NvAPI_GPU_GetAllClocks(NvPhysicalGpuHandle hPhysicalGPU, NV_GPU_CLOCK_INFO *pClkInfo);
typedef struct {
  NvU32 version;
  NvU32 reserved;
  struct {
    NvU32 bIsPresent : 1;
    NvU32 reserved : 31;
    NvU32 frequency;
  } domain[NVAPI_MAX_GPU_PUBLIC_CLOCKS];
} NV_GPU_CLOCK_FREQUENCIES_V1;
#define NV_GPU_MAX_CLOCK_FREQUENCIES 4
#ifndef NV_GPU_MAX_CLOCK_FREQUENCIES
#define NV_GPU_MAX_CLOCK_FREQUENCIES 3
#endif
typedef enum {
  NV_GPU_CLOCK_FREQUENCIES_CURRENT_FREQ = 0,
  NV_GPU_CLOCK_FREQUENCIES_BASE_CLOCK = 1,
  NV_GPU_CLOCK_FREQUENCIES_BOOST_CLOCK = 2,
  NV_GPU_CLOCK_FREQUENCIES_INTERNAL_BOOST_CLOCK = 3,
  NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE_NUM = NV_GPU_MAX_CLOCK_FREQUENCIES
} NV_GPU_CLOCK_FREQUENCIES_CLOCK_TYPE;
typedef struct {
  NvU32 version;
  NvU32 ClockType : 4;
  NvU32 reserved : 20;
  NvU32 reserved1 : 8;
  struct {
    NvU32 bIsPresent : 1;
    NvU32 reserved : 31;
    NvU32 frequency;
  } domain[NVAPI_MAX_GPU_PUBLIC_CLOCKS];
} NV_GPU_CLOCK_FREQUENCIES_V2;
typedef NV_GPU_CLOCK_FREQUENCIES_V2 NV_GPU_CLOCK_FREQUENCIES;
#define NV_GPU_CLOCK_FREQUENCIES_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_FREQUENCIES_V1, 1)
#define NV_GPU_CLOCK_FREQUENCIES_VER_2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_FREQUENCIES_V2, 2)
#define NV_GPU_CLOCK_FREQUENCIES_VER_3 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_FREQUENCIES_V2, 3)
#define NV_GPU_CLOCK_FREQUENCIES_VER NV_GPU_CLOCK_FREQUENCIES_VER_3
NVAPI_INTERFACE NvAPI_GPU_GetAllClockFrequencies(__in NvPhysicalGpuHandle hPhysicalGPU,
                                                 __inout NV_GPU_CLOCK_FREQUENCIES *pClkFreqs);
typedef enum {
  NV_GPU_PUBLIC_CLOCK_DOMAIN_PROGRAMMABLE = 0x00000001,
} NV_GPU_PUBLIC_CLOCK_INFO_DOMAINS_FLAGS;
typedef struct {
  NvU32 version;
  NvU32 flags;
  struct {
    NV_GPU_CLOCK_DOMAIN_ID clkId;
    NvU32 flags;
    NvU32 frequencyAdjustPercent;
  } domains[NVAPI_MAX_GPU_PUBLIC_CLOCKS];
} NV_GPU_PUBLIC_CLOCK_INFO;
#define NV_GPU_PUBLIC_CLOCK_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_PUBLIC_CLOCK_INFO, 1)
#define NV_GPU_PUBLIC_CLOCK_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_PUBLIC_CLOCK_INFO, 2)
#define NV_GPU_PUBLIC_CLOCK_INFO_VER NV_GPU_PUBLIC_CLOCK_INFO_VER2
NVAPI_INTERFACE NvAPI_GPU_GetPublicClockInfo(NvPhysicalGpuHandle hPhysicalGPU,
                                             NV_GPU_PUBLIC_CLOCK_INFO *pPublicClockInfo);
NVAPI_INTERFACE NvAPI_GPU_SetClocks(NvPhysicalGpuHandle hPhysicalGPU, NvU32 bSetDeferred, NV_GPU_CLOCK_INFO *pClkInfo);
NVAPI_INTERFACE NvAPI_GPU_SetClocksShmoo(NvPhysicalGpuHandle hPhysicalGPU, NV_GPU_CLOCK_INFO *pClkInfo);
#define NV_GPU_CLOCK_PART_IDX_MAX 0x0000000F
#define NV_GPU_CLOCK_PART_IDX_UNDEFINED 0x000000FF
typedef struct {
  NvU32 tickCnt;
  NvU64 timens;
} NV_GPU_CLOCK_COUNTER_SAMPLE_V1;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_DOMAIN_ID clkDomain;
  NV_GPU_CLOCK_COUNTER_SAMPLE_V1 sample;
  NvU32 freqkHz;
} NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_DOMAIN_ID clkDomain;
  NV_GPU_CLOCK_COUNTER_SAMPLE_V2 sample;
  NvU32 freqkHz;
} NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V2;
typedef struct {
  NvU8 partIdx;
  NvU8 rsvd[3];
  NvU32 freqkHz;
  NV_GPU_CLOCK_COUNTER_SAMPLE_V2 sample;
} NV_GPU_CLOCK_COUNTER_PART_AVG_FREQ;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_DOMAIN_ID clkDomain;
  NvU8 rsvd[3];
  NvU8 numParts;
  NV_GPU_CLOCK_COUNTER_PART_AVG_FREQ parts[NV_GPU_CLOCK_PART_IDX_MAX];
} NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V3;
#define NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_VER_1                                                             \
  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V1, 1)
#define NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_VER_2                                                             \
  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V2, 2)
#define NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_VER_3                                                             \
  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V3, 3)
#define NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_VER NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_VER_3
#define NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS_V3
NVAPI_INTERFACE NvAPI_GPU_ClockCounterMeasureAvgFreq(NvPhysicalGpuHandle hPhysicalGpu,
                                                     NV_GPU_CLOCK_COUNTER_MEASURE_AVG_FREQ_PARAMS *pMeasure);
NVAPI_INTERFACE NvAPI_GPU_GetPixelClockRange(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_GET_PCLK *pTimings);
typedef struct {
  NvU32 version;
  NV_GET_PCLK publicPclkInfo;
  NvU32 uCurrMeasuredPixelClock;
} NV_GET_PCLK_INTERNAL_V1;
typedef NV_GET_PCLK_INTERNAL_V1 NV_GET_PCLK_INTERNAL;
#define NV_GET_PCLK_INTERNAL_VER1 MAKE_NVAPI_VERSION(NV_GET_PCLK_INTERNAL_V1, 1)
#define NV_GET_PCLK_INTERNAL_VER NV_GET_PCLK_INTERNAL_VER1
NVAPI_INTERFACE NvAPI_GPU_GetPixelClockRangeInternal(NvU32 displayId, NV_GET_PCLK_INTERNAL *pPclkInfo);
NVAPI_INTERFACE NvAPI_GPU_SetPixelClockRange(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId, NV_SET_PCLK *pTimings);
#define NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1 32
typedef enum {
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION_2X = 0x20,
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION_3X = 0x30,
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION_30 = 0x30,
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION_35 = 0x35,
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION_40 = 0x40,
} NV_GPU_CLOCK_CLK_DOMAIN_VERSION;
#define NV_GPU_CLK_CLK_DELTA_MAX_VOLT_RAILS 04
typedef struct {
  NvS32 freqDeltakHz;
  NvS32 voltDeltauV[NV_GPU_CLK_CLK_DELTA_MAX_VOLT_RAILS];
} NV_GPU_CLOCK_CLK_DELTA;
typedef enum _NV_GPU_CLOCK_CLK_FREQ_DELTA_TYPE {
  NV_GPU_CLOCK_CLK_FREQ_DELTA_TYPE_STATIC = 0x0,
  NV_GPU_CLOCK_CLK_FREQ_DELTA_TYPE_PERCENT = 0x1
} NV_GPU_CLOCK_CLK_FREQ_DELTA_TYPE;
typedef struct {
  NvS32 deltakHz;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_FREQ_DELTA_OFFSET_STATIC;
typedef struct {
  NvS16 deltaPercent;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_FREQ_DELTA_OFFSET_PERCENT;
typedef union {
  NV_GPU_CLOCK_CLK_FREQ_DELTA_OFFSET_STATIC staticOffset;
  NV_GPU_CLOCK_CLK_FREQ_DELTA_OFFSET_PERCENT percentOffset;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_FREQ_DELTA_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_FREQ_DELTA_TYPE type;
  NvU8 rsvd[16];
  NV_GPU_CLOCK_CLK_FREQ_DELTA_DATA_V1 data;
} NV_GPU_CLOCK_FREQ_DELTA_V1;
typedef struct {
  NV_GPU_CLOCK_FREQ_DELTA_V1 freqDeltakHz;
  NvS32 voltDeltauV[NV_GPU_CLK_CLK_DELTA_MAX_VOLT_RAILS];
  NvU32 rsvd[16];
} NV_GPU_CLOCK_CLK_DELTA_V1;
typedef struct {
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_3X;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_3X super;
  NV_GPU_CLOCK_CLK_DELTA deltas;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_3X_PROG;
#define NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_35_PROG_CLK_MON_FLAGS_FAULT 0 : 0
#define NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_35_PROG_CLK_MON_FLAGS_FAULT_DEFAULT (0x00000000U)
#define NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_35_PROG_CLK_MON_FLAGS_FAULT_CLEAR (0x00000001U)
typedef struct {
  NvU32 flags;
  NvU32 lowThresholdOverride;
  NvU32 highThresholdOverride;
  NvU8 rsvd[128];
} NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_35_PROG_CLK_MON;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_3X super;
  NV_GPU_CLOCK_CLK_DELTA deltas;
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_35_PROG_CLK_MON clkMon;
  NvU8 rsvd[128];
} NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_40_PROG, *PNV_GPU_CLOCK_CLK_DOMAIN_CONTROL_40_PROG;
typedef union {
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_3X v3x;
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_3X_PROG v3xProg;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_DATA_V1;
typedef union {
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_3X v3x;
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_3X_PROG v3xProg;
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_40_PROG v40Prog;
  NvU8 rsvd[512];
} NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_DATA_V2;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_DATA_V1 data;
} NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE type;
  NvU8 rsvd[256];
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_DATA_V2 data;
} NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_V2;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION clkDomainsVersion;
  NV_GPU_BOARDOBJGRP_MASK_E32 domainsMask;
  NvU8 bOverrideOVOC;
  NV_GPU_CLOCK_CLK_DELTA deltas;
  NvU8 bEnforceVfMonotonicity;
  NvU8 bDebugMode;
  NvU8 rsvd[62];
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_V1 domains[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
} NV_GPU_CLOCK_CLK_DOMAINS_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION clkDomainsVersion;
  NV_GPU_BOARDOBJGRP_MASK_E32 domainsMask;
  NvU8 bOverrideOVOC;
  NvU8 bDebugMode;
  NvU8 bEnforceVfMonotonicity;
  NvU8 bEnforceVfSmoothening;
  NV_GPU_CLOCK_CLK_DELTA deltas;
  NvBool bGrdFreqOCEnabled;
  NvU8 rsvd[255];
  NV_GPU_CLOCK_CLK_DOMAIN_CONTROL_V2 domains[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
} NV_GPU_CLOCK_CLK_DOMAINS_CONTROL_V2;
typedef NV_GPU_CLOCK_CLK_DOMAINS_CONTROL_V2 NV_GPU_CLOCK_CLK_DOMAINS_CONTROL;
#define NV_GPU_CLOCK_CLK_DOMAINS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_DOMAINS_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLK_DOMAINS_CONTROL_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_DOMAINS_CONTROL_V2, 2)
#define NV_GPU_CLOCK_CLK_DOMAINS_CONTROL_VER NV_GPU_CLOCK_CLK_DOMAINS_CONTROL_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockClkDomainsGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                    NV_GPU_CLOCK_CLK_DOMAINS_CONTROL *pClkDomainsControl);
NVAPI_INTERFACE NvAPI_GPU_ClockClkDomainsSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                    NV_GPU_CLOCK_CLK_DOMAINS_CONTROL *pClkDomainsControl);
typedef enum {
  NV_GPU_CLOCK_CLK_DOMAIN_3X_PROG_RPC_ID_FREQ_TO_VOLT = 0x0,
  NV_GPU_CLOCK_CLK_DOMAIN_3X_PROG_RPC_ID_VOLT_TO_FREQ = 0x1,
  NV_GPU_CLOCK_CLK_DOMAIN_3X_PROG_RPC_ID_FREQ_QUANTIZE = 0x2,
  NV_GPU_CLOCK_CLK_DOMAIN_3X_PROG_RPC_ID_GET_CLK_SOURCE = 0x3,
} NV_GPU_CLOCK_CLK_DOMAIN_3X_PROG_RPC_ID;
typedef struct {
  NvU8 perfDomainGrpIdx;
  NV_GPU_CLOCK_DOMAIN_ID ratioDomain;
  NV_GPU_CLOCK_INFO_DOMAIN_PSTATE_USAGE usage;
  NvU8 defaultRatio;
  NvU8 bStayAbovePstate;
  NvU8 bAllowNdivSliding;
  NvU8 constrainedMdiv;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_2X;
typedef struct {
  NvU8 bNoiseAwareCapable;
  NvU8 clientDomainIdx;
  NvU8 rsvd[7];
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X super;
  NvU16 freqMHz;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_FIXED;
#define NV_GPU_CLOCK_CLK_DOMAIN_3X_FIXED_ORDERING_INDEX_INVALID NV_U8_MAX
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X super;
  NvU8 clkProgIdxFirst;
  NvU8 clkProgIdxLast;
  NvU8 noiseUnawareOrderingIndex;
  NvU8 noiseAwareOrderingIndex;
  NvU8 bForceNoiseUnawareOrdering;
  NvS16 freqDeltaMinMHz;
  NvS16 freqDeltaMaxMHz;
  NvS32 factoryOffsetkHz;
  NvU8 rsvd[4];
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_PROG;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_PROG super;
  NvU32 slaveIdxsMask;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_MASTER;
typedef struct {
  NvU32 slaveIdxsMask;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_MASTER_INTERFACE;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_PROG super;
  NvU8 masterIdx;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_SLAVE;
typedef struct {
  NvU8 masterIdx;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_SLAVE_INTERFACE;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_PROG super;
  NvU8 noiseUnawareOrderingIndex;
  NvU8 noiseAwareOrderingIndex;
  NvU8 rsvd[4];
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_PROG;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_PROG super;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_MASTER_INTERFACE master;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_MASTER;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_PROG super;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_SLAVE_INTERFACE slave;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_SLAVE;
typedef struct {
  NvU8 lowThresholdVfeIdx;
  NvU8 highThresholdVfeIdx;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_PROG_CLK_MON, *PNV_GPU_CLOCK_CLK_DOMAIN_INFO_35_PROG_CLK_MON;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_PROG super;
  NvU8 preVoltOrderingIndex;
  NvU8 postVoltOrderingIndex;
  NvU8 rsvd[4];
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_PROG;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_PROG super;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_MASTER_INTERFACE master;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_MASTER;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_PROG super;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_SLAVE_INTERFACE slave;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_SLAVE;
typedef struct {
  NvU8 masterIdx;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_SLAVE, *PNV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_SLAVE;
typedef struct {
  NvU8 clkVfRelIdxFirst;
  NvU8 clkVfRelIdxLast;
  NV_GPU_BOARDOBJGRP_MASK_E32 slaveDomainsMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 masterSlaveDomainsMask;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_MASTER, *PNV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_MASTER;
#define NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_RAIL_VF_TYPE_NONE 0x0U
#define NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_RAIL_VF_TYPE_MASTER 0x1U
#define NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_RAIL_VF_TYPE_SLAVE 0x2U
typedef union {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_MASTER master;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_SLAVE slave;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_DATA_V1;
typedef struct {
  NvU8 type;
  NvU8 clkPos;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_DATA_V1 data;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_ITEM, *PNV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_ITEM;
#define NV_GPU_CLOCK_CLK_DOMAIN_PROG_RAIL_VF_ITEM_MAX 0x2U
typedef struct {
  NvU32 slope;
  NvS32 interceptmW;
} NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_PWR_ADJUSTMENT;
typedef struct {
  NvU32 maxFreqkHz;
  NvU32 voltuV;
} NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_VF_MAPPING;
#define NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_VF_MAPPING_TABLE_MAX_MAPPINGS 16U
typedef struct {
  NvU8 numMappings;
  NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_VF_MAPPING
      mappings[NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_VF_MAPPING_TABLE_MAX_MAPPINGS];
} NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_VF_MAPPING_TABLE;
typedef struct {
  NvBool bValid;
  NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_PWR_ADJUSTMENT pwrAdjustment;
  NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_VF_MAPPING_TABLE vfMappingTable;
} NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_DATA;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X super;
  NvU8 preVoltOrderingIndex;
  NvU8 postVoltOrderingIndex;
  NvU8 clkVFCurveCount;
  NvU8 clkEnumIdxFirst;
  NvU8 clkEnumIdxLast;
  NvS16 freqDeltaMinMHz;
  NvS16 freqDeltaMaxMHz;
  NV_GPU_CLOCK_FREQ_DELTA_V1 factoryDelta;
  NvU32 railMask;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_PROG_CLK_MON clkMon;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG_RAIL_VF_ITEM
  railVfItem[NV_GPU_CLOCK_CLK_DOMAIN_PROG_RAIL_VF_ITEM_MAX];
  NV_GPU_CLOCK_FREQ_DELTA_V1 grdFreqDelta;
  NV_GPU_CLOCK_CLK_DOMAIN_40_PROG_FBVDD_DATA fbvddData;
  NvU8 rsvd[60];
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG;
typedef union {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_2X v2x;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X v3x;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_FIXED v3xFixed;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_PROG v3xProg;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_MASTER v3xMaster;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_SLAVE v3xSlave;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_DATA_V1;
typedef union {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_2X v2x;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X v3x;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_FIXED v3xFixed;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_PROG v3xProg;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_PROG v30Prog;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_MASTER v30Master;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_SLAVE v30Slave;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_PROG v35Prog;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_MASTER v35Master;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_SLAVE v35Slave;
  NvU8 rsvd[128];
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_DATA_V2;
typedef union {
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_2X v2x;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X v3x;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_FIXED v3xFixed;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_3X_PROG v3xProg;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_PROG v30Prog;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_MASTER v30Master;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_30_SLAVE v30Slave;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_PROG v35Prog;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_MASTER v35Master;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_35_SLAVE v35Slave;
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_40_PROG v40Prog;
  NvU8 rsvd[472];
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_DATA_V3;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE type;
  NV_GPU_CLOCK_DOMAIN_ID domain;
  NvU32 partMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_DATA_V1 data;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE type;
  NV_GPU_CLOCK_DOMAIN_ID domain;
  NvU32 partMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_DATA_V2 data;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_V2;
typedef struct {
  NV_GPU_CLOCK_CLK_DOMAIN_TYPE type;
  NV_GPU_CLOCK_DOMAIN_ID domain;
  NvU32 partMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_DATA_V3 data;
} NV_GPU_CLOCK_CLK_DOMAIN_INFO_V3;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION clkDomainsVersion;
  NV_GPU_BOARDOBJGRP_MASK_E32 domainsMask;
  NvU32 vbiosDomains;
  NvU32 readableDomains;
  NvU32 programmableDomains;
  NV_GPU_BOARDOBJGRP_MASK_E32 masterDomainsMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 clientDomainsMask;
  NvU8 rsvd[56];
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_V1 domains[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
} NV_GPU_CLOCK_CLK_DOMAINS_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION clkDomainsVersion;
  NV_GPU_BOARDOBJGRP_MASK_E32 domainsMask;
  NvU32 vbiosDomains;
  NvU32 readableDomains;
  NvU32 programmableDomains;
  NV_GPU_BOARDOBJGRP_MASK_E32 masterDomainsMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 clientDomainsMask;
  NvU16 cntrSamplingPeriodms;
  NvU8 rsvd[128];
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_V2 domains[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_CLOCK_CLK_DOMAINS_INFO_V2;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_CLK_DOMAIN_VERSION clkDomainsVersion;
  NV_GPU_BOARDOBJGRP_MASK_E32 domainsMask;
  NvU32 vbiosDomains;
  NvU32 readableDomains;
  NvU32 programmableDomains;
  NV_GPU_BOARDOBJGRP_MASK_E32 masterDomainsMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 clientDomainsMask;
  NV_GPU_BOARDOBJGRP_MASK_E32 clkMonDomainsMask;
  NvU16 cntrSamplingPeriodms;
  NvU16 clkMonRefWinUsec;
  NvU8 overClockingBin;
  NvBool bClkMonEnabled;
  NvU8 rsvd[126];
  NV_GPU_CLOCK_CLK_DOMAIN_INFO_V3 domains[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_CLOCK_CLK_DOMAINS_INFO_V3;
#define NV_GPU_CLOCK_CLK_DOMAINS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_DOMAINS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_DOMAINS_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_DOMAINS_INFO_V2, 2)
#define NV_GPU_CLOCK_CLK_DOMAINS_INFO_VER3 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_DOMAINS_INFO_V3, 3)
typedef NV_GPU_CLOCK_CLK_DOMAINS_INFO_V3 NV_GPU_CLOCK_CLK_DOMAINS_INFO;
typedef NV_GPU_CLOCK_CLK_DOMAIN_INFO_V3 NV_GPU_CLOCK_CLK_DOMAIN_INFO;
#define NV_GPU_CLOCK_CLK_DOMAINS_INFO_VER NV_GPU_CLOCK_CLK_DOMAINS_INFO_VER3
NVAPI_INTERFACE NvAPI_GPU_ClockClkDomainsGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                 NV_GPU_CLOCK_CLK_DOMAINS_INFO *pClkDomainsInfo);
#define NV_GPU_CLOCK_CLK_DOMAIN_MAX_FREQS_V1 512
typedef struct {
  NvU32 version;
  NvU8 clkDomainIdx;
  NvU16 numFreqs;
  NvU32 freqsMHz[NV_GPU_CLOCK_CLK_DOMAIN_MAX_FREQS_V1];
} NV_GPU_CLOCK_CLK_DOMAIN_FREQS_ENUM_V1;
typedef NV_GPU_CLOCK_CLK_DOMAIN_FREQS_ENUM_V1 NV_GPU_CLOCK_CLK_DOMAIN_FREQS_ENUM;
#define NV_GPU_CLOCK_CLK_DOMAIN_FREQS_ENUM_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_DOMAIN_FREQS_ENUM_V1, 1)
#define NV_GPU_CLOCK_CLK_DOMAIN_FREQS_ENUM_VER NV_GPU_CLOCK_CLK_DOMAIN_FREQS_ENUM_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkDomainFreqsEnum(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_CLOCK_CLK_DOMAIN_FREQS_ENUM *pClkDomainFreqsEnum);
typedef struct {
  NvU8 voltDomain;
  NvU8 voltageType;
  NvU16 clkFreqMHz;
  NvU32 voltageuV;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_DOMAIN_3X_FREQ_TO_VOLT_INFO;
typedef struct {
  NvU8 voltDomain;
  NvU8 voltageType;
  NvU32 voltageuV;
  NvU16 clkFreqMHz;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_DOMAIN_3X_VOLT_TO_FREQ_INFO;
typedef struct {
  NvU16 clkFreqMHz;
  NvBool bReqFreqDeltaAdj;
  NvBool bFloor;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_DOMAIN_3X_FREQ_QUANTIZE_INFO;
typedef struct {
  NvU16 clkFreqMHz;
  NvU8 clkSourceType;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_DOMAIN_3X_CLK_SOURCE_INFO;
typedef union {
  NV_GPU_CLOCK_CLK_DOMAIN_3X_FREQ_TO_VOLT_INFO freqToVoltInfo;
  NV_GPU_CLOCK_CLK_DOMAIN_3X_VOLT_TO_FREQ_INFO voltToFreqInfo;
  NV_GPU_CLOCK_CLK_DOMAIN_3X_FREQ_QUANTIZE_INFO freqQuantizeInfo;
  NV_GPU_CLOCK_CLK_DOMAIN_3X_CLK_SOURCE_INFO clkSourceInfo;
  NvU8 rsvd[16];
} NV_GPU_CLOCK_CLK_DOMAIN_3X_PROG_RPC_DATA;
typedef struct {
  NvU8 type;
  NvU8 rsvd[16];
  NV_GPU_CLOCK_CLK_DOMAIN_3X_PROG_RPC_DATA rpcData;
} NV_GPU_CLOCK_CLK_DOMAIN_3X_PROG_RPC_INFO;
typedef union {
  NV_GPU_CLOCK_CLK_DOMAIN_3X_PROG_RPC_INFO v3xRpcInfo;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_DOMAIN_CLASS_INFO_DATA;
typedef struct {
  NvU32 version;
  NvU32 clkDomainIdx;
  NvU8 classType;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_DOMAIN_CLASS_INFO_DATA infoData;
} NV_GPU_CLOCK_CLK_DOMAIN_RPC_V1;
typedef NV_GPU_CLOCK_CLK_DOMAIN_RPC_V1 NV_GPU_CLOCK_CLK_DOMAIN_RPC;
#define NV_GPU_CLOCK_CLK_DOMAIN_RPC_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_DOMAIN_RPC_V1, 1)
#define NV_GPU_CLOCK_CLK_DOMAIN_RPC_VER NV_GPU_CLOCK_CLK_DOMAIN_RPC_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkDomainRpc(NvPhysicalGpuHandle hPhysicalGpu,
                                            NV_GPU_CLOCK_CLK_DOMAIN_RPC *pClkDomainRpc);
#define NV_GPU_CLOCK_CLK_PROGS_MAX_V1 255
typedef enum {
  NV_GPU_CLOCK_CLK_PROG_TYPE_1X = 0x0,
  NV_GPU_CLOCK_CLK_PROG_TYPE_1X_MASTER = 0x1,
  NV_GPU_CLOCK_CLK_PROG_TYPE_1X_MASTER_RATIO = 0x2,
  NV_GPU_CLOCK_CLK_PROG_TYPE_1X_MASTER_TABLE = 0x3,
  NV_GPU_CLOCK_CLK_PROG_TYPE_3X = 0x4,
  NV_GPU_CLOCK_CLK_PROG_TYPE_30 = 0x5,
  NV_GPU_CLOCK_CLK_PROG_TYPE_30_MASTER = 0x6,
  NV_GPU_CLOCK_CLK_PROG_TYPE_30_MASTER_RATIO = 0x7,
  NV_GPU_CLOCK_CLK_PROG_TYPE_30_MASTER_TABLE = 0x8,
  NV_GPU_CLOCK_CLK_PROG_TYPE_35 = 0x9,
  NV_GPU_CLOCK_CLK_PROG_TYPE_35_MASTER = 0xA,
  NV_GPU_CLOCK_CLK_PROG_TYPE_35_MASTER_RATIO = 0xB,
  NV_GPU_CLOCK_CLK_PROG_TYPE_35_MASTER_TABLE = 0xC,
  NV_GPU_CLOCK_CLK_PROG_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CLOCK_CLK_PROG_TYPE;
typedef enum {
  NV_GPU_CLOCK_CLK_PROG_TYPE_1X_SOURCE_PLL = 0x0,
  NV_GPU_CLOCK_CLK_PROG_TYPE_1X_SOURCE_ONE_SOURCE = 0x1,
  NV_GPU_CLOCK_CLK_PROG_TYPE_1X_SOURCE_NAFLL = 0x2,
  NV_GPU_CLOCK_CLK_PROG_TYPE_1X_SOURCE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CLOCK_CLK_PROG_TYPE_SOURCE;
typedef struct {
  NvU8 pllIdx;
  NvU8 freqStepSizeMHz;
} NV_GPU_CLOCK_CLK_PROG_1X_SOURCE_PLL;
typedef union {
  NV_GPU_CLOCK_CLK_PROG_1X_SOURCE_PLL pll;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_PROG_1X_SOURCE_DATA_V1;
typedef struct {
  NvU32 baseVFSmoothVoltuV;
  NvU32 maxVFRampRate;
  NvU16 maxFreqStepSizeMHz;
} NV_GPU_CLOCK_CLK_PROG_1X_MASTER_SOURCE_NAFLL;
typedef union {
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_SOURCE_NAFLL nafll;
  NvU8 rsvd[128];
} NV_GPU_CLOCK_CLK_PROG_1X_MASTER_SOURCE_DATA_V1;
typedef struct {
  NvU8 source;
  NvU16 freqMaxMHz;
  NvU8 rsvd[8];
  NV_GPU_CLOCK_CLK_PROG_1X_SOURCE_DATA_V1 sourceData;
} NV_GPU_CLOCK_CLK_PROG_INFO_3X;
typedef NV_GPU_CLOCK_CLK_PROG_INFO_3X NV_GPU_CLOCK_CLK_PROG_INFO_1X;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_3X super;
} NV_GPU_CLOCK_CLK_PROG_INFO_30;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_3X super;
  NvU16 offsettedFreqMaxMHz;
} NV_GPU_CLOCK_CLK_PROG_INFO_35;
#define NV_GPU_CLOCK_CLK_PROG_1X_MASTER_VF_ENTRY_MAX_ENTRIES 0x4
typedef struct {
  NvU8 vfeIdx;
  NvU8 gainVfeIdx;
  NvU8 vfPointIdxFirst;
  NvU8 vfPointIdxLast;
} NV_GPU_CLOCK_CLK_PROG_1X_MASTER_VF_ENTRY;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_1X super;
  NvU8 bOCOVEnabled;
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_VF_ENTRY
  vfEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_VF_ENTRY_MAX_ENTRIES];
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_PROG_INFO_1X_MASTER;
typedef struct {
  NvBool bOCOVEnabled;
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_VF_ENTRY
  vfEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_VF_ENTRY_MAX_ENTRIES];
  NvU8 source;
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_SOURCE_DATA_V1 sourceData;
} NV_GPU_CLOCK_CLK_PROG_INFO_3X_MASTER_INTERFACE;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_30 super;
  NV_GPU_CLOCK_CLK_PROG_INFO_3X_MASTER_INTERFACE master;
} NV_GPU_CLOCK_CLK_PROG_INFO_30_MASTER;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_35 super;
  NV_GPU_CLOCK_CLK_PROG_INFO_3X_MASTER_INTERFACE master;
} NV_GPU_CLOCK_CLK_PROG_INFO_35_MASTER;
#define NV_GPU_CLOCK_CLK_PROG_1X_MASTER_MAX_SLAVE_ENTRIES 0x6
typedef struct {
  NvU8 clkDomIdx;
  NvU8 ratio;
} NV_GPU_CLOCK_CLK_PROG_1X_MASTER_RATIO_SLAVE_ENTRY;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_1X_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_RATIO_SLAVE_ENTRY
  slaveEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_MAX_SLAVE_ENTRIES];
} NV_GPU_CLOCK_CLK_PROG_INFO_1X_MASTER_RATIO;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_RATIO_SLAVE_ENTRY
  slaveEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_MAX_SLAVE_ENTRIES];
} NV_GPU_CLOCK_CLK_PROG_INFO_3X_MASTER_RATIO_INTERFACE;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_30_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_INFO_3X_MASTER_RATIO_INTERFACE ratio;
} NV_GPU_CLOCK_CLK_PROG_INFO_30_MASTER_RATIO;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_35_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_INFO_3X_MASTER_RATIO_INTERFACE ratio;
} NV_GPU_CLOCK_CLK_PROG_INFO_35_MASTER_RATIO;
typedef struct {
  NvU8 clkDomIdx;
  NvU16 freqMHz;
} NV_GPU_CLOCK_CLK_PROG_1X_MASTER_TABLE_SLAVE_ENTRY;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_1X_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_TABLE_SLAVE_ENTRY
  slaveEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_MAX_SLAVE_ENTRIES];
} NV_GPU_CLOCK_CLK_PROG_INFO_1X_MASTER_TABLE;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_TABLE_SLAVE_ENTRY
  slaveEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_MAX_SLAVE_ENTRIES];
} NV_GPU_CLOCK_CLK_PROG_INFO_3X_MASTER_TABLE_INTERFACE;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_30_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_INFO_3X_MASTER_TABLE_INTERFACE table;
} NV_GPU_CLOCK_CLK_PROG_INFO_30_MASTER_TABLE;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_INFO_35_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_INFO_3X_MASTER_TABLE_INTERFACE table;
} NV_GPU_CLOCK_CLK_PROG_INFO_35_MASTER_TABLE;
typedef union {
  NV_GPU_CLOCK_CLK_PROG_INFO_1X v1x;
  NV_GPU_CLOCK_CLK_PROG_INFO_1X_MASTER v1xMaster;
  NV_GPU_CLOCK_CLK_PROG_INFO_1X_MASTER_RATIO v1xMasterRatio;
  NV_GPU_CLOCK_CLK_PROG_INFO_1X_MASTER_TABLE v1xMasterTable;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_PROG_INFO_DATA_V1;
typedef union {
  NV_GPU_CLOCK_CLK_PROG_INFO_3X v3x;
  NV_GPU_CLOCK_CLK_PROG_INFO_30 v30;
  NV_GPU_CLOCK_CLK_PROG_INFO_35 v35;
  NV_GPU_CLOCK_CLK_PROG_INFO_30_MASTER v30Master;
  NV_GPU_CLOCK_CLK_PROG_INFO_35_MASTER v35Master;
  NV_GPU_CLOCK_CLK_PROG_INFO_30_MASTER_RATIO v30MasterRatio;
  NV_GPU_CLOCK_CLK_PROG_INFO_35_MASTER_RATIO v35MasterRatio;
  NV_GPU_CLOCK_CLK_PROG_INFO_30_MASTER_TABLE v30MasterTable;
  NV_GPU_CLOCK_CLK_PROG_INFO_35_MASTER_TABLE v35MasterTable;
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLK_PROG_INFO_DATA_V2;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_PROG_INFO_DATA_V1 data;
} NV_GPU_CLOCK_CLK_PROG_INFO_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_PROG_INFO_DATA_V2 data;
} NV_GPU_CLOCK_CLK_PROG_INFO_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 progsMask;
  NvU8 slaveEntryCount;
  NvU8 vfEntryCount;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROG_INFO_V1 progs[NV_GPU_CLOCK_CLK_PROGS_MAX_V1];
} NV_GPU_CLOCK_CLK_PROGS_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 progsMask;
  NvU8 slaveEntryCount;
  NvU8 vfEntryCount;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROG_INFO_V2 progs[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_CLOCK_CLK_PROGS_INFO_V2;
typedef NV_GPU_CLOCK_CLK_PROGS_INFO_V2 NV_GPU_CLOCK_CLK_PROGS_INFO;
typedef NV_GPU_CLOCK_CLK_PROG_INFO_V2 NV_GPU_CLOCK_CLK_PROG_INFO;
#define NV_GPU_CLOCK_CLK_PROGS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROGS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_PROGS_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROGS_INFO_V2, 2)
#define NV_GPU_CLOCK_CLK_PROGS_INFO_VER NV_GPU_CLOCK_CLK_PROGS_INFO_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockClkProgsGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                               NV_GPU_CLOCK_CLK_PROGS_INFO *pClkProgsInfo);
typedef struct {
  NvU16 freqMaxMHz;
} NV_GPU_CLOCK_CLK_PROG_STATUS_30;
typedef struct {
  NvU16 freqMaxMHz;
} NV_GPU_CLOCK_CLK_PROG_STATUS_35;
typedef union {
  NV_GPU_CLOCK_CLK_PROG_STATUS_30 v30;
  NV_GPU_CLOCK_CLK_PROG_STATUS_35 v35;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_PROG_STATUS_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_TYPE type;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROG_STATUS_DATA_V1 data;
} NV_GPU_CLOCK_CLK_PROG_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 progsMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROG_STATUS_V1 progs[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_CLOCK_CLK_PROGS_STATUS_V1;
typedef NV_GPU_CLOCK_CLK_PROGS_STATUS_V1 NV_GPU_CLOCK_CLK_PROGS_STATUS;
typedef NV_GPU_CLOCK_CLK_PROG_STATUS_V1 NV_GPU_CLOCK_CLK_PROG_STATUS;
#define NV_GPU_CLOCK_CLK_PROGS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROGS_STATUS_V1, 1)
#define NV_GPU_CLOCK_CLK_PROGS_STATUS_VER NV_GPU_CLOCK_CLK_PROGS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkProgsGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                 NV_GPU_CLOCK_CLK_PROGS_STATUS *pClkProgsStatus);
typedef struct {
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_PROG_CONTROL_3X;
typedef NV_GPU_CLOCK_CLK_PROG_CONTROL_3X NV_GPU_CLOCK_CLK_PROG_CONTROL_1X;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_3X super;
  NV_GPU_CLOCK_CLK_DELTA deltas;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER;
typedef NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER NV_GPU_CLOCK_CLK_PROG_CONTROL_1X_MASTER;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER master;
} NV_GPU_CLOCK_CLK_PROG_CONTROL_30_MASTER;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER master;
} NV_GPU_CLOCK_CLK_PROG_CONTROL_35_MASTER;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_1X_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_RATIO_SLAVE_ENTRY
  slaveEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_MAX_SLAVE_ENTRIES];
} NV_GPU_CLOCK_CLK_PROG_CONTROL_1X_MASTER_RATIO;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_RATIO_SLAVE_ENTRY
  slaveEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_MAX_SLAVE_ENTRIES];
} NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER_RATIO_INTERFACE;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_30_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER_RATIO_INTERFACE ratio;
} NV_GPU_CLOCK_CLK_PROG_CONTROL_30_MASTER_RATIO;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_35_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER_RATIO_INTERFACE ratio;
} NV_GPU_CLOCK_CLK_PROG_CONTROL_35_MASTER_RATIO;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_1X_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_TABLE_SLAVE_ENTRY
  slaveEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_MAX_SLAVE_ENTRIES];
} NV_GPU_CLOCK_CLK_PROG_CONTROL_1X_MASTER_TABLE;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_1X_MASTER_TABLE_SLAVE_ENTRY
  slaveEntries[NV_GPU_CLOCK_CLK_PROG_1X_MASTER_MAX_SLAVE_ENTRIES];
} NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER_TABLE_INTERFACE;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_30_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER_TABLE_INTERFACE table;
} NV_GPU_CLOCK_CLK_PROG_CONTROL_30_MASTER_TABLE;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_35_MASTER super;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_3X_MASTER_TABLE_INTERFACE table;
} NV_GPU_CLOCK_CLK_PROG_CONTROL_35_MASTER_TABLE;
typedef union {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_1X v1x;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_1X_MASTER v1xMaster;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_1X_MASTER_RATIO v1xMasterRatio;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_1X_MASTER_TABLE v1xMasterTable;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_PROG_CONTROL_DATA_V1;
typedef union {
  NV_GPU_CLOCK_CLK_PROG_CONTROL_3X v3x;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_30_MASTER v30Master;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_30_MASTER_RATIO v30MasterRatio;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_30_MASTER_TABLE v30MasterTable;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_35_MASTER v35Master;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_35_MASTER_RATIO v35MasterRatio;
  NV_GPU_CLOCK_CLK_PROG_CONTROL_35_MASTER_TABLE v35MasterTable;
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLK_PROG_CONTROL_DATA_V2;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_PROG_CONTROL_DATA_V1 data;
} NV_GPU_CLOCK_CLK_PROG_CONTROL_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_PROG_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_PROG_CONTROL_DATA_V2 data;
} NV_GPU_CLOCK_CLK_PROG_CONTROL_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 progsMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROG_CONTROL_V1 progs[NV_GPU_CLOCK_CLK_PROGS_MAX_V1];
} NV_GPU_CLOCK_CLK_PROGS_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 progsMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROG_CONTROL_V2 progs[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_CLOCK_CLK_PROGS_CONTROL_V2;
typedef NV_GPU_CLOCK_CLK_PROGS_CONTROL_V2 NV_GPU_CLOCK_CLK_PROGS_CONTROL;
typedef NV_GPU_CLOCK_CLK_PROG_CONTROL_V2 NV_GPU_CLOCK_CLK_PROG_CONTROL;
#define NV_GPU_CLOCK_CLK_PROGS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROGS_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLK_PROGS_CONTROL_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROGS_CONTROL_V2, 2)
#define NV_GPU_CLOCK_CLK_PROGS_CONTROL_VER NV_GPU_CLOCK_CLK_PROGS_CONTROL_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockClkProgsGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_CLOCK_CLK_PROGS_CONTROL *pClkProgsControl);
NVAPI_INTERFACE NvAPI_GPU_ClockClkProgsSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_CLOCK_CLK_PROGS_CONTROL *pClkProgsControl);
#define NV_GPU_CLOCK_CLK_ENUMS_MAX_V1 255
typedef enum {
  NV_GPU_CLOCK_CLK_ENUM_TYPE_1X = 0x0,
  NV_GPU_CLOCK_CLK_ENUM_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CLOCK_CLK_ENUM_TYPE;
typedef struct {
  NV_GPU_CLOCK_CLK_ENUM_TYPE type;
  NvBool bOCOVEnabled;
  NvU16 freqMinMHz;
  NvU16 freqMaxMHz;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_ENUM_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 enumsMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_ENUM_INFO_V1 enums[NV_GPU_CLOCK_CLK_ENUMS_MAX_V1];
} NV_GPU_CLOCK_CLK_ENUMS_INFO_V1;
typedef NV_GPU_CLOCK_CLK_ENUMS_INFO_V1 NV_GPU_CLOCK_CLK_ENUMS_INFO;
typedef NV_GPU_CLOCK_CLK_ENUM_INFO_V1 NV_GPU_CLOCK_CLK_ENUM_INFO;
#define NV_GPU_CLOCK_CLK_ENUMS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_ENUMS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_ENUMS_INFO_VER NV_GPU_CLOCK_CLK_ENUMS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkEnumsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_GPU_CLOCK_CLK_ENUMS_INFO *pClkEnumsInfo);
#define NV_GPU_CLOCK_CLK_VF_REL_IDX_INVALID NV_U8_MAX
typedef enum {
  NV_GPU_CLOCK_CLK_VF_REL_TYPE_RATIO = 0x00U,
  NV_GPU_CLOCK_CLK_VF_REL_TYPE_TABLE = 0x01U,
  NV_GPU_CLOCK_CLK_VF_REL_TYPE_TABLE_FREQ = 0x02U,
  NV_GPU_CLOCK_CLK_VF_REL_TYPE_RATIO_VOLT = 0x03U,
  NV_GPU_CLOCK_CLK_VF_REL_TYPE_RATIO_FREQ = 0x04U,
  NV_GPU_CLOCK_CLK_VF_REL_TYPE_UNKNOWN = 0xFFU,
} NV_GPU_CLOCK_CLK_VF_REL_TYPE;
#define NV_GPU_CLOCK_CLK_VF_REL_VF_CURVE_IDX_INVALID 0xFFU
#define NV_GPU_CLOCK_CLK_VF_REL_VF_CURVE_IDX_PRI 0x00U
#define NV_GPU_CLOCK_CLK_VF_REL_VF_CURVE_IDX_SEC_0 0x01U
#define NV_GPU_CLOCK_CLK_VF_REL_VF_CURVE_IDX_MAX 0x07U
#define NV_GPU_CLOCK_CLK_VF_REL_VF_ENTRY_SEC_MAX_V1 0x06U
#define NV_GPU_CLOCK_CLK_VF_REL_RATIO_SLAVE_ENTRIES_MAX_V1 0x10U
#define NV_GPU_CLOCK_CLK_VF_REL_TABLE_SLAVE_ENTRIES_MAX_V1 0x10U
#define NV_GPU_CLOCK_CLK_VF_RELS_MAX_V1 255
#define NV_GPU_CLOCK_CLK_VF_REL_RATIO_VOLT_VF_SMOOTH_DATA_ENTRIES_MAX_V1 0x08U
typedef struct {
  NvBoardObjIdx vfeIdx;
  NvBoardObjIdx cpmMaxFreqOffsetVfeIdx;
  NvBoardObjIdx vfPointIdxFirst;
  NvBoardObjIdx vfPointIdxLast;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_REL_VF_ENTRY_PRI_V1;
typedef struct {
  NvBoardObjIdx vfeIdx;
  NvBoardObjIdx dvcoOffsetVfeIdx;
  NvBoardObjIdx vfPointIdxFirst;
  NvBoardObjIdx vfPointIdxLast;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_REL_VF_ENTRY_SEC_V1;
typedef struct {
  NvU32 baseVFSmoothVoltuV;
  NvU32 maxVFRampRate;
  NvU16 maxFreqStepSizeMHz;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_REL_RATIO_VOLT_VF_SMOOTH_DATA_V1;
typedef struct {
  NvU8 vfSmoothDataEntriesCount;
  NV_GPU_CLOCK_CLK_VF_REL_RATIO_VOLT_VF_SMOOTH_DATA_V1
  vfSmoothDataEntries[NV_GPU_CLOCK_CLK_VF_REL_RATIO_VOLT_VF_SMOOTH_DATA_ENTRIES_MAX_V1];
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_VOLT_VF_SMOOTH_DATA_GRP_V1;
typedef struct {
  NvU8 clkDomIdx;
  NvU16 freqMHz;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_REL_TABLE_SLAVE_ENTRY_V1;
typedef struct {
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_VF_REL_TABLE_SLAVE_ENTRY_V1
  slaveEntries[NV_GPU_CLOCK_CLK_VF_REL_TABLE_SLAVE_ENTRIES_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_REL_INFO_TABLE_V1;
typedef struct {
  NvU8 clkDomIdx;
  NvU8 ratio;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_REL_RATIO_SLAVE_ENTRY_V1;
typedef struct {
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_VF_REL_RATIO_SLAVE_ENTRY_V1
  slaveEntries[NV_GPU_CLOCK_CLK_VF_REL_RATIO_SLAVE_ENTRIES_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_V1 ratio;
  NV_GPU_CLOCK_CLK_VF_REL_RATIO_VOLT_VF_SMOOTH_DATA_V1 vfSmoothData;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_VOLT_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_V1 ratio;
  NV_GPU_CLOCK_CLK_VF_REL_RATIO_VOLT_VF_SMOOTH_DATA_V1 vfSmoothData;
  NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_VOLT_VF_SMOOTH_DATA_GRP_V1
  vfSmoothDataGrp;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_VOLT_V2;
typedef union {
  NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_V1 ratio;
  NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_VOLT_V1 ratioVolt;
  NV_GPU_CLOCK_CLK_VF_REL_INFO_TABLE_V1 table;
  NvU32 rsvd[256];
} NV_GPU_CLOCK_CLK_VF_REL_INFO_DATA_V1;
typedef union {
  NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_V1 ratio;
  NV_GPU_CLOCK_CLK_VF_REL_INFO_RATIO_VOLT_V2 ratioVolt;
  NV_GPU_CLOCK_CLK_VF_REL_INFO_TABLE_V1 table;
  NvU32 rsvd[1024];
} NV_GPU_CLOCK_CLK_VF_REL_INFO_DATA_V2;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_REL_TYPE type;
  NvU8 railIdx;
  NvBool bOCOVEnabled;
  NvU16 freqMaxMHz;
  NV_GPU_CLOCK_CLK_VF_REL_VF_ENTRY_PRI_V1 vfEntryPri;
  NV_GPU_CLOCK_CLK_VF_REL_VF_ENTRY_SEC_V1
  vfEntriesSec[NV_GPU_CLOCK_CLK_VF_REL_VF_ENTRY_SEC_MAX_V1];
  NvU32 rsvd[64];
  NV_GPU_CLOCK_CLK_VF_REL_INFO_DATA_V1 data;
} NV_GPU_CLOCK_CLK_VF_REL_INFO_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_REL_TYPE type;
  NvU8 railIdx;
  NvBool bOCOVEnabled;
  NvU16 freqMaxMHz;
  NV_GPU_CLOCK_CLK_VF_REL_VF_ENTRY_PRI_V1 vfEntryPri;
  NV_GPU_CLOCK_CLK_VF_REL_VF_ENTRY_SEC_V1
  vfEntriesSec[NV_GPU_CLOCK_CLK_VF_REL_VF_ENTRY_SEC_MAX_V1];
  NvU32 rsvd[64];
  NV_GPU_CLOCK_CLK_VF_REL_INFO_DATA_V2 data;
} NV_GPU_CLOCK_CLK_VF_REL_INFO_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vfRelsMask;
  NvU8 slaveEntryCount;
  NvU8 vfEntryCountSec;
  NvU32 rsvd[64];
  NV_GPU_CLOCK_CLK_VF_REL_INFO_V1 vfRels[NV_GPU_CLOCK_CLK_VF_RELS_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_RELS_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vfRelsMask;
  NvU8 slaveEntryCount;
  NvU8 vfEntryCountSec;
  NvU32 rsvd[64];
  NV_GPU_CLOCK_CLK_VF_REL_INFO_V2 vfRels[NV_GPU_CLOCK_CLK_VF_RELS_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_RELS_INFO_V2;
typedef NV_GPU_CLOCK_CLK_VF_RELS_INFO_V2 NV_GPU_CLOCK_CLK_VF_RELS_INFO;
typedef NV_GPU_CLOCK_CLK_VF_REL_INFO_V2 NV_GPU_CLOCK_CLK_VF_REL_INFO;
#define NV_GPU_CLOCK_CLK_VF_RELS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_RELS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_VF_RELS_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_RELS_INFO_V2, 2)
#define NV_GPU_CLOCK_CLK_VF_RELS_INFO_VER NV_GPU_CLOCK_CLK_VF_RELS_INFO_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockClkVfRelsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                __inout NV_GPU_CLOCK_CLK_VF_RELS_INFO *pClkVfRelsInfo);
typedef struct {
  NV_GPU_CLOCK_CLK_VF_REL_TYPE type;
  NvU16 offsettedFreqMaxMHz;
  NvU32 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_REL_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vfRelsMask;
  NvU32 rsvd[64];
  NV_GPU_CLOCK_CLK_VF_REL_STATUS_V1 vfRels[NV_GPU_CLOCK_CLK_VF_RELS_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_RELS_STATUS_V1;
typedef NV_GPU_CLOCK_CLK_VF_RELS_STATUS_V1 NV_GPU_CLOCK_CLK_VF_RELS_STATUS;
typedef NV_GPU_CLOCK_CLK_VF_REL_STATUS_V1 NV_GPU_CLOCK_CLK_VF_REL_STATUS;
#define NV_GPU_CLOCK_CLK_VF_RELS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_RELS_STATUS_V1, 1)
#define NV_GPU_CLOCK_CLK_VF_RELS_STATUS_VER NV_GPU_CLOCK_CLK_VF_RELS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkVfRelsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_CLOCK_CLK_VF_RELS_STATUS *pClkVfRelsStatus);
typedef struct {
  NV_GPU_CLOCK_CLK_VF_REL_RATIO_SLAVE_ENTRY_V1
  slaveEntries[NV_GPU_CLOCK_CLK_VF_REL_RATIO_SLAVE_ENTRIES_MAX_V1];
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_REL_CONTROL_RATIO_V1;
typedef union {
  NV_GPU_CLOCK_CLK_VF_REL_CONTROL_RATIO_V1 ratio;
  NvU32 rsvd[256];
} NV_GPU_CLOCK_CLK_VF_REL_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_REL_TYPE type;
  NV_GPU_CLOCK_CLK_DELTA_V1 delta;
  NvU32 rsvd[64];
  NV_GPU_CLOCK_CLK_VF_REL_CONTROL_DATA_V1 data;
} NV_GPU_CLOCK_CLK_VF_REL_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vfRelsMask;
  NvU32 rsvd[64];
  NV_GPU_CLOCK_CLK_VF_REL_CONTROL_V1 vfRels[NV_GPU_CLOCK_CLK_VF_RELS_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_RELS_CONTROL_V1;
typedef NV_GPU_CLOCK_CLK_VF_RELS_CONTROL_V1 NV_GPU_CLOCK_CLK_VF_RELS_CONTROL;
typedef NV_GPU_CLOCK_CLK_VF_REL_CONTROL_V1 NV_GPU_CLOCK_CLK_VF_REL_CONTROL;
#define NV_GPU_CLOCK_CLK_VF_RELS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_RELS_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLK_VF_RELS_CONTROL_VER NV_GPU_CLOCK_CLK_VF_RELS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkVfRelsGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GPU_CLOCK_CLK_VF_RELS_CONTROL *pClkVfRelsControl);
NVAPI_INTERFACE NvAPI_GPU_ClockClkVfRelsSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __in NV_GPU_CLOCK_CLK_VF_RELS_CONTROL *pClkVfRelsControl);
#define NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1 NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS
#define NV_GPU_CLOCK_CLK_VF_POINT_MAX_V2 NV_GPU_BOARDOBJGRP_E512_MAX_OBJECTS
#define NV_GPU_CLOCK_CLK_VF_POINT_IDX_INVALID NV_U8_MAX
typedef enum {
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_FREQ = 0x0,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_VOLT = 0x1,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_30_FREQ = NV_GPU_CLOCK_CLK_VF_POINT_TYPE_FREQ,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_30_VOLT = NV_GPU_CLOCK_CLK_VF_POINT_TYPE_VOLT,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_30 = 0x2,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_35_FREQ = 0x3,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_35_VOLT = 0x4,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_35_VOLT_PRI = NV_GPU_CLOCK_CLK_VF_POINT_TYPE_35_VOLT,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_35 = 0x5,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_35_VOLT_SEC = 0x6,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_40_FREQ = 0x7,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_40_VOLT = 0x8,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_40_VOLT_PRI = NV_GPU_CLOCK_CLK_VF_POINT_TYPE_40_VOLT,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_40 = 0x9,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_40_VOLT_SEC = 0xA,
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CLOCK_CLK_VF_POINT_TYPE;
typedef struct {
  NvU16 freqMHz;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_INFO_FREQ;
typedef NV_GPU_CLOCK_CLK_VF_POINT_INFO_FREQ NV_GPU_CLOCK_CLK_VF_POINT_INFO_30_FREQ;
typedef NV_GPU_CLOCK_CLK_VF_POINT_INFO_FREQ NV_GPU_CLOCK_CLK_VF_POINT_INFO_35_FREQ;
typedef NV_GPU_CLOCK_CLK_VF_POINT_INFO_FREQ NV_GPU_CLOCK_CLK_VF_POINT_INFO_40_FREQ;
typedef struct {
  NvU32 sourceVoltageuV;
  NvU8 rsvd[10];
} NV_GPU_CLOCK_CLK_VF_POINT_INFO_VOLT;
typedef NV_GPU_CLOCK_CLK_VF_POINT_INFO_VOLT NV_GPU_CLOCK_CLK_VF_POINT_INFO_30_VOLT;
typedef NV_GPU_CLOCK_CLK_VF_POINT_INFO_VOLT NV_GPU_CLOCK_CLK_VF_POINT_INFO_35_VOLT;
typedef NV_GPU_CLOCK_CLK_VF_POINT_INFO_VOLT NV_GPU_CLOCK_CLK_VF_POINT_INFO_40_VOLT;
typedef union {
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_FREQ freq;
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_VOLT volt;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VF_POINT_INFO_DATA_V1;
typedef union {
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_30_FREQ v30Freq;
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_30_VOLT v30Volt;
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_35_FREQ v35Freq;
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_35_VOLT v35Volt;
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_40_FREQ v40Freq;
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_40_VOLT v40Volt;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_POINT_INFO_DATA_V2;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE type;
  NvU8 vfeEquIdx;
  NvU8 voltRailIdx;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_DATA_V1 data;
} NV_GPU_CLOCK_CLK_VF_POINT_INFO_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE type;
  NvU8 vfeEquIdx;
  NvU8 voltRailIdx;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_DATA_V2 data;
} NV_GPU_CLOCK_CLK_VF_POINT_INFO_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_V1 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_POINTS_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_POINTS_INFO_V2;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_POINTS_SEC_INFO_V1, *PNV_GPU_CLOCK_CLK_VF_POINTS_SEC_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
  NV_GPU_CLOCK_CLK_VF_POINTS_SEC_INFO_V1 sec;
} NV_GPU_CLOCK_CLK_VF_POINTS_INFO_V3;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[512];
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V2];
} NV_GPU_CLOCK_CLK_VF_POINTS_SEC_INFO_V2, *PNV_GPU_CLOCK_CLK_VF_POINTS_SEC_INFO_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[512];
  NV_GPU_CLOCK_CLK_VF_POINT_INFO_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V2];
  NV_GPU_CLOCK_CLK_VF_POINTS_SEC_INFO_V2 sec;
} NV_GPU_CLOCK_CLK_VF_POINTS_INFO_V4;
typedef NV_GPU_CLOCK_CLK_VF_POINTS_INFO_V4 NV_GPU_CLOCK_CLK_VF_POINTS_INFO;
typedef NV_GPU_CLOCK_CLK_VF_POINT_INFO_V2 NV_GPU_CLOCK_CLK_VF_POINT_INFO;
#define NV_GPU_CLOCK_CLK_VF_POINTS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_VF_POINTS_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_INFO_V2, 2)
#define NV_GPU_CLOCK_CLK_VF_POINTS_INFO_VER3 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_INFO_V3, 3)
#define NV_GPU_CLOCK_CLK_VF_POINTS_INFO_VER4 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_INFO_V4, 4)
#define NV_GPU_CLOCK_CLK_VF_POINTS_INFO_VER NV_GPU_CLOCK_CLK_VF_POINTS_INFO_VER4
NVAPI_INTERFACE NvAPI_GPU_ClockClkVfPointsGetInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_CLOCK_CLK_VF_POINTS_INFO *pClkVfPointsInfo);
typedef struct {
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_FREQ;
typedef struct {
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_VOLT;
typedef struct {
  NvU16 freqMHz;
  NvU32 voltageuV;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_PAIR;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_PAIR pair;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_30;
typedef struct {
  NvU16 freqMHz;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_FREQ_TUPLE;
#define NV_GPU_CLOCK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE 0x5
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_FREQ_TUPLE
  freqTuple[NV_GPU_CLOCK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE];
  NvU32 voltageuV;
  NvU16 cpmMaxFreqOffsetMHz;
  NvU8 rsvd[6];
} NV_GPU_CLOCK_CLK_VF_POINT_BASE_VF_TUPLE;
#define NV_GPU_CLOCK_CLK_VF_POINT_DVCO_OFFSET_CODE_INVALID 0xFF
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_BASE_VF_TUPLE super;
  NvU8 dvcoOffsetCode;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VF_POINT_BASE_VF_TUPLE_SEC, *PNV_GPU_CLOCK_CLK_VF_POINT_BASE_VF_TUPLE_SEC;
typedef struct {
  NvU16 freqMHz;
  NvU32 voltageuV;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_VF_TUPLE;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_BASE_VF_TUPLE baseVFTuple;
  NvU8 rsvd[8];
  NV_GPU_CLOCK_CLK_VF_POINT_VF_TUPLE
  offsetedVFTuple[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35;
typedef NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35 NV_GPU_CLOCK_CLK_VF_POINT_STATUS_40;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_BASE_VF_TUPLE baseVFTuple;
  NV_GPU_CLOCK_CLK_VF_POINT_VF_TUPLE
  offsetedVFTuple[NV_GPU_CLOCK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE];
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_FREQ, *PNV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_FREQ;
typedef NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_FREQ NV_GPU_CLOCK_CLK_VF_POINT_STATUS_40_FREQ;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_BASE_VF_TUPLE baseVFTuple;
  NV_GPU_CLOCK_CLK_VF_POINT_VF_TUPLE
  offsetedVFTuple[NV_GPU_CLOCK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE];
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_VOLT_PRI, *PNV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_VOLT_PRI;
typedef NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_VOLT_PRI NV_GPU_CLOCK_CLK_VF_POINT_STATUS_40_VOLT_PRI;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_BASE_VF_TUPLE_SEC baseVFTuple;
  NV_GPU_CLOCK_CLK_VF_POINT_VF_TUPLE
  offsetedVFTuple[NV_GPU_CLOCK_CLK_VF_POINT_FREQ_TUPLE_MAX_SIZE];
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_VOLT_SEC, *PNV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_VOLT_SEC;
typedef NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_VOLT_SEC NV_GPU_CLOCK_CLK_VF_POINT_STATUS_40_VOLT_SEC;
typedef union {
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_FREQ freq;
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_VOLT volt;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_DATA_V1;
typedef union {
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_30 v30;
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35 v35;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_DATA_V2;
typedef union {
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_30 v30;
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_FREQ v35Freq;
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_VOLT_PRI v35VoltPri;
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_35_VOLT_SEC v35VoltSec;
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_40_FREQ v40Freq;
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_40_VOLT_PRI v40VoltPri;
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_40_VOLT_SEC v40VoltSec;
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_DATA_V3;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE type;
  NvU32 voltageuV;
  NvU16 freqMHz;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_DATA_V1 data;
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_DATA_V2 data;
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V2;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_DATA_V3 data;
} NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V3;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V1 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_V2;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V3 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_POINTS_SEC_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V3 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
  NV_GPU_CLOCK_CLK_VF_POINTS_SEC_STATUS_V1 sec;
} NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_V3;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[512];
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V3 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V2];
} NV_GPU_CLOCK_CLK_VF_POINTS_SEC_STATUS_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[512];
  NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V3 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V2];
  NV_GPU_CLOCK_CLK_VF_POINTS_SEC_STATUS_V2 sec;
} NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_V4;
typedef NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_V4 NV_GPU_CLOCK_CLK_VF_POINTS_STATUS;
typedef NV_GPU_CLOCK_CLK_VF_POINT_STATUS_V3 NV_GPU_CLOCK_CLK_VF_POINT_STATUS;
#define NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_V1, 1)
#define NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_V2, 2)
#define NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_VER3 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_V3, 3)
#define NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_VER4 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_V4, 4)
#define NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_VER NV_GPU_CLOCK_CLK_VF_POINTS_STATUS_VER4
NVAPI_INTERFACE NvAPI_GPU_ClockClkVfPointsGetStatus(NvPhysicalGpuHandle hPhysicalGpu,
                                                    NV_GPU_CLOCK_CLK_VF_POINTS_STATUS *pClkVfPointsStatus);
typedef struct {
  NvS32 voltDeltauV;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_FREQ;
typedef NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_FREQ NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_30_FREQ;
typedef NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_FREQ NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_35_FREQ;
typedef NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_FREQ NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_40_FREQ;
typedef struct {
  NvS32 freqDeltakHz;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_VOLT;
typedef struct {
  NV_GPU_CLOCK_FREQ_DELTA_V1 freqDelta;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_30_VOLT;
typedef NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_30_VOLT NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_35_VOLT;
typedef NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_30_VOLT NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_40_VOLT;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_35_VOLT super;
  NvU8 dvcoOffsetCodeOverride;
  NvU8 rsvd[8];
} NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_35_VOLT_SEC, *PNV_GPU_CLOCK_CLK_VF_POINT_CONTROL_35_VOLT_SEC;
typedef NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_35_VOLT_SEC NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_40_VOLT_SEC;
typedef union {
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_FREQ freq;
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_VOLT volt;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_DATA_V1;
typedef union {
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_30_FREQ v30Freq;
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_30_VOLT v30Volt;
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_35_FREQ v35Freq;
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_35_VOLT v35Volt;
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_35_VOLT_SEC v35VoltSec;
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_40_FREQ v40Freq;
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_40_VOLT v40Volt;
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_40_VOLT_SEC v40VoltSec;
  NvU8 rsvd[1024];
} NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_DATA_V2;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_DATA_V1 data;
} NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VF_POINT_TYPE type;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_DATA_V2 data;
} NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_V1 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_V2;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
} NV_GPU_CLOCK_CLK_VF_POINTS_SEC_CONTROL, *PNV_GPU_CLOCK_CLK_VF_POINTS_SEC_CONTROL;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V1];
  NV_GPU_CLOCK_CLK_VF_POINTS_SEC_CONTROL sec;
} NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_V3;
typedef struct {
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[512];
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V2];
} NV_GPU_CLOCK_CLK_VF_POINTS_SEC_CONTROL_V2, *PNV_GPU_CLOCK_CLK_VF_POINTS_SEC_CONTROL_V2;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E512 vfPointsMask;
  NvU8 rsvd[512];
  NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_V2 vfPoints[NV_GPU_CLOCK_CLK_VF_POINT_MAX_V2];
  NV_GPU_CLOCK_CLK_VF_POINTS_SEC_CONTROL_V2 sec;
} NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_V4;
typedef NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_V4 NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL;
typedef NV_GPU_CLOCK_CLK_VF_POINT_CONTROL_V2 NV_GPU_CLOCK_CLK_VF_POINT_CONTROL;
#define NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_V2, 2)
#define NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_VER3 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_V3, 3)
#define NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_VER4 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_V4, 4)
#define NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_VER NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL_VER4
NVAPI_INTERFACE NvAPI_GPU_ClockClkVfPointsGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                     NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL *pClkVfPointsControl);
NVAPI_INTERFACE NvAPI_GPU_ClockClkVfPointsSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                     NV_GPU_CLOCK_CLK_VF_POINTS_CONTROL *pClkVfPointsControl);
#define NV_GPU_CLOCK_CLK_PROP_REGIMES_MAX_V1 32
typedef enum {
  NV_GPU_CLOCK_CLK_PROP_REGIME_TYPE_1X = 0x0,
  NV_GPU_CLOCK_CLK_PROP_REGIME_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CLOCK_CLK_PROP_REGIME_TYPE;
typedef enum {
  NV_GPU_CLOCK_CLK_PROP_REGIME_HAL_GA10X = 0x00U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_HAL_TU10X_AMPERE = 0x01U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_HAL_MAX = 0x0FU,
} NV_GPU_CLOCK_CLK_PROP_REGIME_HAL;
typedef enum {
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_INVALID = 0x00U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_STRICT = 0x01U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_LOOSE = 0x02U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_DRAM_STRICT = 0x03U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_GPC_STRICT = 0x04U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_DISP_STRICT = 0x05U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_PCIE_STRICT = 0x06U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_IMP = 0x07U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_STRICT_NO_DISP = 0x08U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_XBAR_STRICT = 0x09U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_TGP_STRICT = 0x0AU,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_NV_PWR_STRICT = 0x0BU,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_MS_PWR_STRICT = 0x0CU,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_NV_VOLT_STRICT = 0x0DU,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_MS_VOLT_STRICT = 0x0EU,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_DRAM_LOCK = 0x0FU,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_XBAR_LOCK = 0x11U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_PERF_STRICT = 0x12U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_IMP_CLIENT_STRICT = 0x13U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_GPC_POWER_STRICT = 0x14U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_XBAR_POWER_STRICT = 0x15U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_NVVDD_STRICT = 0x16U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_MSVDD_STRICT = 0x17U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_RSVD_0 = 0x18U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_RSVD_1 = 0x19U,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_RSVD_2 = 0x1AU,
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID_MAX = 0x1FU,
} NV_GPU_CLOCK_CLK_PROP_REGIME_ID;
typedef struct {
  NV_GPU_CLOCK_CLK_PROP_REGIME_TYPE type;
  NV_GPU_CLOCK_CLK_PROP_REGIME_ID regimeId;
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainIndexMask;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_PROP_REGIME_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_CLK_PROP_REGIME_HAL regimeHal;
  NV_GPU_BOARDOBJGRP_MASK_E32 propRegimesMask;
  NvU8 rsvd[256];
  NV_GPU_CLOCK_CLK_PROP_REGIME_INFO_V1 propRegimes[NV_GPU_CLOCK_CLK_PROP_REGIMES_MAX_V1];
} NV_GPU_CLOCK_CLK_PROP_REGIMES_INFO_V1;
typedef NV_GPU_CLOCK_CLK_PROP_REGIMES_INFO_V1 NV_GPU_CLOCK_CLK_PROP_REGIMES_INFO;
#define NV_GPU_CLOCK_CLK_PROP_REGIMES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROP_REGIMES_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_PROP_REGIMES_INFO_VER NV_GPU_CLOCK_CLK_PROP_REGIMES_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropRegimesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __inout NV_GPU_CLOCK_CLK_PROP_REGIMES_INFO *pClkPropRegimesInfo);
typedef struct {
  NV_GPU_CLOCK_CLK_PROP_REGIME_TYPE type;
  NV_GPU_BOARDOBJGRP_MASK_E32 clkDomainMask;
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLK_PROP_REGIME_CONTROL_V1, *PNV_GPU_CLOCK_CLK_PROP_REGIME_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 propRegimesMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROP_REGIME_CONTROL_V1 propRegimes[NV_GPU_CLOCK_CLK_PROP_REGIMES_MAX_V1];
} NV_GPU_CLOCK_CLK_PROP_REGIMES_CONTROL_V1;
typedef NV_GPU_CLOCK_CLK_PROP_REGIMES_CONTROL_V1 NV_GPU_CLOCK_CLK_PROP_REGIMES_CONTROL;
#define NV_GPU_CLOCK_CLK_PROP_REGIMES_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROP_REGIMES_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLK_PROP_REGIMES_CONTROL_VER NV_GPU_CLOCK_CLK_PROP_REGIMES_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropRegimesGetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLOCK_CLK_PROP_REGIMES_CONTROL *pClkPropRegimesControl);
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropRegimesSetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLOCK_CLK_PROP_REGIMES_CONTROL *pClkPropRegimesControl);
#define NV_GPU_CLOCK_CLK_PROP_TOPS_MAX_V1 NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS
typedef enum {
  NV_GPU_CLOCK_CLK_PROP_TOP_TYPE_1X = 0x0,
  NV_GPU_CLOCK_CLK_PROP_TOP_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CLOCK_CLK_PROP_TOP_TYPE;
typedef enum {
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_INVALID = 0xFFU,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_GRAPHICS = 0x00U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_COMPUTE = 0x01U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_0 = 0x02U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_1 = 0x03U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_2 = 0x04U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_3 = 0x05U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_4 = 0x06U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_5 = 0x07U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_6 = 0x08U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_7 = 0x09U,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_8 = 0x0AU,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_9 = 0x0BU,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_10 = 0x0CU,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_11 = 0x0DU,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_12 = 0x0EU,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_RSVD_13 = 0x0FU,
  NV_GPU_CLOCK_CLK_PROP_TOP_ID_MAX = 0x10U,
} NV_GPU_CLOCK_CLK_PROP_TOP_ID;
typedef struct {
  NvU16 dstPath[NV_GPU_CLOCK_CLK_DOMAIN_CLIENT_MAX_DOMAINS_V1];
} NV_GPU_CLOCK_CLK_PROP_TOP_CLK_DOMAIN_DST_PATH_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_CLK_DOMAIN_DST_PATH_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_PROP_TOP_CLK_DOMAIN_DST_PATH_V1
  domainDstPath[NV_GPU_CLOCK_CLK_DOMAIN_CLIENT_MAX_DOMAINS_V1];
} NV_GPU_CLOCK_CLK_PROP_TOP_CLK_DOMAINS_DST_PATH_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_CLK_DOMAINS_DST_PATH_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_PROP_TOP_TYPE type;
  NV_GPU_CLOCK_CLK_PROP_TOP_ID topId;
  NV_GPU_BOARDOBJGRP_MASK_E255 clkPropTopRelIndexMask;
  NV_GPU_CLOCK_CLK_PROP_TOP_CLK_DOMAINS_DST_PATH_V1 domainsDstPath;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_PROP_TOP_INFO_V1;
typedef struct {
  NvU32 version;
  NvU8 topHal;
  NV_GPU_BOARDOBJGRP_MASK_E32 propTopsMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROP_TOP_INFO_V1 propTops[NV_GPU_CLOCK_CLK_PROP_TOPS_MAX_V1];
} NV_GPU_CLOCK_CLK_PROP_TOPS_INFO_V1;
typedef NV_GPU_CLOCK_CLK_PROP_TOPS_INFO_V1 NV_GPU_CLOCK_CLK_PROP_TOPS_INFO;
#define NV_GPU_CLOCK_CLK_PROP_TOPS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROP_TOPS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_PROP_TOPS_INFO_VER NV_GPU_CLOCK_CLK_PROP_TOPS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropTopsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_CLOCK_CLK_PROP_TOPS_INFO *pClkPropTopsInfo);
typedef struct {
  NV_GPU_CLOCK_CLK_PROP_TOP_TYPE type;
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLK_PROP_TOP_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_CLK_PROP_TOP_ID activeTopId;
  NV_GPU_BOARDOBJGRP_MASK_E32 propTopsMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROP_TOP_STATUS_V1 propTops[NV_GPU_CLOCK_CLK_PROP_TOPS_MAX_V1];
} NV_GPU_CLOCK_CLK_PROP_TOPS_STATUS_V1;
typedef NV_GPU_CLOCK_CLK_PROP_TOPS_STATUS_V1 NV_GPU_CLOCK_CLK_PROP_TOPS_STATUS;
#define NV_GPU_CLOCK_CLK_PROP_TOPS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROP_TOPS_STATUS_V1, 1)
#define NV_GPU_CLOCK_CLK_PROP_TOPS_STATUS_VER NV_GPU_CLOCK_CLK_PROP_TOPS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropTopsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_CLOCK_CLK_PROP_TOPS_STATUS *pClkPropTopsStatus);
typedef struct {
  NV_GPU_CLOCK_CLK_PROP_TOP_TYPE type;
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLK_PROP_TOP_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_CLOCK_CLK_PROP_TOP_ID activeTopIdForced;
  NV_GPU_BOARDOBJGRP_MASK_E32 propTopsMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROP_TOP_CONTROL_V1 propTops[NV_GPU_CLOCK_CLK_PROP_TOPS_MAX_V1];
} NV_GPU_CLOCK_CLK_PROP_TOPS_CONTROL_V1;
typedef NV_GPU_CLOCK_CLK_PROP_TOPS_CONTROL_V1 NV_GPU_CLOCK_CLK_PROP_TOPS_CONTROL;
#define NV_GPU_CLOCK_CLK_PROP_TOPS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROP_TOPS_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLK_PROP_TOPS_CONTROL_VER NV_GPU_CLOCK_CLK_PROP_TOPS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropTopsGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __inout NV_GPU_CLOCK_CLK_PROP_TOPS_CONTROL *pClkPropTopsControl);
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropTopsSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __in NV_GPU_CLOCK_CLK_PROP_TOPS_CONTROL *pClkPropTopsControl);
#define NV_GPU_CLOCK_CLK_PROP_TOP_RELS_MAX_V1 NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS
#define NV_GPU_CLOCK_CLK_PROP_TOP_REL_TABLE_REL_TUPLE_MAX_V1 NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS
typedef enum {
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_TYPE_RATIO = 0x0,
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_TYPE_TABLE = 0x1,
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_TYPE_VOLT = 0x2,
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_TYPE_VFE = 0x3,
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_TYPE_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_TYPE;
typedef struct {
  NvU32 ratio;
  NvU32 ratioInverse;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_RATIO_INFO_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_RATIO_INFO_V1;
typedef struct {
  NvU8 tableRelIdxFirst;
  NvU8 tableRelIdxLast;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_TABLE_INFO_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_TABLE_INFO_V1;
typedef struct {
  NvU8 voltRailIdx;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_VOLT_INFO_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_VOLT_INFO_V1;
typedef struct {
  NvU8 vfeIdx;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_VFE_INFO_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_VFE_INFO_V1;
typedef union {
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_RATIO_INFO_V1 ratio;
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_TABLE_INFO_V1 table;
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_VOLT_INFO_V1 volt;
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_VFE_INFO_V1 vfe;
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_INFO_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_TYPE type;
  NvU8 clkDomainIdxSrc;
  NvU8 clkDomainIdxDst;
  NvBool bBiDirectional;
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_INFO_DATA_V1 data;
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_INFO_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_REL_INFO_V1;
typedef struct {
  NvU16 freqMHzSrc;
  NvU16 freqMHzDst;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_TABLE_REL_TUPLE_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_REL_TABLE_REL_TUPLE_V1;
typedef struct {
  NvU32 version;
  NvU8 tableRelTupleCount;
  NV_GPU_BOARDOBJGRP_MASK_E255 propTopRelsMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_TABLE_REL_TUPLE_V1
  tableRelTuple[NV_GPU_CLOCK_CLK_PROP_TOP_REL_TABLE_REL_TUPLE_MAX_V1];
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_INFO_V1 propTopRels[NV_GPU_CLOCK_CLK_PROP_TOP_RELS_MAX_V1];
} NV_GPU_CLOCK_CLK_PROP_TOP_RELS_INFO_V1;
typedef NV_GPU_CLOCK_CLK_PROP_TOP_RELS_INFO_V1 NV_GPU_CLOCK_CLK_PROP_TOP_RELS_INFO;
#define NV_GPU_CLOCK_CLK_PROP_TOP_RELS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROP_TOP_RELS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_PROP_TOP_RELS_INFO_VER NV_GPU_CLOCK_CLK_PROP_TOP_RELS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropTopRelsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __inout NV_GPU_CLOCK_CLK_PROP_TOP_RELS_INFO *pClkPropTopRelsInfo);
typedef struct {
  NvU32 ratio;
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_RATIO_CONTROL_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_RATIO_CONTROL_V1;
typedef union {
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_1X_RATIO_CONTROL_V1 ratio;
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_TYPE type;
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_CONTROL_DATA_V1 data;
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLK_PROP_TOP_REL_CONTROL_V1, *PNV_GPU_CLOCK_CLK_PROP_TOP_REL_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 propTopRelsMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_PROP_TOP_REL_CONTROL_V1 propTopRels[NV_GPU_CLOCK_CLK_PROP_TOP_RELS_MAX_V1];
} NV_GPU_CLOCK_CLK_PROP_TOP_RELS_CONTROL_V1;
typedef NV_GPU_CLOCK_CLK_PROP_TOP_RELS_CONTROL_V1 NV_GPU_CLOCK_CLK_PROP_TOP_RELS_CONTROL;
#define NV_GPU_CLOCK_CLK_PROP_TOP_RELS_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_PROP_TOP_RELS_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLK_PROP_TOP_RELS_CONTROL_VER NV_GPU_CLOCK_CLK_PROP_TOP_RELS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropTopRelsGetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLOCK_CLK_PROP_TOP_RELS_CONTROL *pClkPropTopRelsControl);
NVAPI_INTERFACE NvAPI_GPU_ClockClkPropTopRelsSetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLOCK_CLK_PROP_TOP_RELS_CONTROL *pClkPropTopRelsControl);
#define NV_GPU_CLOCK_ADC_DEVICES_MAX_V1 10
#define NV_GPU_CLOCK_ADC_DEVICES_MAX_V2 32
typedef enum {
  NV_GPU_CLOCK_ADC_DEVICES_DISABLED = 0,
  NV_GPU_CLOCK_ADC_DEVICES_V10 = 1,
  NV_GPU_CLOCK_ADC_DEVICES_V20 = 2,
} NV_GPU_CLOCK_ADC_DEVICES_VERSION;
typedef enum {
  NV_GPU_CLOCK_ADC_DEVICE_TYPE_DISABLED = 0,
  NV_GPU_CLOCK_ADC_DEVICE_TYPE_V10,
  NV_GPU_CLOCK_ADC_DEVICE_TYPE_V20,
  NV_GPU_CLOCK_ADC_DEVICE_TYPE_V30,
  NV_GPU_CLOCK_ADC_DEVICE_TYPE_V30_ISINK_V10,
} NV_GPU_CLOCK_ADC_DEVICE_TYPE;
typedef enum {
  NV_GPU_CLOCK_ADC_CAL_TYPE_UNKNOWN = 0,
  NV_GPU_CLOCK_ADC_CAL_TYPE_V10,
  NV_GPU_CLOCK_ADC_CAL_TYPE_V20,
} NV_GPU_CLOCK_ADC_CAL_TYPE;
typedef enum {
  NV_GPU_CLOCK_ADC_DEVICE_ID_SYS = 0,
  NV_GPU_CLOCK_ADC_DEVICE_ID_LTC,
  NV_GPU_CLOCK_ADC_DEVICE_ID_XBAR,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC0,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC1,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC2,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC3,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC4,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC5,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPCS,
  NV_GPU_CLOCK_ADC_DEVICE_ID_SRAM,
  NV_GPU_CLOCK_ADC_DEVICE_ID_NVD,
  NV_GPU_CLOCK_ADC_DEVICE_ID_HOST,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC6,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC7,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC8,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC9,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC10,
  NV_GPU_CLOCK_ADC_DEVICE_ID_GPC11,
  NV_GPU_CLOCK_ADC_DEVICE_ID_SYS_ISINK,
  NV_GPU_CLOCK_ADC_DEVICE_ID_UNDEFINED = 0xFF,
} NV_GPU_CLOCK_ADC_DEVICE_ID;
typedef struct {
  NvU32 slope;
  NvU32 intercept;
} NV_GPU_CLOCK_ADC_DEVICE_CALIBRATION_V10;
typedef struct {
  NvS8 offset;
  NvS8 gain;
  NvU8 offsetVfeIdx;
  NvU8 coarseControl;
} NV_GPU_CLOCK_ADC_DEVICE_CALIBRATION_V20;
typedef struct {
  NV_GPU_CLOCK_ADC_DEVICE_CALIBRATION_V10 adcCal;
} NV_GPU_CLOCK_ADC_DEVICE_INFO_V10;
typedef union {
  NV_GPU_CLOCK_ADC_DEVICE_CALIBRATION_V10 calV10;
  NV_GPU_CLOCK_ADC_DEVICE_CALIBRATION_V20 calV20;
} NV_GPU_CLOCK_ADC_CAL_DATA_V20;
typedef struct {
  NV_GPU_CLOCK_ADC_CAL_TYPE calType;
  NV_GPU_CLOCK_ADC_CAL_DATA_V20 adcCal;
} NV_GPU_CLOCK_ADC_DEVICE_INFO_V20;
typedef struct {
  NvS8 offset;
  NvS8 gain;
  NvS8 coarseOffset;
  NvS8 lowTempLowVoltErr;
  NvS8 lowTempHighVoltErr;
  NvS8 highTempLowVoltErr;
  NvS8 highTempHighVoltErr;
  NvS8 coarseGain;
} NV_GPU_CLOCK_ADC_DEVICE_INFO_V30;
typedef struct {
  NvS8 adcCodeCorrectionOffsetMin;
  NvS8 adcCodeCorrectionOffsetMax;
  NvU8 calInvalidFuseRevMask;
  NvU8 lowTempErrInvalidFuseRevMask;
  NvU8 highTempErrInvalidFuseRevMask;
  NvS8 lowTemp;
  NvS8 highTemp;
  NvS8 refTemp;
  NvU32 lowVoltuV;
  NvU32 highVoltuV;
  NvU32 refVoltuV;
} NV_GPU_CLOCK_ADC_DEVICE_INFO_ISINK_V10;
typedef struct {
  NV_GPU_CLOCK_ADC_DEVICE_INFO_V30 super;
  NV_GPU_CLOCK_ADC_DEVICE_INFO_ISINK_V10 data;
} NV_GPU_CLOCK_ADC_DEVICE_INFO_V30_ISINK_V10;
typedef union {
  NV_GPU_CLOCK_ADC_DEVICE_INFO_V10 v10;
  NV_GPU_CLOCK_ADC_DEVICE_INFO_V20 v20;
  NV_GPU_CLOCK_ADC_DEVICE_INFO_V30 v30;
  NV_GPU_CLOCK_ADC_DEVICE_INFO_V30_ISINK_V10 v30Isinkv10;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_ADC_DEVICE_INFO_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_ADC_DEVICE_TYPE type;
  NV_GPU_CLOCK_ADC_DEVICE_ID id;
  NV_GPU_VOLT_VOLT_DOMAIN_TYPE voltDomain;
  NvU32 nafllsSharedMask;
  NvU8 porOverrideMode;
  NvBool bDynCal;
  NvU8 rsvd[26];
  NV_GPU_CLOCK_ADC_DEVICE_INFO_DATA_V1 data;
} NV_GPU_CLOCK_ADC_DEVICE_INFO_V1;
typedef struct {
  NvU8 calibrationRevVbios;
  NvU8 calibrationRevFused;
} NV_GPU_CLOCK_ADC_DEVICES_INFO_V10;
typedef struct {
  NvU8 calInvalidFuseRevMask;
  NvU8 lowTempErrInvalidFuseRevMask;
  NvU8 highTempErrInvalidFuseRevMask;
  NvS8 lowTemp;
  NvS8 highTemp;
  NvS8 refTemp;
  NvS8 adcCodeCorrectionOffsetMin;
  NvS8 adcCodeCorrectionOffsetMax;
  NvU32 lowVoltuV;
  NvU32 highVoltuV;
} NV_GPU_CLOCK_ADC_DEVICES_INFO_V20;
typedef union {
  NV_GPU_CLOCK_ADC_DEVICES_INFO_V10 v10;
  NV_GPU_CLOCK_ADC_DEVICES_INFO_V20 v20;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_ADC_DEVICES_INFO_DATA_V2;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 calibrationRevVbios;
  NvU8 calibrationRevFused;
  NvU8 bAdcIsDisableAllowed;
  NvU8 rsvd[2];
  NvU8 rsvd1[64];
  NV_GPU_CLOCK_ADC_DEVICE_INFO_V1 devices[NV_GPU_CLOCK_ADC_DEVICES_MAX_V1];
} NV_GPU_CLOCK_ADC_DEVICES_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 bAdcIsDisableAllowed;
  NV_GPU_CLOCK_ADC_DEVICES_VERSION devicesVersion;
  NV_GPU_CLOCK_ADC_DEVICES_INFO_DATA_V2 data;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_ADC_DEVICE_INFO_V1 devices[NV_GPU_CLOCK_ADC_DEVICES_MAX_V2];
} NV_GPU_CLOCK_ADC_DEVICES_INFO_V2;
typedef NV_GPU_CLOCK_ADC_DEVICES_INFO_V2 NV_GPU_CLOCK_ADC_DEVICES_INFO;
#define NV_GPU_CLOCK_ADC_DEVICES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_ADC_DEVICES_INFO_V1, 1)
#define NV_GPU_CLOCK_ADC_DEVICES_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_ADC_DEVICES_INFO_V2, 2)
#define NV_GPU_CLOCK_ADC_DEVICES_INFO_VER NV_GPU_CLOCK_ADC_DEVICES_INFO_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockAdcDevicesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_CLOCK_ADC_DEVICES_INFO *pClkAdcDevicesInfo);
typedef struct {
  NV_GPU_CLOCK_ADC_DEVICE_CALIBRATION_V10 adcCal;
} NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V10;
typedef struct {
  NV_GPU_CLOCK_ADC_CAL_TYPE calType;
  NV_GPU_CLOCK_ADC_CAL_DATA_V20 adcCal;
} NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V20;
typedef struct {
  NvS8 offset;
  NvS8 gain;
  NvS8 coarseOffset;
  NvS8 lowTempLowVoltErr;
  NvS8 lowTempHighVoltErr;
  NvS8 highTempLowVoltErr;
  NvS8 highTempHighVoltErr;
  NvS8 adcCodeCorrectionOffset;
  NvS8 coarseGain;
} NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V30;
typedef struct {
  NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V30 super;
} NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V30_ISINK_V10;
typedef union {
  NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V10 v10;
  NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V20 v20;
  NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V30 v30;
  NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V30_ISINK_V10 v30Isinkv10;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_ADC_DEVICE_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_ADC_DEVICE_TYPE type;
  NvU8 overrideMode;
  NvU8 rsvd[31];
  NV_GPU_CLOCK_ADC_DEVICE_CONTROL_DATA_V1 data;
} NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 bDefault;
  NvU8 rsvd[3];
  NvU8 rsvd1[64];
  NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V1 devices[NV_GPU_CLOCK_ADC_DEVICES_MAX_V1];
} NV_GPU_CLOCK_ADC_DEVICES_CONTROL_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvBool bDefault;
  NvU8 rsvd[3];
  NvU8 rsvd1[64];
  NV_GPU_CLOCK_ADC_DEVICE_CONTROL_V1 devices[NV_GPU_CLOCK_ADC_DEVICES_MAX_V2];
} NV_GPU_CLOCK_ADC_DEVICES_CONTROL_V2;
typedef NV_GPU_CLOCK_ADC_DEVICES_CONTROL_V2 NV_GPU_CLOCK_ADC_DEVICES_CONTROL;
#define NV_GPU_CLOCK_ADC_DEVICES_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_ADC_DEVICES_CONTROL_V1, 1)
#define NV_GPU_CLOCK_ADC_DEVICES_CONTROL_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_ADC_DEVICES_CONTROL_V2, 2)
#define NV_GPU_CLOCK_ADC_DEVICES_CONTROL_VER NV_GPU_CLOCK_ADC_DEVICES_CONTROL_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockAdcDevicesGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_CLOCK_ADC_DEVICES_CONTROL *pClkAdcDevicesCtrl);
NVAPI_INTERFACE NvAPI_GPU_ClockAdcDevicesSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_CLOCK_ADC_DEVICES_CONTROL *pClkAdcDevicesCtrl);
#define NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V1 10
#define NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V2 32
typedef enum {
  NV_GPU_CLOCK_NAFLL_DEVICE_TYPE_DISABLED = 0x00,
  NV_GPU_CLOCK_NAFLL_DEVICE_TYPE_V10 = 0x01,
  NV_GPU_CLOCK_NAFLL_DEVICE_TYPE_V20 = 0x02,
  NV_GPU_CLOCK_NAFLL_DEVICE_TYPE_V30 = 0x03,
} NV_GPU_CLOCK_NAFLL_DEVICE_TYPE;
typedef enum {
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_SYS = 0,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_LTC,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_XBAR,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC0,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC1,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC2,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC3,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC4,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC5,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPCS,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_NVD,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_HOST,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC6,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC7,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC8,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC9,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC10,
  NV_GPU_CLOCK_NAFLL_DEVICE_ID_GPC11,
} NV_GPU_CLOCK_NAFLL_DEVICE_ID;
typedef enum {
  NV_GPU_CLOCK_NAFLL_LUT_VSELECT_LOGIC = 0,
  NV_GPU_CLOCK_NAFLL_LUT_VSELECT_MIN,
  NV_GPU_CLOCK_NAFLL_LUT_VSELECT_SRAM,
} NV_GPU_CLOCK_NAFLL_LUT_VSELECT_MODE;
typedef struct {
  NvU32 placeholder;
} NV_GPU_CLOCK_NAFLL_DEVICE_INFO_V10;
typedef union {
  NV_GPU_CLOCK_NAFLL_DEVICE_INFO_V10 v10;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_NAFLL_DEVICE_INFO_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_NAFLL_DEVICE_TYPE type;
  NV_GPU_CLOCK_NAFLL_DEVICE_ID id;
  NvU8 mdiv;
  NvU16 inputFreqMHz;
  NV_GPU_CLOCK_DOMAIN_ID clkDomain;
  NvU8 adcIdxLogic;
  NvU8 adcIdxSram;
  NV_GPU_CLOCK_NAFLL_LUT_VSELECT_MODE vselectMode;
  NvU16 hysteresisThreshold;
  NvU16 fixedFreqRegimeLimitMHz;
  NvU8 dvcoMinFreqVFEIdx;
  NvU8 freqCtrlIdx;
  NvU16 inputRefClkFreqMHz;
  NvU16 inputRefClkDivVal;
  NvU8 rsvd[28];
  NV_GPU_CLOCK_NAFLL_DEVICE_INFO_DATA_V1 data;
} NV_GPU_CLOCK_NAFLL_DEVICE_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 lutNumEntries;
  NvU32 lutStepSizeuV;
  NvU32 lutMinVoltageuV;
  NvU16 maxDvcoMinFreqMHz;
  NvU8 rsvd[62];
  NV_GPU_CLOCK_NAFLL_DEVICE_INFO_V1 devices[NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V1];
} NV_GPU_CLOCK_NAFLL_DEVICES_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 lutNumEntries;
  NvU32 lutStepSizeuV;
  NvU32 lutMinVoltageuV;
  NvU16 maxDvcoMinFreqMHz;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_INFO_V1 devices[NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V2];
} NV_GPU_CLOCK_NAFLL_DEVICES_INFO_V2;
typedef NV_GPU_CLOCK_NAFLL_DEVICES_INFO_V2 NV_GPU_CLOCK_NAFLL_DEVICES_INFO;
#define NV_GPU_CLOCK_NAFLL_DEVICES_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_NAFLL_DEVICES_INFO_V1, 1)
#define NV_GPU_CLOCK_NAFLL_DEVICES_INFO_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_NAFLL_DEVICES_INFO_V2, 2)
#define NV_GPU_CLOCK_NAFLL_DEVICES_INFO_VER NV_GPU_CLOCK_NAFLL_DEVICES_INFO_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockNafllDevicesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GPU_CLOCK_NAFLL_DEVICES_INFO *pClkNafllDevicesInfo);
typedef struct {
  NvU32 placeholder;
} NV_GPU_CLOCK_ADC_DEVICE_STATUS_V10;
typedef struct {
  NvS32 offset;
} NV_GPU_CLOCK_ADC_DEVICE_STATUS_V20;
typedef struct {
  NvS8 adcCodeCorrectionOffset;
} NV_GPU_CLOCK_ADC_DEVICE_STATUS_V30;
typedef struct {
  NV_GPU_CLOCK_ADC_DEVICE_STATUS_V30 super;
} NV_GPU_CLOCK_ADC_DEVICE_STATUS_V30_ISINK_V10;
typedef union {
  NV_GPU_CLOCK_ADC_DEVICE_STATUS_V10 v10;
  NV_GPU_CLOCK_ADC_DEVICE_STATUS_V20 v20;
  NV_GPU_CLOCK_ADC_DEVICE_STATUS_V30 v30;
  NV_GPU_CLOCK_ADC_DEVICE_STATUS_V30_ISINK_V10 v30Isinkv10;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_ADC_DEVICE_STATUS_DATA_V1;
typedef struct {
  NvU32 actualVoltageuV;
  NvU32 correctedVoltageuV;
  NvU8 sampledCode;
  NvU8 overrideCode;
  NvU8 instCode;
  NvU8 type;
  NvU8 rsvd[30];
  NV_GPU_CLOCK_ADC_DEVICE_STATUS_DATA_V1 data;
} NV_GPU_CLOCK_ADC_DEVICE_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 rsvd1[64];
  NV_GPU_CLOCK_ADC_DEVICE_STATUS_V1 devices[NV_GPU_CLOCK_ADC_DEVICES_MAX_V1];
} NV_GPU_CLOCK_ADC_DEVICES_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 rsvd1[64];
  NV_GPU_CLOCK_ADC_DEVICE_STATUS_V1 devices[NV_GPU_CLOCK_ADC_DEVICES_MAX_V2];
} NV_GPU_CLOCK_ADC_DEVICES_STATUS_V2;
typedef NV_GPU_CLOCK_ADC_DEVICES_STATUS_V1 NV_GPU_CLOCK_ADC_DEVICES_STATUS;
#define NV_GPU_CLOCK_ADC_DEVICES_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_ADC_DEVICES_STATUS_V1, 1)
#define NV_GPU_CLOCK_ADC_DEVICES_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_ADC_DEVICES_STATUS_V2, 1)
#define NV_GPU_CLOCK_ADC_DEVICES_STATUS_VER NV_GPU_CLOCK_ADC_DEVICES_STATUS_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockAdcDevicesGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GPU_CLOCK_ADC_DEVICES_STATUS *pClkAdcDevicesStatus);
typedef struct {
  NvU32 placeholder;
} NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V10;
typedef union {
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V10 v10;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_DATA_V1;
#define NV_GPU_CLOCK_NAFLL_LUT_NUM_ENTRIES_V1 80
#define NV_GPU_CLOCK_NAFLL_LUT_NUM_ENTRIES_V2 128
typedef struct {
  struct {
    NvU16 ndiv;
    NvU16 vfgain;
  } vfEntries[NV_GPU_CLOCK_NAFLL_LUT_NUM_ENTRIES_V1];
} NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V1;
typedef struct {
  struct {
    NvU16 ndiv;
    NvU16 vfgain;
  } vfEntries[NV_GPU_CLOCK_NAFLL_LUT_NUM_ENTRIES_V2];
} NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V2;
typedef struct {
  NvU16 ndiv;
  NvU16 vfgain;
} NV_GPU_CLOCK_NAFLL_LUT_10_VF_ENTRY_V1, *PNV_GPU_CLOCK_NAFLL_LUT_10_VF_ENTRY_V1;
typedef struct {
  NvU16 ndiv;
  NvU8 ndivOffset;
  NvU8 dvcoOffset;
} NV_GPU_CLOCK_NAFLL_LUT_20_VF_ENTRY_V1, *PNV_GPU_CLOCK_NAFLL_LUT_20_VF_ENTRY_V1;
typedef struct {
  NvU16 ndiv;
  NvU8 ndivOffset;
  NvU8 dvcoOffset;
  NvU16 cpmMaxNdivOffset;
} NV_GPU_CLOCK_NAFLL_LUT_30_VF_ENTRY_V1, *PNV_GPU_CLOCK_NAFLL_LUT_30_VF_ENTRY_V1;
#define NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_SEC_MAX_V1 (0x00000002U)
typedef struct {
  NvU16 ndiv;
  NvU8 ndivOffset[NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_SEC_MAX_V1];
  NvU8 dvcoOffset[NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_SEC_MAX_V1];
  NvU16 cpmMaxNdivOffset;
} NV_GPU_CLOCK_NAFLL_LUT_30_VF_ENTRY_V2, *PNV_GPU_CLOCK_NAFLL_LUT_30_VF_ENTRY_V2;
typedef union {
  NvU32 value;
  NV_GPU_CLOCK_NAFLL_LUT_10_VF_ENTRY_V1 lut10;
  NV_GPU_CLOCK_NAFLL_LUT_20_VF_ENTRY_V1 lut20;
  NV_GPU_CLOCK_NAFLL_LUT_30_VF_ENTRY_V1 lut30;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_DATA_V1, *PNV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_DATA_V1;
typedef struct {
  NvU8 type;
  NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_DATA_V1 data;
} NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_V1, *PNV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_V1;
typedef struct {
  NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_V1 lutVfEntries[NV_GPU_CLOCK_NAFLL_LUT_NUM_ENTRIES_V2];
} NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V3, *PNV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V3;
typedef union {
  NvU32 value;
  NV_GPU_CLOCK_NAFLL_LUT_10_VF_ENTRY_V1 lut10;
  NV_GPU_CLOCK_NAFLL_LUT_20_VF_ENTRY_V1 lut20;
  NV_GPU_CLOCK_NAFLL_LUT_30_VF_ENTRY_V2 lut30;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_DATA_V2, *PNV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_DATA_V2;
typedef struct {
  NvU8 type;
  NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_DATA_V2 data;
} NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_V2, *PNV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_V2;
typedef struct {
  NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_V2 lutVfEntries[NV_GPU_CLOCK_NAFLL_LUT_NUM_ENTRIES_V2];
} NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V4, *PNV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V4;
typedef struct {
  NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V1 lutVfCurve;
  NvU8 currentRegimeId;
  NvU8 rsvd[29];
  NvU16 dvcoMinFreqMHz;
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_DATA_V1 data;
} NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V1;
typedef struct {
  NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V2 lutVfCurve;
  NvU8 currentRegimeId;
  NvU8 rsvd[29];
  NvU16 dvcoMinFreqMHz;
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_DATA_V1 data;
} NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V2;
typedef struct {
  NV_GPU_CLOCK_NAFLL_DEVICE_TYPE type;
  NvU8 currentRegimeId;
  NvU16 dvcoMinFreqMHz;
  NvBool bDvcoMinReached;
  NvU8 reserved[3];
  NvU8 swOverrideMode;
  NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_V1 swOverride;
  NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V3 lutVfCurve;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_DATA_V1 data;
} NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V3;
typedef struct {
  NV_GPU_CLOCK_NAFLL_DEVICE_TYPE type;
  NvU8 currentRegimeId;
  NvU16 dvcoMinFreqMHz;
  NvBool bDvcoMinReached;
  NvU8 reserved[3];
  NvU8 swOverrideMode;
  NV_GPU_CLOCK_NAFLL_LUT_VF_ENTRY_V1 swOverride;
  NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_V4 lutVfCurve;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_DATA_V1 data;
} NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V4;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V1 devices[NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V1];
} NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V2 devices[NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V1];
} NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V2;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V3 devices[NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V1];
} NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V3;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V3 devices[NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V2];
} NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V4;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_STATUS_V4 devices[NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V2];
} NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V5;
typedef NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V5 NV_GPU_CLOCK_NAFLL_DEVICES_STATUS;
#define NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V1, 1)
#define NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V2, 2)
#define NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_VER3 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V3, 3)
#define NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_VER4 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V4, 4)
#define NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_VER5 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_V5, 5)
#define NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_VER NV_GPU_CLOCK_NAFLL_DEVICES_STATUS_VER5
NVAPI_INTERFACE NvAPI_GPU_ClockNafllDevicesGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __inout NV_GPU_CLOCK_NAFLL_DEVICES_STATUS *pClkNafllDevicesStatus);
#define NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_SEC_MAX 2
typedef struct {
  NvU8 rsvd[64];
} NV_GPU_CLOCK_NAFLL_DEVICE_CONTROL_V10;
typedef struct {
  NvBool bQuickSlowdownForceEngage[NV_GPU_CLOCK_NAFLL_LUT_VF_CURVE_SEC_MAX];
  NvU8 rsvd[30];
} NV_GPU_CLOCK_NAFLL_DEVICE_CONTROL_V30;
typedef union {
  NV_GPU_CLOCK_NAFLL_DEVICE_CONTROL_V10 v10;
  NV_GPU_CLOCK_NAFLL_DEVICE_CONTROL_V30 v30;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_NAFLL_DEVICE_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_NAFLL_DEVICE_TYPE type;
  NvU8 targetRegimeIdOverride;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_NAFLL_DEVICE_CONTROL_DATA_V1 data;
} NV_GPU_CLOCK_NAFLL_DEVICE_CONTROL_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_CONTROL_V1 devices[NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V1];
} NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL_V1;
typedef struct {
  NvU32 version;
  NvU32 devMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_NAFLL_DEVICE_CONTROL_V1 devices[NV_GPU_CLOCK_NAFLL_DEVICES_MAX_V2];
} NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL_V2;
typedef NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL_V2 NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL;
#define NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL_V1, 1)
#define NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL_V2, 2)
#define NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL_VER NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockNafllDevicesGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                      __inout NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL *pNafllDevices);
NVAPI_INTERFACE NvAPI_GPU_ClockNafllDevicesSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                      __in NV_GPU_CLOCK_NAFLL_DEVICES_CONTROL *pNafllDevices);
typedef enum {
  NVAPI_GPU_CLOCK_SOURCE_UNKNOWN,
  NVAPI_GPU_CLOCK_SOURCE_NVPLL1,
  NVAPI_GPU_CLOCK_SOURCE_NVPLL2,
  NVAPI_GPU_CLOCK_SOURCE_MPLL,
  NVAPI_GPU_CLOCK_SOURCE_MPLLA,
  NVAPI_GPU_CLOCK_SOURCE_MPLLB,
  NVAPI_GPU_CLOCK_SOURCE_MPLLC,
  NVAPI_GPU_CLOCK_SOURCE_MPLLD,
  NVAPI_GPU_CLOCK_SOURCE_MPLLEXT,
  NVAPI_GPU_CLOCK_SOURCE_HPLL,
  NVAPI_GPU_CLOCK_SOURCE_AGPPLL,
  NVAPI_GPU_CLOCK_SOURCE_DISPPLL,
  NVAPI_GPU_CLOCK_SOURCE_VPLL0,
  NVAPI_GPU_CLOCK_SOURCE_VPLL1,
  NVAPI_GPU_CLOCK_SOURCE_VPLL2,
  NVAPI_GPU_CLOCK_SOURCE_VPLL3,
  NVAPI_GPU_CLOCK_SOURCE_GVPLL,
  NVAPI_GPU_CLOCK_SOURCE_SPPLL0,
  NVAPI_GPU_CLOCK_SOURCE_SPPLL1,
  NVAPI_GPU_CLOCK_SOURCE_XCLK,
  NVAPI_GPU_CLOCK_SOURCE_3XXCLK,
  NVAPI_GPU_CLOCK_SOURCE_PEXREFCLK,
  NVAPI_GPU_CLOCK_SOURCE_VPSPLL,
  NVAPI_GPU_CLOCK_SOURCE_NVCLK,
  NVAPI_GPU_CLOCK_SOURCE_XTAL,
  NVAPI_GPU_CLOCK_SOURCE_3XXCLKDIV2,
  NVAPI_GPU_CLOCK_SOURCE_GPUREF,
  NVAPI_GPU_CLOCK_SOURCE_XCLKGEN2,
  NVAPI_GPU_CLOCK_SOURCE_GPCPLL,
  NVAPI_GPU_CLOCK_SOURCE_LTCPLL,
  NVAPI_GPU_CLOCK_SOURCE_XBARPLL,
  NVAPI_GPU_CLOCK_SOURCE_SYSPLL,
  NVAPI_GPU_CLOCK_SOURCE_XTAL4X,
  NVAPI_GPU_CLOCK_SOURCE_REFMPLL,
  NVAPI_GPU_CLOCK_SOURCE_BYPASSCLK,
  NVAPI_GPU_CLOCK_SOURCE_HOSTCLK,
  NVAPI_GPU_CLOCK_SOURCE_COREPLL,
  NVAPI_GPU_CLOCK_SOURCE_XCLK500,
  NVAPI_GPU_CLOCK_SOURCE_XCLKGEN3,
  NVAPI_GPU_CLOCK_SOURCE_HBMPLL,
  NVAPI_GPU_CLOCK_SOURCE_NVDPLL,
} NV_GPU_CLOCK_SOURCE_ID;
typedef struct {
  NV_GPU_CLOCK_DOMAIN_ID clkDomain;
  NvU32 flags;
  NV_GPU_CLOCK_SOURCE_ID clkSource;
  NvU32 actualFreqKHz;
  NvU32 effectiveFreqKHz;
} NV_GPU_CLOCK_CLK_DOMAIN_FREQ_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU8 rsvd[64];
  NvU32 numFreqInfos;
  NV_GPU_CLOCK_CLK_DOMAIN_FREQ_INFO_V1 freqInfos[NV_GPU_CLOCK_CLK_DOMAINS_MAX_V1];
} NV_GPU_CLOCK_CLK_DOMAINS_FREQ_INFO_V1;
typedef NV_GPU_CLOCK_CLK_DOMAINS_FREQ_INFO_V1 NV_GPU_CLOCK_CLK_DOMAINS_FREQ_INFO;
#define NV_GPU_CLOCK_CLK_DOMAINS_FREQ_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_DOMAINS_FREQ_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_DOMAINS_FREQ_INFO_VER NV_GPU_CLOCK_CLK_DOMAINS_FREQ_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkDomainsGetFreqInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                     __inout NV_GPU_CLOCK_CLK_DOMAINS_FREQ_INFO *pClkFreqInfo);
#define NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_MAX_V1 (32)
typedef enum {
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_DISABLED = 0,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_TYPE_PI,
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_TYPE;
typedef enum {
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_SYS = 0,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_LTC,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_XBAR,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_GPC0,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_GPC1,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_GPC2,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_GPC3,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_GPC4,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_GPC5,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_GPCS,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID_NVD,
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_ID;
typedef enum {
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_PARTS_FREQ_MODE_BCAST = 0,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_PARTS_FREQ_MODE_MIN,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_PARTS_FREQ_MODE_MAX,
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_PARTS_FREQ_MODE_AVG,
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_PARTS_FREQ_MODE;
typedef struct {
  NvS32 propGain;
  NvS32 integGain;
  NvS32 integDecay;
  NvS32 voltDeltaMin;
  NvS32 voltDeltaMax;
  NvU8 slowdownPctMin;
  NvBool bPoison;
  NvU16 droopyPctMin;
  NvU8 thermMonIdx;
  NvU8 rsvd[27];
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_INFO_PI;
typedef union {
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_INFO_PI pi;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_INFO_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_TYPE type;
  NvU8 id;
  NvU8 partsFreqMode;
  NvU32 clkDomain;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_INFO_DATA_V1 data;
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 devMask;
  NvU8 rsvd[62];
  NvBool bContinuousMode;
  NvU8 voltPolicyIdx;
  NvU32 samplingPeriodms;
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_INFO_V1 freqControllers[NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_MAX_V1];
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_INFO_V1;
typedef NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_INFO_V1 NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_INFO;
#define NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_INFO_VER NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkFreqControllerGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                        __inout NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_INFO *pInfo);
typedef struct {
  NvS32 voltDeltauV;
  NvS32 errorkHz;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_STATUS_PI;
typedef union {
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_STATUS_PI pi;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_STATUS_DATA_V1;
typedef struct {
  NvU32 disableClientsMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_STATUS_DATA_V1 data;
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 devMask;
  NvS32 finalVoltDeltauV;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_STATUS_V1 freqControllers[NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_MAX_V1];
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_STATUS_V1;
typedef NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_STATUS_V1 NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_STATUS;
#define NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_STATUS_V1, 1)
#define NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_STATUS_VER NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkFreqControllerGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                          __inout NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_STATUS *pStatus);
typedef struct {
  NvS32 propGain;
  NvS32 integGain;
  NvS32 integDecay;
  NvS32 voltDeltaMin;
  NvS32 voltDeltaMax;
  NvU8 slowdownPctMin;
  NvBool bPoison;
  NvU16 droopyPctMin;
  NvU8 rsvd[30];
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_CONTROL_PI;
typedef union {
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_CONTROL_PI pi;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_TYPE type;
  NvBool bDisable;
  NvS16 freqCapNoiseUnawareVminAbove;
  NvS16 freqCapNoiseUnawareVminBelow;
  NvS16 freqHysteresisPositive;
  NvS16 freqHysteresisNegative;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_CONTROL_DATA_V1 data;
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 devMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_FREQ_CONTROLLER_CONTROL_V1 freqControllers[NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_MAX_V1];
} NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_CONTROL_V1;
typedef NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_CONTROL_V1 NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_CONTROL;
#define NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_CONTROL_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_CONTROL_VER NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkFreqControllersGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                            NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_CONTROL *pClkFreqCtrls);
NVAPI_INTERFACE NvAPI_GPU_ClockClkFreqControllersSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                            NV_GPU_CLOCK_CLK_FREQ_CONTROLLERS_CONTROL *pClkFreqCtrls);
#define NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_MAX_V1 (32)
typedef enum {
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_DISABLED = 0,
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_TYPE_PROP,
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_TYPE;
typedef enum {
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_ADC_MODE_MIN = 0,
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_ADC_MODE_MAX,
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_ADC_MODE_AVG,
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_ADC_MODE;
typedef struct {
  NvS32 voltHysteresisPositive;
  NvS32 voltHysteresisNegative;
  NvS32 propGain;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_INFO_PROP;
typedef union {
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_INFO_PROP prop;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_INFO_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_TYPE type;
  NvU8 voltRailIdx;
  NvU8 adcMode;
  NvU8 thermMonIdx;
  NvU16 droopyPctMin;
  NvU32 adcMask;
  NvS32 voltOffsetMinuV;
  NvS32 voltOffsetMaxuV;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_INFO_DATA_V1 data;
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_INFO_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 devMask;
  NvU8 lowSamplingMultiplier;
  NvS32 voltOffsetThresholduV;
  NvU32 samplingPeriodms;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_INFO_V1 voltControllers[NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_MAX_V1];
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_INFO_V1;
typedef NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_INFO_V1 NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_INFO;
#define NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_INFO_VER NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkVoltControllerGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                        __inout NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_INFO *pInfo);
typedef struct {
  NvS32 erroruV;
  NvU32 senseduV;
  NvU32 measureduV;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_STATUS_PROP;
typedef union {
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_STATUS_PROP prop;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_STATUS_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_TYPE type;
  NvS32 voltOffsetuV;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_STATUS_DATA_V1 data;
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_STATUS_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 devMask;
  NvS32 sampleMaxVoltOffsetuV[NV_GPU_VOLT_VOLT_RAILS_MAX_V1];
  NvS32 totalMaxVoltOffsetuV[NV_GPU_VOLT_VOLT_RAILS_MAX_V1];
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_STATUS_V1 voltControllers[NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_MAX_V1];
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_STATUS_V1;
typedef NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_STATUS_V1 NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_STATUS;
#define NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_STATUS_V1, 1)
#define NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_STATUS_VER NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_STATUS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkVoltControllerGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                          __inout NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_STATUS *pStatus);
typedef struct {
  NvS32 voltHysteresisPositive;
  NvS32 voltHysteresisNegative;
  NvS32 propGain;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_CONTROL_PROP;
typedef union {
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_CONTROL_PROP prop;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_CONTROL_DATA_V1;
typedef struct {
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_TYPE type;
  NvU8 adcMode;
  NvU16 droopyPctMin;
  NvS32 voltOffsetMinuV;
  NvS32 voltOffsetMaxuV;
  NvU32 adcMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_CONTROL_DATA_V1 data;
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_CONTROL_V1;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 devMask;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLK_VOLT_CONTROLLER_CONTROL_V1 voltControllers[NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_MAX_V1];
} NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_CONTROL_V1;
typedef NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_CONTROL_V1 NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_CONTROL;
#define NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_CONTROL_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_CONTROL_VER NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_CONTROL_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClkVoltControllersGetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                            NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_CONTROL *pCtrl);
NVAPI_INTERFACE NvAPI_GPU_ClockClkVoltControllersSetControl(NvPhysicalGpuHandle hPhysicalGpu,
                                                            NV_GPU_CLOCK_CLK_VOLT_CONTROLLERS_CONTROL *pCtrl);
typedef enum _NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_TYPE {
  NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_TYPE_PROG,
  NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_TYPE_FIXED,
} NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_TYPE,
    *PNV_GPU_CLOCK_CLIENT_CLK_DOMAIN_TYPE;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_PROG_V1 {
  NvS32 freqOffsetMaxkHz;
  NvS32 freqOffsetMinkHz;
  NvU8 vfPointIdxFirst;
  NvU8 vfPointIdxLast;
} NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_PROG_V1, *PNV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_PROG_V1;
typedef union _NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_DATA {
  NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_PROG_V1 prog;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_DATA, *PNV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_DATA;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_V1 {
  NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_TYPE type;
  NV_GPU_PUBLIC_CLOCK_ID domainId;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_DATA data;
} NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_V1, *PNV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_V1;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 domainMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLIENT_CLK_DOMAIN_INFO_V1 domains[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO_V1, *PNV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO_V1;
typedef NV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO_V1 NV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO,
    *PNV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO;
#define NV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO_VER NV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClientClkDomainsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                       __out PNV_GPU_CLOCK_CLIENT_CLK_DOMAINS_INFO_V1 pInfo);
typedef enum _NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TYPE {
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TYPE_PROG,
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TYPE_FIXED,
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TYPE,
    *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TYPE;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_INFO_V1 {
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TYPE type;
  NvBool bVoltageBased;
  NvU8 rsvd[16];
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_INFO_V1, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_INFO_V1;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vfPointMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_INFO_V1 vfPoints[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO_V1, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO_V1;
typedef NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO_V1 NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO,
    *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO;
#define NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO_V1, 1)
#define NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO_VER NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockClientClkVfPointsGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                        __out PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_INFO pInfo);
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V1 {
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TYPE type;
  NvU32 freqkHz;
  NvU32 voltageuV;
  NvU8 rsvd[16];
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V1, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V1;
typedef NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V1 NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V2,
    *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V2;
typedef struct {
  NvU32 freqkHz;
  NvU32 voltageuV;
  NvU8 rsvd[32];
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TUPLE_V1, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TUPLE_V1;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V3 {
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TYPE type;
  NvU32 freqkHz;
  NvU32 voltageuV;
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TUPLE_V1 vfTupleBase;
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TUPLE_V1 vfTupleOffset;
  NvU8 rsvd[256];
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V3, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V3;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vfPointMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V1 vfPoints[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V1, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V1;
typedef NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V1 NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V2,
    *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V2;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V3 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vfPointMask;
  NvBool bVfTupleBaseSupported;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V3 vfPoints[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V3, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V3;
typedef NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS_V3 NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS,
    *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_STATUS;
typedef NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V3 NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS,
    *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS;
#define NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V1, 1)
#define NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_VER2 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V2, 2)
#define NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_VER3 MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_V3, 3)
#define NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_VER NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS_VER3
NVAPI_INTERFACE NvAPI_GPU_ClockClientClkVfPointsGetStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                          __inout PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_STATUS pStatus);
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_PROG_V1 {
  NvS32 freqOffsetkHz;
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_PROG_V1, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_PROG_V1;
typedef union _NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_DATA_V1 {
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_PROG_V1 prog;
  NvU8 rsvd[16];
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_DATA_V1, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_DATA_V1;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_V1 {
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_TYPE type;
  NvU8 rsvd[16];
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_DATA_V1 data;
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_V1, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_V1;
typedef struct _NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E255 vfPointMask;
  NvU8 rsvd[32];
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINT_CONTROL_V1 vfPoints[NV_GPU_BOARDOBJGRP_E255_MAX_OBJECTS];
} NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V1, *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V1;
typedef NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V1 NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V2,
    *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V2;
typedef NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V2 NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL,
    *PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL;
#define NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V1, 1)
#define NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_VER2                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V2, 2)
#define NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_VER NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_VER2
NVAPI_INTERFACE NvAPI_GPU_ClockClientClkVfPointsGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                           __inout PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL pControl);
NVAPI_INTERFACE NvAPI_GPU_ClockClientClkVfPointsSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                           __in PNV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL pControl);
typedef struct _NV_GET_LOCKED_CLOCKS_MODE_V1 {
  NvU32 version;
  NvU32 bToggleBoostClocksSupported : 1;
  NvU32 bLockedClocksModeEnabledByDefault : 1;
  NvU32 bLockedClocksModeCurrentlyEnabled : 1;
  NvU32 bClientToggleLockedClocksMode : 1;
  NvU32 reserved : 28;
} NV_GET_LOCKED_CLOCKS_MODE_V1;
#define NV_GET_LOCKED_CLOCKS_MODE_VER1 MAKE_NVAPI_VERSION(NV_GET_LOCKED_CLOCKS_MODE_V1, 1)
#define NV_GET_LOCKED_CLOCKS_MODE_VER NV_GET_LOCKED_CLOCKS_MODE_VER1
typedef NV_GET_LOCKED_CLOCKS_MODE_V1 NV_GET_LOCKED_CLOCKS_MODE;
NVAPI_INTERFACE NvAPI_GPU_GetLockedClockModeStatus(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __inout NV_GET_LOCKED_CLOCKS_MODE *pLockedClocksModeStatus);
#define NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_SAMPLE_INVALID (NV_U32_MAX)
typedef struct _NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_SAMPLE_V1 {
  NV_GPU_PMUMON_SAMPLE_SUPER_V1 super;
  NvU32 gpcClkFreqKHz;
  NvU32 dramClkFreqKHz;
  NvU8 rsvd[64];
} NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_SAMPLE_V1;
#define NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_SAMPLE_COUNT_V1 (50U)
typedef struct _NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_GET_SAMPLES_V1 {
  NvU32 version;
  NV_GPU_PMUMON_GET_SAMPLES_SUPER_V1 super;
  NvU8 rsvd[64];
  NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_SAMPLE_V1 samples[NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_SAMPLE_COUNT_V1];
} NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_GET_SAMPLES_V1;
typedef NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_GET_SAMPLES_V1 NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_GET_SAMPLES;
#define NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_GET_SAMPLES_VER1                                                               \
  MAKE_NVAPI_VERSION(NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_GET_SAMPLES_V1, 1)
#define NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_GET_SAMPLES_VER NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_GET_SAMPLES_VER1
NVAPI_INTERFACE NvAPI_GPU_ClockPmumonClkDomainsGetSamples(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLOCK_PMUMON_CLK_DOMAINS_GET_SAMPLES *pGetSamplesParams);
typedef enum _NV_GPU_ILLUMINATION_ATTRIB {
  NV_GPU_IA_LOGO_BRIGHTNESS = 0,
  NV_GPU_IA_SLI_BRIGHTNESS = 1,
} NV_GPU_ILLUMINATION_ATTRIB;
typedef struct _NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 {
  NvU32 version;
  NvPhysicalGpuHandle hPhysicalGpu;
  NV_GPU_ILLUMINATION_ATTRIB Attribute;
  NvU32 bSupported;
} NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1;
typedef NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1 NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM;
#define NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_VER_1 MAKE_NVAPI_VERSION(NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_V1, 1)
#define NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_VER NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM_VER_1
NVAPI_INTERFACE NvAPI_GPU_QueryIlluminationSupport(
    __inout NV_GPU_QUERY_ILLUMINATION_SUPPORT_PARM *pIlluminationSupportInfo);
typedef struct _NV_GPU_GET_ILLUMINATION_PARM_V1 {
  NvU32 version;
  NvPhysicalGpuHandle hPhysicalGpu;
  NV_GPU_ILLUMINATION_ATTRIB Attribute;
  NvU32 Value;
} NV_GPU_GET_ILLUMINATION_PARM_V1;
typedef NV_GPU_GET_ILLUMINATION_PARM_V1 NV_GPU_GET_ILLUMINATION_PARM;
#define NV_GPU_GET_ILLUMINATION_PARM_VER_1 MAKE_NVAPI_VERSION(NV_GPU_GET_ILLUMINATION_PARM_V1, 1)
#define NV_GPU_GET_ILLUMINATION_PARM_VER NV_GPU_GET_ILLUMINATION_PARM_VER_1
NVAPI_INTERFACE NvAPI_GPU_GetIllumination(NV_GPU_GET_ILLUMINATION_PARM *pIlluminationInfo);
typedef struct _NV_GPU_SET_ILLUMINATION_PARM_V1 {
  NvU32 version;
  NvPhysicalGpuHandle hPhysicalGpu;
  NV_GPU_ILLUMINATION_ATTRIB Attribute;
  NvU32 Value;
} NV_GPU_SET_ILLUMINATION_PARM_V1;
typedef NV_GPU_SET_ILLUMINATION_PARM_V1 NV_GPU_SET_ILLUMINATION_PARM;
#define NV_GPU_SET_ILLUMINATION_PARM_VER_1 MAKE_NVAPI_VERSION(NV_GPU_SET_ILLUMINATION_PARM_V1, 1)
#define NV_GPU_SET_ILLUMINATION_PARM_VER NV_GPU_SET_ILLUMINATION_PARM_VER_1
NVAPI_INTERFACE NvAPI_GPU_SetIllumination(NV_GPU_SET_ILLUMINATION_PARM *pIlluminationInfo);
typedef enum {
  NV_GPU_ILLUM_CTRL_MODE_MANUAL_RGB = 0,
  NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB,
  NV_GPU_ILLUM_CTRL_MODE_MANUAL = 0,
  NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR,
  NV_GPU_ILLUM_CTRL_MODE_INVALID = 0xFF,
} NV_GPU_ILLUM_CTRL_MODE;
typedef enum {
  NV_GPU_ILLUM_ZONE_LOCATION_GPU_TOP_0 = 0x00,
  NV_GPU_ILLUM_ZONE_LOCATION_GPU_FRONT_0 = 0x08,
  NV_GPU_ILLUM_ZONE_LOCATION_GPU_BACK_0 = 0x0C,
  NV_GPU_ILLUM_ZONE_LOCATION_SLI_TOP_0 = 0x20,
  NV_GPU_ILLUM_ZONE_LOCATION_INVALID = 0xFFFFFFFF,
} NV_GPU_ILLUM_ZONE_LOCATION;
typedef enum {
  NV_GPU_ILLUM_DEVICE_TYPE_INVALID = 0,
  NV_GPU_ILLUM_DEVICE_TYPE_MCUV10,
  NV_GPU_ILLUM_DEVICE_TYPE_GPIO_PWM_RGBW_V10,
  NV_GPU_ILLUM_DEVICE_TYPE_GPIO_PWM_SINGLE_COLOR_V10
} NV_GPU_ILLUM_DEVICE_TYPE;
typedef enum {
  NV_GPU_ILLUM_ZONE_TYPE_INVALID = 0,
  NV_GPU_ILLUM_ZONE_TYPE_RGB,
  NV_GPU_ILLUM_ZONE_TYPE_RGB_FIXED,
  NV_GPU_ILLUM_ZONE_TYPE_RGBW,
  NV_GPU_ILLUM_ZONE_TYPE_SINGLE_COLOR,
} NV_GPU_ILLUM_ZONE_TYPE;
#define NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS 2
typedef enum {
  NV_GPU_ILLUM_PIECEWISE_LINEAR_CYCLE_HALF_HALT = 0,
  NV_GPU_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_HALT,
  NV_GPU_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_REPEAT,
  NV_GPU_ILLUM_PIECEWISE_LINEAR_CYCLE_INVALID = 0xFF,
} NV_GPU_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE;
typedef struct _NV_GPU_ILLUM_DEVICE_INFO_DATA_MCUV10 {
  NvU8 i2cDevIdx;
} NV_GPU_ILLUM_DEVICE_INFO_DATA_MCUV10;
typedef struct {
  NvU8 gpioFuncSingleColor;
  NvU8 gpioPinSingleColor;
  NvU8 pwmSource;
  NvU32 rawPeriod;
} NV_GPU_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR_V10, *PNV_GPU_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR_V10;
typedef struct {
  NvU8 gpioFuncRed;
  NvU8 gpioFuncGreen;
  NvU8 gpioFuncBlue;
  NvU8 gpioFuncWhite;
  NvU8 gpioPinRed;
  NvU8 gpioPinGreen;
  NvU8 gpioPinBlue;
  NvU8 gpioPinWhite;
  NvU8 pwmSourceRed;
  NvU8 pwmSourceGreen;
  NvU8 pwmSourceBlue;
  NvU8 pwmSourceWhite;
  NvU32 rawPeriod;
} NV_GPU_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW_V10, *PNV_GPU_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW_V10;
typedef struct _NV_GPU_ILLUM_DEVICE_INFO_V1 {
  NV_GPU_ILLUM_DEVICE_TYPE type;
  NvU32 ctrlModeMask;
  union {
    NV_GPU_ILLUM_DEVICE_INFO_DATA_MCUV10 mcuv10;
    NV_GPU_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW_V10 gprgbwv10;
    NV_GPU_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR_V10 gpscv10;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_ILLUM_DEVICE_INFO_V1;
typedef NV_GPU_ILLUM_DEVICE_INFO_V1 NV_GPU_ILLUM_DEVICE_INFO;
typedef struct _NV_GPU_ILLUM_DEVICE_INFO_PARAMS_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 deviceMask;
  NvU8 rsvd[64];
  NV_GPU_ILLUM_DEVICE_INFO_V1 devices[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_ILLUM_DEVICE_INFO_PARAMS_V1;
#define NV_GPU_ILLUM_DEVICE_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_ILLUM_DEVICE_INFO_PARAMS_V1, 1)
#define NV_GPU_ILLUM_DEVICE_INFO_PARAMS_VER NV_GPU_ILLUM_DEVICE_INFO_PARAMS_VER_1
typedef NV_GPU_ILLUM_DEVICE_INFO_PARAMS_V1 NV_GPU_ILLUM_DEVICE_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_IllumDevicesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __inout NV_GPU_ILLUM_DEVICE_INFO_PARAMS *pIllumDevicesInfo);
typedef struct {
  NvBool bSync;
  NvU64 timeStampms;
} NV_GPU_ILLUM_DEVICE_SYNC;
typedef struct {
  NV_GPU_ILLUM_DEVICE_TYPE type;
  NV_GPU_ILLUM_DEVICE_SYNC syncData;
  NvU8 rsvd[64];
} NV_GPU_ILLUM_DEVICE_CONTROL_V1;
typedef NV_GPU_ILLUM_DEVICE_CONTROL_V1 NV_GPU_ILLUM_DEVICE_CONTROL;
typedef struct {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 deviceMask;
  NvU8 rsvd[64];
  NV_GPU_ILLUM_DEVICE_CONTROL_V1 devices[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_ILLUM_DEVICE_CONTROL_PARAMS_V1;
#define NV_GPU_ILLUM_DEVICE_CONTROL_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_ILLUM_DEVICE_CONTROL_PARAMS_V1, 1)
#define NV_GPU_ILLUM_DEVICE_CONTROL_PARAMS_VER NV_GPU_ILLUM_DEVICE_CONTROL_PARAMS_VER_1
typedef NV_GPU_ILLUM_DEVICE_CONTROL_PARAMS_V1 NV_GPU_ILLUM_DEVICE_CONTROL_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_IllumDevicesSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_ILLUM_DEVICE_CONTROL_PARAMS *pIllumDevicesControl);
NVAPI_INTERFACE NvAPI_GPU_IllumDevicesGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                 __inout NV_GPU_ILLUM_DEVICE_CONTROL_PARAMS *pIllumDevicesControl);
typedef struct _NV_GPU_ILLUM_ZONE_INFO_DATA_RGB {
  NvU8 rsvd;
} NV_GPU_ILLUM_ZONE_INFO_DATA_RGB;
typedef struct _NV_GPU_ILLUM_ZONE_INFO_V1 {
  NV_GPU_ILLUM_ZONE_TYPE type;
  NvU8 illumDeviceIdx;
  NvU8 provIdx;
  NV_GPU_ILLUM_ZONE_LOCATION zoneLocation;
  union {
    NV_GPU_ILLUM_ZONE_INFO_DATA_RGB rgb;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_ILLUM_ZONE_INFO_V1;
typedef NV_GPU_ILLUM_ZONE_INFO_V1 NV_GPU_ILLUM_ZONE_INFO;
typedef struct _NV_GPU_ILLUM_ZONE_INFO_PARAMS_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 zoneMask;
  NvU8 filterPeriodMs;
  NvU8 rsvd[63];
  NV_GPU_ILLUM_ZONE_INFO_V1 zones[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_ILLUM_ZONE_INFO_PARAMS_V1;
#define NV_GPU_ILLUM_ZONE_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_ILLUM_ZONE_INFO_PARAMS_V1, 1)
#define NV_GPU_ILLUM_ZONE_INFO_PARAMS_VER NV_GPU_ILLUM_ZONE_INFO_PARAMS_VER_1
typedef NV_GPU_ILLUM_ZONE_INFO_PARAMS_V1 NV_GPU_ILLUM_ZONE_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_IllumZonesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __inout NV_GPU_ILLUM_ZONE_INFO_PARAMS *pIllumZonesInfo);
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS {
  NvU8 colorR;
  NvU8 colorG;
  NvU8 colorB;
  NvU8 brightnessPct;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB {
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS rgbParams;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR {
  NV_GPU_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE cycleType;
  NvU8 grpCount;
  NvU16 riseTimems;
  NvU16 fallTimems;
  NvU16 ATimems;
  NvU16 BTimems;
  NvU16 grpIdleTimems;
  NvU16 phaseOffsetms;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB {
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS rgbParams[NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS];
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR piecewiseLinearData;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGB {
  union {
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB manualRGB;
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB piecewiseLinearRGB;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGB;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_FIXED_PARAMS {
  NvU8 brightnessPct;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_FIXED_PARAMS;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_FIXED {
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_FIXED_PARAMS rgbFixedParams;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_FIXED;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB_FIXED {
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_FIXED_PARAMS
      rgbFixedParams[NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS];
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR piecewiseLinearData;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB_FIXED;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGB_FIXED {
  union {
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_FIXED manualRGBFixed;
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB_FIXED piecewiseLinearRGBFixed;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGB_FIXED;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS {
  NvU8 brightnessPct;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR {
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS singleColorParams;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR {
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS
      singleColorParams[NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS];
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR piecewiseLinearData;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR {
  union {
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR manualSingleColor;
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR piecewiseLinearSingleColor;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS {
  NvU8 colorR;
  NvU8 colorG;
  NvU8 colorB;
  NvU8 colorW;
  NvU8 brightnessPct;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW {
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS rgbwParams;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW {
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS rgbwParams[NV_GPU_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS];
  NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR piecewiseLinearData;
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW {
  union {
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW manualRGBW;
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW piecewiseLinearRGBW;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_V1 {
  NV_GPU_ILLUM_ZONE_TYPE type;
  NV_GPU_ILLUM_CTRL_MODE ctrlMode;
  union {
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGB rgb;
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGB_FIXED rgbFixed;
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_RGBW rgbw;
    NV_GPU_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR singleColor;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_ILLUM_ZONE_CONTROL_V1;
typedef NV_GPU_ILLUM_ZONE_CONTROL_V1 NV_GPU_ILLUM_ZONE_CONTROL;
typedef struct _NV_GPU_ILLUM_ZONE_CONTROL_PARAMS_V1 {
  NvU32 version;
  NV_GPU_BOARDOBJGRP_MASK_E32 zoneMask;
  NvU32 bDefault : 1;
  NvU32 reservedField : 31;
  NvU8 rsvd[64];
  NV_GPU_ILLUM_ZONE_CONTROL_V1 zones[NV_GPU_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_GPU_ILLUM_ZONE_CONTROL_PARAMS_V1;
#define NV_GPU_ILLUM_ZONE_CONTROL_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_ILLUM_ZONE_CONTROL_PARAMS_V1, 1)
#define NV_GPU_ILLUM_ZONE_CONTROL_PARAMS_VER NV_GPU_ILLUM_ZONE_CONTROL_PARAMS_VER_1
typedef NV_GPU_ILLUM_ZONE_CONTROL_PARAMS_V1 NV_GPU_ILLUM_ZONE_CONTROL_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_IllumZonesGetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_GPU_ILLUM_ZONE_CONTROL_PARAMS *pIllumZonesControl);
NVAPI_INTERFACE NvAPI_GPU_IllumZonesSetControl(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __inout NV_GPU_ILLUM_ZONE_CONTROL_PARAMS *pIllumZonesControl);
typedef enum {
  NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL_RGB = 0,
  NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_RGB,
  NV_GPU_CLIENT_ILLUM_CTRL_MODE_MANUAL = 0,
  NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR,
  NV_GPU_CLIENT_ILLUM_CTRL_MODE_INVALID = 0xFF,
} NV_GPU_CLIENT_ILLUM_CTRL_MODE;
typedef enum {
  NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_TOP_0 = 0x00,
  NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_FRONT_0 = 0x08,
  NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_GPU_BACK_0 = 0x0C,
  NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_SLI_TOP_0 = 0x20,
  NV_GPU_CLIENT_ILLUM_ZONE_LOCATION_INVALID = 0xFFFFFFFF,
} NV_GPU_CLIENT_ILLUM_ZONE_LOCATION;
typedef enum {
  NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_INVALID = 0,
  NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_MCUV10,
  NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_GPIO_PWM_RGBW_V10,
  NV_GPU_CLIENT_ILLUM_DEVICE_TYPE_GPIO_PWM_SINGLE_COLOR_V10,
} NV_GPU_CLIENT_ILLUM_DEVICE_TYPE;
typedef enum {
  NV_GPU_CLIENT_ILLUM_ZONE_TYPE_INVALID = 0,
  NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGB,
  NV_GPU_CLIENT_ILLUM_ZONE_TYPE_COLOR_FIXED,
  NV_GPU_CLIENT_ILLUM_ZONE_TYPE_RGBW,
  NV_GPU_CLIENT_ILLUM_ZONE_TYPE_SINGLE_COLOR,
} NV_GPU_CLIENT_ILLUM_ZONE_TYPE;
#define NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS 2
typedef enum {
  NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_HALF_HALT = 0,
  NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_HALT,
  NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_FULL_REPEAT,
  NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_INVALID = 0xFF,
} NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE;
#define NV_GPU_CLIENT_ILLUM_DEVICE_NUM_DEVICES_MAX 32
typedef struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10 {
  NvU8 i2cDevIdx;
} NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10;
typedef struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW {
  NvU8 gpioPinRed;
  NvU8 gpioPinGreen;
  NvU8 gpioPinBlue;
  NvU8 gpioPinWhite;
} NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW;
typedef struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR {
  NvU8 gpioPinSingleColor;
} NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR;
typedef struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1 {
  NV_GPU_CLIENT_ILLUM_DEVICE_TYPE type;
  NvU32 ctrlModeMask;
  union {
    NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_MCUV10 mcuv10;
    NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_RGBW gpioPwmRgbwv10;
    NV_GPU_CLIENT_ILLUM_DEVICE_INFO_DATA_GPIO_PWM_SINGLE_COLOR gpioPwmSingleColorv10;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1;
typedef struct _NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 numIllumDevices;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_ILLUM_DEVICE_INFO_V1 devices[NV_GPU_CLIENT_ILLUM_DEVICE_NUM_DEVICES_MAX];
} NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1;
#define NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1, 1)
#define NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_VER NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_VER_1
typedef NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS_V1 NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_ClientIllumDevicesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                    __inout NV_GPU_CLIENT_ILLUM_DEVICE_INFO_PARAMS *pIllumDevicesInfo);
typedef struct {
  NvBool bSync;
  NvU64 timeStampms;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1;
typedef struct {
  NV_GPU_CLIENT_ILLUM_DEVICE_TYPE type;
  NV_GPU_CLIENT_ILLUM_DEVICE_SYNC_V1 syncData;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1;
typedef NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1 NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL;
typedef struct {
  NvU32 version;
  NvU32 numIllumDevices;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_V1 devices[NV_GPU_CLIENT_ILLUM_DEVICE_NUM_DEVICES_MAX];
} NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1;
#define NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_VER_1                                                                \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1, 1)
#define NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_VER NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_VER_1
typedef NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS_V1 NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_ClientIllumDevicesGetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu,
    __inout NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS *pClientIllumDevicesControl);
NVAPI_INTERFACE NvAPI_GPU_ClientIllumDevicesSetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu,
    __inout NV_GPU_CLIENT_ILLUM_DEVICE_CONTROL_PARAMS *pClientIllumDevicesControl);
#define NV_GPU_CLIENT_ILLUM_ZONE_NUM_ZONES_MAX 32
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB {
  NvU8 rsvd;
} NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW {
  NvU8 rsvd;
} NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR {
  NvU8 rsvd;
} NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1 {
  NV_GPU_CLIENT_ILLUM_ZONE_TYPE type;
  NvU8 illumDeviceIdx;
  NvU8 provIdx;
  NV_GPU_CLIENT_ILLUM_ZONE_LOCATION zoneLocation;
  union {
    NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGB rgb;
    NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_RGBW rgbw;
    NV_GPU_CLIENT_ILLUM_ZONE_INFO_DATA_SINGLE_COLOR singleColor;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1 {
  NvU32 version;
  NvU32 numIllumZones;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_ILLUM_ZONE_INFO_V1 zones[NV_GPU_CLIENT_ILLUM_ZONE_NUM_ZONES_MAX];
} NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1;
#define NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1, 1)
#define NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_VER NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_VER_1
typedef NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS_V1 NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_ClientIllumZonesGetInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_GPU_CLIENT_ILLUM_ZONE_INFO_PARAMS *pIllumZonesInfo);
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS {
  NvU8 colorR;
  NvU8 colorG;
  NvU8 colorB;
  NvU8 brightnessPct;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB {
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS rgbParams;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR {
  NV_GPU_CLIENT_ILLUM_PIECEWISE_LINEAR_CYCLE_TYPE cycleType;
  NvU8 grpCount;
  NvU16 riseTimems;
  NvU16 fallTimems;
  NvU16 ATimems;
  NvU16 BTimems;
  NvU16 grpIdleTimems;
  NvU16 phaseOffsetms;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB {
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB_PARAMS
      rgbParams[NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS];
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR piecewiseLinearData;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB {
  union {
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGB manualRGB;
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGB piecewiseLinearRGB;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS {
  NvU8 brightnessPct;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED {
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS colorFixedParams;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED {
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED_PARAMS
      colorFixedParams[NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS];
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR piecewiseLinearData;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED {
  union {
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_COLOR_FIXED manualColorFixed;
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_COLOR_FIXED piecewiseLinearColorFixed;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS {
  NvU8 colorR;
  NvU8 colorG;
  NvU8 colorB;
  NvU8 colorW;
  NvU8 brightnessPct;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW {
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS rgbwParams;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW {
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW_PARAMS
      rgbwParams[NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS];
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR piecewiseLinearData;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW {
  union {
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_RGBW manualRGBW;
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_RGBW piecewiseLinearRGBW;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS {
  NvU8 brightnessPct;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR {
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS singleColorParams;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR {
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR_PARAMS
      singleColorParams[NV_GPU_CLIENT_ILLUM_CTRL_MODE_PIECEWISE_LINEAR_COLOR_ENDPOINTS];
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR piecewiseLinearData;
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR {
  union {
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_MANUAL_SINGLE_COLOR manualSingleColor;
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_PIECEWISE_LINEAR_SINGLE_COLOR piecewiseLinearSingleColor;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1 {
  NV_GPU_CLIENT_ILLUM_ZONE_TYPE type;
  NV_GPU_CLIENT_ILLUM_CTRL_MODE ctrlMode;
  union {
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGB rgb;
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_COLOR_FIXED colorFixed;
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_RGBW rgbw;
    NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_DATA_SINGLE_COLOR singleColor;
    NvU8 rsvd[64];
  } data;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1;
typedef struct _NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 {
  NvU32 version;
  NvU32 bDefault : 1;
  NvU32 rsvdField : 31;
  NvU32 numIllumZonesControl;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_V1 zones[NV_GPU_CLIENT_ILLUM_ZONE_NUM_ZONES_MAX];
} NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1;
#define NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1, 1)
#define NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_VER NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_VER_1
typedef NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS_V1 NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS;
NVAPI_INTERFACE NvAPI_GPU_ClientIllumZonesGetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS *pIllumZonesControl);
NVAPI_INTERFACE NvAPI_GPU_ClientIllumZonesSetControl(
    __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GPU_CLIENT_ILLUM_ZONE_CONTROL_PARAMS *pIllumZonesControl);
typedef enum {
  NV_EVENT_ID_DIAG = 0,
  NV_EVENT_ID_ACPI_HOTKEY = 1,
  NV_EVENT_ID_POWER_CONNECTOR = 2,
  NV_EVENT_ID_THERMAL = 3,
  NV_EVENT_ID_DRIVER_RECONNECTED = 4,
  NV_EVENT_ID_HYBRID_DUALVIEW_FAIL_ATTACH = 5,
  NV_EVENT_ID_HYBRID_CHANGE_STATE = 6,
  NV_EVENT_ID_HYBRID_NOTIFY_TRIGGER_RECOMMANDVIDPN = 7,
  NV_EVENT_ID_HYBRID_NOTIFY_TRIGGER_POLL_CHILD_CONNECT = 8,
  NV_EVENT_ID_HYBRID_NEXTDISPLAY_STATE = 9,
  NV_EVENT_ID_HYBRID_NOTIFY_TRIGGER_GET_DGPU_EDIDS = 10,
  NV_EVENT_ID_HYBRID_NOTIFY_LIGHTWEIGHT_STATE = 11,
  NV_EVENT_ID_HYBRID_NOTIFY_HIDE_HEADS = 12,
  NV_EVENT_ID_HYBRID_MUX_DEVICE_HOTPLUG = 13,
  NV_EVENT_ID_UNUSED = 14,
  NV_EVENT_ID_BAD_EDID_MODESET = 15,
  NV_EVENT_ID_SLI_SWAP_MASTER_GPU = 16,
  NV_EVENT_ID_PSTATE_CHANGE = 17,
  NV_EVENT_ID_HYBRID_WIN7_HOTPLUG_POWERUP_DGPU = 18,
  NV_EVENT_ID_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU = 19,
  NV_EVENT_ID_OVERLAY_FAILURE = 20,
  NV_EVENT_ID_GSYNC = 21,
  NV_EVENT_ID_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU = 22,
  NV_EVENT_ID_PINNED_SURFACE_ALLOC = 23,
  NV_EVENT_ID_PINNED_SURFACE_FREE = 24,
  NV_EVENT_ID_COPROC_POWER_REF_COUNT = 25,
  NV_EVENT_ID_HYBRID_DGPU_EVENT = 26,
  NV_EVENT_ID_RESUME_FROM_HIBERNATION_COMMIT_VIDPN_DONE = 27,
  NV_EVENT_ID_RESUME_FROM_STANDBY_COMMIT_VIDPN_DONE = 28,
  NV_EVENT_ID_VMODE_DEPRECATED = 29,
  NV_EVENT_ID_COPROC_RESOLUTION_LIMIT_CHANGED = 30,
  NV_EVENT_ID_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC = 31,
  NV_EVENT_ID_DEPRECATED_01 = 32,
  NV_EVENT_ID_PHYSX_INVALID_CONFIG = 33,
  NV_EVENT_ID_FAN_SPEED_CHANGE = 34,
  NV_EVENT_ID_THERMAL_CHANGE = 35,
  NV_EVENT_ID_HCLONE_SET_SURFACE_INFO_AND_MODESET = 36,
  NV_EVENT_ID_COLOR_PROFILE_CHANGE = 37,
  NV_EVENT_ID_COPROC_FORCE_GPU_SWITCH = 38,
  NV_EVENT_ID_DISPLAYPORT_TOPOLOGY_CHANGED = 39,
  NV_EVENT_ID_COPROC_POWER_STATE_CHANGE = 40,
  NV_EVENT_ID_HOTKEY_TOPOLOGY_CHANGE = 41,
  NV_EVENT_ID_MONITOR_CONNECTION_STATUS_CHANGE = 42,
  NV_EVENT_ID_GC5_STATE_CHANGE = 43,
  NV_EVENT_ID_COMMIT_VIDPN_DONE = 44,
  NV_EVENT_ID_GC6_NOTIFY_STATE_CHANGE = 45,
  NV_EVENT_ID_CURSOR_SHAPE_CHANGE = 46,
  NV_EVENT_ID_DESKTOP_REDRAW_REQUEST = 47,
  NV_EVENT_ID_DWM_CHANGE_REQUEST = 48,
  NV_EVENT_ID_REQUEST_FORCED_TDR = 49,
  NV_EVENT_ID_DSR_STATE_CHANGE = 50,
  NV_EVENT_ID_STOP_DISPLAY_CHANGE_HONORING = 51,
  NV_EVENT_ID_START_DISPLAY_CHANGE_HONORING = 52,
  NV_EVENT_ID_NOTIFY_CHANNEL_ERROR = 53,
  NV_EVENT_ID_HDCP_STATUS = 54,
  NV_EVENT_ID_FORCE_MODESET = 55,
  NV_EVENT_ID_FULL_TDR_OCCURRED = 56,
  NV_EVENT_ID_HDR_SESSION_CHANGE = 57,
  NV_EVENT_ID_NVAPI_INITIALIZED = 58,
  NV_EVENT_ID_UPDATE_OS_HDR = 59,
  NV_EVENT_ID_GRID_LICENSE_STATE_CHANGED = 60,
  NV_EVENT_ID_DRIVER_STATE_CHANGED = 61,
  NV_EVENT_ID_ACTIVE_PROCESS_COUNT_CHANGED = 62,
  NV_EVENT_ID_DISPLAY_MUX_TRANSITION = 63,
  NV_EVENT_ID_QUERY_COLOR_ACCURACY_MODE = 64,
  NV_EVENT_ID_DDS_PANEL_LRST_COMPLETE = 65,
  NV_EVENT_ID_PLATFORM_POWER_MODE_CHANGE = 66,
  NV_EVENT_ID_NVTOPPS_DATA_READY = 67,
  NV_EVENT_ID_HW_CURSOR_STATE_CHANGE = 68,
  NV_EVENT_ID_GROUP_UNICAST_FIRST = 100000,
  NV_EVENT_ID_RIVERMAXDISPLAY = 100001,
  NV_EVENT_ID_GROUP_UNICAST_LAST = 100100,
  NV_EVENT_ID_NONE = 0xffffffff,
} NV_EVENT_ID;
#define IS_UNICAST_EVENT_ID(eventId)                                                                                   \
  ((eventId > NV_EVENT_ID_GROUP_UNICAST_FIRST) && (eventId < NV_EVENT_ID_GROUP_UNICAST_LAST))
typedef enum {
  NV_EVENT_BLOCK_ID_NONE = 0,
  NV_EVENT_BLOCK_ID_ACPI = 1,
  NV_EVENT_BLOCK_ID_HYBRID_CHANGE_STATE = 2,
  NV_EVENT_BLOCK_ID_HYBRID_NEXTDISPLAY_STATE = 3,
  NV_EVENT_BLOCK_ID_HYBRID_NOTIFY_LIGHTWEIGHT_STATE = 4,
  NV_EVENT_BLOCK_ID_HYBRID_DIAG_NOTIFY = 5,
  NV_EVENT_BLOCK_ID_HYBRID_CHANGE_STATE_V2 = 6,
  NV_EVENT_BLOCK_ID_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY = 7,
  NV_EVENT_BLOCK_ID_PSTATE_CHANGE = 8,
  NV_EVENT_BLOCK_ID_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU = 9,
  NV_EVENT_BLOCK_ID_OVERLAY_FAILURE = 10,
  NV_EVENT_BLOCK_ID_GSYNC = 11,
  NV_EVENT_BLOCK_ID_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU = 12,
  NV_EVENT_BLOCK_ID_PINNED_SURFACE_ALLOC = 13,
  NV_EVENT_BLOCK_ID_PINNED_SURFACE_FREE = 14,
  NV_EVENT_BLOCK_ID_COPROC_POWER_REF_COUNT = 15,
  NV_EVENT_BLOCK_ID_HYBRID_DGPU_EVENT = 16,
  NV_EVENT_BLOCK_ID_VMODE_DEPRECATED = 17,
  NV_EVENT_BLOCK_ID_COPROC_RESOLUTION_LIMIT_CHANGED = 18,
  NV_EVENT_BLOCK_ID_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC = 19,
  NV_EVENT_BLOCK_ID_PHYSX_INVALID_CONFIG = 20,
  NV_EVENT_BLOCK_ID_FAN_SPEED_CHANGE = 21,
  NV_EVENT_BLOCK_ID_THERMAL_CHANGE = 22,
  NV_EVENT_BLOCK_ID_COLOR_PROFILE_CHANGE = 23,
  NV_EVENT_BLOCK_ID_COPROC_FORCE_GPU_SWITCH = 24,
  NV_EVENT_BLOCK_ID_DISPLAYPORT_TOPOLOGY_CHANGED = 25,
  NV_EVENT_BLOCK_ID_SET_SURFACE_INFO_AND_MODESET = 26,
  NV_EVENT_BLOCK_ID_COPROC_POWER_STATE_CHANGE = 27,
  NV_EVENT_BLOCK_ID_HOTKEY_TOPOLOGY_CHANGE = 28,
  NV_EVENT_BLOCK_ID_MONITOR_CONNECTION_STATUS_CHANGE = 29,
  NV_EVENT_BLOCK_ID_GC5_STATE_CHANGE = 30,
  NV_EVENT_BLOCK_ID_COMMIT_VIDPN_DONE = 31,
  NV_EVENT_BLOCK_ID_GC6_NOTIFY_STATE_CHANGE = 32,
  NV_EVENT_BLOCK_ID_DESKTOP_REDRAW_REQUEST = 33,
  NV_EVENT_BLOCK_ID_DWM_CHANGE_REQUEST = 34,
  NV_EVENT_BLOCK_ID_REQUEST_FORCED_TDR = 35,
  NV_EVENT_BLOCK_ID_DSR_STATE_CHANGE = 36,
  NV_EVENT_BLOCK_ID_START_DISPLAY_CHANGE_HONORING = 37,
  NV_EVENT_BLOCK_ID_NOTIFY_CHANNEL_ERROR = 38,
  NV_EVENT_BLOCK_ID_HDCP_STATUS = 39,
  NV_EVENT_BLOCK_ID_FORCE_MODESET = 40,
  NV_EVENT_BLOCK_ID_HDR_SESSION_CHANGE = 41,
  NV_EVENT_BLOCK_ID_UPDATE_OS_HDR = 42,
  NV_EVENT_BLOCK_ID_GRID_LICENSE_STATE_CHANGED = 43,
  NV_EVENT_BLOCK_ID_DRIVER_STATE_CHANGED = 44,
  NV_EVENT_BLOCK_ID_ACTIVE_PROCESS_COUNT_CHANGED = 45,
  NV_EVENT_BLOCK_ID_DISPLAY_MUX_TRANSITION = 46,
  NV_EVENT_BLOCK_ID_QUERY_COLOR_ACCURACY_MODE = 47,
  NV_EVENT_BLOCK_ID_PLATFORM_POWER_MODE_CHANGE = 48,
  NV_EVENT_BLOCK_ID_NVTOPPS_DATA_READY = 49,
  NV_EVENT_BLOCK_ID_RIVERMAXDISPLAY = 50,
  NV_EVENT_BLOCK_ID_HW_CURSOR_STATE_CHANGE = 51,
} NV_EVENT_BLOCK_ID;
typedef struct {
  NvU32 cbSize;
  NvU32 version;
  NvU32 cbBlockOffset;
  NV_EVENT_ID EventId;
  NV_EVENT_BLOCK_ID BlockId;
  union {
    NvPhysicalGpuHandle PhysicalGpu;
    NvU32 Reserved32;
    NvU64 Reserved64;
  };
} NV_EVENT, *PNV_EVENT;
#define NV_EVENT_VERSION MAKE_NVAPI_VERSION(NV_EVENT, 1)
typedef struct {
  NvU32 ulInvalidatedDeviceMask;
  NvU32 ulConnectedDeviceMask;
  NV_TARGET_VIEW_MODE config;
} NV_EVENT_BLOCK_ACPI, *PNV_EVENT_BLOCK_ACPI;
typedef struct _NV_EVENT_BLOCK_GRID_LICENSE_STATE_CHANGED {
  NV_LICENSE_FEATURE_TYPE newFeatureType;
} NV_EVENT_BLOCK_GRID_LICENSE_STATE_CHANGED, *PNV_EVENT_BLOCK_GRID_LICENSE_STATE_CHANGED;
typedef struct _NV_EVENT_GRID_LICENSE_STATE_CHANGED {
  NV_EVENT header;
  NV_EVENT_BLOCK_GRID_LICENSE_STATE_CHANGED data;
} NV_EVENT_GRID_LICENSE_STATE_CHANGED, *PNV_EVENT_GRID_LICENSE_STATE_CHANGED;
typedef struct {
  NvU32 srcID;
  union {
    NvU32 targetID;
    NvU32 displayID;
  };
  NvU32 isNonNVPath : 1;
  NvU32 reserved : 31;
} PATH_INFO, *PPATH_INFO;
typedef struct {
  NvU32 pathCount;
  PATH_INFO pathInfo[NVAPI_MAX_DISPLAYS];
} NV_EVENT_BLOCK_HOTKEY_TOPOLOGY_DATA, *PNV_EVENT_BLOCK_HOTKEY_TOPOLOGY_DATA;
#define NV_INVALID_SRC_ID -1
typedef struct _NV_EVENT_BLOCK_HYBRID_CHANGE_STATE {
  NvU32 hybridState;
} NV_EVENT_BLOCK_HYBRID_CHANGE_STATE, *PNV_EVENT_BLOCK_HYBRID_CHANGE_STATE;
typedef struct _NV_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2 {
  NvU32 hybridState;
  NvU32 flags;
} NV_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2, *PNV_EVENT_BLOCK_HYBRID_CHANGE_STATE_V2;
typedef struct _NV_EVENT_BLOCK_HYBRID_NEXT_DISPLAY {
  NvU8 transitionRequest;
  union {
    NvU32 ulACPIId1;
    NvU32 ulDeviceMask;
  };
  NvU32 ulACPIId2;
} NV_EVENT_HYBRID_NEXT_DISPLAY, *PNV_EVENT_HYBRID_NEXT_DISPLAY;
typedef struct _NV_EVENT_BLOCK_PINNED_SURFACE_ALLOC {
  NvU64 hKmHandle;
  NvU32 dwPinnedMemId;
  NvU32 size;
} NV_EVENT_BLOCK_PINNED_SURFACE_ALLOC, *PNV_EVENT_BLOCK_PINNED_SURFACE_ALLOC;
typedef struct _NV_EVENT_BLOCK_PINNED_SURFACE_FREE {
  NvU64 hKmHandle;
  NvU32 hMem;
} NV_EVENT_BLOCK_PINNED_SURFACE_FREE, *PNV_EVENT_BLOCK_PINNED_SURFACE_FREE;
typedef enum {
  NV_STATE_UNDEFINED = 0,
  NV_STATE_EDID_REQUESTED = 1,
} NvEventLightweightState;
typedef struct _NV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE {
  NvEventLightweightState state;
} NV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE, *PNV_EVENT_BLOCK_HYBRID_NOTIFY_LIGHTWEIGHT_STATE;
typedef struct _NV_EVENT_BLOCK_HYBRID_DIAG_NOTIFY {
  NvU32 ulACPINotification;
} NV_EVENT_BLOCK_HYBRID_DIAG_NOTIFY, *PNV_EVENT_BLOCK_HYBRID_DIAG_NOTIFY;
typedef struct _NV_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY {
  NvU32 ulACPIId;
} NV_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY, *PNV_EVENT_BLOCK_HYBRID_MUX_DEVICE_HOTPLUG_NOTIFY;
typedef struct _NV_EVENT_BLOCK_PSTATE_CHANGE {
  NvU32 Pstate;
} NV_EVENT_BLOCK_PSTATE_CHANGE, *PNV_EVENT_BLOCK_PSTATE_CHANGE;
typedef struct _NV_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU {
  NvU32 ulACPIId1;
  NvU32 ulChildId1;
  NvU32 ulACPIId2;
  NvU32 ulChildId2;
  NvU32 ulReserved;
  NV_TARGET_VIEW_MODE ViewMode;
  NvU32 ulPowerUpDgpu;
} NV_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU, *PNV_EVENT_BLOCK_HYBRID_WIN7_HOTKEY_TOPOLOGY_POWERUP_DGPU;
typedef enum _NV_OVERLAY_FAILURE_TYPE {
  NV_OVERLAY_FAILURE_GENERAL = 0,
  NV_OVERLAY_FAILURE_IMP = 1,
} NV_OVERLAY_FAILURE_TYPE;
typedef struct _NV_EVENT_BLOCK_OVERLAY_FAILURE {
  NV_OVERLAY_FAILURE_TYPE type;
  NvU32 ulProcessId;
  NvU32 ulPathCount;
} NV_EVENT_BLOCK_OVERLAY_FAILURE, *PNV_EVENT_BLOCK_OVERLAY_FAILURE;
typedef enum {
  NV_GSYNC_EVENT_NONE = (0x00000000),
  NV_GSYNC_EVENT_SMART_SYNC_LOSS = (0x00000001),
  NV_GSYNC_EVENT_SMART_SYNC_GAIN = (0x00000002),
  NV_GSYNC_EVENT_SMART_STEREO_LOSS = (0x00000004),
  NV_GSYNC_EVENT_SMART_STEREO_GAIN = (0x00000008),
  NV_GSYNC_EVENT_SMART_HOUSESYNC_GAIN = (0x00000010),
  NV_GSYNC_EVENT_SMART_HOUSESYNC_LOSS = (0x00000020),
  NV_GSYNC_EVENT_SMART_RJ45_GAIN = (0x00000040),
  NV_GSYNC_EVENT_SMART_RJ45_LOSS = (0x00000080),
  NV_GSYNC_EVENT_SMART_SYNC_STATE_CHANGE = (0x00010000)
} NV_GSYNC_EVENT;
typedef struct _NV_EVENT_BLOCK_GSYNC {
  NvU32 ulData;
} NV_EVENT_BLOCK_GSYNC, *PNV_EVENT_BLOCK_GSYNC;
typedef struct _NV_EVENT_BLOCK_DSR_STATE_CHANGE {
  NvU32 ulData;
} NV_EVENT_BLOCK_DSR_STATE_CHANGE, *PNV_EVENT_BLOCK_DSR_STATE_CHANGE;
typedef struct _NV_EVENT_BLOCK_MONITOR_CONNECTION_STATUS_CHANGE {
  NvU32 targetId;
  NvU32 ulFlags;
} NV_EVENT_BLOCK_MONITOR_CONNECTION_STATUS_CHANGE, *PNV_EVENT_BLOCK_MONITOR_CONNECTION_STATUS_CHANGE;
#define FULL_TOPOLOGY_POWERUP_DGPU_MAX_HEADS 4
typedef struct _HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO {
  NvU32 ChildId;
  NvU32 SourceId;
  NvU32 Width;
  NvU32 Height;
  NvU32 PixelFormat;
  NvU32 VSyncNumerator;
  NvU32 VSyncDenominator;
  NvU32 ImportanceOrdinal;
  NvU32 Rotation;
  NvU32 Scaling;
  NvU32 ScanlineOrdering;
} *PHYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO, HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO;
typedef struct _NV_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU {
  NvU32 NumPathCount;
  HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU_PATH_INFO PathInfo[FULL_TOPOLOGY_POWERUP_DGPU_MAX_HEADS];
} NV_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU, *PNV_EVENT_BLOCK_HYBRID_WIN7_FULL_TOPOLOGY_POWERUP_DGPU;
typedef struct _NV_EVENT_BLOCK_COPROC_POWER_REF_COUNT {
  NvU64 SequenceNumber;
  NvU32 ReferenceCount;
  NvU32 pad0;
} NV_EVENT_BLOCK_COPROC_POWER_REF_COUNT;
typedef struct _NV_EVENT_BLOCK_ACTIVE_PROCESS_COUNT_CHANGED {
  NvU32 ProcessCount;
} NV_EVENT_BLOCK_ACTIVE_PROCESS_COUNT_CHANGED;
typedef struct _NV_EVENT_BLOCK_HYBRID_DGPU_EVENT {
  NvU32 gpioEvent;
} NV_EVENT_BLOCK_HYBRID_DGPU_EVENT, *PNV_EVENT_BLOCK_HYBRID_DGPU_EVENT;
typedef enum _NV_EVENT_DISPLAY_MUX_TRANSITION_TYPE {
  NV_EVENT_DISPLAY_MUX_TRANSITION_TYPE_NONE = 0x3598FC35,
  NV_EVENT_DISPLAY_MUX_TRANSITION_TYPE_I2D = 0x2517031A,
  NV_EVENT_DISPLAY_MUX_TRANSITION_TYPE_D2I = 0x8125A85C
} NV_EVENT_DISPLAY_MUX_TRANSITION_TYPE;
typedef struct _NV_EVENT_BLOCK_DISPLAY_MUX_TRANSITION {
  NV_EVENT_DISPLAY_MUX_TRANSITION_TYPE muxTransitionType;
} NV_EVENT_BLOCK_DISPLAY_MUX_TRANSITION, *PNV_EVENT_BLOCK_DISPLAY_MUX_TRANSITION;
typedef struct _NV_EVENT_DISPLAY_MUX_TRANSITION {
  NV_EVENT header;
  NV_EVENT_BLOCK_DISPLAY_MUX_TRANSITION data;
} NV_EVENT_DISPLAY_MUX_TRANSITION, *PNV_EVENT_DISPLAY_MUX_TRANSITION;
typedef struct _NV_EVENT_BLOCK_COPROC_RESOLUTION_LIMIT_CHANGED {
  NvU32 ulCurMaxResolutionSize;
  NvU32 bDisabled;
} NV_EVENT_BLOCK_COPROC_RESOLUTION_LIMIT_CHANGED, *PNV_EVENT_BLOCK_COPROC_RESOLUTION_LIMIT_CHANGED;
typedef struct _NV_EVENT_BLOCK_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC {
  NvU32 ulMDTLNextSequenceIndex;
} NV_EVENT_BLOCK_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC, *PNV_EVENT_BLOCK_COPROC_HOTKEY_NEXT_MDTL_INDEX_TO_NVSVC;
typedef struct _NV_EVENT_BLOCK_PHYSX_INVALID_CONFIG {
  NvU64 hProcessId;
} NV_EVENT_BLOCK_PHYSX_INVALID_CONFIG, *PNV_EVENT_BLOCK_PHYSX_INVALID_CONFIG;
typedef enum _NV_COPROC_FORCE_GPU_MODE {
  NV_COPROC_NONE,
  NV_COPROC_FORCE_IGPU,
  NV_COPROC_FORCE_DGPU,
  NV_COPROC_OPTIMUS,
} NV_COPROC_FORCE_GPU_MODE;
typedef struct _NV_EVENT_BLOCK_COPROC_FORCE_GPU_POLICY {
  NV_COPROC_FORCE_GPU_MODE forcedGPUMode;
} NV_EVENT_BLOCK_COPROC_FORCE_GPU_POLICY, *PNV_EVENT_BLOCK_COPROC_FORCE_GPU_POLICY;
typedef struct _NV_EVENT_BLOCK_FAN_SPEED_CHANGE {
  NvU32 fanSpeedLevel;
} NV_EVENT_BLOCK_FAN_SPEED_CHANGE, *PNV_EVENT_BLOCK_FAN_SPEED_CHANGE;
typedef struct _NV_EVENT_BLOCK_THERMAL_CHANGE {
  NvU32 thermalLevel;
} NV_EVENT_BLOCK_THERMAL_CHANGE, *PNV_EVENT_BLOCK_THERMAL_CHANGE;
typedef enum _NV_COLOR_PROFILE_CHANGE_TYPE {
  NV_COLOR_PROFILE_CHANGE_DISABLE_OVERRIDE = 0x00,
  NV_COLOR_PROFILE_CHANGE_ENABLE_OVERRIDE = 0x01,
} NV_COLOR_PROFILE_CHANGE_TYPE;
typedef struct _NV_EVENT_BLOCK_COLOR_PROFILE_CHANGE {
  NV_COLOR_PROFILE_CHANGE_TYPE profileChange;
  NvU32 gpuId;
  NvU32 outputId;
  NvU32 position;
} NV_EVENT_BLOCK_COLOR_PROFILE_CHANGE, *PNV_EVENT_BLOCK_COLOR_PROFILE_CHANGE;
typedef enum _NV_DISPLAY_CONFIG_TYPE {
  NV_DISPLAY_CONFIG_TYPE_STANDARD = 1,
  NV_DISPLAY_CONFIG_TYPE_STREAM_CLONED = 2,
  NV_DISPLAY_CONFIG_TYPE_MOSAIC = 3,
} NV_DISPLAY_CONFIG_TYPE;
typedef enum _NV_TOPO_EVENTTYPE {
  NV_TOPO_EVENTTYPE_DISPLAY_HOTPLUG = 1,
  NV_TOPO_EVENTTYPE_DISPLAY_UNPLUG = 2,
  NV_TOPO_EVENTTYPE_NEW_DEVICE = 3,
  NV_TOPO_EVENTTYPE_LOST_DEVICE = 4,
  NV_TOPO_EVENTTYPE_DETECT_COMPLETED = 5,
  NV_TOPO_EVENTTYPE_BANDWIDTH_CHANGED = 6,
  NV_TOPO_EVENTTYPE_MUST_DISCONNECT = 7,
  NV_TOPO_EVENTTYPE_ZOMBIE_STATE_CHANGED = 8,
  NV_TOPO_EVENTTYPE_CABLE_STATE_CHANGED = 9,
} NV_TOPO_EVENTTYPE;
typedef struct _NV_EVENT_BLOCK_TOPOLOGY_CHANGED {
  NV_TOPO_EVENTTYPE eventType;
  NvU32 gpuId;
  NvU32 subdeviceId;
  NvU32 connectorId;
  NvU32 childUid;
  NvU32 displayId;
  union {
    NV_DISPLAY_CONFIG_TYPE displayType;
    NV_DP_NODE_INFO dpNode;
  };
} NV_EVENT_BLOCK_TOPOLOGY_CHANGED;
typedef struct _NV_EVENT_TOPOLOGY_CHANGED {
  NV_EVENT header;
  NV_EVENT_BLOCK_TOPOLOGY_CHANGED data;
} NV_EVENT_TOPOLOGY_CHANGED;
typedef enum _NV_HCLONE_EVENT_REASON {
  NV_HCLONE_EVENT_REASON_SETTING_HCLONE_TOPOLOGY = 0,
  NV_HCLONE_EVENT_REASON_CLEARING_HCLONE_TOPOLOGY_VOLUNTARY,
  NV_HCLONE_EVENT_REASON_CLEARING_HCLONE_TOPOLOGY_INVOLUNTARY,
  NV_HCLONE_EVENT_REASON_RESOLUTION_CHANGED,
  NV_HCLONE_EVENT_REASON_ZERO_FIND_ZEROR_GAMMA,
} NV_HCLONE_EVENT_REASON;
typedef struct _NV_EVENT_BLOCK_HCLONE_SET_SURFACE_INFO_AND_MODESET {
  NV_HCLONE_EVENT_REASON eventReason;
} NV_EVENT_BLOCK_HCLONE_SET_SURFACE_INFO_AND_MODESET;
typedef struct _NV_EVENT_HCLONE_SET_SURFACE_INFO_AND_MODESET {
  NV_EVENT header;
  NV_EVENT_BLOCK_HCLONE_SET_SURFACE_INFO_AND_MODESET data;
} NV_EVENT_HCLONE_SET_SURFACE_INFO_AND_MODESET;
typedef enum _NV_COPROC_POWER_STATE_CHANGE {
  NV_COPROC_POWER_STATE_CHANGE_ON = 0x206E4F20,
  NV_COPROC_POWER_STATE_CHANGE_GOLD = 0x476F6C64,
  NV_COPROC_POWER_STATE_CHANGE_GC6 = 0x63452A91,
} NV_COPROC_POWER_STATE_CHANGE;
typedef struct _NV_EVENT_BLOCK_COPROC_POWER_STATE_CHANGE {
  NV_COPROC_POWER_STATE_CHANGE coprocPowerStateChange;
} NV_EVENT_BLOCK_COPROC_POWER_STATE_CHANGE, *PNV_EVENT_BLOCK_COPROC_POWER_STATE_CHANGE;
typedef enum _NV_GC5_STATE_CHANGE {
  NV_GC5_STATE_CHANGE_DISARMED = 0,
  NV_GC5_STATE_CHANGE_ARMED = 1,
} NV_GC5_STATE_CHANGE;
typedef enum _NV_GC6_NOTIFY_STATE_CHANGE {
  NV_GC6_NOTIFY_STATE_CHANGE_ENTRY = 0,
  NV_GC6_NOTIFY_STATE_CHANGE_EXIT = 1,
} NV_GC6_NOTIFY_STATE_CHANGE;
typedef enum _NV_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO {
  NV_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO_DEFAULT = 0,
  NV_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO_RESUME_FROM_HIBERNATION,
  NV_EVENT_ENUM_COMMIT_VIDPN_DONE_SCENARIO_RESUME_FROM_STANDBY,
} NV_EVENT_BLOCK_COMMIT_VIDPN_DONE_SCENARIO;
typedef struct _NV_EVENT_BLOCK_COMMIT_VIDPN_DONE {
  NV_EVENT_BLOCK_COMMIT_VIDPN_DONE_SCENARIO scenario;
} NV_EVENT_BLOCK_COMMIT_VIDPN_DONE;
typedef struct _NV_EVENT_COMMIT_VIDPN_DONE {
  NV_EVENT header;
  NV_EVENT_BLOCK_COMMIT_VIDPN_DONE data;
} NV_EVENT_COMMIT_VIDPN_DONE;
typedef struct _NV_EVENT_BLOCK_GC5_STATE_CHANGE {
  NV_GC5_STATE_CHANGE gc5StateChange;
} NV_EVENT_BLOCK_GC5_STATE_CHANGE, *PNV_EVENT_BLOCK_GC5_STATE_CHANGE;
typedef struct _NV_EVENT_GC5_STATE_CHANGE {
  NV_EVENT header;
  NV_EVENT_BLOCK_GC5_STATE_CHANGE data;
} NV_EVENT_GC5_STATE_CHANGE, *PNV_EVENT_GC5_STATE_CHANGE;
typedef struct _NV_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE {
  NV_GC6_NOTIFY_STATE_CHANGE gc6StateChange;
} NV_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE, *PNV_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE;
typedef struct _NV_EVENT_GC6_NOTIFY_STATE_CHANGE {
  NV_EVENT header;
  NV_EVENT_BLOCK_GC6_NOTIFY_STATE_CHANGE data;
} NV_EVENT_GC6_NOTIFY_STATE_CHANGE, *PNV_EVENT_GC6_NOTIFY_STATE_CHANGE;
typedef enum _NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD {
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_SET_PIXEL = 0,
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_RENDER_BEFORE_FLIP,
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_GDI_DESKTOP_REDRAW,
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_REDRAW_DESKTOP,
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_STEREO_ENABLE,
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_STEREO_FORCE_ENABLE,
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_STEREO_DISABLE,
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_STEREO_FORCE_DISABLE,
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD_NONE
} NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD;
typedef struct _NV_EVENT_BLOCK_DESKTOP_REDRAW_REQUEST {
  NvU32 redraw;
  NV_EVENT_ENUM_DESKTOP_REDRAW_REQUEST_METHOD method;
  NvU32 displayId;
  NvU32 loopAdapters;
} NV_EVENT_BLOCK_DESKTOP_REDRAW_REQUEST;
typedef struct _NV_EVENT_DESKTOP_REDRAW_REQUEST {
  NV_EVENT header;
  NV_EVENT_BLOCK_DESKTOP_REDRAW_REQUEST data;
} NV_EVENT_DESKTOP_REDRAW_REQUEST;
typedef enum _TDR_REASON {
  TDR_REASON_UNKNOWN = 0,
  TDR_REASON_BUS_RESET = 1,
  TDR_REASON_GC6_RESET = 2,
  TDR_REASON_NORMAL_RESET = 3
} TDR_REASON;
typedef struct _NV_EVENT_BLOCK_REQUEST_FORCED_TDR {
  TDR_REASON tdrReason;
} NV_EVENT_BLOCK_REQUEST_FORCED_TDR, *PNV_EVENT_BLOCK_REQUEST_FORCED_TDR;
typedef struct _NV_EVENT_REQUEST_FORCED_TDR {
  NV_EVENT header;
  NV_EVENT_BLOCK_REQUEST_FORCED_TDR data;
} NV_EVENT_REQUEST_FORCED_TDR, *PNV_EVENT_REQUEST_FORCED_TDR;
typedef void(__cdecl *NV_EVENT_CALLBACK)(NV_EVENT *Event, void *CallbackParam);
typedef struct _NV_EVENT_BLOCK_DWM_CHANGE_REQUEST {
  NvU32 disable_dwm;
} NV_EVENT_BLOCK_DWM_CHANGE_REQUEST;
typedef struct _NV_EVENT_DWM_CHANGE_REQUEST {
  NV_EVENT header;
  NV_EVENT_BLOCK_DWM_CHANGE_REQUEST data;
} NV_EVENT_DWM_CHANGE_REQUEST;
typedef struct _NV_EVENT_BLOCK_START_DISPLAY_CHANGE_HONORING_REQUEST {
  NvU32 numberOfDisplays;
} NV_EVENT_BLOCK_START_DISPLAY_CHANGE_HONORING_REQUEST;
typedef struct _NV_EVENT_START_DISPLAY_CHANGE_HONORING_REQUEST {
  NV_EVENT header;
  NV_EVENT_BLOCK_START_DISPLAY_CHANGE_HONORING_REQUEST data;
} NV_EVENT_START_DISPLAY_CHANGE_HONORING_REQUEST;
typedef struct _INJECTED_FAULT_INFO {
  NvU64 processId;
  NvU32 bufferCount;
  NvU32 injectedFaultCount;
} INJECTED_FAULT_INFO;
typedef struct _NV_EVENT_BLOCK_CHANNEL_ERROR_INFO {
  NvU32 channelId;
  NvU32 secChannelId;
  NvU32 nodeType;
  NvU32 subDeviceInstance;
  char errorString[1024];
  NvU8 isInjected;
  INJECTED_FAULT_INFO injectedFaultInfo;
} NV_EVENT_BLOCK_CHANNEL_ERROR_INFO;
typedef struct _NV_EVENT_NOTIFY_CHANNEL_ERROR {
  NV_EVENT header;
  NV_EVENT_BLOCK_CHANNEL_ERROR_INFO data;
} NV_EVENT_NOTIFY_CHANNEL_ERROR;
typedef struct _NV_EVENT_BLOCK_HDCP_STATUS {
  NvU32 displayId;
  NvU32 hdcpStatus;
} NV_EVENT_BLOCK_HDCP_STATUS;
typedef struct _NV_EVENT_HDCP_STATUS {
  NV_EVENT header;
  NV_EVENT_BLOCK_HDCP_STATUS data;
} NV_EVENT_HDCP_STATUS;
typedef enum {
  NV_HDR_SESSION_END,
  NV_HDR_SESSION_INIT,
  NV_HDR_SESSION_HDR_ON,
  NV_HDR_SESSION_HDR_OFF,
} NV_HDR_SESSION_STATE;
typedef struct _NV_EVENT_BLOCK_HDR_SESSION_CHANGE {
  NvU32 displayId;
  NV_HDR_SESSION_STATE state;
} NV_EVENT_BLOCK_HDR_SESSION_CHANGE, *PNV_EVENT_BLOCK_HDR_SESSION_CHANGE;
typedef struct _NV_EVENT_HDR_SESSION_CHANGE {
  NV_EVENT header;
  NV_EVENT_BLOCK_HDR_SESSION_CHANGE data;
} NV_EVENT_HDR_SESSION_CHANGE, *PNV_EVENT_HDR_SESSION_CHANGE;
typedef enum _NV_OS_HDR_STATE {
  NV_OS_HDR_DEFAULT,
  NV_OS_HDR_ON,
  NV_OS_HDR_OFF,
} NV_OS_HDR_STATE;
typedef struct _NV_EVENT_BLOCK_UPDATE_HDR_STATE {
  NvU32 displayId;
  NV_OS_HDR_STATE state;
} NV_EVENT_BLOCK_UPDATE_HDR_STATE, *PNV_EVENT_BLOCK_UPDATE_HDR_STATE;
typedef struct _NV_EVENT_UPDATE_HDR_STATE {
  NV_EVENT header;
  NV_EVENT_BLOCK_UPDATE_HDR_STATE data;
} NV_EVENT_UPDATE_HDR_STATE, *PNV_EVENT_UPDATE_HDR_STATE;
typedef enum _NV_EVENT_ENUM_FORCE_MODESET_REASON {
  NV_EVENT_ENUM_FORCE_MODESET_SCENARIO_DEFAULT = 0,
  NV_EVENT_ENUM_FORCE_NULL_MODESET_REASON_HDR_SESSION_TERMINATE,
  NV_EVENT_ENUM_FORCE_NULL_MODESET_REASON_VR_SLI_SESSION_TERMINATE,
  NV_EVENT_ENUM_FORCE_NULL_MODESET_REASON_MERGED_DISPLAY_DISABLED,
  NV_EVENT_ENUM_FORCE_NULL_MODESET_REASON_DDS_RELOAD
} NV_EVENT_FORCE_MODESET_REASON,
    *PNV_EVENT_FORCE_MODESET_REASON;
typedef struct _NV_EVENT_BLOCK_FORCE_MODESET {
  NV_EVENT_FORCE_MODESET_REASON modesetReason;
  NvU32 targetID;
} NV_EVENT_BLOCK_FORCE_MODESET, *PNV_EVENT_BLOCK_FORCE_MODESET;
typedef struct _NV_EVENT_FORCRE_MODESET {
  NV_EVENT header;
  NV_EVENT_BLOCK_FORCE_MODESET data;
} NV_EVENT_FORCE_MODESET, *PNV_EVENT_FORCE_MODESET;
typedef enum _NV_EVENT_DRV_STATE {
  NV_EVENT_DRV_UNLOADING = -1,
  NV_EVENT_DRV_RELOADED = 3,
} NV_EVENT_DRV_STATE,
    *PNV_EVENT_DRV_STATE;
typedef struct _NV_EVENT_BLOCK_DRIVER_STATE_CHANGED {
  NvU32 state;
  NvU32 bExit : 1;
  NvU32 reserved : 31;
} NV_EVENT_BLOCK_DRIVER_STATE_CHANGED, *PNV_EVENT_BLOCK_DRIVER_STATE_CHANGED;
typedef struct _NV_EVENT_DRIVER_STATE_CHANGED {
  NV_EVENT header;
  NV_EVENT_BLOCK_DRIVER_STATE_CHANGED data;
} NV_EVENT_DRIVER_STATE_CHANGED, *PNV_EVENT_DRIVER_STATE_CHANGED;
typedef struct _NV_EVENT_QUERY_COLOR_ACCURACY_MODE {
  NV_EVENT header;
  NvU32 ulData;
} NV_EVENT_QUERY_COLOR_ACCURACY_MODE, *PNV_EVENT_QUERY_COLOR_ACCURACY_MODE;
typedef enum _NV_EVENT_PLATFORM_POWER_MODE_CHANGE_EVENT_REASON {
  NV_EVENT_PLATFORM_POWER_MODE_CHANGE_COMPLETION = 0,
  NV_PLATFORM_POWER_MODE_CHANGE_ACPI_NOTIFICATION = 1,
} NV_EVENT_PLATFORM_POWER_MODE_CHANGE_EVENT_REASON;
typedef struct _NV_EVENT_BLOCK_PLATFORM_POWER_MODE_CHANGE {
  NvU8 platformPowerModeIndex;
  NvU8 platformPowerModeMask;
  NV_EVENT_PLATFORM_POWER_MODE_CHANGE_EVENT_REASON eventReason;
} NV_EVENT_BLOCK_PLATFORM_POWER_MODE_CHANGE, *PNV_EVENT_BLOCK_PLATFORM_POWER_MODE_CHANGE;
typedef struct _NV_EVENT_PLATFORM_POWER_MODE_CHANGE {
  NV_EVENT header;
  NV_EVENT_BLOCK_PLATFORM_POWER_MODE_CHANGE data;
} NV_EVENT_PLATFORM_POWER_MODE_CHANGE, *PNV_EVENT_PLATFORM_POWER_MODE_CHANGE;
typedef struct _NV_EVENT_RIVERMAXDISPLAY {
  NV_EVENT header;
  NV_RIVERMAXDISPLAY_EVENT_DATA data;
} NV_EVENT_RIVERMAXDISPLAY, *PNV_EVENT_RIVERMAXDISPLAY;
typedef struct _NV_EVENT_BLOCK_HW_CURSOR_STATE_CHANGE {
  NvU32 bHwCursorEnabled : 1;
  NvU32 reserved : 31;
  NvU32 vidPnSourceId;
} NV_EVENT_BLOCK_HW_CURSOR_STATE_CHANGE, *PNV_EVENT_BLOCK_HW_CURSOR_STATE_CHANGE;
typedef struct _NV_EVENT_HW_CURSOR_STATE_CHANGE {
  NV_EVENT header;
  NV_EVENT_BLOCK_HW_CURSOR_STATE_CHANGE data;
} NV_EVENT_HW_CURSOR_STATE_CHANGE, *PNV_EVENT_HW_CURSOR_STATE_CHANGE;
NVAPI_INTERFACE NvAPI_Event_RegisterForEvents(NV_EVENT_CALLBACK Callback, void *CallbackParam, NvEventHandle *phClient);
NVAPI_INTERFACE NvAPI_Event_Unregister(NvEventHandle hClient);
typedef enum {
  NVAPI_DEVICE_INFO_UNKNOWN = 0,
  NVAPI_DEVICE_INFO_HOTKEY_INIT,
  NVAPI_DEVICE_INFO_HOTKEY_UPDATE,
  NVAPI_DEVICE_INFO_DEVICE_CHANGE_UPDATE
} NVAPI_DEVICE_INFO_TYPE;
typedef struct {
  NvU32 version;
  NvU32 targetID;
  NvU32 acpiID;
  NvU32 isNonNVDisplay : 1;
  NvU32 isConnected : 1;
  NvU32 isActive : 1;
  NvU32 reserved : 29;
} NVAPI_DISPLAY_DEVICE_INFO_V1;
typedef NVAPI_DISPLAY_DEVICE_INFO_V1 NVAPI_DISPLAY_DEVICE_INFO;
#define NVAPI_DISPLAY_DEVICE_INFO_VER1 MAKE_NVAPI_VERSION(NVAPI_DISPLAY_DEVICE_INFO_V1, 1)
#define NVAPI_DISPLAY_DEVICE_INFO_VER NVAPI_DISPLAY_DEVICE_INFO_VER1
NVAPI_INTERFACE NvAPI_SYS_SetDisplayDeviceInfo(__in NvU32 displayDeviceCount,
                                               __in_ecount(displayDeviceCount)
                                                   NVAPI_DISPLAY_DEVICE_INFO *displayDeviceInfo,
                                               __in NVAPI_DEVICE_INFO_TYPE infoType);
NVAPI_INTERFACE NvAPI_Event_RegisterDriverNotification(NV_EVENT_CALLBACK Callback, void *CallbackParam,
                                                       NvEventHandle *phClient);
NVAPI_INTERFACE NvAPI_Event_UnregisterDriverNotification(NvEventHandle hClient);
NVAPI_INTERFACE NvAPI_Event_GetDriverRegisteredClients(void **pClients);
NVAPI_INTERFACE NvAPI_Event_RegisterCallback(PNV_EVENT_REGISTER_CALLBACK eventCallback, NvEventHandle *phClient);
NVAPI_INTERFACE NvAPI_Event_UnregisterCallback(NvEventHandle hClient);
NVAPI_INTERFACE NvAPI_EnumNvidiaDisplayHandle(NvU32 thisEnum, NvDisplayHandle *pNvDispHandle);
NVAPI_INTERFACE NvAPI_EnumNvidiaUnAttachedDisplayHandle(NvU32 thisEnum,
                                                        NvUnAttachedDisplayHandle *pNvUnAttachedDispHandle);
NVAPI_INTERFACE NvAPI_CreateDisplayFromUnAttachedDisplay(NvUnAttachedDisplayHandle hNvUnAttachedDisp,
                                                         NvDisplayHandle *pNvDisplay);
NVAPI_INTERFACE NvAPI_GetAssociatedNvidiaDisplayHandle(const char *szDisplayName, NvDisplayHandle *pNvDispHandle);
NVAPI_INTERFACE NvAPI_DISP_GetAssociatedUnAttachedNvidiaDisplayHandle(
    const char *szDisplayName, NvUnAttachedDisplayHandle *pNvUnAttachedDispHandle);
NVAPI_INTERFACE NvAPI_GetAssociatedNvidiaDisplayName(NvDisplayHandle NvDispHandle, NvAPI_ShortString szDisplayName);
NVAPI_INTERFACE NvAPI_GetUnAttachedAssociatedDisplayName(NvUnAttachedDisplayHandle hNvUnAttachedDisp,
                                                         NvAPI_ShortString szDisplayName);
NVAPI_INTERFACE NvAPI_EnableHWCursor(NvDisplayHandle hNvDisplay);
NVAPI_INTERFACE NvAPI_DisableHWCursor(NvDisplayHandle hNvDisplay);
NVAPI_INTERFACE NvAPI_GetVBlankCounter(NvDisplayHandle hNvDisplay, NvU32 *pCounter);
NVAPI_INTERFACE NvAPI_SetRefreshRateOverride(NvDisplayHandle hNvDisplay, NvU32 outputsMask, float refreshRate,
                                             NvU32 bSetDeferred);
NVAPI_INTERFACE NvAPI_GetAssociatedDisplayOutputId(NvDisplayHandle hNvDisplay, NvU32 *pOutputId);
NVAPI_INTERFACE NvAPI_GetAssociatedDisplayOutputIdEx(NvDisplayHandle hNvDisplay, NvU32 *pOutputId, NvU32 *pGpuId);
typedef struct _NV_DISPLAY_PORT_INFO_V1 {
  NvU32 version;
  NvU32 dpcd_ver;
  NV_DP_LINK_RATE maxLinkRate;
  NV_DP_LANE_COUNT maxLaneCount;
  NV_DP_LINK_RATE curLinkRate;
  NV_DP_LANE_COUNT curLaneCount;
  NV_DP_COLOR_FORMAT colorFormat;
  NV_DP_DYNAMIC_RANGE dynamicRange;
  NV_DP_COLORIMETRY colorimetry;
  NV_DP_BPC bpc;
  NvU32 isDp : 1;
  NvU32 isInternalDp : 1;
  NvU32 isColorCtrlSupported : 1;
  NvU32 is6BPCSupported : 1;
  NvU32 is8BPCSupported : 1;
  NvU32 is10BPCSupported : 1;
  NvU32 is12BPCSupported : 1;
  NvU32 is16BPCSupported : 1;
  NvU32 isYCrCb420Supported : 1;
  NvU32 isYCrCb422Supported : 1;
  NvU32 isYCrCb444Supported : 1;
  NvU32 isRgb444SupportedOnCurrentMode : 1;
  NvU32 isYCbCr444SupportedOnCurrentMode : 1;
  NvU32 isYCbCr422SupportedOnCurrentMode : 1;
  NvU32 isYCbCr420SupportedOnCurrentMode : 1;
  NvU32 is6BPCSupportedOnCurrentMode : 1;
  NvU32 is8BPCSupportedOnCurrentMode : 1;
  NvU32 is10BPCSupportedOnCurrentMode : 1;
  NvU32 is12BPCSupportedOnCurrentMode : 1;
  NvU32 is16BPCSupportedOnCurrentMode : 1;
  NvU32 isMonxvYCC601Capable : 1;
  NvU32 isMonxvYCC709Capable : 1;
  NvU32 isMonsYCC601Capable : 1;
  NvU32 isMonAdobeYCC601Capable : 1;
  NvU32 isMonAdobeRGBCapable : 1;
  NvU32 isMonBT2020RGBCapable : 1;
  NvU32 isMonBT2020YCCCapable : 1;
  NvU32 isMonBT2020cYCCCapable : 1;
  NvU32 reserved : 4;
} NV_DISPLAY_PORT_INFO_V1;
typedef NV_DISPLAY_PORT_INFO_V1 NV_DISPLAY_PORT_INFO;
#define NV_DISPLAY_PORT_INFO_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_INFO, 1)
#define NV_DISPLAY_PORT_INFO_VER2 MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_INFO, 2)
#define NV_DISPLAY_PORT_INFO_VER NV_DISPLAY_PORT_INFO_VER2
NVAPI_INTERFACE NvAPI_GetDisplayPortInfo(__in_opt NvDisplayHandle hNvDisplay, __in NvU32 outputId,
                                         __inout NV_DISPLAY_PORT_INFO *pInfo);
typedef struct {
  NvU32 version;
  NV_DP_LINK_RATE linkRate;
  NV_DP_LANE_COUNT laneCount;
  NV_DP_COLOR_FORMAT colorFormat;
  NV_DP_DYNAMIC_RANGE dynamicRange;
  NV_DP_COLORIMETRY colorimetry;
  NV_DP_BPC bpc;
  NvU32 isHPD : 1;
  NvU32 isSetDeferred : 1;
  NvU32 isChromaLpfOff : 1;
  NvU32 isDitherOff : 1;
  NvU32 testLinkTrain : 1;
  NvU32 testColorChange : 1;
} NV_DISPLAY_PORT_CONFIG;
#define NV_DISPLAY_PORT_CONFIG_VER MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_CONFIG, 2)
#define NV_DISPLAY_PORT_CONFIG_VER_1 MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_CONFIG, 1)
#define NV_DISPLAY_PORT_CONFIG_VER_2 MAKE_NVAPI_VERSION(NV_DISPLAY_PORT_CONFIG, 2)
NVAPI_INTERFACE NvAPI_SetDisplayPort(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_PORT_CONFIG *pCfg);
typedef struct _NV_HDMI_SUPPORT_INFO_V1 {
  NvU32 version;
  NvU32 isGpuHDMICapable : 1;
  NvU32 isMonUnderscanCapable : 1;
  NvU32 isMonBasicAudioCapable : 1;
  NvU32 isMonYCbCr444Capable : 1;
  NvU32 isMonYCbCr422Capable : 1;
  NvU32 isMonxvYCC601Capable : 1;
  NvU32 isMonxvYCC709Capable : 1;
  NvU32 isMonHDMI : 1;
  NvU32 reserved : 24;
  NvU32 EDID861ExtRev;
} NV_HDMI_SUPPORT_INFO_V1;
typedef struct _NV_HDMI_SUPPORT_INFO_V2 {
  NvU32 version;
  NvU32 isGpuHDMICapable : 1;
  NvU32 isMonUnderscanCapable : 1;
  NvU32 isMonBasicAudioCapable : 1;
  NvU32 isMonYCbCr444Capable : 1;
  NvU32 isMonYCbCr422Capable : 1;
  NvU32 isMonxvYCC601Capable : 1;
  NvU32 isMonxvYCC709Capable : 1;
  NvU32 isMonHDMI : 1;
  NvU32 isMonsYCC601Capable : 1;
  NvU32 isMonAdobeYCC601Capable : 1;
  NvU32 isMonAdobeRGBCapable : 1;
  NvU32 reserved : 21;
  NvU32 EDID861ExtRev;
} NV_HDMI_SUPPORT_INFO_V2;
#define NV_HDMI_SUPPORT_INFO_VER1 MAKE_NVAPI_VERSION(NV_HDMI_SUPPORT_INFO_V1, 1)
#define NV_HDMI_SUPPORT_INFO_VER2 MAKE_NVAPI_VERSION(NV_HDMI_SUPPORT_INFO_V2, 2)
typedef struct _NV_HDMI_SUPPORT_INFO_V3 {
  NvU32 version;
  NvU32 isGpuHDMICapable : 1;
  NvU32 isMonUnderscanCapable : 1;
  NvU32 isMonBasicAudioCapable : 1;
  NvU32 isMonYCbCr444Capable : 1;
  NvU32 isMonYCbCr422Capable : 1;
  NvU32 isMonxvYCC601Capable : 1;
  NvU32 isMonxvYCC709Capable : 1;
  NvU32 isMonHDMI : 1;
  NvU32 isMonRgb444Capable : 1;
  NvU32 isMonYCbCr420Capable : 1;
  NvU32 isRgb444SupportedOnCurrentMode : 1;
  NvU32 isYCbCr444SupportedOnCurrentMode : 1;
  NvU32 isYCbCr422SupportedOnCurrentMode : 1;
  NvU32 isYCbCr420SupportedOnCurrentMode : 1;
  NvU32 isMonsYCC601Capable : 1;
  NvU32 isMonAdobeYCC601Capable : 1;
  NvU32 isMonAdobeRGBCapable : 1;
  NvU32 isMonBT2020RGBCapable : 1;
  NvU32 isMonBT2020YCCCapable : 1;
  NvU32 isMonBT2020cYCCCapable : 1;
  NvU32 is8BPCSupported : 1;
  NvU32 is10BPCSupported : 1;
  NvU32 is12BPCSupported : 1;
  NvU32 is16BPCSupported : 1;
  NvU32 is8BPCSupportedOnCurrentMode : 1;
  NvU32 is10BPCSupportedOnCurrentMode : 1;
  NvU32 is12BPCSupportedOnCurrentMode : 1;
  NvU32 is16BPCSupportedOnCurrentMode : 1;
  NvU32 isHdrGammaSupported : 1;
  NvU32 isST2084EotfSupported : 1;
  NvU32 reserved : 2;
  NvU32 EDID861ExtRev;
} NV_HDMI_SUPPORT_INFO_V3;
#define NV_HDMI_SUPPORT_INFO_VER3 MAKE_NVAPI_VERSION(NV_HDMI_SUPPORT_INFO_V3, 3)
typedef enum _NV_HDMI_FRL_RATE {
  NV_HDMI_FRL_RATE_NONE,
  NV_HDMI_FRL_RATE_3LANES_3GBPS,
  NV_HDMI_FRL_RATE_3LANES_6GBPS,
  NV_HDMI_FRL_RATE_4LANES_6GBPS,
  NV_HDMI_FRL_RATE_4LANES_8GBPS,
  NV_HDMI_FRL_RATE_4LANES_10GBPS,
  NV_HDMI_FRL_RATE_4LANES_12GBPS
} NV_HDMI_FRL_RATE;
typedef struct _NV_HDMI_SUPPORT_INFO_V4 {
  NvU32 version;
  NvU32 isGpuHDMICapable : 1;
  NvU32 isMonUnderscanCapable : 1;
  NvU32 isMonBasicAudioCapable : 1;
  NvU32 isMonYCbCr444Capable : 1;
  NvU32 isMonYCbCr422Capable : 1;
  NvU32 isMonxvYCC601Capable : 1;
  NvU32 isMonxvYCC709Capable : 1;
  NvU32 isMonHDMI : 1;
  NvU32 isMonRgb444Capable : 1;
  NvU32 isMonYCbCr420Capable : 1;
  NvU32 isRgb444SupportedOnCurrentMode : 1;
  NvU32 isYCbCr444SupportedOnCurrentMode : 1;
  NvU32 isYCbCr422SupportedOnCurrentMode : 1;
  NvU32 isYCbCr420SupportedOnCurrentMode : 1;
  NvU32 isMonsYCC601Capable : 1;
  NvU32 isMonAdobeYCC601Capable : 1;
  NvU32 isMonAdobeRGBCapable : 1;
  NvU32 isMonBT2020RGBCapable : 1;
  NvU32 isMonBT2020YCCCapable : 1;
  NvU32 isMonBT2020cYCCCapable : 1;
  NvU32 is8BPCSupported : 1;
  NvU32 is10BPCSupported : 1;
  NvU32 is12BPCSupported : 1;
  NvU32 is16BPCSupported : 1;
  NvU32 is8BPCSupportedOnCurrentMode : 1;
  NvU32 is10BPCSupportedOnCurrentMode : 1;
  NvU32 is12BPCSupportedOnCurrentMode : 1;
  NvU32 is16BPCSupportedOnCurrentMode : 1;
  NvU32 isHdrGammaSupported : 1;
  NvU32 isST2084EotfSupported : 1;
  NvU32 isGpuFrlCapable : 1;
  NvU32 reserved : 1;
  NvU32 EDID861ExtRev;
  NV_HDMI_FRL_RATE maxMonFrlRate;
  NV_HDMI_FRL_RATE maxMonAsessedFrlRate;
  NV_HDMI_FRL_RATE maxMonDscFrlRate;
  NV_HDMI_FRL_RATE maxGpuFrlRate;
} NV_HDMI_SUPPORT_INFO_V4;
#define NV_HDMI_SUPPORT_INFO_VER4 MAKE_NVAPI_VERSION(NV_HDMI_SUPPORT_INFO_V4, 4)
typedef NV_HDMI_SUPPORT_INFO_V4 NV_HDMI_SUPPORT_INFO;
#define NV_HDMI_SUPPORT_INFO_VER NV_HDMI_SUPPORT_INFO_VER4
#ifndef NV_HDMI_SUPPORT_INFO_VER
typedef NV_HDMI_SUPPORT_INFO_V2 NV_HDMI_SUPPORT_INFO;
#define NV_HDMI_SUPPORT_INFO_VER NV_HDMI_SUPPORT_INFO_VER2
#endif
NVAPI_INTERFACE NvAPI_GetHDMISupportInfo(__in_opt NvDisplayHandle hNvDisplay, __in NvU32 outputId,
                                         __inout NV_HDMI_SUPPORT_INFO *pInfo);
#define NVAPI_HDMI_STEREO_MAX_MODES 256
typedef enum {
  NV_HDMI_STEREO_3D_NONE = 0x00,
  NV_STEREO_NVISION,
  NV_HDMI_STEREO_3D_FRAME_PACKING,
  NV_HDMI_STEREO_3D_FRAME_PACKING_INT,
  NV_HDMI_STEREO_3D_LINE_ALT,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_FULL,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_ODD_LEFT_ODD_RIGHT,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_ODD_LEFT_EVEN_RIGHT,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_EVEN_LEFT_ODD_RIGHT,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL_EVEN_LEFT_EVEN_RIGHT,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINCUX_ODD_LEFT_ODD_RIGHT,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINCUX_ODD_LEFT_EVEN_RIGHT,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINCUX_EVEN_LEFT_ODD_RIGHT,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_QUINCUX_EVEN_LEFT_EVEN_RIGHT,
  NV_HDMI_STEREO_3D_FIELD_ALT,
  NV_HDMI_STEREO_3D_L_DEPTH,
  NV_HDMI_STEREO_3D_L_DEPTH_GFX,
  NV_HDMI_STEREO_3D_TOP_BOTTOM,
  NV_HDMI_STEREO_3D_SIDE_BY_SIDE_HALF_HORIZONTAIL,
  NV_HDMI_STEREO_3D_ANY = 0xff,
} NV_HDMI_STEREO_TYPE;
typedef struct {
  NvU16 HVisible;
  NvU16 VVisible;
  NvU16 HActive;
  NvU16 VActive;
  NvU16 VActiveSpace[2];
  NvU16 rr;
  NV_HDMI_STEREO_TYPE stereoType;
} NV_HDMI_STEREO_MODE;
typedef struct {
  NvU32 version;
  NvU32 displayId;
  NvU16 enumIndex;
  NvU16 count;
  NvU32 width;
  NvU32 height;
  NvU32 refreshRate;
  NvU32 bMatchDimension : 1;
  NvU32 bMatchRR : 1;
  NvU32 bPassThroughMode : 1;
  NvU32 reserved : 29;
  NvU16 numberOfModes;
  NV_HDMI_STEREO_MODE modeList[NVAPI_HDMI_STEREO_MAX_MODES];
} NV_HDMI_STEREO_MODES_LIST_V1;
typedef NV_HDMI_STEREO_MODES_LIST_V1 NV_HDMI_STEREO_MODES_LIST;
#define NV_HDMI_STEREO_MODES_LIST_VER1 MAKE_NVAPI_VERSION(NV_HDMI_STEREO_MODES_LIST_V1, 1)
#define NV_HDMI_STEREO_MODES_LIST_VER NV_HDMI_STEREO_MODES_LIST_VER1
NVAPI_INTERFACE NvAPI_DISP_EnumHDMIStereoModes(NV_HDMI_STEREO_MODES_LIST *pHDMIStereoModes);
typedef struct {
  NvU32 version;
  NV_HDMI_STEREO_TYPE type;
  NvU32 reserved;
} NV_HDMI_STEREO_SETTINGS_V1;
typedef NV_HDMI_STEREO_SETTINGS_V1 NV_HDMI_STEREO_SETTINGS;
#define NV_HDMI_STEREO_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_HDMI_STEREO_SETTINGS_V1, 1)
#define NV_HDMI_STEREO_SETTINGS_VER NV_HDMI_STEREO_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_DISP_SetHDMIStereoSettings(NvU32 displayId, NV_HDMI_STEREO_SETTINGS *hdmiStereoSettings);
NVAPI_INTERFACE NvAPI_DISP_GetHDMIStereoSettings(NvU32 displayId, NV_HDMI_STEREO_SETTINGS *hdmiStereoSettings);
typedef enum _NV_INFOFRAME_TYPE {
  NV_INFOFRAME_TYPE_AVI = 2,
  NV_INFOFRAME_TYPE_SPD = 3,
  NV_INFOFRAME_TYPE_AUDIO = 4,
  NV_INFOFRAME_TYPE_MS = 5,
} NV_INFOFRAME_TYPE;
typedef struct {
  NvU8 type;
  NvU8 version;
  NvU8 length;
} NV_INFOFRAME_HEADER;
typedef struct {
  NvU8 channelCount : 3;
  NvU8 rsvd_bits_byte1 : 1;
  NvU8 codingType : 4;
  NvU8 sampleSize : 2;
  NvU8 sampleRate : 3;
  NvU8 rsvd_bits_byte2 : 3;
  NvU8 codingExtensionType : 5;
  NvU8 rsvd_bits_byte3 : 3;
  NvU8 speakerPlacement;
  NvU8 lfePlaybackLevel : 2;
  NvU8 rsvd_bits_byte5 : 1;
  NvU8 levelShift : 4;
  NvU8 downmixInhibit : 1;
  NvU8 rsvd_byte6;
  NvU8 rsvd_byte7;
  NvU8 rsvd_byte8;
  NvU8 rsvd_byte9;
  NvU8 rsvd_byte10;
} NV_AUDIO_INFOFRAME;
typedef struct {
  NvU8 scanInfo : 2;
  NvU8 barInfo : 2;
  NvU8 activeFormatInfoPresent : 1;
  NvU8 colorSpace : 2;
  NvU8 rsvd_bits_byte1 : 1;
  NvU8 activeFormatAspectRatio : 4;
  NvU8 picAspectRatio : 2;
  NvU8 colorimetry : 2;
  NvU8 nonuniformScaling : 2;
  NvU8 rgbQuantizationRange : 2;
  NvU8 extendedColorimetry : 3;
  NvU8 itContent : 1;
  NvU8 vic : 7;
  NvU8 rsvd_bits_byte4 : 1;
  NvU8 pixelRepeat : 4;
  NvU8 contentTypes : 2;
  NvU8 yccQuantizationRange : 2;
  NvU8 topBarLow;
  NvU8 topBarHigh;
  NvU8 bottomBarLow;
  NvU8 bottomBarHigh;
  NvU8 leftBarLow;
  NvU8 leftBarHigh;
  NvU8 rightBarLow;
  NvU8 rightBarHigh;
} NV_VIDEO_INFOFRAME;
typedef struct {
  NV_INFOFRAME_HEADER header;
  union {
    NV_AUDIO_INFOFRAME audio;
    NV_VIDEO_INFOFRAME video;
  } u;
} NV_INFOFRAME;
NVAPI_INTERFACE NvAPI_GetInfoFrame(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId, __in NV_INFOFRAME_TYPE type,
                                   __out NV_INFOFRAME *pInfoFrame);
NVAPI_INTERFACE NvAPI_SetInfoFrame(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId, __in NV_INFOFRAME_TYPE type,
                                   __in NV_INFOFRAME *pInfoFrame);
typedef struct _NV_INFOFRAME_STATE {
  NvU32 bDisabled : 1;
  NvU32 bDriverCtrl : 1;
  NvU32 reserved : 30;
} NV_INFOFRAME_STATE;
NVAPI_INTERFACE NvAPI_SetInfoFrameState(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId,
                                        __in NV_INFOFRAME_TYPE type, __in NV_INFOFRAME_STATE *pState);
NVAPI_INTERFACE NvAPI_GetInfoFrameState(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId,
                                        __in NV_INFOFRAME_TYPE type, __out NV_INFOFRAME_STATE *pState);
typedef struct _NV_INFOFRAME_STATE_PVT {
  NV_INFOFRAME_STATE state;
  NvU32 bInHDMIBlackList : 1;
  NvU32 reserved : 31;
} NV_INFOFRAME_STATE_PVT;
NVAPI_INTERFACE NvAPI_GetInfoFrameStatePvt(__in NvDisplayHandle hNvDisplay, __in NvU32 displayId,
                                           __in NV_INFOFRAME_TYPE type, __out NV_INFOFRAME_STATE_PVT *pState);
typedef enum {
  NV_INFOFRAME_CMD_GET_DEFAULT = 0,
  NV_INFOFRAME_CMD_RESET,
  NV_INFOFRAME_CMD_GET,
  NV_INFOFRAME_CMD_SET,
  NV_INFOFRAME_CMD_GET_OVERRIDE,
  NV_INFOFRAME_CMD_SET_OVERRIDE,
  NV_INFOFRAME_CMD_GET_PROPERTY,
  NV_INFOFRAME_CMD_SET_PROPERTY,
} NV_INFOFRAME_CMD;
typedef enum {
  NV_INFOFRAME_PROPERTY_MODE_AUTO = 0,
  NV_INFOFRAME_PROPERTY_MODE_ENABLE,
  NV_INFOFRAME_PROPERTY_MODE_DISABLE,
  NV_INFOFRAME_PROPERTY_MODE_ALLOW_OVERRIDE,
} NV_INFOFRAME_PROPERTY_MODE;
typedef enum {
  NV_INFOFRAME_PROPERTY_BLACKLIST_FALSE = 0,
  NV_INFOFRAME_PROPERTY_BLACKLIST_TRUE,
} NV_INFOFRAME_PROPERTY_BLACKLIST;
typedef struct {
  NvU32 mode : 4;
  NvU32 blackList : 2;
  NvU32 reserved : 10;
  NvU32 version : 8;
  NvU32 length : 8;
} NV_INFOFRAME_PROPERTY;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_NODATA = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_OVERSCAN,
  NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_UNDERSCAN,
  NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_FUTURE,
  NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_SCANINFO;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_NOT_PRESENT = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_VERTICAL_PRESENT,
  NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_HORIZONTAL_PRESENT,
  NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_BOTH_PRESENT,
  NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_BARDATA;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_AFI_ABSENT = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_AFI_PRESENT,
  NV_INFOFRAME_FIELD_VALUE_AVI_AFI_AUTO = 3
} NV_INFOFRAME_FIELD_VALUE_AVI_ACTIVEFORMATINFO;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_RGB = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr422,
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_YCbCr444,
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_FUTURE,
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_COLORFORMAT;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_F17_FALSE = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_F17_TRUE,
  NV_INFOFRAME_FIELD_VALUE_AVI_F17_AUTO = 3
} NV_INFOFRAME_FIELD_VALUE_AVI_F17;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_NO_AFD = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE01,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE02,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE03,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_LETTERBOX_GT16x9,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE05,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE06,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE07,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_EQUAL_CODEDFRAME = 8,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_4x3,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_16x9,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_CENTER_14x9,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_RESERVE12,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_4x3_ON_14x9,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_14x9,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_16x9_ON_4x3,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION_AUTO = 31,
} NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOACTIVEPORTION;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_NO_DATA = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_4x3,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_16x9,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_FUTURE,
  NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_ASPECTRATIOCODEDFRAME;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_NO_DATA = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_SMPTE_170M,
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_ITUR_BT709,
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_USE_EXTENDED_COLORIMETRY,
  NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_COLORIMETRY;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_NO_DATA = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_HORIZONTAL,
  NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_VERTICAL,
  NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_BOTH,
  NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_NONUNIFORMPICTURESCALING;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_DEFAULT = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_LIMITED_RANGE,
  NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_FULL_RANGE,
  NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_RESERVED,
  NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_RGBQUANTIZATION;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC601 = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_XVYCC709,
  NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_SYCC601,
  NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBEYCC601,
  NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_ADOBERGB,
  NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED05,
  NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED06,
  NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_RESERVED07,
  NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY_AUTO = 15
} NV_INFOFRAME_FIELD_VALUE_AVI_EXTENDEDCOLORIMETRY;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_ITC_VIDEO_CONTENT = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_ITC_ITCONTENT,
  NV_INFOFRAME_FIELD_VALUE_AVI_ITC_AUTO = 3
} NV_INFOFRAME_FIELD_VALUE_AVI_ITC;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_NONE = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X02,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X03,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X04,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X05,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X06,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X07,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X08,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X09,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_X10,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED10,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED11,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED12,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED13,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED14,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_RESERVED15,
  NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION_AUTO = 31
} NV_INFOFRAME_FIELD_VALUE_AVI_PIXELREPETITION;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GRAPHICS = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_PHOTO,
  NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_CINEMA,
  NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_GAME,
  NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_CONTENTTYPE;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_LIMITED_RANGE = 0,
  NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_FULL_RANGE,
  NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED02,
  NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_RESERVED03,
  NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AVI_YCCQUANTIZATION;
typedef struct {
  NvU32 vic : 8;
  NvU32 pixelRepeat : 5;
  NvU32 colorSpace : 3;
  NvU32 colorimetry : 3;
  NvU32 extendedColorimetry : 4;
  NvU32 rgbQuantizationRange : 3;
  NvU32 yccQuantizationRange : 3;
  NvU32 itContent : 2;
  NvU32 contentTypes : 3;
  NvU32 scanInfo : 3;
  NvU32 activeFormatInfoPresent : 2;
  NvU32 activeFormatAspectRatio : 5;
  NvU32 picAspectRatio : 3;
  NvU32 nonuniformScaling : 3;
  NvU32 barInfo : 3;
  NvU32 top_bar : 17;
  NvU32 bottom_bar : 17;
  NvU32 left_bar : 17;
  NvU32 right_bar : 17;
  NvU32 Future17 : 2;
  NvU32 Future47 : 2;
} NV_INFOFRAME_VIDEO;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_IN_HEADER = 0,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_2,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_3,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_4,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_5,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_6,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_7,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_8,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT_AUTO = 15
} NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELCOUNT;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_IN_HEADER = 0,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_PCM,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AC3,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG1,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MP3,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MPEG2,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AACLC,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTS,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_ATRAC,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DSD,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_EAC3,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DTSHD,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_MLP,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_DST,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_WMAPRO,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_USE_CODING_EXTENSION_TYPE,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE_AUTO = 31
} NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGTYPE;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_IN_HEADER = 0,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_16BITS,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_20BITS,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_24BITS,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLESIZE;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_IN_HEADER = 0,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_32000HZ,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_44100HZ,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_48000HZ,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_88200KHZ,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_96000KHZ,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_176400KHZ,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_192000KHZ,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY_AUTO = 15
} NV_INFOFRAME_FIELD_VALUE_AUDIO_SAMPLEFREQUENCY;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_USE_CODING_TYPE = 0,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAAC,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_HEAACV2,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_MPEGSURROUND,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE04,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE05,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE06,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE07,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE08,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE09,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE10,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE11,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE12,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE13,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE14,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE15,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE16,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE17,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE18,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE19,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE20,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE21,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE22,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE23,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE24,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE25,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE26,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE27,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE28,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE29,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE30,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_RESERVE31,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE_AUTO = 63
} NV_INFOFRAME_FIELD_VALUE_AUDIO_CODINGEXTENSIONTYPE;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_X_FR_FL = 0,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_X_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_X_RC_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_X_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_RC_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_RRC_RLC_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_X_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_X_RC_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRC_FLC_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_X_FCH_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_X_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_X_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_RC_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FCH_RC_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_TC_FCH_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRH_FLH_RR_RL_FC_LFE_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_X_FR_FL,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_FRW_FLW_RR_RL_FC_LFE_FR_FL = 0X31,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION_AUTO = 0x1FF
} NV_INFOFRAME_FIELD_VALUE_AUDIO_CHANNELALLOCATION;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_NO_DATA = 0,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_0DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_PLUS10DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_RESERVED03,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL_AUTO = 7
} NV_INFOFRAME_FIELD_VALUE_AUDIO_LFEPLAYBACKLEVEL;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_0DB = 0,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_1DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_2DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_3DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_4DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_5DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_6DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_7DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_8DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_9DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_10DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_11DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_12DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_13DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_14DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_15DB,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES_AUTO = 31
} NV_INFOFRAME_FIELD_VALUE_AUDIO_LEVELSHIFTVALUES;
typedef enum {
  NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PERMITTED = 0,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_PROHIBITED,
  NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX_AUTO = 3
} NV_INFOFRAME_FIELD_VALUE_AUDIO_DOWNMIX;
typedef struct {
  NvU32 codingType : 5;
  NvU32 codingExtensionType : 6;
  NvU32 sampleSize : 3;
  NvU32 sampleRate : 4;
  NvU32 channelCount : 4;
  NvU32 speakerPlacement : 9;
  NvU32 downmixInhibit : 2;
  NvU32 lfePlaybackLevel : 3;
  NvU32 levelShift : 5;
  NvU32 Future12 : 2;
  NvU32 Future2x : 4;
  NvU32 Future3x : 4;
  NvU32 Future52 : 2;
  NvU32 Future6 : 9;
  NvU32 Future7 : 9;
  NvU32 Future8 : 9;
  NvU32 Future9 : 9;
  NvU32 Future10 : 9;
} NV_INFOFRAME_AUDIO;
typedef struct {
  NvU32 version;
  NvU16 size;
  NvU8 cmd;
  NvU8 type;
  union {
    NV_INFOFRAME_PROPERTY property;
    NV_INFOFRAME_AUDIO audio;
    NV_INFOFRAME_VIDEO video;
  } infoframe;
} NV_INFOFRAME_DATA;
#define NV_INFOFRAME_DATA_VER MAKE_NVAPI_VERSION(NV_INFOFRAME_DATA, 1)
NVAPI_INTERFACE NvAPI_Disp_InfoFrameControl(__in NvU32 displayId, __inout NV_INFOFRAME_DATA *pInfoframeData);
typedef enum {
  NV_COLOR_CMD_GET = 1,
  NV_COLOR_CMD_SET,
  NV_COLOR_CMD_IS_SUPPORTED_COLOR,
  NV_COLOR_CMD_GET_DEFAULT
} NV_COLOR_CMD;
typedef enum {
  NV_COLOR_FORMAT_RGB = 0,
  NV_COLOR_FORMAT_YUV422,
  NV_COLOR_FORMAT_YUV444,
  NV_COLOR_FORMAT_YUV420,
  NV_COLOR_FORMAT_DEFAULT = 0xFE,
  NV_COLOR_FORMAT_AUTO = 0xFF
} NV_COLOR_FORMAT;
typedef enum {
  NV_COLOR_COLORIMETRY_RGB = 0,
  NV_COLOR_COLORIMETRY_YCC601,
  NV_COLOR_COLORIMETRY_YCC709,
  NV_COLOR_COLORIMETRY_XVYCC601,
  NV_COLOR_COLORIMETRY_XVYCC709,
  NV_COLOR_COLORIMETRY_SYCC601,
  NV_COLOR_COLORIMETRY_ADOBEYCC601,
  NV_COLOR_COLORIMETRY_ADOBERGB,
  NV_COLOR_COLORIMETRY_BT2020RGB,
  NV_COLOR_COLORIMETRY_BT2020YCC,
  NV_COLOR_COLORIMETRY_BT2020cYCC,
  NV_COLOR_COLORIMETRY_DEFAULT = 0xFE,
  NV_COLOR_COLORIMETRY_AUTO = 0xFF
} NV_COLOR_COLORIMETRY;
typedef enum _NV_DYNAMIC_RANGE {
  NV_DYNAMIC_RANGE_VESA = 0x0,
  NV_DYNAMIC_RANGE_CEA = 0x1,
  NV_DYNAMIC_RANGE_AUTO = 0xFF
} NV_DYNAMIC_RANGE;
typedef enum _NV_BPC {
  NV_BPC_DEFAULT = 0,
  NV_BPC_6 = 1,
  NV_BPC_8 = 2,
  NV_BPC_10 = 3,
  NV_BPC_12 = 4,
  NV_BPC_16 = 5,
} NV_BPC;
typedef enum _NV_COLOR_SELECTION_POLICY {
  NV_COLOR_SELECTION_POLICY_USER = 0,
  NV_COLOR_SELECTION_POLICY_BEST_QUALITY = 1,
  NV_COLOR_SELECTION_POLICY_DEFAULT = NV_COLOR_SELECTION_POLICY_BEST_QUALITY,
  NV_COLOR_SELECTION_POLICY_UNKNOWN = 0xFF,
} NV_COLOR_SELECTION_POLICY;
typedef enum _NV_DESKTOP_COLOR_DEPTH {
  NV_DESKTOP_COLOR_DEPTH_DEFAULT = 0x0,
  NV_DESKTOP_COLOR_DEPTH_8BPC = 0x1,
  NV_DESKTOP_COLOR_DEPTH_10BPC = 0x2,
  NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT = 0x3,
  NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT_WCG = 0x4,
  NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT_HDR = 0x5,
  NV_DESKTOP_COLOR_DEPTH_MAX_VALUE = NV_DESKTOP_COLOR_DEPTH_16BPC_FLOAT_HDR,
} NV_DESKTOP_COLOR_DEPTH;
typedef struct _NV_COLOR_DATA_V1 {
  NvU32 version;
  NvU16 size;
  NvU8 cmd;
  struct {
    NvU8 colorFormat;
    NvU8 colorimetry;
  } data;
} NV_COLOR_DATA_V1;
typedef struct _NV_COLOR_DATA_V2 {
  NvU32 version;
  NvU16 size;
  NvU8 cmd;
  struct {
    NvU8 colorFormat;
    NvU8 colorimetry;
    NvU8 dynamicRange;
  } data;
} NV_COLOR_DATA_V2;
typedef struct _NV_COLOR_DATA_V3 {
  NvU32 version;
  NvU16 size;
  NvU8 cmd;
  struct {
    NvU8 colorFormat;
    NvU8 colorimetry;
    NvU8 dynamicRange;
    NV_BPC bpc;
  } data;
} NV_COLOR_DATA_V3;
typedef struct _NV_COLOR_DATA_V4 {
  NvU32 version;
  NvU16 size;
  NvU8 cmd;
  struct {
    NvU8 colorFormat;
    NvU8 colorimetry;
    NvU8 dynamicRange;
    NV_BPC bpc;
    NV_COLOR_SELECTION_POLICY colorSelectionPolicy;
  } data;
} NV_COLOR_DATA_V4;
typedef struct _NV_COLOR_DATA_V5 {
  NvU32 version;
  NvU16 size;
  NvU8 cmd;
  struct {
    NvU8 colorFormat;
    NvU8 colorimetry;
    NvU8 dynamicRange;
    NV_BPC bpc;
    NV_COLOR_SELECTION_POLICY colorSelectionPolicy;
    NV_DESKTOP_COLOR_DEPTH depth;
  } data;
} NV_COLOR_DATA_V5;
typedef NV_COLOR_DATA_V5 NV_COLOR_DATA;
#define NV_COLOR_DATA_VER1 MAKE_NVAPI_VERSION(NV_COLOR_DATA_V1, 1)
#define NV_COLOR_DATA_VER2 MAKE_NVAPI_VERSION(NV_COLOR_DATA_V2, 2)
#define NV_COLOR_DATA_VER3 MAKE_NVAPI_VERSION(NV_COLOR_DATA_V3, 3)
#define NV_COLOR_DATA_VER4 MAKE_NVAPI_VERSION(NV_COLOR_DATA_V4, 4)
#define NV_COLOR_DATA_VER5 MAKE_NVAPI_VERSION(NV_COLOR_DATA_V5, 5)
#define NV_COLOR_DATA_VER NV_COLOR_DATA_VER5
NVAPI_INTERFACE NvAPI_Disp_ColorControl(NvU32 displayId, NV_COLOR_DATA *pColorData);
typedef struct _NV_COLOR_COMBINATION_DATA_V1 {
  NvU32 version;
  NV_COLOR_FORMAT colorFormat;
  NV_COLOR_COLORIMETRY colorimetry;
  NV_DYNAMIC_RANGE dynamicRange;
  NV_BPC bpc;
  NvU32 isSupported : 1;
  NvU32 reserved : 31;
} NV_COLOR_COMBINATION_DATA_V1;
typedef struct _NV_COLOR_COMBINATION_DATA_V2 {
  NvU32 version;
  NV_COLOR_FORMAT colorFormat;
  NV_COLOR_COLORIMETRY colorimetry;
  NV_DYNAMIC_RANGE dynamicRange;
  NV_BPC bpc;
  NvU32 isSupported : 1;
  NvU32 reserved : 31;
  NV_DESKTOP_COLOR_DEPTH depth;
} NV_COLOR_COMBINATION_DATA_V2;
typedef NV_COLOR_COMBINATION_DATA_V2 NV_COLOR_COMBINATION_DATA;
#define NV_COLOR_COMBINATION_DATA_VER1 MAKE_NVAPI_VERSION(NV_COLOR_COMBINATION_DATA_V1, 1)
#define NV_COLOR_COMBINATION_DATA_VER2 MAKE_NVAPI_VERSION(NV_COLOR_COMBINATION_DATA_V2, 2)
#define NV_COLOR_COMBINATION_DATA_VER NV_COLOR_COMBINATION_DATA_VER2
NVAPI_INTERFACE NvAPI_Disp_GetColorSupportedCombinations(__in NvU32 displayId, __in NvU32 combinationsCount,
                                                         __inout NV_COLOR_COMBINATION_DATA *pColorData);
typedef enum { NV_STATIC_METADATA_TYPE_1 = 0 } NV_STATIC_METADATA_DESCRIPTOR_ID;
typedef struct _NV_HDR_CAPABILITIES_V1 {
  NvU32 version;
  NvU32 isST2084EotfSupported : 1;
  NvU32 isTraditionalHdrGammaSupported : 1;
  NvU32 isEdrSupported : 1;
  NvU32 driverExpandDefaultHdrParameters : 1;
  NvU32 isTraditionalSdrGammaSupported : 1;
  NvU32 reserved : 27;
  NV_STATIC_METADATA_DESCRIPTOR_ID static_metadata_descriptor_id;
  struct {
    NvU16 displayPrimary_x0;
    NvU16 displayPrimary_y0;
    NvU16 displayPrimary_x1;
    NvU16 displayPrimary_y1;
    NvU16 displayPrimary_x2;
    NvU16 displayPrimary_y2;
    NvU16 displayWhitePoint_x;
    NvU16 displayWhitePoint_y;
    NvU16 desired_content_max_luminance;
    NvU16 desired_content_min_luminance;
    NvU16 desired_content_max_frame_average_luminance;
  } display_data;
} NV_HDR_CAPABILITIES_V1;
typedef struct _NV_HDR_CAPABILITIES_V2 {
  NvU32 version;
  NvU32 isST2084EotfSupported : 1;
  NvU32 isTraditionalHdrGammaSupported : 1;
  NvU32 isEdrSupported : 1;
  NvU32 driverExpandDefaultHdrParameters : 1;
  NvU32 isTraditionalSdrGammaSupported : 1;
  NvU32 isDolbyVisionSupported : 1;
  NvU32 reserved : 26;
  NV_STATIC_METADATA_DESCRIPTOR_ID static_metadata_descriptor_id;
  struct {
    NvU16 displayPrimary_x0;
    NvU16 displayPrimary_y0;
    NvU16 displayPrimary_x1;
    NvU16 displayPrimary_y1;
    NvU16 displayPrimary_x2;
    NvU16 displayPrimary_y2;
    NvU16 displayWhitePoint_x;
    NvU16 displayWhitePoint_y;
    NvU16 desired_content_max_luminance;
    NvU16 desired_content_min_luminance;
    NvU16 desired_content_max_frame_average_luminance;
  } display_data;
  struct {
    NvU32 VSVDB_version : 3;
    NvU32 dm_version : 8;
    NvU32 supports_2160p60hz : 1;
    NvU32 supports_YUV422_12bit : 1;
    NvU32 supports_global_dimming : 1;
    NvU32 colorimetry : 1;
    NvU32 supports_backlight_control : 2;
    NvU32 backlt_min_luma : 2;
    NvU32 interface_supported_by_sink : 2;
    NvU32 supports_10b_12b_444 : 2;
    NvU32 reserved : 9;
    NvU16 target_min_luminance;
    NvU16 target_max_luminance;
    NvU16 cc_red_x;
    NvU16 cc_red_y;
    NvU16 cc_green_x;
    NvU16 cc_green_y;
    NvU16 cc_blue_x;
    NvU16 cc_blue_y;
    NvU16 cc_white_x;
    NvU16 cc_white_y;
  } dv_static_metadata;
} NV_HDR_CAPABILITIES_V2;
#define NV_HDR_CAPABILITIES_VER1 MAKE_NVAPI_VERSION(NV_HDR_CAPABILITIES_V1, 1)
#define NV_HDR_CAPABILITIES_VER2 MAKE_NVAPI_VERSION(NV_HDR_CAPABILITIES_V2, 2)
#define NV_HDR_CAPABILITIES_VER NV_HDR_CAPABILITIES_VER2
typedef NV_HDR_CAPABILITIES_V2 NV_HDR_CAPABILITIES;
NVAPI_INTERFACE NvAPI_Disp_GetHdrCapabilities(__in NvU32 displayId, __inout NV_HDR_CAPABILITIES *pHdrCapabilities);
typedef enum {
  NV_HDR_CONTROL_CMD_GET,
  NV_HDR_CONTROL_CMD_SET,
} NV_HDR_CONTROL_CMD;
typedef struct _NV_HDR_SESSION_CONFIG_DATA {
  NvU32 version;
  NV_HDR_CONTROL_CMD cmd;
  NvU32 sessionExpireTime;
  NvU32 bSessionState : 1;
  NvU32 bHDRState : 1;
  NvU32 reserved : 30;
} NV_HDR_SESSION_CONFIG_DATA_V1;
typedef NV_HDR_SESSION_CONFIG_DATA_V1 NV_HDR_SESSION_CONFIG_DATA;
#define NV_HDR_SESSION_CONFIG_DATA_VER1 MAKE_NVAPI_VERSION(NV_HDR_SESSION_CONFIG_DATA_V1, 1)
#define NV_HDR_SESSION_CONFIG_DATA_VER NV_HDR_SESSION_CONFIG_DATA_VER1
NVAPI_INTERFACE NvAPI_Disp_HdrSessionControl(__in NvU32 displayId, __inout NV_HDR_SESSION_CONFIG_DATA *pHdrConfigData);
typedef enum { NV_HDR_CMD_GET = 0, NV_HDR_CMD_SET = 1 } NV_HDR_CMD;
typedef enum {
  NV_HDR_MODE_OFF = 0,
  NV_HDR_MODE_UHDA = 2,
  NV_HDR_MODE_UHDA_PASSTHROUGH = 5,
  NV_HDR_MODE_DOLBY_VISION = 7,
  NV_HDR_MODE_EDR = 3,
  NV_HDR_MODE_SDR = 4,
  NV_HDR_MODE_UHDA_NB = 6,
  NV_HDR_MODE_UHDBD = 2
} NV_HDR_MODE;
typedef struct _NV_HDR_COLOR_DATA_V1 {
  NvU32 version;
  NV_HDR_CMD cmd;
  NV_HDR_MODE hdrMode;
  NV_STATIC_METADATA_DESCRIPTOR_ID static_metadata_descriptor_id;
  struct {
    NvU16 displayPrimary_x0;
    NvU16 displayPrimary_y0;
    NvU16 displayPrimary_x1;
    NvU16 displayPrimary_y1;
    NvU16 displayPrimary_x2;
    NvU16 displayPrimary_y2;
    NvU16 displayWhitePoint_x;
    NvU16 displayWhitePoint_y;
    NvU16 max_display_mastering_luminance;
    NvU16 min_display_mastering_luminance;
    NvU16 max_content_light_level;
    NvU16 max_frame_average_light_level;
  } mastering_display_data;
} NV_HDR_COLOR_DATA_V1;
typedef struct _NV_HDR_COLOR_DATA_V2 {
  NvU32 version;
  NV_HDR_CMD cmd;
  NV_HDR_MODE hdrMode;
  NV_STATIC_METADATA_DESCRIPTOR_ID static_metadata_descriptor_id;
  struct {
    NvU16 displayPrimary_x0;
    NvU16 displayPrimary_y0;
    NvU16 displayPrimary_x1;
    NvU16 displayPrimary_y1;
    NvU16 displayPrimary_x2;
    NvU16 displayPrimary_y2;
    NvU16 displayWhitePoint_x;
    NvU16 displayWhitePoint_y;
    NvU16 max_display_mastering_luminance;
    NvU16 min_display_mastering_luminance;
    NvU16 max_content_light_level;
    NvU16 max_frame_average_light_level;
  } mastering_display_data;
  NV_COLOR_FORMAT hdrColorFormat;
  NV_DYNAMIC_RANGE hdrDynamicRange;
  NV_BPC hdrBpc;
} NV_HDR_COLOR_DATA_V2;
typedef struct _NV_HDR_COLOR_DATA_V3 {
  NvU32 version;
  NV_HDR_CMD cmd;
  NV_HDR_MODE hdrMode;
  NV_STATIC_METADATA_DESCRIPTOR_ID static_metadata_descriptor_id;
  struct {
    NvU16 displayPrimary_x0;
    NvU16 displayPrimary_y0;
    NvU16 displayPrimary_x1;
    NvU16 displayPrimary_y1;
    NvU16 displayPrimary_x2;
    NvU16 displayPrimary_y2;
    NvU16 displayWhitePoint_x;
    NvU16 displayWhitePoint_y;
    NvU16 max_display_mastering_luminance;
    NvU16 min_display_mastering_luminance;
    NvU16 max_content_light_level;
    NvU16 max_frame_average_light_level;
  } mastering_display_data;
  NV_COLOR_FORMAT hdrColorFormat;
  NV_DYNAMIC_RANGE hdrDynamicRange;
  NV_BPC hdrBpc;
  NV_OS_HDR_STATE osHdrMode;
} NV_HDR_COLOR_DATA_V3;
#define NV_HDR_COLOR_DATA_VER3 MAKE_NVAPI_VERSION(NV_HDR_COLOR_DATA_V3, 3)
#define NV_HDR_COLOR_DATA_VER NV_HDR_COLOR_DATA_VER3
typedef NV_HDR_COLOR_DATA_V3 NV_HDR_COLOR_DATA;
#define NV_HDR_COLOR_DATA_VER1 MAKE_NVAPI_VERSION(NV_HDR_COLOR_DATA_V1, 1)
#define NV_HDR_COLOR_DATA_VER2 MAKE_NVAPI_VERSION(NV_HDR_COLOR_DATA_V2, 2)
#ifndef NV_HDR_COLOR_DATA_VER
#define NV_HDR_COLOR_DATA_VER NV_HDR_COLOR_DATA_VER2
typedef NV_HDR_COLOR_DATA_V2 NV_HDR_COLOR_DATA;
#endif
NVAPI_INTERFACE NvAPI_Disp_HdrColorControl(__in NvU32 displayId, __inout NV_HDR_COLOR_DATA *pHdrColorData);
#define NV_BRIGHTNESS_CALIBRATION_RAMP_POINTS 101
#define NV_BRIGHTNESS_MIN_LUMINANCE_LIMIT 2.0f
#define NV_BRIGHTNESS_MAX_LUMINANCE_LIMIT 10000.0f
typedef struct _NV_BRIGHTNESS_CALIBRATION_DATA_V1 {
  NvU32 version;
  float minLuminance;
  float maxLuminance;
  float ramp[NV_BRIGHTNESS_CALIBRATION_RAMP_POINTS];
} NV_BRIGHTNESS_CALIBRATION_DATA_V1;
typedef NV_BRIGHTNESS_CALIBRATION_DATA_V1 NV_BRIGHTNESS_CALIBRATION_DATA;
#define NV_BRIGHTNESS_CALIBRATION_DATA_VER1 MAKE_NVAPI_VERSION(NV_BRIGHTNESS_CALIBRATION_DATA_V1, 1)
#define NV_BRIGHTNESS_CALIBRATION_DATA_VER NV_BRIGHTNESS_CALIBRATION_DATA_VER1
NVAPI_INTERFACE NvAPI_Disp_GetBrightnessCalibrationData(__in NvU32 displayId,
                                                        __out NV_BRIGHTNESS_CALIBRATION_DATA *pBrightnessCalibration);
NVAPI_INTERFACE NvAPI_Disp_SetBrightnessCalibrationData(__in NvU32 displayId,
                                                        __in NV_BRIGHTNESS_CALIBRATION_DATA *pBrightnessCalibration);
#define NV_MAX_TRANSITION_TIME 1000
typedef struct _NV_GET_BRIGHTNESS_NITS_V1 {
  NvU32 version;
  NvU32 currentBrightnessMillinits;
  NvU32 targetBrightnessMillinits;
  float sdrWhiteLevelLuminance;
  NvU32 reserved[8];
} NV_GET_BRIGHTNESS_NITS_V1;
#define NV_GET_BRIGHTNESS_NITS_VER1 MAKE_NVAPI_VERSION(NV_GET_BRIGHTNESS_NITS_V1, 1)
#define NV_GET_BRIGHTNESS_NITS_VER NV_GET_BRIGHTNESS_NITS_VER1
typedef NV_GET_BRIGHTNESS_NITS_V1 NV_GET_BRIGHTNESS_NITS;
NVAPI_INTERFACE NvAPI_Disp_GetBrightnessNits(__in NvU32 displayId, __inout NV_GET_BRIGHTNESS_NITS *pBrightnessData);
typedef struct _NV_SET_BRIGHTNESS_NITS_V1 {
  NvU32 version;
  NvU32 brightnessMillinits;
  NvU32 transitionTimeMs;
  NvU32 sdrWhiteLevelMillinits;
  NvU32 reserved[8];
} NV_SET_BRIGHTNESS_NITS_V1;
#define NV_SET_BRIGHTNESS_NITS_VER1 MAKE_NVAPI_VERSION(NV_SET_BRIGHTNESS_NITS_V1, 1)
#define NV_SET_BRIGHTNESS_NITS_VER NV_SET_BRIGHTNESS_NITS_VER1
typedef NV_SET_BRIGHTNESS_NITS_V1 NV_SET_BRIGHTNESS_NITS;
NVAPI_INTERFACE NvAPI_Disp_SetBrightnessNits(__in NvU32 displayId, __in NV_SET_BRIGHTNESS_NITS *pBrightnessData);
typedef struct {
  NvU32 version;
  NvU32 currentLevel;
  NvU32 minLevel;
  NvU32 maxLevel;
} NV_DISPLAY_DVC_INFO;
#define NV_DISPLAY_DVC_INFO_VER MAKE_NVAPI_VERSION(NV_DISPLAY_DVC_INFO, 1)
NVAPI_INTERFACE NvAPI_GetDVCInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_DVC_INFO *pDVCInfo);
NVAPI_INTERFACE NvAPI_SetDVCLevel(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 level);
typedef struct {
  NvU32 version;
  NvS32 currentLevel;
  NvS32 minLevel;
  NvS32 maxLevel;
  NvS32 defaultLevel;
} NV_DISPLAY_DVC_INFO_EX;
#define NV_DISPLAY_DVC_INFO_EX_VER MAKE_NVAPI_VERSION(NV_DISPLAY_DVC_INFO_EX, 1)
NVAPI_INTERFACE NvAPI_GetDVCInfoEx(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_DVC_INFO_EX *pDVCInfo);
NVAPI_INTERFACE NvAPI_SetDVCLevelEx(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_DVC_INFO_EX *pDVCInfo);
typedef struct {
  NvU32 version;
  NvU32 currentHueAngle;
  NvU32 defaultHueAngle;
} NV_DISPLAY_HUE_INFO;
#define NV_DISPLAY_HUE_INFO_VER MAKE_NVAPI_VERSION(NV_DISPLAY_HUE_INFO, 1)
NVAPI_INTERFACE NvAPI_GetHUEInfo(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_DISPLAY_HUE_INFO *pHUEInfo);
NVAPI_INTERFACE NvAPI_SetHUEAngle(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 hueAngle);
typedef struct {
  NvU32 version;
  NvU32 currentLevel;
  NvU32 minLevel;
  NvU32 maxLevel;
} NV_DISPLAY_IMAGE_SHARPENING_INFO;
#define NV_DISPLAY_IMAGE_SHARPENING_INFO_VER MAKE_NVAPI_VERSION(NV_DISPLAY_IMAGE_SHARPENING_INFO, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_GetImageSharpeningInfo(NvDisplayHandle hNvDisplay, NvU32 outputId,
                                 NV_DISPLAY_IMAGE_SHARPENING_INFO *pImageSharpeningInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_SetImageSharpeningLevel(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 level);
typedef struct {
  NvU32 version;
  struct {
    NvU32 defaultLevel;
    NvU32 currentLevel;
    NvU32 minLevel;
    NvU32 maxLevel;
  } flicker, saturation;
} NV_TV_ENCODER_CONTROLS;
#define NV_TV_ENCODER_CONTROLS_VER MAKE_NVAPI_VERSION(NV_TV_ENCODER_CONTROLS, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_GetTVEncoderControls(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_ENCODER_CONTROLS *pTvEncoderInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_SetTVEncoderControls(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_TV_ENCODER_CONTROLS *pTvEncoderInfo);
typedef enum {
  NV_TV_BORDER_COLOR_BLACK = 0,
  NV_TV_BORDER_COLOR_GREY = 1,
} NV_TV_BORDER_COLOR;
NVAPI_INTERFACE NvAPI_GetTVOutputBorderColor(NvDisplayHandle hNvDisplay, NvU32 outputId,
                                             NV_TV_BORDER_COLOR *pBorderColor);
NVAPI_INTERFACE NvAPI_SetTVOutputBorderColor(NvDisplayHandle hNvDisplay, NvU32 outputId,
                                             NV_TV_BORDER_COLOR borderColor);
NVAPI_INTERFACE NvAPI_GetDisplayPosition(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 *pXOffset, NvU32 *pYOffset);
NVAPI_INTERFACE NvAPI_SetDisplayPosition(NvDisplayHandle hNvDisplay, NvU32 outputId, NvU32 xOffset, NvU32 yOffset);
NVAPI_INTERFACE NvAPI_RmConfigGet(NvDisplayHandle hNvDisplay, NvU32 opcode, NvU32 *pValue);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 352.") NVAPI_INTERFACE
    NvAPI_GetGFAHandle(void **GFAHandle);
NVAPI_INTERFACE NvAPI_GetDisplaySettings(NvDisplayHandle hNvDisplay, NV_DISP_PATH *pPaths, NvU32 *pPathCount);
typedef struct {
  NvU32 isInterlaced : 4;
  NvU32 reserved0 : 12;
  union {
    NvU32 tvFormat : 8;
    NvU32 ceaId : 8;
    NvU32 nvPsfId : 8;
  };
  NvU32 scaling : 8;
} NV_TIMING_FLAG;
typedef struct _NV_TIMING_INPUT {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  float rr;
  NV_TIMING_FLAG flag;
  NV_TIMING_OVERRIDE type;
} NV_TIMING_INPUT;
#define NV_TIMING_INPUT_VER MAKE_NVAPI_VERSION(NV_TIMING_INPUT, 1)
#define NV_GET_CEA_FORMAT(n) (((n) & 0x3F800000) >> 23)
#define NV_GET_ANALOG_TV_FORMAT(n) ((((n) & 0x0FF00) == 0x1100 || ((n) & 0x0FF00) == 0x1200) ? ((n) & 0x0FF) : 0)
#define NV_IS_ANALOG_TV_FORMAT(n) ((((n) & 0x0FF00) == 0x1100 || ((n) & 0x0FF00) == 0x1200) ? 1 : 0)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_GetTiming.") NVAPI_INTERFACE
    NvAPI_GetTiming(NvDisplayHandle hNvDisplay, NvU32 width, NvU32 height, float rr, NV_TIMING_FLAG flag,
                    NvU32 outputId, NV_TIMING_OVERRIDE type, NV_TIMING *pT);
NVAPI_INTERFACE NvAPI_DISP_GetTiming(__in NvU32 displayId, __in NV_TIMING_INPUT *timingInput, __out NV_TIMING *pTiming);
typedef enum {
  NV_MONITOR_CAPS_TYPE_HDMI_VSDB = 0x1000,
  NV_MONITOR_CAPS_TYPE_HDMI_VCDB = 0x1001,
  NV_MONITOR_CAPS_TYPE_GENERIC = 0x1002,
} NV_MONITOR_CAPS_TYPE;
typedef struct _NV_MONITOR_CAPS_VCDB {
  NvU8 quantizationRangeYcc : 1;
  NvU8 quantizationRangeRgb : 1;
  NvU8 scanInfoPreferredVideoFormat : 2;
  NvU8 scanInfoITVideoFormats : 2;
  NvU8 scanInfoCEVideoFormats : 2;
} NV_MONITOR_CAPS_VCDB;
typedef struct _NV_MONITOR_CAPS_VSDB {
  NvU8 sourcePhysicalAddressB : 4;
  NvU8 sourcePhysicalAddressA : 4;
  NvU8 sourcePhysicalAddressD : 4;
  NvU8 sourcePhysicalAddressC : 4;
  NvU8 supportDualDviOperation : 1;
  NvU8 reserved6 : 2;
  NvU8 supportDeepColorYCbCr444 : 1;
  NvU8 supportDeepColor30bits : 1;
  NvU8 supportDeepColor36bits : 1;
  NvU8 supportDeepColor48bits : 1;
  NvU8 supportAI : 1;
  NvU8 maxTmdsClock;
  NvU8 cnc0SupportGraphicsTextContent : 1;
  NvU8 cnc1SupportPhotoContent : 1;
  NvU8 cnc2SupportCinemaContent : 1;
  NvU8 cnc3SupportGameContent : 1;
  NvU8 reserved8 : 1;
  NvU8 hasVicEntries : 1;
  NvU8 hasInterlacedLatencyField : 1;
  NvU8 hasLatencyField : 1;
  NvU8 videoLatency;
  NvU8 audioLatency;
  NvU8 interlacedVideoLatency;
  NvU8 interlacedAudioLatency;
  NvU8 reserved13 : 7;
  NvU8 has3dEntries : 1;
  NvU8 hdmi3dLength : 5;
  NvU8 hdmiVicLength : 3;
  NvU8 hdmi_vic[7];
  NvU8 hdmi_3d[31];
} NV_MONITOR_CAPS_VSDB;
typedef struct _NV_MONITOR_CAPS_GENERIC {
  NvU8 supportVRR : 1;
  NvU8 supportULMB : 1;
  NvU8 isTrueGsync : 1;
  NvU8 isRLACapable : 1;
  NvU8 reserved : 4;
} NV_MONITOR_CAPS_GENERIC;
typedef struct _NV_MONITOR_CAPABILITIES_V1 {
  NvU32 version;
  NvU16 size;
  NvU32 infoType;
  NvU32 connectorType;
  NvU8 bIsValidInfo : 1;
  union {
    NV_MONITOR_CAPS_VSDB vsdb;
    NV_MONITOR_CAPS_VCDB vcdb;
    NV_MONITOR_CAPS_GENERIC caps;
  } data;
} NV_MONITOR_CAPABILITIES_V1;
typedef NV_MONITOR_CAPABILITIES_V1 NV_MONITOR_CAPABILITIES;
#define NV_MONITOR_CAPABILITIES_VER1 MAKE_NVAPI_VERSION(NV_MONITOR_CAPABILITIES_V1, 1)
#define NV_MONITOR_CAPABILITIES_VER NV_MONITOR_CAPABILITIES_VER1
NVAPI_INTERFACE NvAPI_DISP_GetMonitorCapabilities(__in NvU32 displayId,
                                                  __inout NV_MONITOR_CAPABILITIES *pMonitorCapabilities);
typedef struct _NV_MONITOR_COLOR_DATA {
  NvU32 version;
  NV_DP_COLOR_FORMAT colorFormat;
  NV_DP_BPC backendBitDepths;
} NV_MONITOR_COLOR_CAPS_V1;
typedef NV_MONITOR_COLOR_CAPS_V1 NV_MONITOR_COLOR_CAPS;
#define NV_MONITOR_COLOR_CAPS_VER1 MAKE_NVAPI_VERSION(NV_MONITOR_COLOR_CAPS_V1, 1)
#define NV_MONITOR_COLOR_CAPS_VER NV_MONITOR_COLOR_CAPS_VER1
NVAPI_INTERFACE NvAPI_DISP_GetMonitorColorCapabilities(__in NvU32 displayId,
                                                       __inout_ecount_part_opt(*pColorCapsCount, *pColorCapsCount)
                                                           NV_MONITOR_COLOR_CAPS *pMonitorColorCapabilities,
                                                       __inout NvU32 *pColorCapsCount);
typedef struct {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NvU32 depth;
  NV_FORMAT colorFormat;
  NV_VIEWPORTF srcPartition;
  float xRatio;
  float yRatio;
  NV_TIMING timing;
  NvU32 hwModeSetOnly : 1;
} NV_CUSTOM_DISPLAY;
#define NV_CUSTOM_DISPLAY_VER MAKE_NVAPI_VERSION(NV_CUSTOM_DISPLAY, 1)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_EnumCustomDisplay.")
    NVAPI_INTERFACE
    NvAPI_EnumCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 index, NvU32 outputId, NV_CUSTOM_DISPLAY *pC);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_TryCustomDisplay.")
    NVAPI_INTERFACE NvAPI_TryCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 *pDispOutputId,
                                           NV_CUSTOM_DISPLAY *pCustDisp, NvU32 count, NvU32 hwModeSetOnly);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_RevertCustomDisplayTrial.")
    NVAPI_INTERFACE NvAPI_RevertCustomDisplayTrial(NvDisplayHandle hNvDisplay);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_DeleteCustomDisplay.")
    NVAPI_INTERFACE NvAPI_DeleteCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_DISP_SaveCustomDisplay.")
    NVAPI_INTERFACE
    NvAPI_SaveCustomDisplay(NvDisplayHandle hNvDisplay, NvU32 isThisOutputIdOnly, NvU32 isThisMonitorIdOnly);
NVAPI_INTERFACE NvAPI_DISP_EnumCustomDisplay(__in NvU32 displayId, __in NvU32 index,
                                             __inout NV_CUSTOM_DISPLAY *pCustDisp);
NVAPI_INTERFACE NvAPI_DISP_TryCustomDisplay(__in_ecount(count) NvU32 *pDisplayIds, __in NvU32 count,
                                            __in_ecount(count) NV_CUSTOM_DISPLAY *pCustDisp);
NVAPI_INTERFACE NvAPI_DISP_DeleteCustomDisplay(__in_ecount(count) NvU32 *pDisplayIds, __in NvU32 count,
                                               __in NV_CUSTOM_DISPLAY *pCustDisp);
NVAPI_INTERFACE NvAPI_DISP_SaveCustomDisplay(__in_ecount(count) NvU32 *pDisplayIds, __in NvU32 count,
                                             __in NvU32 isThisOutputIdOnly, __in NvU32 isThisMonitorIdOnly);
NVAPI_INTERFACE NvAPI_DISP_RevertCustomDisplayTrial(__in_ecount(count) NvU32 *pDisplayIds, __in NvU32 count);
typedef struct {
  NvU32 version;
  float xRatioMin;
  float xRatioMax;
  float yRatioMin;
  float yRatioMax;
  NvU32 supportSourceUnderscan : 1;
  NvU32 supportScalerUnderscan : 1;
  NvU32 supportMonitorIdMatch : 1;
  NvU32 supportDisplayOutputIdMatch : 1;
  NvU32 supportXYIndependentCtrl : 1;
  NvU32 isSourceUnderscanRecommended : 1;
  NvU32 isScalerUnderscanRecommended : 1;
} NV_UNDERSCAN_CAP;
#define NV_UNDERSCAN_CAP_VER MAKE_NVAPI_VERSION(NV_UNDERSCAN_CAP, 1)
NVAPI_INTERFACE NvAPI_QueryUnderscanCap(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NV_UNDERSCAN_CAP *cap);
typedef enum NV_CURSOR_SIZE {
  NV_CURSOR_SIZE_64 = 64,
  NV_CURSOR_SIZE_128 = 128,
  NV_CURSOR_SIZE_256 = 256
} NV_CURSOR_SIZE;
typedef struct {
  NvU32 version;
  NvU32 targetId;
  NV_CURSOR_SIZE cursorSize;
  NvU32 hwCursorEnable : 1;
  NvU32 reserved : 31;
} NV_CURSOR_STATE_V1;
typedef NV_CURSOR_STATE_V1 NV_CURSOR_STATE;
#define NV_CURSOR_STATE_VER_1 MAKE_NVAPI_VERSION(NV_CURSOR_STATE_V1, 1)
#define NV_CURSOR_STATE_VER NV_CURSOR_STATE_VER_1
NVAPI_INTERFACE NvAPI_DISP_SetCursorState(__in NvDisplayHandle hNvDisplay, __in NV_CURSOR_STATE *cursorState);
NVAPI_INTERFACE NvAPI_DISP_GetCursorState(__in NvDisplayHandle hNvDisplay, __inout NV_CURSOR_STATE *cursorState);
typedef struct {
  NvU32 version;
  float xRatio;
  float yRatio;
  NvU32 nativeWidth;
  NvU32 nativeHeight;
  NvU32 nativeRR;
  NvU32 isInterlaced : 1;
  NvU32 isScalerUnderscan : 1;
  NvU32 isOnThisMonitorOnly : 1;
  NvU32 isOnThisDisplayOutputIdOnly : 1;
  NvU32 isEnabled : 1;
  NvU32 reserved : 27;
} NV_UNDERSCAN_CONFIG;
#define NV_UNDERSCAN_CONFIG_VER1 MAKE_NVAPI_VERSION(NV_UNDERSCAN_CONFIG, 1)
#define NV_UNDERSCAN_CONFIG_VER2 MAKE_NVAPI_VERSION(NV_UNDERSCAN_CONFIG, 2)
#define NV_UNDERSCAN_CONFIG_VER NV_UNDERSCAN_CONFIG_VER2
NVAPI_INTERFACE NvAPI_EnumUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index,
                                          NV_UNDERSCAN_CONFIG *config);
#define NVAPI_INDEX_CURRENT_ENTRY -1
#define NVAPI_INDEX_ALL_ENTRIES -2
#define NVAPI_INDEX_UNINITIALIZED -3
NVAPI_INTERFACE NvAPI_DeleteUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NvU32 index);
NVAPI_INTERFACE NvAPI_SetUnderscanConfig(NvDisplayHandle hNvDisplay, NvU32 displayOutputId, NV_UNDERSCAN_CONFIG *config,
                                         NvU32 setDeferred);
NVAPI_INTERFACE NvAPI_DISP_EnableUnderscanConfig(NvU32 displayId, NvU32 index);
NVAPI_INTERFACE NvAPI_DISP_DisableUnderscanConfig(NvU32 displayId, NvU32 index);
typedef struct {
  NvU32 x;
  NvU32 y;
  NvU32 w;
  NvU32 h;
} NVAPI_VIEWPORT;
typedef struct _NV_VIEW_PORT_INFO_V1 {
  NvU32 version;
  NVAPI_VIEWPORT viewPort;
  NvU32 viewPortLockState : 1;
  NvU32 reserved : 31;
} NV_VIEW_PORT_INFO_V1;
typedef struct _NV_VIEW_PORT_INFO_V2 {
  NvU32 version;
  NVAPI_VIEWPORT viewPort;
  NvU32 viewPortLockState : 1;
  NvU32 reserved : 31;
  NvU32 zoomValue;
} NV_VIEW_PORT_INFO_V2;
typedef NV_VIEW_PORT_INFO_V2 NV_VIEW_PORT_INFO;
#define NV_VIEW_PORT_INFO_VER1 MAKE_NVAPI_VERSION(NV_VIEW_PORT_INFO_V1, 1)
#define NV_VIEW_PORT_INFO_VER2 MAKE_NVAPI_VERSION(NV_VIEW_PORT_INFO_V2, 2)
#define NV_VIEW_PORT_INFO_VER NV_VIEW_PORT_INFO_VER2
NVAPI_INTERFACE NvAPI_DISP_GetViewPortInfo(__in NvU32 displayId, __inout NV_VIEW_PORT_INFO *viewPortInfo);
#define NV_VIEW_PORT_INFO_SET_VIEWPORT 0x00000001
#define NV_VIEW_PORT_INFO_SET_LOCK_STATE 0x00000002
#define NV_VIEW_PORT_INFO_SET_ZOOM 0x00000004
NVAPI_INTERFACE NvAPI_DISP_SetViewPortInfo(__in NvU32 displayId, __in NV_VIEW_PORT_INFO *viewPortInfo,
                                           __in NvU32 setFlags);
typedef struct _NV_DISPLAY_FEATURE_CONFIG {
  NvU32 version;
  NvU32 isPanAndScanEnabled : 1;
  NvU32 modulePresentSyncGDIPrimaryTarget : 1;
  NvU32 reserved : 30;
} NV_DISPLAY_FEATURE_CONFIG_V1;
#define NV_DISPLAY_FEATURE_CONFIG_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_FEATURE_CONFIG_V1, 1)
#define NV_DISPLAY_FEATURE_CONFIG_VER NV_DISPLAY_FEATURE_CONFIG_VER1
typedef NV_DISPLAY_FEATURE_CONFIG_V1 NV_DISPLAY_FEATURE_CONFIG;
NVAPI_INTERFACE NvAPI_DISP_GetFeatureConfig(__in NvU32 displayId,
                                            __inout NV_DISPLAY_FEATURE_CONFIG *pDisplayFeatureConfig);
NVAPI_INTERFACE NvAPI_DISP_SetFeatureConfig(__in NvU32 displayId,
                                            __inout NV_DISPLAY_FEATURE_CONFIG *pDisplayFeatureConfig);
typedef struct _NV_DISPLAY_FEATURE {
  NvU32 enableScalerUnderscan : 1;
  NvU32 enableCEoverHDMI : 1;
  NvU32 reservedOEM : 1;
  NvU32 isDriverCtrlCEoverHDMI : 1;
  NvU32 isSGMClockLockSet : 1;
  NvU32 enableSGMClockLock : 1;
  NvU32 isConsistentPerformanceSet : 1;
  NvU32 enableConsistentPerformance : 1;
  NvU32 reserved : 24;
} NV_DISPLAY_FEATURE;
NVAPI_INTERFACE NvAPI_GetDisplayFeatureConfig(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE *pFeature);
NVAPI_INTERFACE NvAPI_SetDisplayFeatureConfig(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE feature);
NVAPI_INTERFACE NvAPI_GetDisplayFeatureConfigDefaults(NvDisplayHandle hNvDisplay, NV_DISPLAY_FEATURE *pFeature);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig.")
    NVAPI_INTERFACE NvAPI_GetView(NvDisplayHandle hNvDisplay, NV_VIEW_TARGET_INFO *pTargets, NvU32 *pTargetMaskCount,
                                  NV_TARGET_VIEW_MODE *pTargetView);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_GetDisplayConfig.")
    NVAPI_INTERFACE NvAPI_GetViewEx(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo, NvU32 *pPathCount,
                                    NV_TARGET_VIEW_MODE *pTargetViewMode);
NVAPI_INTERFACE NvAPI_GetSupportedViews(NvDisplayHandle hNvDisplay, NV_TARGET_VIEW_MODE *pTargetViews,
                                        NvU32 *pViewCount);
NVAPI_INTERFACE NvAPI_GetSupportedViewsEx(NvDisplayHandle hNvDisplay, NV_TARGET_VIEW_MODE *pTargetViews,
                                          NvU32 *pViewCount, NvU32 flag);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_DISP_SetDisplayConfig.")
    NVAPI_INTERFACE NvAPI_SetViewExInternal(NvDisplayHandle hNvDisplay, NV_DISPLAY_PATH_INFO *pPathInfo,
                                            NV_TARGET_VIEW_MODE displayView);
NVAPI_INTERFACE NvAPI_DISP_IsFullscreenAppRunning(NvDisplayHandle hNvDisplay, NvU32 *pFullScreenApp);
typedef enum _NV_HDMI_AUDIO_STREAM_MUTE_STATUS {
  NV_SET_HDMI_AUDIO_STREAM_MUTE_OFF = 0x00,
  NV_SET_HDMI_AUDIO_STREAM_MUTE_ON = 0x01,
} NV_HDMI_AUDIO_STREAM_MUTE_STATUS;
typedef struct {
  NvU32 version;
  NV_HDMI_AUDIO_STREAM_MUTE_STATUS nvHdmiAudioMute;
} NV_HDMI_AUDIO_INFO;
#define NV_HDMI_AUDIO_INFO_VER MAKE_NVAPI_VERSION(NV_HDMI_AUDIO_INFO, 1)
NVAPI_INTERFACE NvAPI_SetHDMIAudioStreamMute(NvDisplayHandle hNvDisplay, NvU32 outputId,
                                             NV_HDMI_AUDIO_INFO *pNvHdmiAudioInfo);
#define NVAPI_DPCD_MAX_DATA_SIZE 16
typedef enum _NV_DPCD_CMD {
  NV_DP_AUXCH_CMD_REQ_TYPE_WRITE = 0,
  NV_DP_AUXCH_CMD_REQ_TYPE_READ,
  NV_DP_AUXCH_CMD_REQ_TYPE_I2C_WRITE,
  NV_DP_AUXCH_CMD_REQ_TYPE_I2C_READ,
  NV_DP_AUXCH_CMD_REQ_TYPE_I2C_WRITE_STATUS,
  NV_DP_AUXCH_CMD_REQ_TYPE_MOT_I2C_WRITE,
  NV_DP_AUXCH_CMD_REQ_TYPE_MOT_I2C_READ
} NV_DPCD_CMD;
typedef enum _NV_DPCD_REPLY_TYPE {
  NV_DP_AUXCH_REPLYTYPE_ACK = 0,
  NV_DP_AUXCH_REPLYTYPE_NACK = 1,
  NV_DP_AUXCH_REPLYTYPE_NACK_WRITE_FAILURE = 1,
  NV_DP_AUXCH_REPLYTYPE_NACK_INVALID_RAD = 2,
  NV_DP_AUXCH_REPLYTYPE_NACK_CRC_FAILURE = 3,
  NV_DP_AUXCH_REPLYTYPE_NACK_BAD_PARAM = 4,
  NV_DP_AUXCH_REPLYTYPE_DEFER = 5,
  NV_DP_AUXCH_REPLYTYPE_NACK_LINK_FAILURE = 6,
  NV_DP_AUXCH_REPLYTYPE_NACK_NO_RESOURCES = 7,
  NV_DP_AUXCH_REPLYTYPE_NACK_DPCD_FAIL = 8,
  NV_DP_AUXCH_REPLYTYPE_NACK_I2C_FAIL = 9,
  NV_DP_AUXCH_REPLYTYPE_NACK_ALLOCATE_FAIL = 10,
  NV_DP_AUXCH_REPLYTYPE_TIMEOUT = 0x100,
  NV_DP_AUXCH_REPLYTYPE_INVALID_ARGUMENT = 0xFFFFFFFF
} NV_DPCD_REPLY_TYPE;
typedef struct _NV_DPCD_PARAMS_V1 {
  NvU32 version;
  NvU32 displayId;
  NV_DPCD_CMD cmd;
  NvU32 addr;
  NvU8 data[NVAPI_DPCD_MAX_DATA_SIZE];
  NvU32 size;
  NV_DPCD_REPLY_TYPE replyType;
} NV_DPCD_PARAMS_V1;
typedef struct _NV_DPCD_PARAMS_V2 {
  NvU32 version;
  NvU32 displayId;
  NV_DPCD_CMD cmd;
  NvU32 addr;
  NvU8 data[NVAPI_DPCD_MAX_DATA_SIZE];
  NvU32 size;
  NV_DPCD_REPLY_TYPE replyType;
  NV_DP_ADDRESS auxAddress;
} NV_DPCD_PARAMS_V2;
typedef struct _NV_DPCD_PARAMS_V3 {
  NvU32 version;
  NvU32 displayId;
  NV_DPCD_CMD cmd;
  NvU32 addr;
  NvU8 data[NVAPI_DPCD_MAX_DATA_SIZE];
  NvU32 size;
  NV_DPCD_REPLY_TYPE replyType;
  NV_DP_ADDRESS auxAddress;
  NV_POSITION tilePosition;
} NV_DPCD_PARAMS_V3;
#define NV_DPCD_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_DPCD_PARAMS_V1, 1)
#define NV_DPCD_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_DPCD_PARAMS_V2, 2)
#define NV_DPCD_PARAMS_VER3 MAKE_NVAPI_VERSION(NV_DPCD_PARAMS_V3, 3)
#define NV_DPCD_PARAMS_VER NV_DPCD_PARAMS_VER3
typedef NV_DPCD_PARAMS_V3 NV_DPCD_PARAMS;
NVAPI_INTERFACE NvAPI_Disp_DpAuxChannelControl(__in NvDisplayHandle hNvDisplay, __inout NV_DPCD_PARAMS *pDpcdParams,
                                               __in NvU32 reserved);
typedef enum _NV_DP_TESTPATTERN_DATA {
  NV_DP_TESTPATTERN_DATA_NONE,
  NV_DP_TESTPATTERN_DATA_D10_2,
  NV_DP_TESTPATTERN_DATA_SERMP,
  NV_DP_TESTPATTERN_DATA_PRBS_7,
  NV_DP_TESTPATTERN_DATA_CSTM,
  NV_DP_TESTPATTERN_DATA_HBR2COMPLIANCE,
  NV_DP_TESTPATTERN_DATA_CP2520PAT3
} NV_DP_TESTPATTERN_DATA;
typedef struct _NV_DP_TESTPATTERN_CSTM {
  NvU32 lower;
  NvU32 middle;
  NvU32 upper;
} NV_DP_TESTPATTERN_CSTM;
typedef struct _NV_DP_TESTPATTERN {
  NvU32 version;
  NvU32 rootDisplayId;
  NV_DP_TESTPATTERN_DATA testPattern;
  NV_DP_TESTPATTERN_CSTM cstmTestPattern;
  NvU32 isHBR2 : 1;
  NvU32 laneMask : 8;
  NvU32 bSkipLaneDataOverride : 1;
  NvU32 reserved : 22;
} NV_DP_TESTPATTERN_V1;
#define NV_DP_TESTPATTERN_VER1 MAKE_NVAPI_VERSION(NV_DP_TESTPATTERN_V1, 1)
#define NV_DP_TESTPATTERN_VER NV_DP_TESTPATTERN_VER1
typedef NV_DP_TESTPATTERN_V1 NV_DP_TESTPATTERN;
NVAPI_INTERFACE NvAPI_Disp_DP_SetTestPattern(__in NV_DP_TESTPATTERN *pDpTestPattern);
NVAPI_INTERFACE NvAPI_Disp_DP_GetTestPattern(__inout NV_DP_TESTPATTERN *pDpTestPattern);
#define NV_DP_MAX_LANES 4
typedef enum {
  NV_DP_PREEMPHASIS_LEVEL_NONE,
  NV_DP_PREEMPHASIS_LEVEL_1,
  NV_DP_PREEMPHASIS_LEVEL_2,
  NV_DP_PREEMPHASIS_LEVEL_3,
  NV_DP_PREEMPHASIS_LEVEL_UNDEFINED = 0xFF
} NV_DP_PREEMPHASIS_LEVEL;
typedef enum {
  NV_DP_DRIVE_CURRENT_LEVEL_0,
  NV_DP_DRIVE_CURRENT_LEVEL_1,
  NV_DP_DRIVE_CURRENT_LEVEL_2,
  NV_DP_DRIVE_CURRENT_LEVEL_3,
  NV_DP_DRIVE_CURRENT_LEVEL_UNDEFINED = 0xFF
} NV_DP_DRIVE_CURRENT_LEVEL;
typedef enum _NV_DP_VOLTAGE_SWING_LEVEL {
  NV_DP_VOLTAGE_SWING_LEVEL_0,
  NV_DP_VOLTAGE_SWING_LEVEL_1,
  NV_DP_VOLTAGE_SWING_LEVEL_2,
  NV_DP_VOLTAGE_SWING_LEVEL_3,
  NV_DP_VOLTAGE_SWING_LEVEL_UNDEFINED = 0xFF
} NV_DP_VOLTAGE_SWING_LEVEL;
typedef struct _NV_DP_LANE_DATA {
  NV_DP_PREEMPHASIS_LEVEL preEmphasisLevel;
  union {
    NV_DP_DRIVE_CURRENT_LEVEL driveCurrent;
    NV_DP_VOLTAGE_SWING_LEVEL voltageSwingLevel;
  };
} NV_DP_LANE_DATA;
typedef struct _NV_DP_LANE_CONFIG {
  NvU32 version;
  NvU32 rootDisplayId;
  NvU32 numLanes;
  NV_DP_LANE_DATA data[NV_DP_MAX_LANES];
} NV_DP_LANE_CONFIG_V1;
#define NV_DP_LANE_CONFIG_VER1 MAKE_NVAPI_VERSION(NV_DP_LANE_CONFIG_V1, 1)
#define NV_DP_LANE_CONFIG_VER NV_DP_LANE_CONFIG_VER1
typedef NV_DP_LANE_CONFIG_V1 NV_DP_LANE_CONFIG;
NVAPI_INTERFACE NvAPI_Disp_DP_GetLaneConfig(__inout NV_DP_LANE_CONFIG *pDpLaneConfig);
NVAPI_INTERFACE NvAPI_Disp_DP_SetLaneConfig(__in NV_DP_LANE_CONFIG *pDpLaneConfig);
typedef enum _NV_DP_LINK_CONFIG_CMD { NV_DP_LINK_CONFIG_CMD_GET = 0, NV_DP_LINK_CONFIG_CMD_SET } NV_DP_LINK_CONFIG_CMD;
typedef struct _NV_DP_LINK_CONFIG_V1 {
  NvU32 version;
  NvU32 rootDisplayId;
  NV_DP_LINK_CONFIG_CMD cmd;
  NvU8 useDefaults;
  NV_DP_LINK_RATE linkRate;
  NvU32 laneCount;
  NvU32 forceLinkConfig : 1;
  NvU32 forceRGDivMode : 1;
  NvU32 disablePostLTRequest : 1;
  NvU32 disableLTTPR : 1;
  NvU32 enableFEC : 1;
  NvU32 reserved : 27;
} NV_DP_LINK_CONFIG_V1;
#define NV_DP_LINK_CONFIG_VER1 MAKE_NVAPI_VERSION(NV_DP_LINK_CONFIG_V1, 1)
#define NV_DP_LINK_CONFIG_VER NV_DP_LINK_CONFIG_VER1
typedef NV_DP_LINK_CONFIG_V1 NV_DP_LINK_CONFIG;
NVAPI_INTERFACE NvAPI_DISP_DP_LinkConfiguration(__inout NV_DP_LINK_CONFIG *pNvDpLinkConfig);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 295. Instead, use NvAPI_Disp_DpAuxChannelControl.")
    NVAPI_INTERFACE NvAPI_Diag_DPCD(NvPhysicalGpuHandle nvGPUHandle, void *pDpcdParams, NvU32 size);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use following "
                            "functions: NvAPI_Disp_DP_SetTestPattern, NvAPI_Disp_DP_GetTestPattern.") NVAPI_INTERFACE
    NvAPI_Diag_DP_TestPattern(NvPhysicalGpuHandle nvGPUHandle, NvU32 set, void *pTestPatternParams, NvU32 size);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Diag_DP_VideoInfo(NvPhysicalGpuHandle nvGPUHandle, NvU32 set, void *pVideoInfoParams, NvU32 size);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 295. Instead, use following "
                            "functions: NvAPI_Disp_DP_SetLaneConfig, NvAPI_Disp_DP_GetLaneConfig.") NVAPI_INTERFACE
    NvAPI_Diag_DP_LaneData(NvPhysicalGpuHandle nvGPUHandle, NvU32 set, void *pLaneDataParams, NvU32 size);
typedef struct {
  NvU32 GPUId;
  NvU32 Devicemask;
} NV_HYBRID_GPU_INFO;
typedef struct {
  NvU32 version;
  NvU32 GPUCount;
  NV_HYBRID_GPU_INFO GPUs[NVAPI_MAX_PHYSICAL_GPUS];
} NV_HYBRID_OUTPUTS_INFO;
#define NV_HYBRID_OUTPUTS_INFO_VER MAKE_NVAPI_VERSION(NV_HYBRID_OUTPUTS_INFO, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_GetHybridConnectedOutputs(NV_HYBRID_OUTPUTS_INFO *dGPUInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_GetHybridEDID(NvU32 GPUId, NvU32 displayOutputId, NV_EDID *pEDID);
typedef enum _NV_HYBRID_MESSAGE {
  NV_HYBRID_MESSAGE_D3D_ATTACH = 0x00,
  NV_HYBRID_MESSAGE_OGL_ATTACH = 0x01,
  NV_HYBRID_MESSAGE_PROCESS_ATTACH = 0x02,
  NV_HYBRID_MESSAGE_PROCESS_DETACH = 0x03,
  NV_HYBRID_MESSAGE_POWER_SETTING = 0x04,
  NV_HYBRID_MESSAGE_POWER_SOURCE = 0x05,
  NV_HYBRID_MESSAGE_DISPLAY_SETTING = 0x06,
  NV_HYBRID_MESSAGE_DOCKING = 0x07,
  NV_HYBRID_MESSAGE_THERMAL = 0x08,
  NV_HYBRID_MESSAGE_SETHYBRIDMODE = 0x09,
} NV_HYBRID_MESSAGE;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_SendHybridMessage(NV_HYBRID_MESSAGE msgType, NvU32 param);
typedef enum _NV_HYBRID_MODE {
  NV_HYBRID_MODE_IGPU = 0x00,
  NV_HYBRID_MODE_DGPU = 0x01,
  NV_HYBRID_MODE_MULTI_ADAPTER = 0x02,
  NV_HYBRID_MODE_INVALID = 0x03,
  NV_HYBRID_MODE_DGPU_WARMUP = 0x04,
  NV_HYBRID_MODE_DGPU_DEEP_IDLE = 0x05,
  NV_HYBRID_MODE_INSTALL = 0x06,
  NV_HYBRID_MODE_ADAPTIVE = 0x07,
} NV_HYBRID_MODE;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_SetHybridMode(NV_HYBRID_MODE mode);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_GetHybridMode(NV_HYBRID_MODE *pMode);
typedef enum _NV_HYBRID_SWITCH_METHOD {
  NV_HYBRID_SWITCH_METHOD_NONE = 0x00,
  NV_HYBRID_SWITCH_METHOD_UNKNOWN = 0x01,
  NV_HYBRID_SWITCH_METHOD_HOTKEY = 0x02,
  NV_HYBRID_SWITCH_METHOD_PHYSICAL_SWITCH = 0x03,
} NV_HYBRID_SWITCH_METHOD;
typedef struct {
  NV_HYBRID_SWITCH_METHOD method;
  NvU32 numberOfWays;
} NV_HYBRID_TRANSITION_METHOD;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_GetHybridSwitchStatus(NV_HYBRID_MODE *pMode);
typedef struct {
  NvU32 version;
  NvU32 validHybridModes;
  NvU32 hybridStatus;
} NV_HYBRID_INFO_v1;
typedef struct {
  NvU32 version;
  NvU32 validHybridModes;
  NvU32 hybridStatus;
  NvU32 hybridDefaultGPU;
  NvU32 hybridUIState;
  NvU32 hybridDriverState;
  NvU32 bIsHybridPerfSliSupported : 1;
  NvU32 bIsHybridMCP : 1;
  NvU32 bIsHybridMobileSystem : 1;
  NvU32 transferNodeType;
} NV_HYBRID_INFO_v2;
typedef struct {
  NvU32 version;
  NvU32 validHybridModes;
  NvU32 hybridStatus;
  NvU32 hybridDefaultGPU;
  NvU32 hybridUIState;
  NvU32 hybridDriverState;
  NvU32 bIsHybridPerfSliSupported : 1;
  NvU32 bIsHybridMCP : 1;
  NvU32 bIsHybridMobileSystem : 1;
  NvU32 transferNodeType;
  NvU8 showHybridUI;
} NV_HYBRID_INFO_v3;
typedef struct {
  NvU32 version;
  NvU32 validHybridModes;
  NvU32 hybridStatus;
  NvU32 hybridDefaultGPU;
  NvU32 hybridUIState;
  NvU32 hybridDriverState;
  NvU32 bIsHybridPerfSliSupported : 1;
  NvU32 bIsHybridMCP : 1;
  NvU32 bIsHybridMobileSystem : 1;
  NvU32 transferNodeType;
  NvU8 showHybridUI;
  NV_HYBRID_TRANSITION_METHOD transMethod;
} NV_HYBRID_INFO;
#define NV_HYBRID_INFO_VER_1 MAKE_NVAPI_VERSION(NV_HYBRID_INFO_v1, 1)
#define NV_HYBRID_INFO_VER_2 MAKE_NVAPI_VERSION(NV_HYBRID_INFO_v2, 2)
#define NV_HYBRID_INFO_VER_3 MAKE_NVAPI_VERSION(NV_HYBRID_INFO_v3, 3)
#define NV_HYBRID_INFO_VER MAKE_NVAPI_VERSION(NV_HYBRID_INFO, 4)
typedef enum {
  NV_HYBRID_STATUS_OK = 0x00000000,
  NV_HYBRID_STATUS_CHIPSET_NOT_SUPPORTED = 0x00000001,
  NV_HYBRID_STATUS_MGPU_NOT_SUPPORTED = 0x00000002,
  NV_HYBRID_STATUS_DGPU_NOT_SUPPORTED = 0x00000004,
  NV_HYBRID_STATUS_NO_ASYNC_DMA_ENGINE = 0x00000008,
  NV_HYBRID_STATUS_SBIOS_NOT_CONFIGURED = 0x00000010,
  NV_HYBRID_STATUS_DGPUS_NOT_IDENTICAL = 0x00000020,
  NV_HYBRID_STATUS_INVALID_GPU_COUNT = 0x00000040,
  NV_HYBRID_STATUS_DGPU_DEEP_IDLE_NOT_SUPPORTED = 0x00000080
} NV_HYBRID_STATUS;
typedef enum {
  NV_HYBRID_VALID_MODE_NONE = 0x00000000,
  NV_HYBRID_VALID_MODE_POWER = 0x00000001,
  NV_HYBRID_VALID_MODE_PERF = 0x00000002,
  NV_HYBRID_VALID_MODE_PERFSLI = 0x00000004,
  NV_HYBRID_VALID_MODE_MULTI_ADAPTER = 0x00000008,
  NV_HYBRID_VALID_MODE_POWER_DEEP_IDLE = 0x00000010
} NV_HYBRID_VALID_MODES;
typedef enum _NV_HYBRID_TRANSFER_NODE {
  NV_HYBRID_TRANSFER_NODE_3D = 0x00000000,
  NV_HYBRID_TRANSFER_NODE_CIPHER = 0x00000001,
  NV_HYBRID_TRANSFER_NODE_VP = 0x00000002,
  NV_HYBRID_TRANSFER_NODE_DMACOPY0 = 0x00000003,
  NV_HYBRID_TRANSFER_NODE_DMACOPY1 = 0x00000004,
  NV_HYBRID_TRANSFER_NODE_UNKNOWN = 0xFFFFFFFF
} NV_HYBRID_TRANSFER_NODE;
typedef enum _NV_HYBRID_STATE {
  NV_HYBRID_STATE_POWER = 0x00000000,
  NV_HYBRID_STATE_PERF = 0x00000001,
  NV_HYBRID_STATE_MULTI_ADAPTER = 0x00000002,
  NV_HYBRID_STATE_INVALID = 0xFFFFFFFF,
} NV_HYBRID_STATE;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_GetHybridInfo(NV_HYBRID_INFO *pHybridInfo);
typedef enum _NV_COPROC_STATUS {
  NV_COPROC_STATUS_OK = 0x00000000,
  NV_COPROC_STATUS_CHIPSET_NOT_SUPPORTED = 0x00000001,
  NV_COPROC_STATUS_MGPU_NOT_SUPPORTED = 0x00000002,
  NV_COPROC_STATUS_DGPU_NOT_SUPPORTED = 0x00000004,
  NV_COPROC_STATUS_INVALID_GPU_COUNT = 0x00000008,
  NV_COPROC_STATUS_DISABLED_BY_REG_KEY = 0x00000010,
  NV_COPROC_STATUS_DGPU_POSTING_DEVICE = 0x00000020,
  NV_COPROC_STATUS_DISABLED_BY_HYBRID = 0x00000040,
  NV_COPROC_STATUS_OS_NOT_SUPPORTED = 0x00000080,
  NV_COPROC_STATUS_SBIOS_NOT_CONFIGURED = 0x00000100,
  NV_COPROC_STATUS_DGPU_NOT_SUPPORTED_BY_MSHYBRID = 0x00000200,
  NV_COPROC_STATUS_TRANSCODE_ONLY_NOT_SUPPORTED = 0x00000400,
  NV_COPROC_STATUS_XGPU_NOT_SUPPORTED = 0x00000800,
  NV_COPROC_STATUS_DISABLED_NOT_SUPPORTED_IGPU_DRIVER_MODEL = 0x00001000,
  NV_COPROC_STATUS_UNKNOWN = 0xFFFFFFFF,
} NV_COPROC_STATUS;
typedef enum _NV_COPROC_PROBLEM_TYPE {
  NV_COPROC_PROBLEM_MISC = 0x00000001,
  NV_COPROC_PROBLEM_DISABLED = 0x00000002,
  NV_COPROC_PROBLEM_DDI_ACQUIRE = 0x00000004,
  NV_COPROC_PROBLEM_BUS_SCAN = 0x00000008,
  NV_COPROC_PROBLEM_POWER_EVENT = 0x00000010,
  NV_COPROC_PROBLEM_PS_RULE = 0x00000020,
  NV_COPROC_PROBLEM_ACPI = 0x00000040,
  NV_COPROC_PROBLEM_DEVICE = 0x00000080,
  NV_COPROC_PROBLEM_OUTSTANDING_LOCK = 0x00000100,
  NV_COPROC_PROBLEM_CPUVISIBLE_SURFACE = 0x00000200,
  NV_COPROC_PROBLEM_SRLESS_MONITOR = 0x00000400,
  NV_COPROC_PROBLEM_AUDIO_MONITOR = 0x00000800,
  NV_COPROC_PROBLEM_FLIP = 0x00001000,
  NV_COPROC_PROBLEM_CMD_BUF = 0x00002000,
  NV_COPROC_PROBLEM_DEFERRED_WORK = 0x00004000,
  NV_COPROC_PROBLEM_SR_INACTIVE = 0x00008000,
  NV_COPROC_PROBLEM_REF_RM = 0x00010000,
  NV_COPROC_PROBLEM_REF_MSHYBRID = 0x00020000,
} NV_COPROC_PROBLEM_TYPE;
typedef enum _NV_COPROC_STATE {
  NV_COPROC_STATE_DGPU_GOLD = 0x00000000,
  NV_COPROC_STATE_DGPU_ON = 0x00000001,
  NV_COPROC_STATE_DGPU_GC6 = 0x00000002,
} NV_COPROC_STATE;
typedef enum _NV_COPROC_GC6_TYPE {
  NV_COPROC_GC6_TYPE_NONE = 0x00000000,
  NV_COPROC_GC6_TYPE_NVPM = 0x00000001,
  NV_COPROC_GC6_TYPE_OSPM = 0x00000002,
  NV_COPROC_GC6_TYPE_FAST = 0x00000003,
  NV_COPROC_GC6_TYPE_INCREMENTAL = 0x00000004,
} NV_COPROC_GC6_TYPE;
typedef enum _NV_JT_FLAGS {
  NV_JT_FLAGS_NONE = 0x00000000,
  NV_JT_FLAGS_GC6_ENABLED = 0x00000001,
  NV_JT_FLAGS_SUPPORTS_GC6_TDR = 0x00000002,
} NV_JT_FLAGS;
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocStatus(NvU32 *pCoprocStatus, NV_COPROC_STATE *pCoprocState);
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocStatusEx(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NvU32 *pCoprocStatus,
                                               __inout NV_COPROC_STATE *pCoprocState);
typedef enum {
  NVAPI_CMD_GET,
  NVAPI_CMD_SET,
} NVAPI_CMD;
typedef struct _NVAPI_COPROC_CONTROL_LIMITED_CYCLES_V1 {
  NvU32 version;
  NVAPI_CMD cmd;
  NvU32 cyclesLimited : 1;
  NvU32 reserved : 31;
  NvU64 powerTransitionCount;
  NvU64 timeSinceBootMs;
  NvU64 budget;
} NVAPI_COPROC_CONTROL_LIMITED_CYCLES_V1;
typedef NVAPI_COPROC_CONTROL_LIMITED_CYCLES_V1 NVAPI_COPROC_CONTROL_LIMITED_CYCLES;
#define NVAPI_COPROC_CONTROL_LIMITED_CYCLES_VER1 MAKE_NVAPI_VERSION(NVAPI_COPROC_CONTROL_LIMITED_CYCLES_V1, 1)
#define NVAPI_COPROC_CONTROL_LIMITED_CYCLES_VER NVAPI_COPROC_CONTROL_LIMITED_CYCLES_VER1
NVAPI_INTERFACE NvAPI_Coproc_ControlLimitedCycles(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NVAPI_COPROC_CONTROL_LIMITED_CYCLES *coprocData);
#define NVAPI_COPROC_REGISTER_PROCESS_DISABLE_GOLD 0x00000001
#define NVAPI_COPROC_REGISTER_PROCESS_DISABLE_GC6 0x00000002
#define NVAPI_COPROC_REGISTER_PROCESS_ENABLE_GC5 0x00000004
#define NVAPI_COPROC_REGISTER_PROCESS_ALL 0x00000007
typedef struct _NVAPI_COPROC_REGISTER_PROCESS_V1 {
  NvU32 version;
  NvU32 processSettings;
  NvU32 processSettingsMask;
  NvU32 GC5frameRateFPS;
} NVAPI_COPROC_REGISTER_PROCESS_V1;
typedef NVAPI_COPROC_REGISTER_PROCESS_V1 NVAPI_COPROC_REGISTER_PROCESS;
#define NVAPI_COPROC_REGISTER_PROCESS_VER1 MAKE_NVAPI_VERSION(NVAPI_COPROC_REGISTER_PROCESS_V1, 1)
#define NVAPI_COPROC_REGISTER_PROCESS_VER NVAPI_COPROC_REGISTER_PROCESS_VER1
NVAPI_INTERFACE NvAPI_Coproc_RegisterProcess(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __in NVAPI_COPROC_REGISTER_PROCESS *coprocData);
typedef enum _NV_D3COLD_SUPPORT_TYPE {
  NV_D3COLD_SUPPORT_NONE = 0,
  NV_D3COLD_SUPPORT_GC_OFF_1_0 = 1,
  NV_D3COLD_SUPPORT_GC_OFF_3_0 = 2
} NV_D3COLD_SUPPORT_TYPE;
typedef enum _NV_SBIOS_OPTIMUS_HDA_CAP_TYPE {
  NV_SBIOS_OPTIMUS_HDA_CAP_NONE = 0,
  NV_SBIOS_OPTIMUS_HDA_CAP_ON_BOOT_HDA_DISABLED,
  NV_SBIOS_OPTIMUS_HDA_CAP_ON_BOOT_HDA_PRESENT
} NV_SBIOS_OPTIMUS_HDA_CAP_TYPE;
typedef struct _RTD3DRKEY {
  union {
    struct {
      NvU32 enable : 1;
      NvU32 overrideRM : 1;
      NvU32 overridePlaform : 1;
      NvU32 turnONCorePower : 1;
      NvU32 enableASPM : 2;
      NvU32 reserved : 26;
    } details;
    NvU32 value;
  };
} RTD3DRKEY_V1, *PRTD3DRKEY_V1;
typedef struct _NV_RTD3_SUPPORT_INFO {
  struct {
    NvU32 DRKeyExists : 1;
    NvU32 platformDSMSupport : 1;
    NvU32 PerstDelayNegotiationFailed : 1;
    NvU32 chipSupport : 1;
    NvU32 GC6Support : 1;
    NvU32 GCOFFSupport : 1;
    NvU32 AUXPowerGC6Negotiated : 1;
    NvU32 AUXPowerGCOFFNegotiated : 1;
    NvU32 corePowerCutAllowed : 1;
    NvU32 powerManageWithxUSB : 1;
    NvU32 noD3OnShortIdleWithxUSBPort : 1;
    NvU32 noD3WithxUSBDeviceConnect : 1;
    NvU32 noD3OnWithxUSBAtD0State : 1;
    NvU32 noD3OnWithHDAAtD0State : 1;
    NvU32 reserved : 18;
  } config;
  NvU16 GC6TotalBoardPowerMilliWatts;
  NvU16 GCOffTotalBoardPowerMilliWatts;
  NvU16 perstDelayMicroSecs;
  RTD3DRKEY_V1 DRKey;
} NV_RTD3_SUPPORT_INF_V1;
typedef enum {
  PCIEPOWERCONTROL_KEY_ORDER_CHIPSET_GPU_ID = 1,
  PCIEPOWERCONTROL_KEY_ORDER_WILDCARD,
  PCIEPOWERCONTROL_KEY_ORDER_CHIPSET_ID,
  PCIEPOWERCONTROL_KEY_ORDER_MAX
} PCIEPOWERCONTROL_KEY_ORDER;
typedef enum _PCIEPOWERCONTROL_KEY_LOCATION {
  PCIEPOWERCONTROL_KEY_LOCATION_NOT_PRESENT = 0,
  PCIEPOWERCONTROL_KEY_LOCATION_GLOBAL,
  PCIEPOWERCONTROL_KEY_LOCATION_ADAPTER,
  PCIEPOWERCONTROL_KEY_LOCATION_UEFI,
  PCIEPOWERCONTROL_KEY_LOCATION_DR,
} PCIEPOWERCONTROL_KEY_LOCATION;
typedef struct {
  struct {
    NvU32 DRKeyExists : 1;
    NvU32 platformDSMSupport : 1;
    NvU32 PerstDelayNegotiationFailed : 1;
    NvU32 chipSupport : 1;
    NvU32 GC6Support : 1;
    NvU32 GCOFFSupport : 1;
    NvU32 AUXPowerGC6Negotiated : 1;
    NvU32 AUXPowerGCOFFNegotiated : 1;
    NvU32 corePowerCutAllowed : 1;
    NvU32 powerManageWithxUSB : 1;
    NvU32 noD3OnShortIdleWithxUSBPort : 1;
    NvU32 noD3WithxUSBDeviceConnect : 1;
    NvU32 noD3OnWithxUSBAtD0State : 1;
    NvU32 noD3OnWithHDAAtD0State : 1;
    NvU32 reserved : 18;
  } config;
  NvU16 GC6TotalBoardPowerMilliWatts;
  NvU16 GCOffTotalBoardPowerMilliWatts;
  NvU16 perstDelayMicroSecs;
  RTD3DRKEY_V1 DRKey;
  PCIEPOWERCONTROL_KEY_ORDER identifiedKeyOrder;
  PCIEPOWERCONTROL_KEY_LOCATION identifiedKeyLocation;
} NV_RTD3_SUPPORT_INF_V2;
typedef struct {
  NvU32 version;
  NvU32 coprocStatusMask;
  NvU32 coprocFlags;
  NvU32 totalReferenceCount;
  NvU32 deviceCount;
  NvU32 allocationCount;
  NvU32 activeEntryPointCount;
  NvU32 timeInCurrentStateMs;
  NvU32 timeInLastStateMs;
  NvU8 currentState;
  NvU8 lastState;
} NV_COPROC_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 coprocStatusMask;
  NvU32 coprocFlags;
  NvU32 totalReferenceCount;
  NvU32 deviceCount;
  NvU32 allocationCount;
  NvU32 activeEntryPointCount;
  NvU32 timeInCurrentStateMs;
  NvU32 timeInLastStateMs;
  NvU8 currentState;
  NvU8 lastState;
  NvU32 goldMask;
  NvU32 GC6Mask;
  NvU32 JTFlags;
} NV_COPROC_INFO_V2;
typedef struct {
  NvU32 version;
  NvU32 coprocStatusMask;
  NvU32 coprocFlags;
  NvU32 totalReferenceCount;
  NvU32 deviceCount;
  NvU32 allocationCount;
  NvU32 activeEntryPointCount;
  NvU32 timeInCurrentStateMs;
  NvU32 timeInLastStateMs;
  NvU8 currentState;
  NvU8 lastState;
  NvU32 goldMask;
  NvU32 GC6Mask;
  NvU32 JTFlags;
  NvU32 refCountGC6;
} NV_COPROC_INFO_V3;
typedef struct {
  NvU32 version;
  NvU32 coprocStatusMask;
  NvU32 coprocFlags;
  NvU32 totalReferenceCount;
  NvU32 deviceCount;
  NvU32 allocationCount;
  NvU32 activeEntryPointCount;
  NvU32 timeInCurrentStateMs;
  NvU32 timeInLastStateMs;
  NvU8 currentState;
  NvU8 lastState;
  NvU32 goldMask;
  NvU32 GC6Mask;
  NvU32 JTFlags;
  NvU32 refCountGC6;
  NvU32 isRTD3Supported : 1;
  NvU32 reserved : 31;
  NV_D3COLD_SUPPORT_TYPE platformD3ColdSupportType;
} NV_COPROC_INFO_V4;
typedef struct {
  NvU32 version;
  NvU32 coprocStatusMask;
  NvU32 coprocFlags;
  NvU32 totalReferenceCount;
  NvU32 deviceCount;
  NvU32 allocationCount;
  NvU32 activeEntryPointCount;
  NvU32 timeInCurrentStateMs;
  NvU32 timeInLastStateMs;
  NvU8 currentState;
  NvU8 lastState;
  NvU32 goldMask;
  NvU32 GC6Mask;
  NvU32 JTFlags;
  NvU32 refCountGC6;
  NvU32 isRTD3Supported : 1;
  NvU32 isFastGC6Supported : 1;
  NvU32 reserved : 30;
  NV_D3COLD_SUPPORT_TYPE platformD3ColdSupportType;
  NvU8 gc6Type;
} NV_COPROC_INFO_V5;
typedef struct {
  NvU32 version;
  NvU32 coprocStatusMask;
  NvU32 coprocFlags;
  NvU32 totalReferenceCount;
  NvU32 deviceCount;
  NvU32 allocationCount;
  NvU32 activeEntryPointCount;
  NvU32 timeInCurrentStateMs;
  NvU32 timeInLastStateMs;
  NvU8 currentState;
  NvU8 lastState;
  NvU32 goldMask;
  NvU32 GC6Mask;
  NvU32 JTFlags;
  NvU32 refCountGC6;
  NvU32 isRTD3Supported : 1;
  NvU32 isFastGC6Supported : 1;
  NvU32 reserved : 30;
  NV_D3COLD_SUPPORT_TYPE platformD3ColdSupportType;
  NvU8 gc6Type;
  NV_SBIOS_OPTIMUS_HDA_CAP_TYPE sbiosHDASupport;
  NV_RTD3_SUPPORT_INF_V1 RTD3SupportInfo;
} NV_COPROC_INFO_V6;
typedef struct {
  NvU32 version;
  NvU32 coprocStatusMask;
  NvU32 coprocFlags;
  NvU32 totalReferenceCount;
  NvU32 deviceCount;
  NvU32 allocationCount;
  NvU32 activeEntryPointCount;
  NvU32 timeInCurrentStateMs;
  NvU32 timeInLastStateMs;
  NvU8 currentState;
  NvU8 lastState;
  NvU32 goldMask;
  NvU32 GC6Mask;
  NvU32 JTFlags;
  NvU32 refCountGC6;
  NvU32 isRTD3Supported : 1;
  NvU32 isFastGC6Supported : 1;
  NvU32 reserved : 30;
  NV_D3COLD_SUPPORT_TYPE platformD3ColdSupportType;
  NvU8 gc6Type;
  NV_SBIOS_OPTIMUS_HDA_CAP_TYPE sbiosHDASupport;
  NV_RTD3_SUPPORT_INF_V2 RTD3SupportInfo;
} NV_COPROC_INFO_V7;
typedef NV_COPROC_INFO_V7 NV_COPROC_INFO;
#define NV_COPROC_INFO_VER_1 MAKE_NVAPI_VERSION(NV_COPROC_INFO_V1, 1)
#define NV_COPROC_INFO_VER_2 MAKE_NVAPI_VERSION(NV_COPROC_INFO_V2, 2)
#define NV_COPROC_INFO_VER_3 MAKE_NVAPI_VERSION(NV_COPROC_INFO_V3, 3)
#define NV_COPROC_INFO_VER_4 MAKE_NVAPI_VERSION(NV_COPROC_INFO_V4, 4)
#define NV_COPROC_INFO_VER_5 MAKE_NVAPI_VERSION(NV_COPROC_INFO_V5, 5)
#define NV_COPROC_INFO_VER_6 MAKE_NVAPI_VERSION(NV_COPROC_INFO_V6, 6)
#define NV_COPROC_INFO_VER_7 MAKE_NVAPI_VERSION(NV_COPROC_INFO_V7, 7)
#define NV_COPROC_INFO_VER NV_COPROC_INFO_VER_7
typedef enum _NV_COPROC_FLAGS {
  NV_COPROC_FLAGS_NONE = 0x00000000,
  NV_COPROC_FLAGS_MONITOR_FOUND = 0x00000001,
  NV_COPROC_FLAGS_TIMER_SCHEDULED = 0x00000002,
  NV_COPROC_FLAGS_GOLD_ON_HYBRID = 0x00000004,
  NV_COPROC_FLAGS_GCOFF_ENABLED = 0x00000004,
  NV_COPROC_FLAGS_CHECK_SBIOS_COOKIE = 0x00000008,
  NV_COPROC_FLAGS_SBIOS_NOT_CONFIGURED = 0x00000010,
  NV_COPROC_FLAGS_IGPU_MODE_ONLY = 0x00000020,
  NV_COPROC_FLAGS_HDMI_AUDIO_DYNAMIC = 0x00000040,
  NV_COPROC_FLAGS_FORCE_GPU_SWITCH_AVAILABLE = 0x00000080,
  NV_COPROC_FLAGS_FORCE_OPTIMUS = 0x00000100,
  NV_COPROC_FLAGS_REQUIRED_SBIOS_COOKIE = 0x00000200,
  NV_COPROC_FLAGS_DGPU_MODE_ONLY = 0x00000400,
  NV_COPROC_FLAGS_ENABLE_FRAMERATE_LIMITER = 0x00000800,
  NV_COPROC_FLAGS_FWD_OPTIMUS = 0x00001000,
  NV_COPROC_FLAGS_TRANSCODE = 0x00002000,
  NV_COPROC_FLAGS_GPU_SOLDERED_ON_MB = 0x00004000,
  NV_COPROC_FLAGS_MS_HYBRID = 0x00008000,
  NV_COPROC_FLAGS_CHECK_XGPU_CONFIG = 0x00010000,
  NV_COPROC_FLAGS_QUADRO = 0x00020000,
  NV_COPROC_FLAGS_MS_HYBRID_NV_APPROVED = 0x00040000,
  NV_COPROC_FLAGS_DGPU_PASSTHROUGH = 0x00080000,
  NV_COPROC_FLAGS_DGPU_VIDEOLESS = 0x00100000,
  NV_COPROC_FLAGS_TRANSITION_LIMITED = 0x00200000,
  NV_COPROC_FLAGS_HW_NOT_SUPPORT_MSHYBRID_WIN10_PLUS = 0x00400000,
  NV_COPROC_FLAGS_OPTIMUS_STYLE_POWER_MANAGEMENT = 0x00800000,
  NV_COPROC_FLAGS_STOPWHITELISTING_APP_FOR_DGPU = 0x01000000,
  NV_COPROC_FLAGS_D3HOT_SUPPORTED = 0x02000000,
  NV_COPROC_FLAGS_HDMI_AUDIO_DYNAMIC_ONLY_DEVICE_REFRESH = 0x04000000,
  NV_COPROC_FLAGS_AGGRESSIVE_PSTATE_ONLY_SUPPORTED = 0x08000000,
  NV_COPROC_FLAGS_LONG_IDLE_D3_SUPPORTED = 0x10000000,
  NV_COPROC_FLAGS_ARE_ENGINES_IDLE = 0x20000000,
} NV_COPROC_FLAGS;
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocInfo(__inout NV_COPROC_INFO *pCoprocInfo);
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocInfoEx(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_COPROC_INFO *pCoprocInfo);
NVAPI_INTERFACE NvAPI_Coproc_SetCoprocInfoFlags(NvU32 coprocInfoFlags);
typedef struct _NV_COPROC_FLAGS_EX_V1 {
  NvU32 version;
  NvU32 is_IGPU_MODE_ONLY : 1;
  NvU32 is_DGPU_MODE_ONLY : 1;
  NvU32 reserved : 30;
} NV_COPROC_FLAGS_EX_V1;
typedef struct _NV_COPROC_FLAGS_EX_V2 {
  NvU32 version;
  NvU32 is_IGPU_MODE_ONLY : 1;
  NvU32 is_DGPU_MODE_ONLY : 1;
  NvU32 reserved : 30;
  NvPhysicalGpuHandle hPhysicalGpu;
} NV_COPROC_FLAGS_EX_V2;
#define NV_COPROC_FLAGS_EX_VER1 MAKE_NVAPI_VERSION(NV_COPROC_FLAGS_EX_V1, 1)
#define NV_COPROC_FLAGS_EX_VER2 MAKE_NVAPI_VERSION(NV_COPROC_FLAGS_EX_V2, 2)
#define NV_COPROC_FLAGS_EX_VER NV_COPROC_FLAGS_EX_VER2
typedef NV_COPROC_FLAGS_EX_V2 NV_COPROC_FLAGS_EX;
NVAPI_INTERFACE NvAPI_Coproc_SetCoprocInfoFlagsEx(NV_COPROC_FLAGS_EX *coprocInfoExFlags);
NVAPI_INTERFACE NvAPI_Coproc_SetCoprocInfoFlagsEx2(__in NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 coprocInfoFlags);
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocInfoFlagsEx(NV_COPROC_FLAGS_EX *coprocInfoExFlags);
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocInfoFlagsEx2(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                   __out NV_COPROC_FLAGS_EX *coprocInfoExFlags);
typedef enum _NVAPI_COPROC_OVERRIDE_OPTION {
  NVAPI_COPROC_OVERRIDE_OPTION_SET = 0,
  NVAPI_COPROC_OVERRIDE_OPTION_RESET = 1
} NVAPI_COPROC_OVERRIDE_OPTION;
typedef struct _NV_COPROC_OVERRIDE_INFO_FLAGS {
  NvU32 version;
  NVAPI_COPROC_OVERRIDE_OPTION coprocOverrideOption;
  NvU32 is_STOP_WHITELISTING_APP_FOR_DGPU : 1;
  NvU32 reserved : 31;
} NV_COPROC_OVERRIDE_INFO_FLAGS_V1;
typedef NV_COPROC_OVERRIDE_INFO_FLAGS_V1 NV_COPROC_OVERRIDE_INFO_FLAGS;
#define NV_COPROC_OVERRIDE_INFO_FLAGS_VER1 MAKE_NVAPI_VERSION(NV_COPROC_OVERRIDE_INFO_FLAGS_V1, 1)
#define NV_COPROC_OVERRIDE_INFO_FLAGS_VER NV_COPROC_OVERRIDE_INFO_FLAGS_VER1
NVAPI_INTERFACE NvAPI_Coproc_OverrideCoprocInfoFlags(NV_COPROC_OVERRIDE_INFO_FLAGS *coprocOverrideInfoFlags);
NVAPI_INTERFACE NvAPI_Coproc_OverrideCoprocInfoFlagsEx(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                       __in NV_COPROC_OVERRIDE_INFO_FLAGS *coprocOverrideInfoFlags);
typedef enum {
  NV_COPROC_POWER_OFF_MODE_UNSAFE = 0,
  NV_COPROC_POWER_OFF_MODE_GPU_OFF = 1,
  NV_COPROC_POWER_OFF_MODE_HDA_REMOVE = 0xff10,
} NV_COPROC_POWER_OFF_MODE;
NVAPI_INTERFACE NvAPI_Coproc_NotifyCoprocPowerState(NvU32 IsSafetoPowerOff, NvU64 SequenceNumber, NvU32 *pStatus);
NVAPI_INTERFACE NvAPI_Coproc_NotifyCoprocPowerStateEx(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                      __in NvU32 IsSafetoPowerOff, __in NvU64 SequenceNumber,
                                                      __out NvU32 *pStatus);
typedef struct {
  NvU32 version;
  NvU32 appStatus;
} NV_COPROC_APP_INFO;
#define NV_COPROC_APP_INFO_VER MAKE_NVAPI_VERSION(NV_COPROC_APP_INFO, 1)
typedef enum {
  NV_COPROC_APP_STATUS_ENABLED = 0x00000000,
  NV_COPROC_APP_STATUS_DISABLED = 0x00000001,
} NV_COPROC_APP_STATUS;
NVAPI_INTERFACE NvAPI_Coproc_GetApplicationCoprocInfo(NV_COPROC_APP_INFO *pCoprocAppInfo);
#define NV_COPROC_STATE_CHANGE_LOG_COUNT 32
typedef enum _NV_COPROC_POWER_STATE {
  NV_COPROC_POWER_STATE_ERROR = 0,
  NV_COPROC_POWER_STATE_ON,
  NV_COPROC_POWER_STATE_GOLD,
  NV_COPROC_POWER_STATE_EXITING_GOLD,
  NV_COPROC_POWER_STATE_ENTERING_GOLD,
  NV_COPROC_POWER_STATE_WAITING_FOR_SVC,
  NV_COPROC_POWER_STATE_GC6,
  NV_COPROC_POWER_STATE_EXITING_GC6,
  NV_COPROC_POWER_STATE_ENTERING_GC6,
  NV_COPROC_POWER_STATE_READY_GOLD,
  NV_COPROC_POWER_STATE_READY_GC6
} NV_COPROC_POWER_STATE;
typedef struct _NV_COPROC_STATE_CHANGE_ENTRY {
  NvU64 timeStampMicroseconds;
  NV_COPROC_POWER_STATE coprocPowerState;
  NvU32 coprocReason;
} NV_COPROC_STATE_CHANGE_ENTRY;
typedef struct _NV_COPROC_GET_GOLD_STATISTICS_V1 {
  NvU32 version;
  NvU32 dwGoldTimeoutValue;
  NvU32 dwGoldTransitionCount;
  NvU32 dwMinTimeInGoldMs;
  NvU32 dwMaxTimeInGoldMs;
  NvU32 dwAvgTimeInGoldMs;
  NvU32 dwMinTimeEnteringGoldMs;
  NvU32 dwMaxTimeEnteringGoldMs;
  NvU32 dwAvgTimeEnteringGoldMs;
  NvU32 dwMinTimeExitingGoldMs;
  NvU32 dwMaxTimeExitingGoldMs;
  NvU32 dwAvgTimeExitingGoldMs;
  NV_COPROC_STATE_CHANGE_ENTRY stateChangeLog[NV_COPROC_STATE_CHANGE_LOG_COUNT];
} NV_COPROC_GOLD_STATISTICS_V1;
#define NV_COPROC_GOLD_STATISTICS_VER1 MAKE_NVAPI_VERSION(NV_COPROC_GOLD_STATISTICS_V1, 1)
typedef struct _NV_COPROC_GOLD_STATISTICS_V2 {
  NvU32 version;
  NvU32 dwGoldTimeoutValue;
  NvU32 dwGoldTransitionCount;
  NvU32 dwMinTimeInGoldMs;
  NvU32 dwMaxTimeInGoldMs;
  NvU32 dwAvgTimeInGoldMs;
  NvU32 dwMinTimeEnteringGoldMs;
  NvU32 dwMaxTimeEnteringGoldMs;
  NvU32 dwAvgTimeEnteringGoldMs;
  NvU32 dwMinTimeExitingGoldMs;
  NvU32 dwMaxTimeExitingGoldMs;
  NvU32 dwAvgTimeExitingGoldMs;
  NV_COPROC_STATE_CHANGE_ENTRY stateChangeLog[NV_COPROC_STATE_CHANGE_LOG_COUNT];
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvU32 refCountGoldMask;
  NvU32 refCountGoldMaskCumulative;
  NvU32 totTimeInGoldMs;
  NvU32 totTimeEnteringGoldMs;
  NvU32 totTimeExitingGoldMs;
  NvS32 goldHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGoldHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGoldHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
} NV_COPROC_GOLD_STATISTICS_V2;
#define NV_COPROC_GOLD_STATISTICS_VER2 MAKE_NVAPI_VERSION(NV_COPROC_GOLD_STATISTICS_V2, 2)
typedef struct _NV_COPROC_GOLD_STATISTICS_V3 {
  NvU32 version;
  NvU32 dwGoldTimeoutValue;
  NvU32 dwGoldTransitionCount;
  NvU32 dwMinTimeInGoldMs;
  NvU32 dwMaxTimeInGoldMs;
  NvU32 dwAvgTimeInGoldMs;
  NvU32 dwMinTimeEnteringGoldMs;
  NvU32 dwMaxTimeEnteringGoldMs;
  NvU32 dwAvgTimeEnteringGoldMs;
  NvU32 dwMinTimeExitingGoldMs;
  NvU32 dwMaxTimeExitingGoldMs;
  NvU32 dwAvgTimeExitingGoldMs;
  NV_COPROC_STATE_CHANGE_ENTRY stateChangeLog[NV_COPROC_STATE_CHANGE_LOG_COUNT];
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvU32 refCountGoldMask;
  NvU32 refCountGoldMaskCumulative;
  NvU32 totTimeInGoldMs;
  NvU32 totTimeEnteringGoldMs;
  NvU32 totTimeExitingGoldMs;
  NvS32 goldHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGoldHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGoldHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvU32 exitD3HotGCOFFCount;
  NvU32 minTimeExitD3HotGCOFFDurationMs;
  NvU32 maxTimeExitD3HotGCOFFDurationMs;
  NvU32 avgTimeExitD3HotGCOFFDurationMs;
  NvU32 totTimeExitD3HotGCOFFDurationMs;
  NvU32 minTimeRmExitD3HotGCOFFDurationMs;
  NvU32 maxTimeRmExitD3HotGCOFFDurationMs;
  NvU32 avgTimeRmExitD3HotGCOFFDurationMs;
  NvU32 totTimeRmExitD3HotGCOFFDurationMs;
  NvU32 minTimeRmExitGCOFFDurationMs;
  NvU32 maxTimeRmExitGCOFFDurationMs;
  NvU32 avgTimeRmExitGCOFFDurationMs;
  NvU32 totTimeRmExitGCOFFDurationMs;
  NvS32 exitD3HotGCOFFHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 rmExitD3HotGCOFFHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 rmExitGCOFFHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
} NV_COPROC_GOLD_STATISTICS_V3;
#define NV_COPROC_GOLD_STATISTICS_VER3 MAKE_NVAPI_VERSION(NV_COPROC_GOLD_STATISTICS_V3, 3)
typedef struct _NV_COPROC_GOLD_STATISTICS_V4 {
  NvU32 version;
  NvU32 dwGoldTimeoutValue;
  NvU32 dwGoldTransitionCount;
  NvU32 dwMinTimeInGoldMs;
  NvU32 dwMaxTimeInGoldMs;
  NvU32 dwAvgTimeInGoldMs;
  NvU32 dwMinTimeEnteringGoldMs;
  NvU32 dwMaxTimeEnteringGoldMs;
  NvU32 dwAvgTimeEnteringGoldMs;
  NvU32 dwMinTimeExitingGoldMs;
  NvU32 dwMaxTimeExitingGoldMs;
  NvU32 dwAvgTimeExitingGoldMs;
  NV_COPROC_STATE_CHANGE_ENTRY stateChangeLog[NV_COPROC_STATE_CHANGE_LOG_COUNT];
  NvU64 clearTime;
  NvU64 currentTime;
  NvU32 timeIncrement;
  NvU32 refCountGoldMask;
  NvU32 refCountGoldMaskCumulative;
  NvU32 totTimeInGoldMs;
  NvU32 totTimeEnteringGoldMs;
  NvU32 totTimeExitingGoldMs;
  NvS32 goldHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enteringGoldHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 exitingGoldHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvU32 exitD3HotGCOFFCount;
  NvU32 minTimeExitD3HotGCOFFDurationMs;
  NvU32 maxTimeExitD3HotGCOFFDurationMs;
  NvU32 avgTimeExitD3HotGCOFFDurationMs;
  NvU32 totTimeExitD3HotGCOFFDurationMs;
  NvU32 minTimeRmExitD3HotGCOFFDurationMs;
  NvU32 maxTimeRmExitD3HotGCOFFDurationMs;
  NvU32 avgTimeRmExitD3HotGCOFFDurationMs;
  NvU32 totTimeRmExitD3HotGCOFFDurationMs;
  NvU32 minTimeRmExitGCOFFDurationMs;
  NvU32 maxTimeRmExitGCOFFDurationMs;
  NvU32 avgTimeRmExitGCOFFDurationMs;
  NvU32 totTimeRmExitGCOFFDurationMs;
  NvS32 exitD3HotGCOFFHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 rmExitD3HotGCOFFHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 rmExitGCOFFHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NV_COUNTER_INFO inD3HotGCOffDurationMs;
  NV_COUNTER_INFO enterD3HotGCOffDurationMs;
  NV_COUNTER_INFO rmEnterD3HotGCOFFDurationMs;
  NV_COUNTER_INFO rmEnterD3ColdGCOFFDurationMs;
  NvS32 inD3HotGCOffHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 enterD3HotGCOffHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
  NvS32 rmEnterD3HotGCOFFHistogram[NV_GPU_STATE_CHANGE_LOG_COUNT];
} NV_COPROC_GOLD_STATISTICS_V4;
#define NV_COPROC_GOLD_STATISTICS_VER4 MAKE_NVAPI_VERSION(NV_COPROC_GOLD_STATISTICS_V4, 4)
typedef NV_COPROC_GOLD_STATISTICS_V4 NV_COPROC_GOLD_STATISTICS;
#define NV_COPROC_GOLD_STATISTICS_VER NV_COPROC_GOLD_STATISTICS_VER4
NVAPI_INTERFACE NvAPI_Coproc_GetGoldStatistics(NvU32 bClearStatistics, NV_COPROC_GOLD_STATISTICS *pCoprocGoldStats);
NVAPI_INTERFACE NvAPI_Coproc_GetGoldStatisticsEx(__in NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 bClearStatistics,
                                                 __out NV_COPROC_GOLD_STATISTICS *pCoprocGoldStats);
typedef enum _NV_COPROC_HYSTERESIS_TYPE {
  NV_COPROC_HYSTERESIS_GOLD,
  NV_COPROC_HYSTERESIS_GC6,
  NV_COPROC_HYSTERESIS_ALL,
  NV_COPROC_HYSTERESIS_NONE,
} NV_COPROC_HYSTERESIS_TYPE;
typedef struct _NV_COPROC_HYSTERESIS {
  NvU32 version;
  NV_COPROC_HYSTERESIS_TYPE type;
  NvU32 goldIdleTimeoutMs;
  NvU32 GC6IdleTimeoutMs;
} NV_COPROC_HYSTERESIS_V1;
typedef NV_COPROC_HYSTERESIS_V1 NV_COPROC_HYSTERESIS;
#define NV_COPROC_HYSTERESIS_VER1 MAKE_NVAPI_VERSION(NV_COPROC_HYSTERESIS_V1, 1)
#define NV_COPROC_HYSTERESIS_VER NV_COPROC_HYSTERESIS_VER1
NVAPI_INTERFACE NvAPI_Coproc_SetHysteresis(__inout NV_COPROC_HYSTERESIS *pCoprocSetHysteresis);
NVAPI_INTERFACE NvAPI_Coproc_SetHysteresisEx(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_COPROC_HYSTERESIS *pCoprocSetHysteresis);
NVAPI_INTERFACE NvAPI_Coproc_GetHysteresis(__inout NV_COPROC_HYSTERESIS *pCoprocGetHysteresis);
NVAPI_INTERFACE NvAPI_Coproc_GetHysteresisEx(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout NV_COPROC_HYSTERESIS *pCoprocGetHysteresis);
typedef struct _NV_COPROC_GC6_WAKE_BEHAVIOR {
  NvU32 version;
  NvU32 bUseHwTimer;
  NvU32 timeToWakeUs;
} NV_COPROC_GC6_WAKE_BEHAVIOR_V1;
typedef NV_COPROC_GC6_WAKE_BEHAVIOR_V1 NV_COPROC_GC6_WAKE_BEHAVIOR;
#define NV_COPROC_GC6_WAKE_BEHAVIOR_VER1 MAKE_NVAPI_VERSION(NV_COPROC_GC6_WAKE_BEHAVIOR_V1, 1)
#define NV_COPROC_GC6_WAKE_BEHAVIOR_VER NV_COPROC_GC6_WAKE_BEHAVIOR_VER1
NVAPI_INTERFACE NvAPI_Coproc_SetGC6WakeBehavior(__inout NV_COPROC_GC6_WAKE_BEHAVIOR *pCoprocSetGC6WakeBehavior);
NVAPI_INTERFACE NvAPI_Coproc_SetGC6WakeBehaviorEx(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                  __inout NV_COPROC_GC6_WAKE_BEHAVIOR *pCoprocSetGC6WakeBehavior);
NVAPI_INTERFACE NvAPI_Hybrid_ControlDriverHDABus(NvU32 stateChange);
NVAPI_INTERFACE NvAPI_Hybrid_ControlDriverHDABusEx(__in NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 stateChange);
NVAPI_INTERFACE NvAPI_Hybrid_ControlDriverHDA(NvU32 stateChange);
NVAPI_INTERFACE NvAPI_Hybrid_ControlDriverHDAEx(__in NvPhysicalGpuHandle hPhysicalGpu, __in NvU32 stateChange);
NVAPI_INTERFACE NvAPI_GetHybridStatusString(NvU32 nr, NvAPI_String szDesc);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_GetHybridModesString(NvU32 nr, NvAPI_String szDesc);
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocStatusString(NvU32 nr, NvAPI_String szDesc);
NVAPI_INTERFACE NvAPI_Coproc_GetCoprocFlagsString(NvU32 nr, NvAPI_String szDesc);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_LightWeightDGPU(NvU32 flags);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_HybridIGPUHeadsControl(NvU8 bHide);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_QueryHybridIGPUHeadsControl(NvU8 *pbHide);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_IsIntelHybrid(NvU8 *IsIntel);
typedef enum _NV_HYBRID_POWERSTATE {
  NV_HYBRID_POWERSTATE_OFF = 0x00,
  NV_HYBRID_POWERSTATE_ON = 0x01,
  NV_HYBRID_POWERSTATE_DEEPIDLE = 0x02,
} NV_HYBRID_POWERSTATE;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_SetDGPUPowerState(NV_HYBRID_POWERSTATE powerState);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_GetDGPUPowerState(NV_HYBRID_POWERSTATE *pPowerState);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_StartTransition(NV_HYBRID_MODE mode, NvTransitionHandle *phTransition);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_StopTransition(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);
typedef enum _NV_HYBRID_DRIVERSTATE {
  NV_HYBRID_DRIVERSTATE_UNKNOWN = 0x00,
  NV_HYBRID_DRIVERSTATE_DISABLED = 0x01,
  NV_HYBRID_DRIVERSTATE_ENABLED = 0x02,
  NV_HYBRID_DRIVERSTATE_PROBLEM = 0x03,
  NV_HYBRID_DRIVERSTATE_STARTING = 0x04,
} NV_HYBRID_DRIVERSTATE;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_SetDGPUDriverState(NvTransitionHandle hTransition, NV_HYBRID_DRIVERSTATE driverState);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_GetDGPUDriverState(NvTransitionHandle hTransition, NV_HYBRID_DRIVERSTATE *pDriverState);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_StartDisplaySwitch(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_StopDisplaySwitch(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_GetMirroredDisplays(NvTransitionHandle hTransition, NvU32 *pMirroredHeadIDs);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_SwapDisplays(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_SetDisplayMUX(NvTransitionHandle hTransition, NV_HYBRID_MODE mode);
#define NV_MAX_HYBRID_ACPI_IDS 16
typedef struct {
  NvU32 acpiId;
  NvU32 intelId;
  NvU32 displayId;
  NvPhysicalGpuHandle physicalGpu;
  NvU32 outputId;
} NV_HYBRID_INTEL_DEVICE_MAP_ENTRY;
typedef struct {
  NvU32 version;
  NvU32 count;
  NV_HYBRID_INTEL_DEVICE_MAP_ENTRY maps[NV_MAX_HYBRID_ACPI_IDS];
} NV_HYBRID_INTEL_DEVICE_MAP;
#define NV_HYBRID_INTEL_DEVICE_MAP_VER MAKE_NVAPI_VERSION(NV_HYBRID_INTEL_DEVICE_MAP, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_GetIntelDeviceMap(NV_HYBRID_INTEL_DEVICE_MAP *pMap);
typedef struct {
  NvU32 version;
  NvAPI_LongString appName;
  NvAPI_LongString friendlyName;
} NV_HYBRID_APP_INFO;
#define NV_HYBRID_APP_INFO_VER MAKE_NVAPI_VERSION(NV_HYBRID_APP_INFO, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_QueryUnblockedNonMigratableApps(NV_HYBRID_APP_INFO apps[NVAPI_MAX_3D_Apps], NvU32 *total);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_QueryBlockedMigratableApps(NV_HYBRID_APP_INFO apps[NVAPI_MAX_3D_Apps], NvU32 *total);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_SetAppMigrationState(NV_HYBRID_APP_INFO app, NvU32 flag);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_IsAppMigrationStateChangeable(NV_HYBRID_APP_INFO app, NvU32 *allowed);
#define NV_SET_HYBRID_MODE_DEFER_NON_MIGRATABLE_APP_SHUTDOWN 0x00000001
#define NVAPI_ADAPTIVE_POLICY_ON 0x00000002
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_SetHybridModeEx(NV_HYBRID_MODE mode, NvU32 flags);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_InitHybridMicroController();
NVAPI_INTERFACE NvAPI_CreateUnAttachedDisplayFromDisplay(NvDisplayHandle hNvDisplay,
                                                         NvUnAttachedDisplayHandle *pNvUnAttachedDisp);
typedef struct {
  NvU32 version;
  NvU32 isGPUScalingAvailable : 1;
  NvU32 isGPUFixedAspectRatioScalingAvailable : 1;
  NvU32 isMonitorScalingAvailable : 1;
  NvU32 isCenterScalingAvailable : 1;
} NV_GET_SCALING_CAPS_V1;
typedef struct {
  NvU32 version;
  union {
    NvU32 isGPUScalingAvailable : 1;
    NvU32 isGPUScalingToNative : 1;
  };
  union {
    NvU32 isGPUFixedAspectRatioScalingAvailable : 1;
    NvU32 isGPUScalingToAspectScanoutToNative : 1;
  };
  union {
    NvU32 isMonitorScalingAvailable : 1;
    NvU32 isGPUScalingToClosest : 1;
  };
  union {
    NvU32 isCenterScalingAvailable : 1;
    NvU32 isGPUScanoutToNative : 1;
  };
  NvU32 isGPUScalingToAspectScanoutToClosest : 1;
  NvU32 isGPUScanoutToClosest : 1;
  NvU32 isGpuRepeatToAspectScanoutToNative : 1;
  NvU32 reserved : 29;
  NV_SCALING defaultScaling;
  NV_SCALING currentScaling;
} NV_GET_SCALING_CAPS_V2;
typedef NV_GET_SCALING_CAPS_V2 NV_GET_SCALING_CAPS;
#define NV_GET_SCALING_CAPS_VER1 MAKE_NVAPI_VERSION(NV_GET_SCALING_CAPS_V1, 1)
#define NV_GET_SCALING_CAPS_VER2 MAKE_NVAPI_VERSION(NV_GET_SCALING_CAPS_V2, 2)
#define NV_GET_SCALING_CAPS_VER NV_GET_SCALING_CAPS_VER2
NVAPI_INTERFACE NvAPI_DISP_GetScalingCapsOverride(NvU32 displayId, NV_GET_SCALING_CAPS *pScalingCaps);
NVAPI_INTERFACE NvAPI_DISP_SetScalingCapsOverride(NvU32 displayId, NV_GET_SCALING_CAPS *pScalingCaps,
                                                  NV_SCALING preferredScaling);
NVAPI_INTERFACE NvAPI_GetScalingCaps(NvDisplayHandle hNvDisplay, NvU32 outputId, NV_GET_SCALING_CAPS *pScalingCaps);
NVAPI_INTERFACE NvAPI_DISP_GetScalingCaps(NvU32 displayId, NV_GET_SCALING_CAPS *pScalingCaps);
typedef struct {
  NvU32 version;
  NvU32 present;
  NvU32 fwVersion;
} NV_GPU_HYBRID_CONTROLLER_INFO;
#define NV_GPU_HYBRID_CONTROLLER_INFO_VER MAKE_NVAPI_VERSION(NV_GPU_HYBRID_CONTROLLER_INFO, 1)
NVAPI_INTERFACE NvAPI_GPU_GetHybridControllerInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                  NV_GPU_HYBRID_CONTROLLER_INFO *pHybridControllerInfo);
typedef struct {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NvU32 depth;
  NvU32 refresh;
  NvU32 format;
  NvU32 interlaced;
} NVAPI_DISPLAY_MODE;
NVAPI_INTERFACE NvAPI_Disp_EnumerateDisplayModes(NvDisplayHandle hNvDisplay, NvU32 modeIndex, NVAPI_DISPLAY_MODE *mode);
#define NV_MAX_PROTECTED_VIDEO_SESSIONS_V1 8
#define NV_MAX_PROTECTED_VIDEO_SESSIONS_V2 24
#define NV_MAX_PROTECTED_VIDEO_SESSIONS_V3 48
typedef enum _NV_PROTECTED_VIDEO_SESSION_TYPE {
  NV_VIDEO_SESSION_COPP = 0,
  NV_VIDEO_SESSION_OPM = 1
} NV_PROTECTED_VIDEO_SESSION_TYPE;
typedef struct _NVAPI_PROTECTED_VIDEO_SESSION_INFO_V1 {
  NvU32 version;
  NvU32 dwNumProtSessions;
  NV_PROTECTED_VIDEO_SESSION_TYPE sessionType[NV_MAX_PROTECTED_VIDEO_SESSIONS_V1];
} NVAPI_PROTECTED_VIDEO_SESSION_INFO_V1;
typedef struct _NVAPI_PROTECTED_VIDEO_SESSION_INFO_V2 {
  NvU32 version;
  NvU32 dwNumProtSessions;
  NV_PROTECTED_VIDEO_SESSION_TYPE sessionType[NV_MAX_PROTECTED_VIDEO_SESSIONS_V2];
} NVAPI_PROTECTED_VIDEO_SESSION_INFO_V2;
typedef struct _NVAPI_PROTECTED_VIDEO_SESSION_INFO_V3 {
  NvU32 version;
  NvU32 dwNumProtSessions;
  NV_PROTECTED_VIDEO_SESSION_TYPE sessionType[NV_MAX_PROTECTED_VIDEO_SESSIONS_V3];
} NVAPI_PROTECTED_VIDEO_SESSION_INFO_V3;
typedef NVAPI_PROTECTED_VIDEO_SESSION_INFO_V3 NVAPI_PROTECTED_VIDEO_SESSION_INFO;
#define NVAPI_PROTECTED_VIDEO_SESSION_INFO_VER_V1 MAKE_NVAPI_VERSION(NVAPI_PROTECTED_VIDEO_SESSION_INFO_V1, 1)
#define NVAPI_PROTECTED_VIDEO_SESSION_INFO_VER_V2 MAKE_NVAPI_VERSION(NVAPI_PROTECTED_VIDEO_SESSION_INFO_V2, 2)
#define NVAPI_PROTECTED_VIDEO_SESSION_INFO_VER_V3 MAKE_NVAPI_VERSION(NVAPI_PROTECTED_VIDEO_SESSION_INFO_V3, 3)
#define NVAPI_PROTECTED_VIDEO_SESSION_INFO_VER NVAPI_PROTECTED_VIDEO_SESSION_INFO_VER_V3
NVAPI_INTERFACE NvAPI_Video_GetProtectedVideoSessionInfo(NVAPI_PROTECTED_VIDEO_SESSION_INFO *pProtVideoSessionInfo);
NVAPI_INTERFACE NvAPI_DISP_GetDisplayIdByDisplayName(const char *displayName, NvU32 *displayId);
NVAPI_INTERFACE NvAPI_DISP_GetGDIPrimaryDisplayId(NvU32 *displayId);
typedef enum {
  NV_SR_ENTRY_METHOD_UNSUPPORTED = 0,
  NV_SR_ENTRY_METHOD_INBAND,
  NV_SR_ENTRY_METHOD_SIDEBAND,
} NV_SR_ENTRY_METHOD_ENUM;
typedef struct _NV_SR_ENTRY_PARAM_V1 {
  NvU32 version;
  NvU32 displayId;
  NV_SR_ENTRY_METHOD_ENUM entryMethod;
} NV_SR_ENTRY_PARAM_V1;
typedef NV_SR_ENTRY_PARAM_V1 NV_SR_ENTRY_PARAM;
#define NV_SR_ENTRY_PARAM_VER_1 MAKE_NVAPI_VERSION(NV_SR_ENTRY_PARAM_V1, 1)
#define NV_SR_ENTRY_PARAM_VER NV_SR_ENTRY_PARAM_VER_1
NVAPI_INTERFACE NvAPI_DISP_EnterSparseSelfRefreshPanel(__in NV_SR_ENTRY_PARAM *pSrEntryParams);
typedef enum {
  NV_SR_EXIT_METHOD_UNSUPPORTED = 0,
  NV_SR_EXIT_METHOD_INBAND,
  NV_SR_EXIT_METHOD_SIDEBAND,
} NV_SR_EXIT_METHOD_ENUM;
typedef enum {
  NV_SR_RESYNC_METHOD_UNSUPPORTED = 0,
  NV_SR_RESYNC_METHOD_SLIDING_SYNC,
  NV_SR_RESYNC_METHOD_FRAMELOCK,
  NV_SR_RESYNC_METHOD_BLANK_STRETCH,
} NV_SR_RESYNC_METHOD_ENUM;
typedef struct _NV_SR_EXIT_PARAM_V1 {
  NvU32 version;
  NvU32 displayId;
  NV_SR_EXIT_METHOD_ENUM exitMethod;
  NV_SR_RESYNC_METHOD_ENUM resyncMethod;
  NvU32 resyncDelay : 2;
  NvU32 reserved : 30;
} NV_SR_EXIT_PARAM_V1;
typedef NV_SR_EXIT_PARAM_V1 NV_SR_EXIT_PARAM;
#define NV_SR_EXIT_PARAM_VER_1 MAKE_NVAPI_VERSION(NV_SR_EXIT_PARAM_V1, 1)
#define NV_SR_EXIT_PARAM_VER NV_SR_EXIT_PARAM_VER_1
NVAPI_INTERFACE NvAPI_DISP_ExitSparseSelfRefreshPanel(__in NV_SR_EXIT_PARAM *pSrExitParams);
typedef struct _NV_SR_STATE_PARAM_V1 {
  NvU32 version;
  NvU32 displayId;
  NvU32 status;
} NV_SR_STATE_PARAM_V1;
typedef NV_SR_STATE_PARAM_V1 NV_SR_STATE_PARAM;
#define NV_SR_STATE_PARAM_VER_1 MAKE_NVAPI_VERSION(NV_SR_STATE_PARAM_V1, 1)
#define NV_SR_STATE_PARAM_VER NV_SR_STATE_PARAM_VER_1
NVAPI_INTERFACE NvAPI_DISP_GetSelfRefreshPanelStatus(__inout NV_SR_STATE_PARAM *pSrStatus);
typedef struct _NV_BURST_SR_ENTRY_PARAM_V1 {
  NvU32 version;
  NvU32 displayId;
  NV_SR_ENTRY_METHOD_ENUM entryMethod;
  NvU32 extraVFPExtension;
  NvU32 resyncDelay : 2;
  NvU32 reserved : 30;
} NV_BURST_SR_ENTRY_PARAM_V1;
typedef NV_BURST_SR_ENTRY_PARAM_V1 NV_BURST_SR_ENTRY_PARAM;
#define NV_BURST_SR_ENTRY_PARAM_VER_1 MAKE_NVAPI_VERSION(NV_BURST_SR_ENTRY_PARAM_V1, 1)
#define NV_BURST_SR_ENTRY_PARAM_VER NV_BURST_SR_ENTRY_PARAM_VER_1
NVAPI_INTERFACE NvAPI_DISP_EnterBurstSelfRefresh(__in NV_BURST_SR_ENTRY_PARAM *pBurstSREntry);
typedef struct _NV_BURST_SR_EXIT_PARAM_V1 {
  NvU32 version;
  NvU32 displayId;
  NV_SR_EXIT_METHOD_ENUM exitMethod;
  NvU32 resyncDelay : 2;
  NvU32 reserved : 30;
} NV_BURST_SR_EXIT_PARAM_V1;
typedef NV_BURST_SR_EXIT_PARAM_V1 NV_BURST_SR_EXIT_PARAM;
#define NV_BURST_SR_EXIT_PARAM_VER_1 MAKE_NVAPI_VERSION(NV_BURST_SR_EXIT_PARAM_V1, 1)
#define NV_BURST_SR_EXIT_PARAM_VER NV_BURST_SR_EXIT_PARAM_VER_1
NVAPI_INTERFACE NvAPI_DISP_ExitBurstSelfRefresh(__in NV_BURST_SR_EXIT_PARAM *pBurstSRExit);
typedef struct _NV_BUFFERED_SR_ENTRY_PARAM_V1 {
  NvU32 version;
  NvU32 displayId;
  NV_SR_ENTRY_METHOD_ENUM entryMethod;
  NvU32 GPUFramePeriodScale;
  NvU32 resyncDelay : 2;
  NvU32 reserved : 30;
} NV_BUFFERED_SR_ENTRY_PARAM_V1;
typedef NV_BUFFERED_SR_ENTRY_PARAM_V1 NV_BUFFERED_SR_ENTRY_PARAM;
#define NV_BUFFERED_SR_ENTRY_PARAM_VER_1 MAKE_NVAPI_VERSION(NV_BUFFERED_SR_ENTRY_PARAM_V1, 1)
#define NV_BUFFERED_SR_ENTRY_PARAM_VER NV_BUFFERED_SR_ENTRY_PARAM_VER_1
NVAPI_INTERFACE NvAPI_DISP_EnterBufferedSelfRefresh(__in NV_BUFFERED_SR_ENTRY_PARAM *pBufferedSREntry);
typedef struct _NV_BUFFERED_SR_EXIT_PARAM_V1 {
  NvU32 version;
  NvU32 displayId;
  NV_SR_EXIT_METHOD_ENUM exitMethod;
  NV_SR_RESYNC_METHOD_ENUM resyncMethod;
  NvU32 resyncDelay : 2;
  NvU32 reserved : 30;
} NV_BUFFERED_SR_EXIT_PARAM_V1;
typedef NV_BUFFERED_SR_EXIT_PARAM_V1 NV_BUFFERED_SR_EXIT_PARAM;
#define NV_BUFFERED_SR_EXIT_PARAM_VER_1 MAKE_NVAPI_VERSION(NV_BUFFERED_SR_EXIT_PARAM_V1, 1)
#define NV_BUFFERED_SR_EXIT_PARAM_VER NV_BUFFERED_SR_EXIT_PARAM_VER_1
NVAPI_INTERFACE NvAPI_DISP_ExitBufferedSelfRefresh(__in NV_BUFFERED_SR_EXIT_PARAM *pBufferedSRExit);
#ifndef NV_CLUSTER_STRUCTS_DEFINED
#define NV_CLUSTER_STRUCTS_DEFINED
typedef struct _NV_TILE_INFO_V1 {
  NvU32 version;
  NvU32 displayId;
  NvU32 locationX;
  NvU32 locationY;
} NV_TILE_INFO_V1;
typedef NV_TILE_INFO_V1 NV_TILE_INFO;
#define NV_TILE_INFO_VER1 MAKE_NVAPI_VERSION(NV_TILE_INFO_V1, 1)
#define NV_TILE_INFO_VER NV_TILE_INFO_VER1
typedef struct _NV_PIVOT_V1 {
  NvU32 version;
  NV_TIMING timing;
  NV_DP_COLOR_FORMAT colorFormat;
  NV_DP_BPC backendBitDepth;
} NV_PIVOT_V1;
typedef NV_PIVOT_V1 NV_PIVOT;
#define NV_PIVOT_VER1 MAKE_NVAPI_VERSION(NV_PIVOT_V1, 1)
#define NV_PIVOT_VER NV_PIVOT_VER1
typedef enum _NV_CLUSTER_TYPE {
  NV_CLUSTER_TYPE_UNKNOWN = 0,
  NV_CLUSTER_TYPE_DP_STREAM_CLONE = 1,
  NV_CLUSTER_TYPE_MOSAIC_SPAN = 2,
  NV_CLUSTER_TYPE_TILE = 3,
} NV_CLUSTER_TYPE;
typedef enum _NV_CLUSTER_STATE {
  NV_CLUSTER_STATE_UNKNOWN = 0,
  NV_CLUSTER_STATE_DISABLED,
  NV_CLUSTER_STATE_ENABLED,
  NV_CLUSTER_STATE_DELETE,
} NV_CLUSTER_STATE;
typedef enum _NV_CLUSTER_DISCOVERY_MODE {
  NV_CLUSTER_DISCOVERY_MODE_UNKNOWN = 0,
  NV_CLUSTER_DISCOVERY_MODE_MANUAL,
  NV_CLUSTER_DISCOVERY_MODE_AUTO
} NV_CLUSTER_DISCOVERY_MODE;
#define NV_DEFAULT_CLUSTER_PRIORITY 0
typedef struct _NV_CLUSTER_V1 {
  NvU32 version;
  NvU32 id;
  NvU32 displayId;
  NvU32 priority;
  NV_PIVOT pivot;
  NV_CLUSTER_TYPE type;
  NV_CLUSTER_DISCOVERY_MODE discoveryMode;
  NV_CLUSTER_STATE state;
  NvU32 numOfNodeEntries;
  union {
    NV_DP_NODE_INFO *pDPNodeEntries;
    NV_TILE_INFO *pTileEntries;
  };
  NvU32 isCEDevice : 1;
  NvU32 isAudioCapable : 1;
  NvU32 reserved : 30;
} NV_CLUSTER_V1;
typedef NV_CLUSTER_V1 NV_CLUSTER;
#define NV_CLUSTER_VER1 MAKE_NVAPI_VERSION(NV_CLUSTER_V1, 1)
#define NV_CLUSTER_VER NV_CLUSTER_VER1
#endif
NVAPI_INTERFACE NvAPI_GPU_EnumClusterTopologies(__in NvU32 rootDisplayId, __in_opt NV_PIVOT *pPivot,
                                                __in NvU32 thisEnum, __inout NV_CLUSTER *pClusterTopology);
NVAPI_INTERFACE NvAPI_GPU_SetupClusterTopology(__in NvU32 rootDisplayId, __inout NV_CLUSTER *pClusterTopology,
                                               __out_opt NvU32 *clusterId);
typedef enum _NV_IMP_MODE_STRUCTURE {
  NV_IMP_MODE_INTERLACED = 0,
  NV_IMP_MODE_PROGRESSIVE,
} NV_IMP_MODE_TYPE;
typedef enum _NV_IMP_VERTICAL_TAPS {
  NV_IMP_MODE_VERTICAL_TAPS1 = 0,
  NV_IMP_MODE_VERTICAL_TAPS2,
  NV_IMP_MODE_VERTICAL_TAPS3,
  NV_IMP_MODE_VERTICAL_TAPS3_ADAPTIVE,
  NV_IMP_MODE_VERTICAL_TAPS5,
} NV_IMP_VERTICAL_TAPS;
typedef enum _NV_IMP_HORIZONTAL_TAPS {
  NV_IMP_MODE_HORIZONTAL_TAPS1 = 0,
  NV_IMP_MODE_HORIZONTAL_TAPS2,
  NV_IMP_MODE_HORIZONTAL_TAPS8,
} NV_IMP_HORIZONTAL_TAPS;
typedef enum _NV_IMP_FORMAT {
  NV_IMP_MODE_FORMAT_I8 = 0,
  NV_IMP_MODE_FORMAT_VOID16,
  NV_IMP_MODE_FORMAT_VOID32,
  NV_IMP_MODE_FORMAT_RF16_GF16_BF16_AF16,
  NV_IMP_MODE_FORMAT_A8R8G8B8,
  NV_IMP_MODE_FORMAT_A2B10G10R10,
  NV_IMP_MODE_FORMAT_A8B8G8R8,
  NV_IMP_MODE_FORMAT_R5G6B5,
  NV_IMP_MODE_FORMAT_A1R5G5B5
} NV_IMP_FORMAT;
typedef enum _NV_IMP_SUPERSAMPLE {
  NV_IMP_MODE_SS_X1AA = 0,
  NV_IMP_MODE_SS_X4AA,
} NV_IMP_SUPERSAMPLE;
typedef enum _NV_IMP_BASE_USAGE_BOUNDS_USABLE {
  NV_IMP_MODE_BASE_USAGE_BOUNDS_USABLE_CURRENT = 0,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_USABLE_NO,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_USABLE_YES,
} NV_IMP_BASE_USAGE_BOUNDS_USABLE;
typedef enum _NV_IMP_BASE_USAGE_BOUNDS_DEPTH {
  NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_CURRENT = 0,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_8,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_16,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_32,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_DEPTH_64,
} NV_IMP_BASE_USAGE_BOUNDS_DEPTH;
typedef enum _NV_IMP_BASE_USAGE_BOUNDS_SS {
  NV_IMP_MODE_BASE_USAGE_BOUNDS_SS_CURRENT = 0,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_SS_X1AA,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_SS_X4AA,
} NV_IMP_BASE_USAGE_BOUNDS_SS;
typedef enum _NV_IMP_BASE_USAGE_BOUNDS_LUT {
  NV_IMP_MODE_BASE_USAGE_BOUNDS_BASE_LUT_USAGE_NONE = 0,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_BASE_LUT_USAGE_257,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_BASE_LUT_USAGE_1025,
} NV_IMP_BASE_USAGE_BOUNDS_BASE_LUT;
typedef enum _NV_IMP_BASE_USAGE_BOUNDS_OUTPUT_LUT {
  NV_IMP_MODE_BASE_USAGE_BOUNDS_OUTPUT_LUT_USAGE_NONE = 0,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_OUTPUT_LUT_USAGE_257,
  NV_IMP_MODE_BASE_USAGE_BOUNDS_OUTPUT_LUT_USAGE_1025,
} NV_IMP_BASE_USAGE_BOUNDS_OUTPUT_LUT;
typedef enum _NV_IMP_OVERLAY_USAGE_BOUNDS_USABLE {
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_USABLE_USE_CURRENT = 0,
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_USABLE_NO,
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_USABLE_YES,
} NV_IMP_OVERLAY_USAGE_BOUNDS_USABLE;
typedef enum _NV_IMP_OVERLAY_USAGE_BOUNDS_DEPTH {
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_USE_CURRENT = 0,
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_16,
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_32,
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_PIXEL_DEPTH_64,
} NV_IMP_OVERLAY_USAGE_BOUNDS_DEPTH;
typedef enum _NV_IMP_OVERLAY_USAGE_BOUNDS_OUTPUT_LUT {
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_OVERLAY_LUT_USAGE_NONE = 0,
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_OVERLAY_LUT_USAGE_257,
  NV_IMP_MODE_OVERLAY_USAGE_BOUNDS_OVERLAY_LUT_USAGE_1025,
} NV_IMP_OVERLAY_USAGE_BOUNDS_OUTPUT_LUT;
typedef enum _NV_IMP_BASE_LUT_LO_MODE {
  NV_IMP_MODE_BASE_LUT_LO_MODE_LORES = 0,
  NV_IMP_MODE_BASE_LUT_LO_MODE_HIRES,
  NV_IMP_MODE_BASE_LUT_LO_MODE_INDEX_1025_UNITY_RANGE,
  NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_1025_UNITY_RANGE,
  NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_1025_XRBIAS_RANGE,
  NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_1025_XVYCC_RANGE,
  NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_257_UNITY_RANGE,
  NV_IMP_MODE_BASE_LUT_LO_MODE_INTERPOLATE_257_LEGACY_RANGE,
} NV_IMP_BASE_LUT_LO_MODE;
typedef enum _NV_IMP_OUTPUT_LUT_LO_MODE {
  NV_IMP_MODE_OUTPUT_LUT_LO_MODE_LORES = 0,
  NV_IMP_MODE_OUTPUT_LUT_LO_MODE_HIRES,
  NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INDEX_1025_UNITY_RANGE,
  NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_1025_UNITY_RANGE,
  NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_1025_XRBIAS_RANGE,
  NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_1025_XVYCC_RANGE,
  NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_257_UNITY_RANGE,
  NV_IMP_MODE_OUTPUT_LUT_LO_MODE_INTERPOLATE_257_LEGACY_RANGE,
} NV_IMP_OUTPUT_LUT_LO_MODE;
typedef enum _NV_IMP_OUTPUT_RESOURCE_PIXEL_DEPTH {
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_DEFAULT = 0,
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_16_422,
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_18_444,
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_20_422,
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_24_422,
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_24_444,
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_30_444,
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_32_422,
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_36_444,
  NV_IMP_MODE_OUTPUT_RESOURCE_PIXEL_DEPTH_BPP_48_444,
} NV_IMP_OUTPUT_RESOURCE_PIXEL_DEPTH;
typedef enum _NV_IMP_PIXEL_REPLICATE_MODE {
  NV_IMP_MODE_PIXEL_REPLICATE_MODE_OFF = 0,
  NV_IMP_MODE_PIXEL_REPLICATE_MODE_X2,
  NV_IMP_MODE_PIXEL_REPLICATE_MODE_X4,
} NV_IMP_PIXEL_REPLICATE_MODE;
typedef enum _NV_IMP_REQUESTED_OPERATION {
  NV_IMP_MODE_REQUESTED_OPERATION_QUERY = 0,
  NV_IMP_MODE_REQUESTED_OPERATION_PRE_MODESET,
  NV_IMP_MODE_REQUESTED_OPERATION_POST_MODESET,
  NV_IMP_MODE_REQUESTED_OPERATION_QUERY_USE_SC,
  NV_IMP_MODE_REQUESTED_OPERATION_PRE_MODESET_USE_SC,
  NV_IMP_MODE_REQUESTED_OPERATION_POST_MODESET_USE_SC,
  NV_IMP_MODE_REQUESTED_OPERATION_COMPUTE_DMI_DURATION,
  NV_IMP_MODE_REQUESTED_OPERATION_SUPERVISOR,
} NV_IMP_REQUESTED_OPERATION;
typedef enum _NV_IMP_POSSIBLE_PSTATES {
  NV_IMP_MODE_POSSIBLE_PSTATES_UNDEFINED = 0,
  NV_IMP_MODE_POSSIBLE_PSTATES_P0,
  NV_IMP_MODE_POSSIBLE_PSTATES_P1,
  NV_IMP_MODE_POSSIBLE_PSTATES_P2,
  NV_IMP_MODE_POSSIBLE_PSTATES_P3,
  NV_IMP_MODE_POSSIBLE_PSTATES_P8,
  NV_IMP_MODE_POSSIBLE_PSTATES_P10,
  NV_IMP_MODE_POSSIBLE_PSTATES_P12,
  NV_IMP_MODE_POSSIBLE_PSTATES_P15,
  NV_IMP_MODE_POSSIBLE_PSTATES_MAX = 8,
} NV_IMP_POSSIBLE_PSTATES;
typedef struct _NV_IMP_MODE_EX_V1 {
  NvU32 version;
  NvU32 displayId;
  NvU32 isHeadActive : 1;
  NvU32 isPossible : 1;
  NvU32 reserved : 30;
  struct {
    NvU32 frequency;
    NvU32 adj1000Div1001;
  } PixelClock;
  struct {
    NvU32 width;
    NvU32 height;
  } RasterSize;
  struct {
    NvU32 x;
    NvU32 y;
  } RasterBlankStart;
  struct {
    NvU32 x;
    NvU32 y;
  } RasterBlankEnd;
  struct {
    NvU32 yStart;
    NvU32 yEnd;
  } RasterVertBlank2;
  struct {
    NvU32 width;
    NvU32 height;
  } ViewportSizeOut;
  struct {
    NvU32 width;
    NvU32 height;
  } ViewportSizeOutMin;
  struct {
    NvU32 width;
    NvU32 height;
  } ViewportSizeOutMax;
  struct {
    NvU32 width;
    NvU32 height;
  } ViewportSizeIn;
  struct {
    NV_IMP_MODE_TYPE structure;
  } Control;
  struct {
    NV_IMP_VERTICAL_TAPS verticalTaps;
    NV_IMP_HORIZONTAL_TAPS horizontalTaps;
    NvU32 force422 : 1;
    NvU32 reserved : 31;
  } OutputScaler;
  struct {
    NV_IMP_FORMAT format;
    NV_IMP_SUPERSAMPLE superSample;
  } ChannelParams;
  struct {
    NV_IMP_BASE_USAGE_BOUNDS_USABLE usable;
    NV_IMP_BASE_USAGE_BOUNDS_DEPTH pixelDepth;
    NV_IMP_BASE_USAGE_BOUNDS_SS superSample;
    NV_IMP_BASE_USAGE_BOUNDS_BASE_LUT baseLutUsage;
    NV_IMP_BASE_USAGE_BOUNDS_OUTPUT_LUT outputLutUsage;
  } BaseUsageBounds;
  struct {
    NV_IMP_OVERLAY_USAGE_BOUNDS_USABLE usable;
    NV_IMP_OVERLAY_USAGE_BOUNDS_DEPTH pixelDepth;
    NV_IMP_OVERLAY_USAGE_BOUNDS_OUTPUT_LUT overlayLutUsage;
  } OverlayUsageBounds;
  struct {
    NvU32 enable : 1;
    NvU32 reserved : 31;
    NV_IMP_BASE_LUT_LO_MODE mode;
  } BaseLutLo;
  struct {
    NvU32 enable : 1;
    NvU32 reserved : 31;
    NV_IMP_OUTPUT_LUT_LO_MODE mode;
  } OutputLutLo;
  NV_IMP_OUTPUT_RESOURCE_PIXEL_DEPTH outputResourcePixelDepthBPP;
  struct {
    NvU32 owner;
    NvU32 protocol;
  } Dac;
  struct {
    NvU32 owner;
    NvU32 protocol;
    NV_IMP_PIXEL_REPLICATE_MODE pixelReplicateMode;
  } Sor;
  struct {
    NvU32 owner;
    NvU32 protocol;
  } Pior;
  NV_IMP_REQUESTED_OPERATION requestedOperation;
  NvU32 duration;
  NV_IMP_POSSIBLE_PSTATES minPState;
} NV_IMP_MODE_EX_V1;
typedef NV_IMP_MODE_EX_V1 NV_IMP_MODE_EX;
#define NV_IMP_MODE_EX_VER_1 MAKE_NVAPI_VERSION(NV_IMP_MODE_EX_V1, 1)
#define NV_IMP_MODE_EX_VER NV_IMP_MODE_EX_VER_1
NVAPI_INTERFACE NvAPI_Disp_ConstructIMPModeEx(__in_ecount(pathCount) NV_DISPLAYCONFIG_PATH_INFO *pPathInfo,
                                              __in NvU32 pathCount, __inout_ecount(*modeCount) NV_IMP_MODE_EX *pIMPMode,
                                              __inout NvU32 *modeCount);
typedef enum _NV_IMP_DISP_LOCK_MODE {
  NV_IMP_DISP_LOCK_MODE_UNKNOWN = 0xFFFFFFFF,
  NV_IMP_DISP_LOCK_MODE_NO_LOCK = 0,
  NV_IMP_DISP_LOCK_MODE_FRAME_LOCK = 1,
  NV_IMP_DISP_LOCK_MODE_RASTER_LOCK = 3
} NV_IMP_DISP_LOCK_MODE;
typedef enum _NV_IMP_DISP_LOCK_PIN {
  NV_IMP_DISP_LOCK_PIN_UNKNOWN = 0xFFFFFFFF,
  NV_IMP_DISP_LOCK_PIN_0 = 0,
  NV_IMP_DISP_LOCK_PIN_1 = 1,
  NV_IMP_DISP_LOCK_PIN_2 = 2,
  NV_IMP_DISP_LOCK_PIN_3 = 3,
  NV_IMP_DISP_LOCK_PIN_4 = 4,
  NV_IMP_DISP_LOCK_PIN_5 = 5,
  NV_IMP_DISP_LOCK_PIN_6 = 6,
  NV_IMP_DISP_LOCK_PIN_7 = 7,
  NV_IMP_DISP_LOCK_PIN_8 = 8,
  NV_IMP_DISP_LOCK_PIN_9 = 9,
  NV_IMP_DISP_LOCK_PIN_A = 10,
  NV_IMP_DISP_LOCK_PIN_B = 11,
  NV_IMP_DISP_LOCK_PIN_C = 12,
  NV_IMP_DISP_LOCK_PIN_D = 13,
  NV_IMP_DISP_LOCK_PIN_E = 14,
  NV_IMP_DISP_LOCK_PIN_F = 15,
  NV_IMP_DISP_LOCK_PIN_UNSPECIFIED = 16,
  NV_IMP_DISP_INTERNAL_SCAN_LOCK_0 = 24,
  NV_IMP_DISP_INTERNAL_SCAN_LOCK_1 = 25,
  NV_IMP_DISP_INTERNAL_SCAN_LOCK_2 = 26,
  NV_IMP_DISP_INTERNAL_SCAN_LOCK_3 = 27,
  NV_IMP_DISP_INTERNAL_FLIP_LOCK_0 = 30,
  NV_IMP_DISP_INTERNAL_FLIP_LOCK_1 = 31
} NV_IMP_DISP_LOCK_PIN;
typedef enum _NV_IMP_LUT_USAGE {
  NV_IMP_LUT_USAGE_NONE,
  NV_IMP_LUT_USAGE_257,
  NV_IMP_LUT_USAGE_1025,
} NV_IMP_LUT_USAGE;
typedef struct _NV_IMP_HEAD_V1 {
  NvU8 headIndex;
  NvU32 maxPixelClkKHz;
  struct {
    NvU32 width;
    NvU32 height;
  } RasterSize;
  struct {
    NvU32 x;
    NvU32 y;
  } RasterBlankStart;
  struct {
    NvU32 x;
    NvU32 y;
  } RasterBlankEnd;
  struct {
    NvU32 yStart;
    NvU32 yEnd;
  } RasterVertBlank2;
  struct {
    NV_IMP_DISP_LOCK_MODE masterLockMode;
    NV_IMP_DISP_LOCK_PIN masterLockPin;
    NV_IMP_DISP_LOCK_MODE slaveLockMode;
    NV_IMP_DISP_LOCK_PIN slaveLockPin;
  } Control;
  NvU32 maxDownscaleFactorH;
  NvU32 maxDownscaleFactorV;
  NvBool bUpscalingAllowedV;
  struct {
    NvU16 leadingRasterLines;
    NvU16 trailingRasterLines;
  } minFrameIdle;
  NV_IMP_LUT_USAGE lut;
  NvU8 cursorSize32p;
} NV_IMP_HEAD_V1;
typedef struct _NV_IMP_WINDOW_V1 {
  NvU32 windowIndex;
  NvU32 owningHead;
  NvU32 formatUsageBound;
  NvU32 maxPixelsFetchedPerLine;
  NvU32 maxDownscaleFactorH;
  NvU32 maxDownscaleFactorV;
  NvBool bUpscalingAllowedV;
  NV_IMP_LUT_USAGE lut;
} NV_IMP_WINDOW_V1;
#define NV_IMP_OPTIONS_GET_MARGIN (0x00000001)
#define NV_IMP_OPTIONS_NEED_MIN_VPSTATE (0x00000002)
#define NV_IMP_MAX_POSSIBLE_HEADS 8
#define NV_IMP_MAX_POSSIBLE_WINDOWS 32
typedef struct _NV_IMP_MODE_C372_V1 {
  NvU32 displayId;
  NvU32 subdeviceIndex;
  NvU8 numHeads;
  NvU8 numWindows;
  NV_IMP_HEAD_V1 head;
  NV_IMP_WINDOW_V1 window[NV_IMP_MAX_POSSIBLE_WINDOWS];
  NvU32 options;
  NvBool bIsPossible;
  NvU32 minImpVPState;
  NvU32 worstCaseMargin;
  NvAPI_ShortString worstCaseDomain;
  NvBool bUseCachedPerfState;
} NV_IMP_MODE_C372_V1;
typedef enum _NV_IMP_MODE_OUPUT_STRUCT_TYPE { NV_IMP_MODE_OUPUT_STRUCT_TYPE_C372 } NV_IMP_MODE_OUPUT_STRUCT_TYPE;
typedef struct _NV_IMP_MODE_EX2_V1 {
  NvU32 version;
  NV_IMP_MODE_OUPUT_STRUCT_TYPE impModeStructType;
  union {
    NV_IMP_MODE_C372_V1 impModeC372;
  };
} NV_IMP_MODE_EX2_V1;
typedef NV_IMP_MODE_EX2_V1 NV_IMP_MODE_EX2;
#define NV_IMP_MODE_EX2_VER1 MAKE_NVAPI_VERSION(NV_IMP_MODE_EX2_V1, 1)
#define NV_IMP_MODE_EX2_VER NV_IMP_MODE_EX2_VER1
NVAPI_INTERFACE NvAPI_DISP_ConstructIMPModeEx2(__in_ecount(pathCount) NV_DISPLAYCONFIG_PATH_INFO *pPathInfo,
                                               __in NvU32 pathCount,
                                               __inout_ecount(*modeCount) NV_IMP_MODE_EX2 *pIMPMode,
                                               __inout NvU32 *modeCount);
NVAPI_INTERFACE NvAPI_DISP_GetDisplayConfig(__inout NvU32 *pathInfoCount,
                                            __out_ecount_full_opt(*pathInfoCount) NV_DISPLAYCONFIG_PATH_INFO *pathInfo);
NVAPI_INTERFACE NvAPI_DISP_SetDisplayConfig(__in NvU32 pathInfoCount,
                                            __in_ecount(pathInfoCount) NV_DISPLAYCONFIG_PATH_INFO *pathInfo,
                                            __in NvU32 flags);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Hybrid_SetHybridModeAndDisplayConfig(NV_HYBRID_MODE mode, NvU32 pathInfoCount,
                                               NV_DISPLAYCONFIG_PATH_INFO *pathInfo, NvU32 flags);
typedef struct _NV_TV_CLASSIFICATION_TYPE {
  NvU32 isPC : 1;
  NvU32 isSDTV : 1;
  NvU32 isEDTV : 1;
  NvU32 isHDTV : 1;
  NvU32 reserved : 28;
} NV_TV_CLASSIFICATION_TYPE;
typedef struct _NV_TV_CLASSIFICATION {
  NvU32 version;
  NV_TV_CLASSIFICATION_TYPE identifiedAs;
  NV_TV_CLASSIFICATION_TYPE treatedAs;
} NV_TV_CLASSIFICATION;
#define NV_TV_CLASSIFICATION_VER MAKE_NVAPI_VERSION(NV_TV_CLASSIFICATION, 1)
NVAPI_INTERFACE NvAPI_DISP_GetTvClassification(NvU32 displayId, NV_TV_CLASSIFICATION *pTvClass);
typedef enum {
  NV_DISPLAY_SOURCE_FILTER_NONE = 0,
  NV_DISPLAY_SOURCE_FILTER_DUPLICATE = 1,
  NV_DISPLAY_SOURCE_FILTER_1400x1050 = 2,
  NV_DISPLAY_SOURCE_FILTER_INVALID = 3,
  NV_DISPLAY_SOURCE_FILTER_CRT_NO_EDID_MATCH = 4,
  NV_DISPLAY_SOURCE_FILTER_DFPTV_TOO_LARGE_PRIMARY = 5,
  NV_DISPLAY_SOURCE_FILTER_DFPTV_TOO_LARGE_CLONE = 6,
  NV_DISPLAY_SOURCE_FILTER_DFPTV_UNDERSCAN = 7,
  NV_DISPLAY_SOURCE_FILTER_DFPTV_TOO_LARGE_NO_EDID = 8,
  NV_DISPLAY_SOURCE_FILTER_HDTV_TOO_LARGE = 9,
  NV_DISPLAY_SOURCE_FILTER_SDTV_TOO_LARGE = 10,
  NV_DISPLAY_SOURCE_FILTER_DFP_CLONE_UNDERSCAN = 11,
  NV_DISPLAY_SOURCE_FILTER_DFP_CLONE_TOO_LARGE = 12,
  NV_DISPLAY_SOURCE_FILTER_LOGIC_SCALING = 13,
  NV_DISPLAY_SOURCE_FILTER_UNRECOGNIZED = 14,
  NV_DISPLAY_SOURCE_FILTER_ES_GPU = 15,
  NV_DISPLAY_SOURCE_FILTER_DFPTV_NOT_CE_FOR_HDMI = 16,
  NV_DISPLAY_SOURCE_FILTER_HYBRID_EXCEEDED_MAX_LIMIT = 17,
  NV_DISPLAY_SOURCE_FILTER_HYBRID_INTERPOSER = 18,
  NV_DISPLAY_SOURCE_FILTER_MCP7X_IMP_WAR = 19,
  NV_DISPLAY_SOURCE_FILTER_R_AND_T = 20,
  NV_DISPLAY_SOURCE_FILTER_VIDPN_TARGET_COMBINATION = 21,
  NV_DISPLAY_SOURCE_FILTER_COPROC_RESOLUTION_LIMITER = 22,
  NV_DISPLAY_SOURCE_FILTER_MOSAIC_COMPAT_MISMATCH = 23,
  NV_DISPLAY_SOURCE_FILTER_HCLONE_SOURCE_MISMATCH = 24,
  NV_DISPLAY_SOURCE_FILTER_IMP_CHECK_WITH_CVT = 25,
  NV_DISPLAY_SOURCE_FILTER_IMP_CHECK_WITH_CVT_RB = 26,
  NV_DISPLAY_SOURCE_FILTER_GRAYSCALE_INVALID = 27,
  NV_DISPLAY_SOURCE_FILTER_SIZE_LIMIT_EXCEEDED = 28,
  NV_DISPLAY_SOURCE_FILTER_MOSAIC_OS_ADDED_MODE = 29,
  NV_DISPLAY_SOURCE_FILTER_BAR1_SIZE_LIMIT_EXCEEDED = 30,
  NV_DISPLAY_SOURCE_FILTER_DP_INSUFFICIENT_LINK_BW = 31,
  NV_DISPLAY_SOURCE_FILTER_IMP_MULTIHEAD = 32,
  NV_DISPLAY_SOURCE_FILTER_TEGRA_LIMITED_SCALING_CLONE = 33,
  NV_DISPLAY_SOURCE_FILTER_UNDEFINED1 = 34,
  NV_DISPLAY_SOURCE_FILTER_UNDEFINED3 = 35,
  NV_DISPLAY_SOURCE_FILTER_YUV422_INVALID = 36,
  NV_DISPLAY_SOURCE_FILTER_NON_MOSAIC_RESOLUTION = 37,
  NV_DISPLAY_SOURCE_FILTER_MULTI_TILE_MODE = 38,
  NV_DISPLAY_SOURCE_FILTER_VRDISPLAY = 39,
  NV_DISPLAY_SOURCE_FILTER_NATIVE_TILE_MODE_IS_NONE_EDID = 40,
  NV_DISPLAY_SOURCE_FILTER_NON_VIRTUAL_SPLIT_RESOLUTION = 41,
  NV_DISPLAY_SOURCE_FILTER_HW_YCBCR420 = 42,
  NV_DISPLAY_SOURCE_FILTER_ALL
} NV_DISPLAY_SOURCE_FILTER;
typedef struct {
  NvU32 hybridList : 1;
  NvU32 nbsi : 1;
  NvU32 infStandard : 1;
  NvU32 infCustom : 1;
  NvU32 hdtv : 1;
  NvU32 fallbackNvmode : 1;
  NvU32 fallbackHdtv : 1;
  NvU32 underscan : 1;
  NvU32 custom : 1;
  NvU32 osAdditionalMode : 1;
  NvU32 nativeRotation : 1;
  NvU32 hSpan : 1;
  NvU32 vSpan : 1;
  NvU32 edid : 1;
  NvU32 edidNativeRefreshRate : 1;
  NvU32 edidDTD : 1;
  NvU32 edidSTD : 1;
  NvU32 edidEST : 1;
  NvU32 edidCVT : 1;
  NvU32 edid861ST : 1;
  NvU32 edidExtDTD : 1;
  NvU32 edidExtVTB : 1;
  NvU32 defaultUnderscan : 1;
  NvU32 hyperSampling : 1;
  NvU32 upScaling : 1;
  NvU32 dlDsr : 1;
  NvU32 reserved : 6;
} NV_DISPLAY_SOURCE_ORIGIN;
typedef struct {
  NvU32 identity : 1;
  NvU32 rotation90 : 1;
  NvU32 rotation180 : 1;
  NvU32 rotation270 : 1;
  NvU32 reserved : 28;
} NV_DISPLAY_ROTATE_CAPABILITY;
typedef struct _NV_DISPLAY_SOURCE_MODE_V1 {
  NvU32 version;
  NV_RESOLUTION resolution;
  NV_FORMAT colorFormat;
  NV_DISPLAY_ROTATE_CAPABILITY rotation;
  NV_DISPLAY_SOURCE_FILTER filteredOutBy;
  NV_DISPLAY_SOURCE_ORIGIN origin;
} NV_DISPLAY_SOURCE_MODE_V1;
typedef NV_DISPLAY_SOURCE_MODE_V1 NV_DISPLAY_SOURCE_MODE;
#define NV_DISPLAY_SOURCE_MODE_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_SOURCE_MODE_V1, 1)
#define NV_DISPLAY_SOURCE_MODE_VER NV_DISPLAY_SOURCE_MODE_VER1
#define NVAPI_MAX_PATH_PER_TOPOLOGY 8
typedef struct {
  NvU32 version;
  struct {
    NvU32 srcID;
    NvU32 displayID;
    NvU32 importanceOrdinal;
    NV_DISPLAY_SOURCE_MODE pinnedSourceMode;
  } path[NVAPI_MAX_PATH_PER_TOPOLOGY];
  NvU32 pathCount;
} NV_DISPLAY_TOPOLOGY_V1;
typedef struct {
  NvU32 version;
  struct {
    NvU32 srcID;
    union {
      NvU32 targetId;
      NvU32 displayID;
    };
    NvU32 importanceOrdinal;
    NV_DISPLAY_SOURCE_MODE pinnedSourceMode;
    NvU32 isNonNVIDIA : 1;
    NvU32 isAttachedToDesktop : 1;
    NvU32 isPanAndScanTarget : 1;
    NvU32 reserved : 29;
  } path[NVAPI_MAX_PATH_PER_TOPOLOGY];
  NvU32 pathCount;
} NV_DISPLAY_TOPOLOGY_V2;
typedef NV_DISPLAY_TOPOLOGY_V2 NV_DISPLAY_TOPOLOGY;
#define NV_DISPLAY_TOPOLOGY_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_TOPOLOGY_V1, 1)
#define NV_DISPLAY_TOPOLOGY_VER2 MAKE_NVAPI_VERSION(NV_DISPLAY_TOPOLOGY_V2, 2)
#define NV_DISPLAY_TOPOLOGY_VER NV_DISPLAY_TOPOLOGY_VER2
NVAPI_INTERFACE NvAPI_DISP_GetSourceModeSet(__in NV_DISPLAY_TOPOLOGY *pTopology, __in NvU32 pathIndex,
                                            __inout_ecount_part_opt(*pSourceModeCount, *pSourceModeCount)
                                                NV_DISPLAY_SOURCE_MODE *pSourceModeSet,
                                            __inout NvU32 *pSourceModeCount, __in NvU8 bIsFilteringInvalidMode);
typedef struct {
  NvU32 gvo : 1;
  NvU32 sdtv : 1;
  NvU32 lenovoSlowRefreshRate : 1;
  NvU32 unused2 : 1;
  NvU32 hybridList : 1;
  NvU32 nbsi : 1;
  NvU32 infStandard : 1;
  NvU32 infCustom : 1;
  NvU32 hdtv : 1;
  NvU32 fallbackNvmode : 1;
  NvU32 fallbackHdtv : 1;
  NvU32 underscan : 1;
  NvU32 custom : 1;
  NvU32 osAdditionalMode : 1;
  NvU32 nativeRotation : 1;
  NvU32 hSpan : 1;
  NvU32 vSpan : 1;
  NvU32 edid : 1;
  NvU32 edidNativeRefreshRate : 1;
  NvU32 edidDTD : 1;
  NvU32 edidSTD : 1;
  NvU32 edidEST : 1;
  NvU32 edidCVT : 1;
  NvU32 edid861ST : 1;
  NvU32 edidExtDTD : 1;
  NvU32 edidExtVTB : 1;
  NvU32 edidHdmiExt : 1;
  NvU32 reserved : 5;
} NV_DISPLAY_TARGET_ORIGIN;
typedef struct {
  NvU32 version;
  NvU32 visibleWidth;
  NvU32 visibleHeight;
  NvU32 totalWidth;
  NvU32 totalHeight;
  NV_DISPLAY_REFRESH_RATE refreshRate;
  NvU32 pclk;
  NvU32 aspectRatio;
  NV_DISPLAY_TARGET_ORIGIN origin;
  NvU32 isInterlaced : 1;
  NvU32 reserved : 31;
} NV_DISPLAY_TARGET_MODE_V1;
typedef struct {
  NvU32 version;
  NvU32 visibleWidth;
  NvU32 visibleHeight;
  NvU32 totalWidth;
  NvU32 totalHeight;
  NV_DISPLAY_REFRESH_RATE refreshRate;
  NvU32 pclk;
  NvU32 aspectRatio;
  NV_DISPLAY_TARGET_ORIGIN origin;
  NvU32 isInterlaced : 1;
  NvU32 isPreferred : 1;
  NvU32 reserved : 30;
  NV_DISPLAY_TV_FORMAT tvFormat;
} NV_DISPLAY_TARGET_MODE_V2;
typedef struct {
  NvU32 version;
  NvU32 visibleWidth;
  NvU32 visibleHeight;
  NvU32 totalWidth;
  NvU32 totalHeight;
  NV_DISPLAY_REFRESH_RATE refreshRate;
  NvU32 pclk;
  NvU32 aspectRatio;
  NV_DISPLAY_TARGET_ORIGIN origin;
  NvU32 isInterlaced : 1;
  NvU32 isPreferred : 1;
  NvU32 reserved : 30;
  NV_DISPLAY_TV_FORMAT tvFormat;
  NvU32 hSyncNumerator;
  NvU32 hSyncDenominator;
  NvU32 videoStandard;
} NV_DISPLAY_TARGET_MODE_V3;
#define NV_DISPLAY_TARGET_MODE_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_TARGET_MODE_V1, 1)
#define NV_DISPLAY_TARGET_MODE_VER2 MAKE_NVAPI_VERSION(NV_DISPLAY_TARGET_MODE_V2, 2)
#define NV_DISPLAY_TARGET_MODE_VER3 MAKE_NVAPI_VERSION(NV_DISPLAY_TARGET_MODE_V3, 3)
#define NV_DISPLAY_TARGET_MODE_VER NV_DISPLAY_TARGET_MODE_VER3
typedef NV_DISPLAY_TARGET_MODE_V3 NV_DISPLAY_TARGET_MODE;
#define NV_MAX_TARGET_MODE_NUM 32
NVAPI_INTERFACE NvAPI_DISP_GetTargetModeSet(__in NV_DISPLAY_TOPOLOGY *pTopology, __in NvU32 pathIndex,
                                            __out_ecount_part(NV_MAX_TARGET_MODE_NUM, *pTargetModeCount)
                                                NV_DISPLAY_TARGET_MODE pTargetModeSet[NV_MAX_TARGET_MODE_NUM],
                                            __out NvU32 *pTargetModeCount);
typedef struct {
  NvU32 version;
  NvU32 useGpuScalerOnly : 1;
  NvU32 useGpuAndDisplayScaler : 1;
  NvU32 reserved : 30;
} NV_DISPLAY_TARGET_MODE_SETTINGS_V1;
#define NV_DISPLAY_TARGET_MODE_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_TARGET_MODE_SETTINGS_V1, 1)
#define NV_DISPLAY_TARGET_MODE_SETTINGS_VER NV_DISPLAY_TARGET_MODE_SETTINGS_VER1
typedef NV_DISPLAY_TARGET_MODE_SETTINGS_V1 NV_DISPLAY_TARGET_MODE_SETTINGS;
NVAPI_INTERFACE NvAPI_DISP_GetTargetModeSetEx(__in NV_DISPLAY_TOPOLOGY *pTopology, __in NvU32 pathIndex,
                                              __inout_ecount_part(NV_MAX_TARGET_MODE_NUM, *pTargetModeCount)
                                                  NV_DISPLAY_TARGET_MODE pTargetModeSet[NV_MAX_TARGET_MODE_NUM],
                                              __out NvU32 *pTargetModeCount,
                                              __in NV_DISPLAY_TARGET_MODE_SETTINGS targetModeSettings);
NVAPI_INTERFACE NvAPI_DISP_GetScanoutRasterDimension(__in NV_DISPLAY_TOPOLOGY *pTopology, __in NvU32 pathIndex,
                                                     __in NV_DISPLAY_TARGET_MODE *pPinnedTargetMode,
                                                     __in NV_SCALING scaling, __out NV_RECT *pScanoutRectangle,
                                                     __out NV_RECT *pRasterRectangle);
typedef struct {
  NvU32 version;
  NV_DISPLAY_TARGET_ORIGIN targetOrigin;
  NV_TIMING timingInfo;
} NV_BACKEND_TIMING_INFO_V1;
typedef NV_BACKEND_TIMING_INFO_V1 NV_BACKEND_TIMING_INFO;
#define NV_BACKEND_TIMING_INFO_VER1 MAKE_NVAPI_VERSION(NV_BACKEND_TIMING_INFO_V1, 1)
#define NV_BACKEND_TIMING_INFO_VER NV_BACKEND_TIMING_INFO_VER1
NVAPI_INTERFACE NvAPI_DISP_GetTimingInfo(__in NvU32 displayID, __inout NvU32 *timingInfoCount,
                                         __inout_ecount_part_opt(*timingInfoCount, *timingInfoCount)
                                             NV_BACKEND_TIMING_INFO *timingInfo);
typedef struct {
  NvU32 identity : 1;
  NvU32 centered : 1;
  NvU32 stretched : 1;
  NvU32 aspectRatioCenteredMax : 1;
  NvU32 custom : 1;
  NvU32 reserved : 27;
} NV_DISPLAY_SCALING_SUPPORT;
NVAPI_INTERFACE NvAPI_DISP_GetScalingSupport(NV_DISPLAY_TOPOLOGY *pTopology, NvU32 pathIndex,
                                             NV_DISPLAY_TARGET_MODE *pPinnedTargetMode,
                                             NV_DISPLAY_SCALING_SUPPORT *pScalingSupport);
typedef struct _NV_DISPLAY_BLANKING_INFO_V1 {
  NvU32 version;
  NvU32 blankingState : 1;
  NvU32 persistBlankingAcrossHotPlugUnplug : 1;
  NvU32 reserved : 30;
} NV_DISPLAY_BLANKING_INFO_V1;
typedef NV_DISPLAY_BLANKING_INFO_V1 NV_DISPLAY_BLANKING_INFO;
#define NV_DISPLAY_BLANKING_INFO_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_BLANKING_INFO_V1, 1)
#define NV_DISPLAY_BLANKING_INFO_VER NV_DISPLAY_BLANKING_INFO_VER1
NVAPI_INTERFACE NvAPI_DISP_GetDisplayBlankingState(NvU32 displayId, NV_DISPLAY_BLANKING_INFO *pDisplayBlankingState);
NVAPI_INTERFACE NvAPI_DISP_SetDisplayBlankingState(NvU32 displayId, NV_DISPLAY_BLANKING_INFO *pDisplayBlankingState);
typedef struct _NV_DISPLAY_EDID_MONITOR_RANGE {
  NvU16 minRefreshRateHz;
  NvU16 maxRefreshRateHz;
  NvU16 minLineRateKHz;
  NvU16 maxLineRateKHz;
  NvU16 maxPclkMHz;
} NV_DISPLAY_EDID_TIMING_RANGE;
typedef struct _NV_DISPLAY_EDID_DATA_V1 {
  NvU32 version;
  NvAPI_ShortString displayName;
  NvAPI_ShortString manufacturerName;
  NvU32 specificID;
  NvU32 commonID;
  NvU32 isValid : 1;
  NvU32 reserved : 31;
} NV_DISPLAY_EDID_DATA_V1;
typedef struct _NV_DISPLAY_EDID_DATA_V2 {
  NvU32 version;
  NvAPI_ShortString displayName;
  NvAPI_ShortString manufacturerName;
  NvU32 specificID;
  NvU32 commonID;
  NvU32 isValid : 1;
  NvU32 reserved : 31;
  NV_DISPLAY_EDID_TIMING_RANGE timingRangeLimit;
} NV_DISPLAY_EDID_DATA_V2;
typedef NV_DISPLAY_EDID_DATA_V2 NV_DISPLAY_EDID_DATA;
#define NV_DISPLAY_EDID_DATA_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_EDID_DATA_V1, 1)
#define NV_DISPLAY_EDID_DATA_VER2 MAKE_NVAPI_VERSION(NV_DISPLAY_EDID_DATA_V2, 2)
#define NV_DISPLAY_EDID_DATA_VER NV_DISPLAY_EDID_DATA_VER2
NVAPI_INTERFACE NvAPI_DISP_GetEdidParsed(NvU32 displayId, NV_DISPLAY_EDID_DATA *pEdidData);
NVAPI_INTERFACE NvAPI_Coproc_QueryHDAudioState(NvU32 *pHDAState);
NVAPI_INTERFACE NvAPI_Coproc_QueryHDAudioStateEx(__in NvPhysicalGpuHandle hPhysicalGpu, __out NvU32 *pHDAState);
typedef struct {
  NvU32 width;
  NvU32 height;
  NV_FORMAT colorFormat;
  NV_DISPLAY_REFRESH_RATE refreshRate;
  NvU32 reserved;
} NV_DISPLAY_SETTING;
typedef struct {
  NvU32 version;
  NvU32 isNonNVIDIA : 1;
  NvU32 isAttachedToDesktop : 1;
  NvU32 reserved : 30;
  NvU32 sourceId;
  union {
    NvU32 targetId;
    NvU32 displayId;
  };
  NV_DISPLAY_SETTING dispSetting;
  NvU32 reserved1;
} NV_HCLONE_PATH_V1;
typedef NV_HCLONE_PATH_V1 NV_HCLONE_PATH;
#define NV_HCLONE_PATH_VER1 MAKE_NVAPI_VERSION(NV_HCLONE_PATH_V1, 1)
#define NV_HCLONE_PATH_VER NV_HCLONE_PATH_VER1
typedef struct {
  NvU32 version;
  NvU32 numPaths;
  NV_HCLONE_PATH *pHClonePathArray;
  NvU32 reserved1;
} NV_HCLONE_NODE_V1;
typedef NV_HCLONE_NODE_V1 NV_HCLONE_NODE;
#define NV_HCLONE_NODE_VER1 MAKE_NVAPI_VERSION(NV_HCLONE_NODE_V1, 1)
#define NV_HCLONE_NODE_VER NV_HCLONE_NODE_VER1
typedef enum NV_HCLONE_HOTPLUG_BEHAVIOR {
  NV_HCLONE_HOTPLUG_BEHAVIOR_CCD = 0,
  NV_HCLONE_HOTPLUG_BEHAVIOR_EXTENDED,
  NV_HCLONE_HOTPLUG_BEHAVIOR_UI,
} NV_HCLONE_HOTPLUG_BEHAVIOR;
typedef struct {
  NvU32 version;
  NvU32 numHCloneNodes;
  NV_HCLONE_NODE *pHCloneNodeArray;
  NvU32 isMultiHClonePairsEnabled : 1;
  NvU32 isNWayHCloneNodesEnabled : 1;
  NvU32 reserved1 : 30;
  NV_HCLONE_HOTPLUG_BEHAVIOR HCloneHotPlugBehavior;
} NV_HCLONE_TOPOLOGY_V1;
typedef NV_HCLONE_TOPOLOGY_V1 NV_HCLONE_TOPOLOGY;
#define NV_HCLONE_TOPOLOGY_VER1 MAKE_NVAPI_VERSION(NV_HCLONE_TOPOLOGY_V1, 1)
#define NV_HCLONE_TOPOLOGY_VER NV_HCLONE_TOPOLOGY_VER1
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 510.") NVAPI_INTERFACE
    NvAPI_DISP_SetHCloneTopology(__in NV_HCLONE_TOPOLOGY *pHCloneTopology);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 510.") NVAPI_INTERFACE
    NvAPI_DISP_GetHCloneTopology(__inout NV_HCLONE_TOPOLOGY *pHCloneTopology);
typedef struct {
  NvU32 version;
  union {
    NvU32 displayID;
    NvU32 targetID;
  };
  NvU32 isNonNVIDIA : 1;
  NvU32 isPrimaryCapable : 1;
  NvU32 isSecondaryCapable : 1;
  NvU32 reserved : 29;
} NV_HCLONE_DISPLAY_CAPS_V1;
typedef NV_HCLONE_DISPLAY_CAPS_V1 NV_HCLONE_DISPLAY_CAPS;
#define NV_HCLONE_DISPLAY_CAPS_VER1 MAKE_NVAPI_VERSION(NV_HCLONE_DISPLAY_CAPS_V1, 1)
#define NV_HCLONE_DISPLAY_CAPS_VER NV_HCLONE_DISPLAY_CAPS_VER1
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 510.") NVAPI_INTERFACE
    NvAPI_DISP_GetHCloneDisplayCaps(__inout_ecount_full(countDisplay) NV_HCLONE_DISPLAY_CAPS *pDisplayCaps,
                                    __in NvU32 countDisplay);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 510.") NVAPI_INTERFACE
    NvAPI_DISP_ValidateHCloneTopology(__in NV_HCLONE_TOPOLOGY *pHCloneTopology, __out NvU32 *pValid);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 510.") NVAPI_INTERFACE
    NvAPI_DISP_GetHCloneIGPUDisplayEdid(__in NvU32 targetId,
                                        __out_bcount_part_opt(*pSizeofEDID, *pSizeofEDID) NvU8 *pEdid,
                                        __inout NvU32 *pSizeofEDID);
typedef enum _NV_WIDE_COLOR_RANGE {
  NV_COLOR_UNKNOWN = 0,
  NV_COLOR_xvYCC,
} NV_WIDE_COLOR_RANGE;
typedef struct _NV_WIDE_COLOR_RANGE_SETTING {
  NvU32 version;
  NV_WIDE_COLOR_RANGE colorRange;
  NvU32 enable : 1;
  NvU32 reserved : 31;
} NV_WIDE_COLOR_RANGE_SETTING_V1;
typedef NV_WIDE_COLOR_RANGE_SETTING_V1 NV_WIDE_COLOR_RANGE_SETTING;
#define NV_WIDE_COLOR_RANGE_SETTING_VER1 MAKE_NVAPI_VERSION(NV_WIDE_COLOR_RANGE_SETTING_V1, 1)
#define NV_WIDE_COLOR_RANGE_SETTING_VER NV_WIDE_COLOR_RANGE_SETTING_VER1
NVAPI_INTERFACE NvAPI_DISP_SetWideColorRange(NvU32 displayId, NV_WIDE_COLOR_RANGE_SETTING *colorRangeSetting);
NVAPI_INTERFACE NvAPI_DISP_GetWideColorRange(NvU32 displayId, NV_WIDE_COLOR_RANGE_SETTING *colorRangeSetting);
typedef enum _NV_HDCP_STATUS_INFO {
  NV_HDCP_STATUS_INFO_AVAILABLE = 0x00000000,
  NV_HDCP_STATUS_INFO_UNAVAILABLE = 0x00000001,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_DISPLAY_ID = 0x00000002,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_DISPLAY = 0x00000004,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_DISPLAY_MODE = 0x00000008,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_GPU = 0x00000010,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_INVALID_GPU_MODE = 0x00000020,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_UNTRUST = 0x00000040,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_LINK_FAILURES = 0x00000080,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_KSV_LENGTH = 0x00000100,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_KSV_SIGNATURE = 0x00000200,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_SRM_SIGNATURE = 0x00000400,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_SRM_REVOKED = 0x00000800,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_REPEATER_NO_READY = 0x00001000,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_TOPOLOGY_ERROR = 0x00002000,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_BAD_DISPLAY = 0x00004000,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_DEVICE_REVOKED = 0x00008000,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_DEVICE_INVALID = 0x00010000,
  NV_HDCP_STATUS_INFO_UNAVAILABLE_ABORT_HOP_LIMIT_EXCEEDED = 0x00020000,
} NV_HDCP_STATUS_INFO;
typedef struct _NV_HDCP_LINK_STATUS {
  NV_HDCP_STATUS_INFO nvHdcpStatusInfo;
  NvU64 bRepeaterPresent : 1;
  NvU64 bDebuggerDetected : 1;
  NvU64 bHDCPOn : 1;
  NvU64 bReserved1 : 61;
  NvU64 qwReserved2;
} NV_HDCP_LINK_STATUS;
typedef struct _NV_MACROVISION_STATUS {
  NvU64 bMacrovisionOn : 1;
  NvU64 bReserved1 : 63;
  NvU64 qwReserved2;
} NV_MACROVISION_STATUS;
typedef struct _NV_VIDEO_LINK_INFO {
  NvU32 version;
  NV_HDCP_LINK_STATUS hdcpStatus;
  NV_MACROVISION_STATUS macrovisionStatus;
} NV_VIDEO_LINK_INFO;
#define NV_VIDEO_LINK_INFO_VER MAKE_NVAPI_VERSION(NV_VIDEO_LINK_INFO, 1)
NVAPI_INTERFACE NvAPI_GetVideoLinkParams(__in_opt NvDisplayHandle hNvDisplay, __in NvU32 outputId,
                                         __inout NV_VIDEO_LINK_INFO *pVideoLinkInfo);
typedef enum _NV_RESOLUTION_SPEC {
  NV_RESOLUTION_SPEC_UNKNOWN = 0,
  NV_RESOLUTION_SPEC_VESA = 1,
  NV_RESOLUTION_SPEC_CEA = 2,
  NV_RESOLUTION_SPEC_HANDHELD = 3,
} NV_RESOLUTION_SPEC;
typedef struct _NV_RESOLUTION_EX_V1 {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NvU32 colorDepth;
  NvU32 refreshRate;
  NvU16 isInterlaced : 1;
  NvU16 isNative : 1;
  NvU16 is3D : 1;
  NvU16 reserved : 13;
  NV_RESOLUTION_SPEC originSpec;
} NV_RESOLUTION_EX_V1;
typedef NV_RESOLUTION_EX_V1 NV_RESOLUTION_EX;
#define NV_RESOLUTION_EX_VER1 MAKE_NVAPI_VERSION(NV_RESOLUTION_EX_V1, 1)
#define NV_RESOLUTION_EX_VER NV_RESOLUTION_EX_VER1
typedef enum _NV_BPC_CONFIG_CMD { NV_BPC_CONFIG_CMD_GET = 0, NV_BPC_CONFIG_CMD_SET } NV_BPC_CONFIG_CMD;
typedef struct _NV_BPC_CONFIG_V1 {
  NvU32 version;
  NvU32 displayId;
  NV_BPC_CONFIG_CMD cmd;
  NvU32 bpc;
  NvU32 ditherOff : 1;
  NvU32 forceAtCurLinkConfig : 1;
  NvU32 forceRGDivMode : 1;
} NV_BPC_CONFIG_V1;
#define NV_BPC_CONFIG_VER1 MAKE_NVAPI_VERSION(NV_BPC_CONFIG_V1, 1)
#define NV_BPC_CONFIG_VER NV_BPC_CONFIG_VER1
typedef NV_BPC_CONFIG_V1 NV_BPC_CONFIG;
NVAPI_INTERFACE NvAPI_DISP_BpcConfiguration(__inout NV_BPC_CONFIG *pNvBpcConfig);
NVAPI_INTERFACE NvAPI_DISP_GetDisplayHandleFromDisplayId(__in NvU32 displayId, __out NvDisplayHandle *phNvDisplay);
NVAPI_INTERFACE NvAPI_DISP_GetDisplayIdFromDisplayHandle(__in NvDisplayHandle hNvDisplay, __out NvU32 *pDisplayId);
typedef enum _NV_DP_REQUEST { NV_DP_REQUEST_QSES } NV_DP_REQUEST;
typedef enum _NV_DP_REQUEST_STATUS {
  NV_DP_REQUEST_STATUS_PENDING = 0,
  NV_DP_REQUEST_STATUS_DONE = 1,
  NV_DP_REQUEST_STATUS_ERROR = 2,
  NV_DP_REQUEST_STATUS_NEWREQUEST = 3,
} NV_DP_REQUEST_STATUS;
typedef enum _NV_DP_STREAM_STATE {
  NV_DP_STREAM_STATE_NOT_EXIST = 0,
  NV_DP_STREAM_STATE_INACTICE = 1,
  NV_DP_STREAM_STATE_ACTIVE = 2,
} NV_DP_STREAM_STATE;
typedef enum _NV_OUTPUT_SINK_TYPE {
  NV_OUTPUT_SINK_TYPE_UNCONNECTED = 0,
  NV_OUTPUT_SINK_TYPE_NONEAUTH_LEGACY_DEVICE = 1,
  NV_OUTPUT_SINK_TYPE_NONE12CP_OR_NONQSE = 2,
  NV_OUTPUT_SINK_TYPE_DP_MST = 4
} NV_OUTPUT_SINK_TYPE;
typedef enum _NV_OUTPUT_CPTYPE { NV_OUTPUT_CPTYPE_HDCP1x = 1, NV_OUTPUT_CPTYPE_HDCP2x = 2 } NV_OUTPUT_CPTYPE;
typedef struct _NV_DP_REPLY_QSES {
  NV_DP_STREAM_STATE streamState;
  NvU8 repeaterFuncPresent;
  NvU8 encryption;
  NvU8 authentication;
  NV_OUTPUT_SINK_TYPE sinkType;
  NV_OUTPUT_CPTYPE cpType;
  NvU8 signedLPrime;
  NvU8 streamId;
  NvU8 LPrime[20];
} NV_DP_REPLY_QSES;
typedef struct _NV_DP_REQUEST_HEADER {
  NvU32 requestSize;
  void *pRequest;
} NV_DP_REQUEST_HEADER;
#define NV_DP_REQUEST_HEADER_VER1 MAKE_NVAPI_VERSION(NV_DP_REQUEST_HEADER, 1)
typedef struct _NV_DP_STATUS_REQUEST_QSES {
  NV_DP_REQUEST requestType;
  NvU32 streamID;
  NV_DP_REPLY_QSES reply;
} NV_DP_STATUS_REQUEST_QSES;
NVAPI_INTERFACE NvAPI_DISP_DP_QueryStatus(__in NvU32 displayId, __inout NV_DP_REQUEST_HEADER *pRequestHeader);
NVAPI_INTERFACE NvAPI_DISP_DP_GetStreamIDs(__in NvU32 displayId, __inout_opt NvU32 *pStreamIds, __inout NvU32 *pCount);
NVAPI_INTERFACE NvAPI_DISP_ApplyAndSaveCustomResolution(__in NvU32 displayId, __in NV_RESOLUTION_EX *pResolution);
NVAPI_INTERFACE NvAPI_DISP_GetDisplayIdsInCluster(__in NvU32 clusterDisplayId, __out NV_CLUSTER_TYPE *clusterType,
                                                  __inout NvU32 *displayIdCount,
                                                  __out_ecount_part_opt(*displayIdCount, *displayIdCount)
                                                      NvU32 *displayIds);
#define NV_HYPER_SAMPLING_FLAG_CREATE_DESKTOP_RESOLUTION 0x00000001
#define NV_HYPER_SAMPLING_FLAG_FOR_DL_DSR_RESOLUTION 0x00000002
#define NV_HYPER_SAMPLING_FLAG_FOR_UPSCALING_RESOLUTION 0x00000008
#define NVAPI_MAX_SMOOTH_SCALING_SETTING_COUNT 10
typedef enum _NV_HYPER_SAMPLING_CMD {
  NV_HYPER_SAMPLING_CREATE = 1,
  NV_HYPER_SAMPLING_APPLY_SHARPNESS_ONLY = 2,
} NV_HYPER_SAMPLING_CMD;
typedef struct _NV_HYPER_SAMPLING_V1 {
  NvU32 version;
  NvU32 samplingFactorsCount;
  NvU32 *samplingFactors;
  NvU32 sharpness;
} NV_HYPER_SAMPLING_V1;
typedef struct _NV_HYPER_SAMPLING_V2 {
  NvU32 version;
  NvU32 samplingFactorsCount;
  NvU32 *samplingFactors;
  NvU32 sharpness;
  NV_RESOLUTION *hyperSampledRes;
} NV_HYPER_SAMPLING_V2;
#define NV_HYPER_SAMPLING_VER1 MAKE_NVAPI_VERSION(NV_HYPER_SAMPLING_V1, 1)
#define NV_HYPER_SAMPLING_VER2 MAKE_NVAPI_VERSION(NV_HYPER_SAMPLING_V2, 2)
#define NV_HYPER_SAMPLING_VER NV_HYPER_SAMPLING_VER2
typedef NV_HYPER_SAMPLING_V2 NV_HYPER_SAMPLING;
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 346. Instead, use NvAPI_DISP_SetHyperSamplingSettingsEx.")
    NVAPI_INTERFACE NvAPI_DISP_SetHyperSamplingSettings(__in_opt NvU32 displayId, __in NV_HYPER_SAMPLING_CMD cmd,
                                                        __inout NV_HYPER_SAMPLING hyperSampling, __in NvU32 *flag);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 346. Instead, use NvAPI_DISP_GetHyperSamplingSettingsEx.")
    NVAPI_INTERFACE NvAPI_DISP_GetHyperSamplingSettings(__in_opt NvU32 displayId,
                                                        __in_opt NV_HYPER_SAMPLING *hyperSampling, __in NvU32 *flag);
typedef struct _NV_HYPER_SAMPLING_EX_V3 {
  NvU32 version;
  NvU32 samplingFactorsCount;
  NvU32 *pSamplingFactors;
  NvU32 sharpness;
  NV_RESOLUTION *pHyperSampledRes;
  NvU32 flag;
} NV_HYPER_SAMPLING_EX_V3;
typedef struct _NV_HYPER_SAMPLING_EX_V4 {
  NvU32 version;
  NvU32 samplingFactorsCount;
  NvU32 *pSamplingFactors;
  NvU32 sharpness;
  NV_RESOLUTION *pHyperSampledRes;
  NvU32 flag;
  NvU32 customWidth;
  NvU32 customHeight;
} NV_HYPER_SAMPLING_EX_V4;
typedef NV_HYPER_SAMPLING_V1 NV_HYPER_SAMPLING_EX_V1;
typedef NV_HYPER_SAMPLING_V2 NV_HYPER_SAMPLING_EX_V2;
#define NV_HYPER_SAMPLING_EX_VER1 NV_HYPER_SAMPLING_VER1
#define NV_HYPER_SAMPLING_EX_VER2 NV_HYPER_SAMPLING_VER2
#define NV_HYPER_SAMPLING_EX_VER3 MAKE_NVAPI_VERSION(NV_HYPER_SAMPLING_EX_V3, 3)
#define NV_HYPER_SAMPLING_EX_VER4 MAKE_NVAPI_VERSION(NV_HYPER_SAMPLING_EX_V4, 4)
#define NV_HYPER_SAMPLING_EX_VER NV_HYPER_SAMPLING_EX_VER4
typedef NV_HYPER_SAMPLING_EX_V4 NV_HYPER_SAMPLING_EX;
NVAPI_INTERFACE NvAPI_DISP_SetHyperSamplingSettingsEx(__in_opt NvU32 displayId, __in NV_HYPER_SAMPLING_CMD cmd,
                                                      __inout NV_HYPER_SAMPLING_EX *pHyperSampling);
NVAPI_INTERFACE NvAPI_DISP_GetHyperSamplingSettingsEx(__in_opt NvU32 displayId,
                                                      __in_opt NV_HYPER_SAMPLING_EX *pHyperSampling, __in NvU32 flag);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 396. Instead, use NvAPI_DISP_SetOculusZoomFactor.")
    NVAPI_INTERFACE NvAPI_DISP_SetOculusZoomFactor(__in NvU32 displayId, __in float fZoom);
typedef struct {
  NvU64 timeStamp;
  NvU32 ctxDmaAddr0;
  NvU32 scanoutData;
} SCANOUTLOGGING;
typedef enum {
  NV_SCANOUT_LOGGING_DISABLE = 0,
  NV_SCANOUT_LOGGING_ENABLE = 1,
  NV_SCANOUT_LOGGING_GET = 2
} NV_SCANOUT_LOGGING_CMD;
typedef enum {
  NV_SCANOUT_LOG_FLAG_CTXDMA1 = 0,
  NV_SCANOUT_LOG_FLAG_CRC = 1,
  NV_SCANOUT_LOG_FLAG_VRRSTATE = 2,
} NV_SCANOUT_LOG_FLAG;
typedef struct _NV_SCANOUT_LOGGING {
  NvU32 version;
  NvU32 displayId;
  void *pLoggingAddr;
  NvU32 size;
  NvU32 verticalScanline;
  NV_SCANOUT_LOGGING_CMD cmd;
  NvU8 bFreeBuffer;
  NvU8 bUseRasterLineIntr;
  NV_SCANOUT_LOG_FLAG scanoutLogFlag;
} NV_SCANOUT_LOGGING_V1;
#define NV_SCANOUT_LOGGING_VER1 MAKE_NVAPI_VERSION(NV_SCANOUT_LOGGING_V1, 1)
#define NV_SCANOUT_LOGGING_VER NV_SCANOUT_LOGGING_VER1
typedef NV_SCANOUT_LOGGING_V1 NV_SCANOUT_LOGGING;
NVAPI_INTERFACE NvAPI_DISP_ScanoutLogging(__inout NV_SCANOUT_LOGGING *pScanoutLogging);
typedef enum { NV_DP_FULL_LT_STATS = 0, NV_DP_FAST_LT_STATS = 1, NV_DP_NO_LT_STATS = 2 } NV_DP_LT_TYPE_FLAG;
typedef enum { NV_DP_RESET_LT_STATS = 0, NV_DP_GET_LT_STATS = 1 } NV_DP_LT_STATS_CMD;
typedef struct _NV_DP_LT_STATS {
  NvU32 version;
  NvU32 displayId;
  NV_DP_LT_TYPE_FLAG flag;
  NV_DP_LT_STATS_CMD cmd;
  NvU32 dpLTSuccess;
  NvU32 dpLTFailure;
  NvU64 dpMinTimeMicroSec;
  NvU64 dpMaxTimeMicroSec;
  NvU64 dpAvgTimeMicroSec;
} NV_DP_LT_STATS_V1;
#define NV_DP_LT_STATS_VER1 MAKE_NVAPI_VERSION(NV_DP_LT_STATS_V1, 1)
#define NV_DP_LT_STATS_VER NV_DP_LT_STATS_VER1
typedef NV_DP_LT_STATS_V1 NV_DP_LT_STATS;
NVAPI_INTERFACE NvAPI_DISP_LTStats(__inout NV_DP_LT_STATS *pDpLTStats);
#define NV_GSYNC_OVERRIDE_EDID_BUFFER_SIZE 512
typedef struct _NV_GSYNC_INFO {
  NvU32 version;
  NvU32 vLowFrameFreqTimeEst;
  NvU32 vrrMaxFrameInterval;
  NvU32 bDDPanel : 1;
  NvU32 bExternalGsyncPanel : 1;
  NvU32 bNvsrPanel : 1;
  NvU32 bPanelAuthenticated : 1;
  NvU32 bSmartDimmerEnabled : 1;
  NvU32 bVrrCapability : 1;
  NvU32 bVrrAuthenticated : 1;
  NvU32 bCookieValidated : 1;
  NvU32 bVrrBlockInEdid : 1;
  NvU32 bNvsrValidated : 1;
  NvU32 bDDPanelForced : 1;
  NvU32 bNvsrPacdMatched : 1;
  NvU32 bNvsrMutexUnlocked : 1;
  NvU32 reserved : 19;
  NvU8 rmCtrlError;
  NvU8 overrideEdidBufferData[NV_GSYNC_OVERRIDE_EDID_BUFFER_SIZE];
} NV_GSYNC_INFO_V1;
#define NV_GSYNC_INFO_VER1 MAKE_NVAPI_VERSION(NV_GSYNC_INFO_V1, 1)
#define NV_GSYNC_INFO_VER NV_GSYNC_INFO_VER1
typedef NV_GSYNC_INFO_V1 NV_GSYNC_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetGSyncInfo(__in NvU32 displayId, __inout NV_GSYNC_INFO *pGsyncInfo);
typedef enum _NV_SR_ENTER_EXIT_STATS_MODE {
  NV_SR_STATS_SPARSE_MODE = 0,
  NV_SR_STATS_BURST_MODE = 1
} NV_SR_ENTER_EXIT_STATS_MODE;
typedef struct _SR_STATS {
  NvU64 minTimeMicroSec;
  NvU64 maxTimeMicroSec;
  NvU64 avgTimeMicroSec;
} SR_STATS;
typedef struct _NV_SR_GET_STATS {
  NvU32 version;
  NvU32 displayId;
  NV_SR_ENTER_EXIT_STATS_MODE mode;
  SR_STATS SREnterStats;
  SR_STATS SRExitStats;
} NV_SR_GET_STATS_V1;
#define NV_SR_GET_STATS_VER1 MAKE_NVAPI_VERSION(NV_SR_GET_STATS_V1, 1)
#define NV_SR_GET_STATS_VER NV_SR_GET_STATS_VER1
typedef NV_SR_GET_STATS_V1 NV_SR_GET_STATS;
NVAPI_INTERFACE NvAPI_DISP_SR_GET_LATENCY_STATS(__inout NV_SR_GET_STATS *pSRGetStats);
typedef struct _NV_SR_RESET_STATS {
  NvU32 version;
  NvU32 displayId;
  NV_SR_ENTER_EXIT_STATS_MODE mode;
} NV_SR_RESET_STATS_V1;
#define NV_SR_RESET_STATS_VER1 MAKE_NVAPI_VERSION(NV_SR_RESET_STATS_V1, 1)
#define NV_SR_RESET_STATS_VER NV_SR_RESET_STATS_VER1
typedef NV_SR_RESET_STATS_V1 NV_SR_RESET_STATS;
NVAPI_INTERFACE NvAPI_DISP_SR_RESET_LATENCY_STATS(__inout NV_SR_RESET_STATS *pSRResetStats);
#define NV_DP_MAX_MSG_SIZE 16
typedef struct {
  NvU32 auxEvents;
  NvU32 auxRequestTimeStamp;
  NvU32 auxMessageReqSize;
  NvU32 auxMessageReplySize;
  NvU32 auxOutPort;
  NvU32 auxPortAddress;
  NvU32 auxReplyTimeStamp;
  NvU32 auxSerialNo;
  NvU8 auxPacket[NV_DP_MAX_MSG_SIZE];
} NV_DP_AUX_PACKET;
typedef struct {
  NvU32 version;
  NV_DP_AUX_PACKET auxPacket;
} NV_DP_AUX_DATA_V1;
#define NV_DP_AUX_DATA_VER1 MAKE_NVAPI_VERSION(NV_DP_AUX_DATA_V1, 1)
#define NV_DP_AUX_DATA_VER NV_DP_AUX_DATA_VER1
typedef NV_DP_AUX_DATA_V1 NV_DP_AUX_DATA;
NVAPI_INTERFACE NvAPI_DP_ReadAuxLogger(__in NvU32 hPhysicalGpu, __in NvU32 auxloggerReadSize,
                                       __out NvU32 *numLogsRetrieved, __out NV_DP_AUX_PACKET *auxloggerAppBuffer);
#define NV_VRR_GPU_NO_SUPPORT NV_BIT(0)
#define NV_VRR_DISPLAY_NO_SUPPORT NV_BIT(1)
#define NV_VRR_CURRENT_DISPLAY_SETTINGS_NO_SUPPORT NV_BIT(2)
#define NV_VRR_MODE_DISABLED NV_BIT(3)
typedef enum _NV_VRR_MODE {
  NV_VRR_MODE_NOT_SUPPORTED = 0,
  NV_VRR_MODE_FULLSCREEN_ONLY = 1,
  NV_VRR_MODE_FULLSCREEN_AND_WINDOWED = 2,
} NV_VRR_MODE;
typedef struct _NV_VRR_SETTINGS {
  NvU32 version;
  NV_VRR_MODE currentSupportedMode;
  NvU32 problemFlags;
} NV_VRR_SETTINGS_V1;
#define NV_VRR_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_VRR_SETTINGS_V1, 1)
#define NV_VRR_SETTINGS_VER NV_VRR_SETTINGS_VER1
typedef NV_VRR_SETTINGS_V1 NV_VRR_SETTINGS;
NVAPI_INTERFACE NvAPI_DISP_GetCurrentVRRSettings(__in NvU32 displayId, __inout NV_VRR_SETTINGS *pVRRSettings);
NVAPI_INTERFACE NvAPI_DISP_EnableDirectMode(__in NvU32 vendorId, __in NvU32 reserved);
NVAPI_INTERFACE NvAPI_DISP_DisableDirectMode(__in NvU32 vendorId, __in NvU32 reserved);
typedef struct _NV_DIRECT_MODE_DISPLAY_HANDLE {
  NvU32 displayId;
  void *pDisplayContext;
} NV_DIRECT_MODE_DISPLAY_HANDLE;
typedef enum _NV_ENUM_DIRECTMODE_DISPLAY_FLAG {
  NV_ENUM_DIRECTMODE_DISPLAY_CAPABLE = 0,
  NV_ENUM_DIRECTMODE_DISPLAY_ENABLED
} NV_ENUM_DIRECTMODE_DISPLAY_FLAG;
NVAPI_INTERFACE NvAPI_DISP_EnumerateDirectModeDisplays(__in NvU32 vendorId, __inout NvU32 *pNumDisplays,
                                                       __inout_opt NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                                       __in NV_ENUM_DIRECTMODE_DISPLAY_FLAG flag);
NVAPI_INTERFACE NvAPI_DISP_GetDirectModeDisplayHandleFromDisplayId(__in NvU32 displayId,
                                                                   __out NV_DIRECT_MODE_DISPLAY_HANDLE *phNvDisplay);
NVAPI_INTERFACE NvAPI_DISP_GetDisplayIdFromDirectModeDisplayHandle(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phNvDisplay,
                                                                   __out NvU32 *pDisplayId);
typedef enum _NV_DIRECTMODE_DISPLAY_CONTROL {
  NV_DM_DISPLAY_CONTROL_POWER_ON,
  NV_DM_DISPLAY_CONTROL_POWER_OFF,
  NV_DM_DISPLAY_CONTROL_VISIBILITY_ON,
  NV_DM_DISPLAY_CONTROL_VISIBILITY_OFF
} NV_DIRECTMODE_DISPLAY_CONTROL;
NVAPI_INTERFACE NvAPI_DISP_DirectModeDisplayControl(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phNvDisplay,
                                                    __in NV_DIRECTMODE_DISPLAY_CONTROL dispControl);
NV_DECLARE_HANDLE(NvNotifyHandle);
NVAPI_INTERFACE NvAPI_DISP_DirectModeGetVSyncWaitableObject(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phNvDisplay,
                                                            __out NvNotifyHandle *phEvent);
NVAPI_INTERFACE NvAPI_DISP_DirectModeGetPresentWaitableObject(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phNvDisplay,
                                                              __out NvNotifyHandle *phEvent);
NVAPI_INTERFACE NvAPI_DISP_DirectModeGetMissedFrameWaitableObject(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phNvDisplay,
                                                                  __out NvNotifyHandle *phEvent);
typedef enum _NV_ENUM_OS_DEDICATED_DISPLAY_FLAG {
  NV_ENUM_OS_DEDICATED_DISPLAY_ENABLED = 0
} NV_ENUM_OS_DEDICATED_DISPLAY_FLAG;
typedef struct _NV_ENUMERATE_OS_DEDICATED_DISPLAYS_PARAMS {
  NvU32 version;
  NvU32 vendorId;
  NvU32 *pNumDisplays;
  NvU32 *pDisplayIds;
  NV_ENUM_OS_DEDICATED_DISPLAY_FLAG flag;
} NV_ENUMERATE_OS_DEDICATED_DISPLAYS_PARAMS_V1;
typedef NV_ENUMERATE_OS_DEDICATED_DISPLAYS_PARAMS_V1 NV_ENUMERATE_OS_DEDICATED_DISPLAYS_PARAMS;
#define NV_ENUMERATE_OS_DEDICATED_DISPLAYS_PARAMS_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_ENUMERATE_OS_DEDICATED_DISPLAYS_PARAMS_V1, 1)
#define NV_ENUMERATE_OS_DEDICATED_DISPLAYS_PARAMS_VER NV_ENUMERATE_OS_DEDICATED_DISPLAYS_PARAMS_VER1
NVAPI_INTERFACE NvAPI_DISP_EnumerateOsDedicatedDisplays(
    __inout NV_ENUMERATE_OS_DEDICATED_DISPLAYS_PARAMS *pEnumerateOsDedicatedDisplaysParams);
typedef struct {
  NvU32 version;
  NvU8 bDirectFlipCapable;
  NvU8 bIsInIFlipMode;
} NV_DISP_IFLIP_STATE, *PNV_DISP_IFLIP_STATE;
#define NV_DISP_IFLIP_STATE_VER MAKE_NVAPI_VERSION(NV_DISP_IFLIP_STATE, 1)
NVAPI_INTERFACE NvAPI_DISP_GetIFlipStateByDisplayName(const char *displayName, PNV_DISP_IFLIP_STATE pIFlipState);
typedef struct {
  NvU32 version;
  NvU8 bAppWindowCanBeCaptured : 1;
  NvU8 reserved : 7;
  NvU32 dwAppProcId;
} NV_MSHYBRID_FBC_CAPTURE_STATE, *PNV_MSHYBRID_FBC_CAPTURE_STATE;
#define NV_MSHYBRID_FBC_CAPTURE_STATE_VER MAKE_NVAPI_VERSION(NV_MSHYBRID_FBC_CAPTURE_STATE, 1)
NVAPI_INTERFACE NvAPI_DISP_GetMSHybridFBCCaptureState(NV_MSHYBRID_FBC_CAPTURE_STATE *pFBCCaptureState);
#define MAX_PREEMP_SWING_TRIES 20
typedef struct _NV_DP_PreEmpSwingStats {
  NvU8 dpPreEmpAndSwing0_1[MAX_PREEMP_SWING_TRIES];
  NvU8 dpPreEmpAndSwing2_3[MAX_PREEMP_SWING_TRIES];
  NvU8 dpNumPreEmpAndSwingTries;
} NV_DP_PreEmpSwingStats;
typedef struct _NV_DP_LinkTrainingStats {
  NV_DP_PreEmpSwingStats CRStats;
  NV_DP_PreEmpSwingStats CEStats;
} NV_DP_LinkTrainingStats;
typedef struct _NV_DP_LINKSTATISTICS {
  NvU32 version;
  NvU32 displayId;
  NvU32 dpLTSuccess;
  NvU32 dpLTFailure;
  NvU64 dpLTAvgTimeUs;
  NvU64 dpLTMinTimeUs;
  NvU64 dpLTMaxTimeUs;
  NV_DP_LinkTrainingStats fallbackConfig;
  NV_DP_LinkTrainingStats reqConfig;
} NV_DP_LINKSTATISTICS_V1;
#define NV_DP_LINKSTATISTICS_VER1 MAKE_NVAPI_VERSION(NV_DP_LINKSTATISTICS_V1, 1)
#define NV_DP_LINKSTATISTICS_VER NV_DP_LINKSTATISTICS_VER1
typedef NV_DP_LINKSTATISTICS_V1 NV_DP_LINKSTATISTICS;
NVAPI_INTERFACE NvAPI_Disp_DP_GetDPLinkStatistics(__inout NV_DP_LINKSTATISTICS *pDpLinkStatistics);
NVAPI_INTERFACE NvAPI_DISP_GetVidPnSourceId(__in const char *pDeviceName, __out NvU32 *pVidPnSourceId);
typedef struct _NV_IMP_QUERY_MODE_V1 {
  NvU32 version;
  NV_DISP_PATH dispInfo[NV_MAX_HEADS];
  NV_COLOR_FORMAT colorFormat;
  NvAPI_ShortString worstCaseDomain;
  NvU32 isDpImpPossible;
  NvU32 isPossible;
  NvU32 worstCaseMargin;
  NvU32 minPerfLevel;
} NV_IMP_QUERY_MODE_V1;
typedef struct _NV_IMP_QUERY_MODE_V2 {
  NvU32 version;
  NV_DISP_PATH dispInfo[NV_MAX_HEADS];
  NV_COLOR_FORMAT colorFormat;
  NvAPI_ShortString worstCaseDomain;
  NvU32 isDpImpPossible;
  NvU32 isPossible;
  NvU32 worstCaseMargin;
  NvU32 minPerfLevel;
  NvU32 numOfWindowPerHead[NV_MAX_HEADS];
} NV_IMP_QUERY_MODE_V2;
typedef struct _NV_IMP_QUERY_MODE_V3 {
  NvU32 version;
  NV_DISP_PATH dispInfo[NV_MAX_HEADS];
  NV_COLOR_FORMAT colorFormat;
  NvAPI_ShortString worstCaseDomain;
  NvU32 isDpImpPossible;
  NvU32 isPossible;
  NvU32 worstCaseMargin;
  NvU32 minPerfLevel;
  NvU32 numOfWindowPerHead[NV_MAX_HEADS];
  NvU32 dispClkKHz;
  NvU32 reserved[4];
} NV_IMP_QUERY_MODE_V3;
#define NV_IMP_QUERY_MODE_VER_1 MAKE_NVAPI_VERSION(NV_IMP_QUERY_MODE_V1, 1)
#define NV_IMP_QUERY_MODE_VER_2 MAKE_NVAPI_VERSION(NV_IMP_QUERY_MODE_V2, 2)
#define NV_IMP_QUERY_MODE_VER_3 MAKE_NVAPI_VERSION(NV_IMP_QUERY_MODE_V3, 3)
#define NV_IMP_QUERY_MODE_VER NV_IMP_QUERY_MODE_VER_3
typedef NV_IMP_QUERY_MODE_V3 NV_IMP_QUERY_MODE;
NVAPI_INTERFACE NvAPI_DISP_IMPQuery(__inout NV_IMP_QUERY_MODE *pImpQueryInfo);
typedef struct _NV_DSC_DATA_V1 {
  NvU32 sliceWidth;
  NvU32 sliceCount;
  NvU8 dpMode;
  NvU32 modeWidth;
  NvU32 modeHeight;
  NvU32 refreshRate;
  NvU32 bitsPerPixel;
  NvU32 dscState;
  NvU32 fecState;
  NvU32 colorFormat;
  NvU32 bitsPerComponent;
  NvU32 dscVersion;
} NV_DSC_DATA_V1;
typedef struct _NV_DSC_CONTROL_DATA_V1 {
  NvU32 version;
  NVAPI_CMD cmd;
  NV_DSC_DATA_V1 data;
} NV_DSC_CONTROL_DATA_V1;
typedef NV_DSC_CONTROL_DATA_V1 NV_DSC_CONTROL_DATA;
#define NV_DSC_CONTROL_DATA_VER1 MAKE_NVAPI_VERSION(NV_DSC_CONTROL_DATA_V1, 1)
#define NV_DSC_CONTROL_DATA_VER NV_DSC_CONTROL_DATA_VER1
NVAPI_INTERFACE NvAPI_DISP_DpDscControl(__in NvU32 displayId, __inout NV_DSC_CONTROL_DATA *pDscControlData);
typedef enum _NV_HDMI_FRL_PREFERENCE {
  NV_HDMI_FRL_PREFERENCE_ANY_CONFIG = 0,
  NV_HDMI_FRL_PREFERENCE_OPTIMUM_CONFIG,
  NV_HDMI_FRL_PREFERENCE_LOWEST_BANDWIDTH,
  NV_HDMI_FRL_PREFERENCE_HIGHEST_PIXEL_QUALITY,
  NV_HDMI_FRL_PREFERENCE_HIGHEST_BANDWIDTH
} NV_HDMI_FRL_PREFERENCE;
typedef struct _NV_DSC_PARAMS_V1 {
  NvU32 dscState;
  NvU32 bitsPerPixel;
  NvU32 bitsPerComponent;
  NvU32 sliceCount;
  NvU32 colorFormat;
  NvU32 dscVersion;
  NvU32 isDp : 1;
  NvU32 bForceHdmiFrl : 1;
  NvU32 reserved : 30;
  union {
    struct {
      NV_HDMI_FRL_PREFERENCE configCtrl;
      NV_HDMI_FRL_RATE frlRate;
    } hdmi;
    struct {
      NvU32 fecState;
      NvU8 mstMode;
    } dp;
  } context;
  NvU32 sliceWidth;
  NvU32 modeWidth;
  NvU32 modeHeight;
  NvU32 refreshRate;
  NvU32 reserved1;
} NV_DSC_PARAMS_V1;
typedef struct _NV_DSC_CONTROL_V1 {
  NvU32 version;
  NVAPI_CMD cmd;
  NV_DSC_PARAMS_V1 data;
} NV_DSC_CONTROL_V1;
typedef NV_DSC_CONTROL_V1 NV_DSC_CONTROL;
#define NV_DSC_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_DSC_CONTROL_V1, 1)
#define NV_DSC_CONTROL_VER NV_DSC_CONTROL_VER1
NVAPI_INTERFACE NvAPI_DISP_DscControl(__in NvU32 displayId, __inout NV_DSC_CONTROL *pDscControl);
typedef struct _NV_GET_BT_INFO_V1 {
  NvU32 version;
  NvU8 overridePanelCapbyAux;
  NvU8 overridePanelCapbyPin;
  NvU8 overridebacklightSupported;
  NvU8 overridebacklightEnabled;
} NV_GET_BT_INFO_V1;
#define NV_GET_BT_INFO_VER1 MAKE_NVAPI_VERSION(NV_GET_BT_INFO_V1, 1)
#define NV_GET_BT_INFO_VER NV_GET_BT_INFO_VER1
typedef NV_GET_BT_INFO_V1 NV_GET_BT_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetBackLightInfo(__in NvU32 displayId, __inout NV_GET_BT_INFO *pBacklightType);
#define NV_GET_SBIOS_INFO_DATA_SIZE 20
typedef struct _NV_GET_SBIOS_BRIGHTNESS_INFO_V1 {
  NvU32 version;
  NvU8 backlightType;
  NvU8 pwmInfoProvider;
  NvU8 pwmInfoEntries;
  NvU16 minDutyCyclePer1000[NV_GET_SBIOS_INFO_DATA_SIZE];
  NvU16 maxDutyCyclePer1000[NV_GET_SBIOS_INFO_DATA_SIZE];
  NvU16 input_curve[NV_GET_SBIOS_INFO_DATA_SIZE];
  NvU16 output_curve[NV_GET_SBIOS_INFO_DATA_SIZE];
  NvU32 pwmFrequency[NV_GET_SBIOS_INFO_DATA_SIZE];
  NvU32 nbciControlType;
  NvU32 pwmInfoEntriesTotal;
  NvU32 nEntries;
  NvU32 reserved[4];
} NV_GET_SBIOS_BRIGHTNESS_INFO_V1;
#define NV_GET_SBIOS_BRIGHTNESS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GET_SBIOS_BRIGHTNESS_INFO_V1, 1)
#define NV_GET_SBIOS_BRIGHTNESS_INFO_VER NV_GET_SBIOS_BRIGHTNESS_INFO_VER1
typedef NV_GET_SBIOS_BRIGHTNESS_INFO_V1 NV_GET_SBIOS_BRIGHTNESS_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetSbiosBrightnessInfo(__in NvU32 displayId,
                                                  __inout NV_GET_SBIOS_BRIGHTNESS_INFO *pSbiosBrightnessInfo);
#define NV_GET_PANEL_DPCD_MAX_DATA_SIZE 16
typedef struct _NV_GET_PANEL_BRIGHTNESS_INFO_V1 {
  NvU32 version;
  NvU8 dpcd_data[NV_GET_PANEL_DPCD_MAX_DATA_SIZE];
  NvU32 targetFreq;
  NvU32 actualFreq;
  NvU32 dutyCycle;
  NvU32 reserved[4];
} NV_GET_PANEL_BRIGHTNESS_INFO_V1;
#define NV_GET_PANEL_BRIGHTNESS_INFO_VER1 MAKE_NVAPI_VERSION(NV_GET_PANEL_BRIGHTNESS_INFO_V1, 1)
#define NV_GET_PANEL_BRIGHTNESS_INFO_VER NV_GET_PANEL_BRIGHTNESS_INFO_VER1
typedef NV_GET_PANEL_BRIGHTNESS_INFO_V1 NV_GET_PANEL_BRIGHTNESS_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetPanelBrightnessInfo(__in NvU32 displayId,
                                                  __inout NV_GET_PANEL_BRIGHTNESS_INFO *pPanelBrightnessInfo);
#define NVAPI_DP_FEC_ERROR_COUNT_MAX 5
#define NVAPI_DP_FEC_MAX_LANE_COUNT 4
#define NVAPI_UNCORRECTED_BLOCK_COUNT 1
#define NVAPI_DP_CORRECTED_BLOCK_COUNT 2
#define NVAPI_DP_BIT_COUNT 4
#define NVAPI_DP_PARITY_BLOCK_COUNT 8
#define NVAPI_DP_PARITY_BIT_COUNT 16
typedef struct _NV_FEC_QUERY_DATA_V1 {
  NV_DP_ADDRESS auxAddress;
  NvU8 fecStatus;
  NvU16 fecErrorCount[NVAPI_DP_FEC_MAX_LANE_COUNT][NVAPI_DP_FEC_ERROR_COUNT_MAX];
  NvU32 flags;
} NV_FEC_QUERY_DATA_V1;
typedef struct _NV_FEC_QUERY_CONTROL_DATA_V1 {
  NvU32 version;
  NV_FEC_QUERY_DATA_V1 data;
} NV_FEC_QUERY_CONTROL_DATA_V1;
typedef NV_FEC_QUERY_CONTROL_DATA_V1 NV_FEC_QUERY_CONTROL_DATA;
#define NV_FEC_QUERY_CONTROL_DATA_VER1 MAKE_NVAPI_VERSION(NV_FEC_QUERY_CONTROL_DATA_V1, 1)
#define NV_FEC_QUERY_CONTROL_DATA_VER NV_FEC_QUERY_CONTROL_DATA_VER1
NVAPI_INTERFACE NvAPI_DISP_DpFecQueryControl(__in NvU32 displayId,
                                             __inout NV_FEC_QUERY_CONTROL_DATA *pFecQueryControlData);
typedef enum _NV_DSC_CRC_CMD {
  NV_DSC_CRC_CMD_GET = 0,
  NV_DSC_CRC_CMD_SET,
} NV_DSC_CRC_CMD;
typedef struct _NV_DSC_CRC_CONTROL_V1 {
  NV_DP_ADDRESS auxAddress;
  NV_DSC_CRC_CMD cmd;
  NvBool bEnable;
  NvU16 gpuCrc0;
  NvU16 gpuCrc1;
  NvU16 gpuCrc2;
  NvU16 sinkCrc0;
  NvU16 sinkCrc1;
  NvU16 sinkCrc2;
} NV_DSC_CRC_CONTROL_DATA_V1;
typedef struct _NV_DSC_CRC_CONTROL_CONTROL_DATA_V1 {
  NvU32 version;
  NV_DSC_CRC_CONTROL_DATA_V1 data;
} NV_DSC_CRC_CONTROL_CONTROL_DATA_V1;
typedef NV_DSC_CRC_CONTROL_CONTROL_DATA_V1 NV_DSC_CRC_CONTROL_CONTROL_DATA;
#define NV_DSC_CRC_CONTROL_CONTROL_DATA_VER1 MAKE_NVAPI_VERSION(NV_DSC_CRC_CONTROL_CONTROL_DATA_V1, 1)
#define NV_DSC_CRC_CONTROL_CONTROL_DATA_VER NV_DSC_CRC_CONTROL_CONTROL_DATA_VER1
NVAPI_INTERFACE NvAPI_DISP_DpDscCrcControlControl(__in NvU32 displayId,
                                                  __inout NV_DSC_CRC_CONTROL_CONTROL_DATA *pCrcControlControlData);
#define NVAPI_DP_PPS_SIZE 32
#define NVAPI_HEAD_SET_DSC_PPS_DATA0_DSC_VERSION_MINOR 3 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA0_DSC_VERSION_MAJOR 7 : 4
#define NVAPI_HEAD_SET_DSC_PPS_DATA0_PPS_IDENTIFIER 15 : 8
#define NVAPI_HEAD_SET_DSC_PPS_DATA0_RESERVED 23 : 16
#define NVAPI_HEAD_SET_DSC_PPS_DATA0_LINEBUF_DEPTH 27 : 24
#define NVAPI_HEAD_SET_DSC_PPS_DATA0_BITS_PER_COMPONENT 31 : 28
#define NVAPI_HEAD_SET_DSC_PPS_DATA1_BITS_PER_PIXEL_HIGH 1 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA1_VBR_ENABLE 2 : 2
#define NVAPI_HEAD_SET_DSC_PPS_DATA1_SIMPLE422 3 : 3
#define NVAPI_HEAD_SET_DSC_PPS_DATA1_CONVERT_RGB 4 : 4
#define NVAPI_HEAD_SET_DSC_PPS_DATA1_BLOCK_PRED_ENABLE 5 : 5
#define NVAPI_HEAD_SET_DSC_PPS_DATA1_RESERVED 7 : 6
#define NVAPI_HEAD_SET_DSC_PPS_DATA1_BITS_PER_PIXEL_LOW 15 : 8
#define NVAPI_HEAD_SET_DSC_PPS_DATA1_PIC_HEIGHT_HIGH 23 : 16
#define NVAPI_HEAD_SET_DSC_PPS_DATA1_PIC_HEIGHT_LOW 31 : 24
#define NVAPI_HEAD_SET_DSC_PPS_DATA2_PIC_WIDTH_HIGH 7 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA2_PIC_WIDTH_LOW 15 : 8
#define NVAPI_HEAD_SET_DSC_PPS_DATA2_SLICE_HEIGHT_HIGH 23 : 16
#define NVAPI_HEAD_SET_DSC_PPS_DATA2_SLICE_HEIGHT_LOW 31 : 24
#define NVAPI_HEAD_SET_DSC_PPS_DATA3_SLICE_WIDTH_HIGH 7 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA3_SLICE_WIDTH_LOW 15 : 8
#define NVAPI_HEAD_SET_DSC_PPS_DATA3_CHUNK_SIZE_HIGH 23 : 16
#define NVAPI_HEAD_SET_DSC_PPS_DATA3_CHUNK_SIZE_LOW 31 : 24
#define NVAPI_HEAD_SET_DSC_PPS_DATA4_INITIAL_XMIT_DELAY_HIGH 1 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA4_RESERVED 7 : 2
#define NVAPI_HEAD_SET_DSC_PPS_DATA4_INITIAL_XMIT_DELAY_LOW 15 : 8
#define NVAPI_HEAD_SET_DSC_PPS_DATA4_INITIAL_DEC_DELAY_HIGH 23 : 16
#define NVAPI_HEAD_SET_DSC_PPS_DATA4_INITIAL_DEC_DELAY_LOW 31 : 24
#define NVAPI_HEAD_SET_DSC_PPS_DATA5_RESERVED0 7 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA5_INITIAL_SCALE_VALUE 13 : 8
#define NVAPI_HEAD_SET_DSC_PPS_DATA5_RESERVED1 15 : 14
#define NVAPI_HEAD_SET_DSC_PPS_DATA5_SCALE_INCREMENT_INTERVAL_HIGH 23 : 16
#define NVAPI_HEAD_SET_DSC_PPS_DATA5_SCALE_INCREMENT_INTERVAL_LOW 31 : 24
#define NVAPI_HEAD_SET_DSC_PPS_DATA6_SCALE_DECREMENT_INTERVAL_HIGH 3 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA6_RESERVED0 7 : 4
#define NVAPI_HEAD_SET_DSC_PPS_DATA6_SCALE_DECREMENT_INTERVAL_LOW 15 : 8
#define NVAPI_HEAD_SET_DSC_PPS_DATA6_RESERVED1 23 : 16
#define NVAPI_HEAD_SET_DSC_PPS_DATA6_FIRST_LINE_BPG_OFFSET 28 : 24
#define NVAPI_HEAD_SET_DSC_PPS_DATA6_RESERVED2 31 : 29
#define NVAPI_HEAD_SET_DSC_PPS_DATA7_NFL_BPG_OFFSET_HIGH 7 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA7_NFL_BPG_OFFSET_LOW 15 : 8
#define NVAPI_HEAD_SET_DSC_PPS_DATA7_SLICE_BPG_OFFSET_HIGH 23 : 16
#define NVAPI_HEAD_SET_DSC_PPS_DATA7_SLICE_BPG_OFFSET_LOW 31 : 24
#define NVAPI_HEAD_SET_DSC_PPS_DATA8_INITIAL_OFFSET_HIGH 7 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA8_INITIAL_OFFSET_LOW 15 : 8
#define NVAPI_HEAD_SET_DSC_PPS_DATA8_FINAL_OFFSET_HIGH 23 : 16
#define NVAPI_HEAD_SET_DSC_PPS_DATA8_FINAL_OFFSET_LOW 31 : 24
#define NVAPI_HEAD_SET_DSC_PPS_DATA9_FLATNESS_MIN_QP 4 : 0
#define NVAPI_HEAD_SET_DSC_PPS_DATA9_RESERVED0 7 : 5
#define NVAPI_HEAD_SET_DSC_PPS_DATA9_FLATNESS_MAX_QP 12 : 8
typedef struct _NV_PPS_QUERY_V1 {
  NV_DP_ADDRESS auxAddress;
  NvU32 pps[NVAPI_DP_PPS_SIZE];
  NvBool bHardwareState;
} NV_PPS_QUERY_DATA_V1;
typedef struct _NV_PPS_QUERY_CONTROL_DATA_V1 {
  NvU32 version;
  NV_PPS_QUERY_DATA_V1 data;
} NV_PPS_QUERY_CONTROL_DATA_V1;
typedef NV_PPS_QUERY_CONTROL_DATA_V1 NV_PPS_QUERY_CONTROL_DATA;
#define NV_PPS_QUERY_CONTROL_DATA_VER1 MAKE_NVAPI_VERSION(NV_PPS_QUERY_CONTROL_DATA_V1, 1)
#define NV_PPS_QUERY_CONTROL_DATA_VER NV_PPS_QUERY_CONTROL_DATA_VER1
NVAPI_INTERFACE NvAPI_DISP_DpPpsQueryControl(__in NvU32 displayId,
                                             __inout NV_PPS_QUERY_CONTROL_DATA *pPpsQueryControlData);
typedef struct _NV_EDID_DATA_V1 {
  NvU32 version;
  NvU8 *pEDID;
  NvU32 sizeOfEDID;
} NV_EDID_DATA_V1;
typedef struct _NV_EDID_DATA_V2 {
  NvU32 version;
  NvU8 *pEDID;
  NvU32 sizeOfEDID;
  NvU32 reserved[8];
} NV_EDID_DATA_V2;
typedef NV_EDID_DATA_V2 NV_EDID_DATA;
#define NV_EDID_DATA_VER1 MAKE_NVAPI_VERSION(NV_EDID_DATA_V1, 1)
#define NV_EDID_DATA_VER2 MAKE_NVAPI_VERSION(NV_EDID_DATA_V2, 2)
#define NV_EDID_DATA_VER NV_EDID_DATA_VER2
NVAPI_INTERFACE NvAPI_DISP_GetEdidData(__in NvU32 displayId, __inout NV_EDID_DATA *pEdidParams,
                                       __inout NV_EDID_FLAG *pFlag);
NVAPI_INTERFACE NvAPI_DISP_ValidateEdidData(__in NvU32 displayId, __in NV_EDID_DATA *pEdidParams, __out NvU32 *pFlag);
NVAPI_INTERFACE NvAPI_DISP_SetEdidData(__in NvU32 displayId, __in NV_EDID_DATA *pEdidParams);
NVAPI_INTERFACE NvAPI_DISP_ValidateEdid(NvU32 displayId, NV_EDID *pEdid, NvU32 *pVFlag);
typedef struct _NV_PAN_SCAN_INFO_V1 {
  NvU32 version;
  NvU32 bPanScanState : 1;
  NvU32 reserved : 31;
} NV_PAN_SCAN_INFO_V1;
#define NV_PAN_SCAN_INFO_VER1 MAKE_NVAPI_VERSION(NV_PAN_SCAN_INFO_V1, 1)
#define NV_PAN_SCAN_INFO_VER NV_PAN_SCAN_INFO_VER1
typedef NV_PAN_SCAN_INFO_V1 NV_PAN_SCAN_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetPanScanInfo(__in NvU32 displayId, __inout NV_PAN_SCAN_INFO *panScanInfo);
NVAPI_INTERFACE NvAPI_DISP_SetPanScanInfo(__in NvU32 displayId, __in NV_PAN_SCAN_INFO *panScanInfo);
typedef struct _NV_GET_ADAPTIVE_SYNC_DATA_V1 {
  NvU32 version;
  NvU32 maxFrameInterval;
  NvU32 bDisableAdaptiveSync : 1;
  NvU32 bDisableFrameSplitting : 1;
  NvU32 reserved : 30;
  NvU32 lastFlipRefreshCount;
  NvU64 lastFlipTimeStamp;
  NvU32 reservedEx[4];
} NV_GET_ADAPTIVE_SYNC_DATA_V1;
#define NV_GET_ADAPTIVE_SYNC_DATA_VER1 MAKE_NVAPI_VERSION(NV_GET_ADAPTIVE_SYNC_DATA_V1, 1)
#define NV_GET_ADAPTIVE_SYNC_DATA_VER NV_GET_ADAPTIVE_SYNC_DATA_VER1
typedef NV_GET_ADAPTIVE_SYNC_DATA_V1 NV_GET_ADAPTIVE_SYNC_DATA;
NVAPI_INTERFACE NvAPI_DISP_GetAdaptiveSyncData(__in NvU32 displayId,
                                               __inout NV_GET_ADAPTIVE_SYNC_DATA *pAdaptiveSyncData);
typedef struct _NV_SET_ADAPTIVE_SYNC_DATA_V1 {
  NvU32 version;
  NvU32 maxFrameInterval;
  NvU32 bDisableAdaptiveSync : 1;
  NvU32 bDisableFrameSplitting : 1;
  NvU32 reserved : 30;
  NvU32 reservedEx[7];
} NV_SET_ADAPTIVE_SYNC_DATA_V1;
#define NV_SET_ADAPTIVE_SYNC_DATA_VER1 MAKE_NVAPI_VERSION(NV_SET_ADAPTIVE_SYNC_DATA_V1, 1)
#define NV_SET_ADAPTIVE_SYNC_DATA_VER NV_SET_ADAPTIVE_SYNC_DATA_VER1
typedef NV_SET_ADAPTIVE_SYNC_DATA_V1 NV_SET_ADAPTIVE_SYNC_DATA;
NVAPI_INTERFACE NvAPI_DISP_SetAdaptiveSyncData(__in NvU32 displayId, __in NV_SET_ADAPTIVE_SYNC_DATA *pAdaptiveSyncData);
typedef struct _NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1 {
  NvU32 version;
  NvU32 frameIntervalUs;
  NvU32 reservedEx[8];
} NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1;
#define NV_GET_VIRTUAL_REFRESH_RATE_DATA_VER1 MAKE_NVAPI_VERSION(_NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1, 1)
#define NV_GET_VIRTUAL_REFRESH_RATE_DATA_VER NV_GET_VIRTUAL_REFRESH_RATE_DATA_VER1
typedef NV_GET_VIRTUAL_REFRESH_RATE_DATA_V1 NV_GET_VIRTUAL_REFRESH_RATE_DATA;
NVAPI_INTERFACE NvAPI_DISP_GetVirtualRefreshRateData(__in NvU32 displayId,
                                                     __inout NV_GET_VIRTUAL_REFRESH_RATE_DATA *pVirtualRefreshRateData);
typedef struct _NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1 {
  NvU32 version;
  NvU32 frameIntervalUs;
  NvU32 reservedEx[8];
} NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1;
#define NV_SET_VIRTUAL_REFRESH_RATE_DATA_VER1 MAKE_NVAPI_VERSION(_NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1, 1)
#define NV_SET_VIRTUAL_REFRESH_RATE_DATA_VER NV_SET_VIRTUAL_REFRESH_RATE_DATA_VER1
typedef NV_SET_VIRTUAL_REFRESH_RATE_DATA_V1 NV_SET_VIRTUAL_REFRESH_RATE_DATA;
NVAPI_INTERFACE NvAPI_DISP_SetVirtualRefreshRateData(__in NvU32 displayId,
                                                     __in NV_SET_VIRTUAL_REFRESH_RATE_DATA *pVirtualRefreshRateData);
typedef enum _NV_MUX_TRANSITION { NV_MUX_TRANSITION_BEGIN = 0, NV_MUX_TRANSITION_END = 1 } NV_MUX_TRANSITION;
typedef enum _NV_MUX_TRANSITION_MODE {
  NV_MUX_TRANSITION_MODE_IGPU_TO_DGPU = 0,
  NV_MUX_TRANSITION_MODE_DGPU_TO_IGPU = 1,
} NV_MUX_TRANSITION_MODE;
typedef struct _NV_MUX_TRANSITION_DATA_V1 {
  NvU32 version;
  NV_MUX_TRANSITION muxTransition;
  NV_MUX_TRANSITION_MODE muxTransitionMode;
  NvU32 bskipSR : 1;
  NvU32 bBlockingSrExit : 1;
  NvU32 bForceExitSR : 1;
  NvU32 reserved : 29;
  NvU32 reservedEx[7];
} NV_MUX_TRANSITION_DATA_V1;
#define NV_MUX_TRANSITION_DATA_VER1 MAKE_NVAPI_VERSION(NV_MUX_TRANSITION_DATA_V1, 1)
#define NV_MUX_TRANSITION_DATA_VER NV_MUX_TRANSITION_DATA_VER1
typedef NV_MUX_TRANSITION_DATA_V1 NV_MUX_TRANSITION_DATA;
NVAPI_INTERFACE NvAPI_DISP_MuxTransition(__in NvU32 displayId, __in NV_MUX_TRANSITION_DATA *pMuxTransitionData);
typedef enum _NV_MUX_STATE { NV_MUX_STATE_INVALID = 0, NV_MUX_STATE_IGPU = 1, NV_MUX_STATE_DGPU = 2 } NV_MUX_STATE;
typedef enum _NV_DYNAMIC_DISPLAY_MUX_SWITCH_TYPE {
  NV_DYNAMIC_DISPLAY_MUX_SWITCH_TYPE_INVALID = 0,
  NV_DYNAMIC_DISPLAY_MUX_SWITCH_TYPE_AUTOMATIC = 1,
  NV_DYNAMIC_DISPLAY_MUX_SWITCH_TYPE_MANUAL = 2,
} NV_DYNAMIC_DISPLAY_MUX_SWITCH_TYPE;
typedef struct _NV_GET_DISPLAY_MUX_INFO_V1 {
  NvU32 version;
  NV_DYNAMIC_DISPLAY_MUX_SWITCH_TYPE muxSwitchType;
  NV_MUX_STATE muxState;
  NvU32 isSupported : 1;
  NvU32 reserved : 31;
} NV_GET_DISPLAY_MUX_INFO_V1;
#define NV_GET_DISPLAY_MUX_INFO_VER1 MAKE_NVAPI_VERSION(NV_GET_DISPLAY_MUX_INFO_V1, 1)
#define NV_GET_DISPLAY_MUX_INFO_VER NV_GET_DISPLAY_MUX_INFO_VER1
typedef NV_GET_DISPLAY_MUX_INFO_V1 NV_GET_DISPLAY_MUX_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetDisplayMuxCaps(__in NvU32 displayId, __inout NV_GET_DISPLAY_MUX_INFO *pDisplayMuxInfo);
typedef enum _NV_MUX_MODE {
  NV_MUX_MODE_INVALID = 0,
  NV_MUX_MODE_INTEGRATED_ONLY = 1,
  NV_MUX_MODE_DISCRETE_ONLY = 2,
  NV_MUX_MODE_HYBRID = 3,
  NV_MUX_MODE_DYNAMIC = 4
} NV_MUX_MODE;
typedef struct _NV_MUX_INFO_V1 {
  NvU32 version;
  NV_MUX_STATE muxState;
  NV_MUX_MODE muxMode;
  NvU32 bInternalDisplay : 1;
  NvU32 reserved : 31;
} NV_MUX_INFO_V1;
#define NV_MUX_INFO_VER1 MAKE_NVAPI_VERSION(NV_MUX_INFO_V1, 1)
#define NV_MUX_INFO_VER NV_MUX_INFO_VER1
typedef NV_MUX_INFO_V1 NV_MUX_INFO;
NVAPI_INTERFACE NvAPI_DISP_QueryMuxInfo(__in NvU32 displayId, __inout NV_MUX_INFO *pMuxInfo);
typedef enum _NV_MUX_IGPU_BL_EN_STATE {
  NV_MUX_IGPU_BL_EN_STATE_INVALID = 0,
  NV_MUX_IGPU_BL_EN_STATE_OFF = 1,
  NV_MUX_IGPU_BL_EN_STATE_ON = 2
} NV_MUX_IGPU_BL_EN_STATE;
typedef struct _NV_MUX_IGPU_BL_EN_DATA_V1 {
  NvU32 version;
  NV_MUX_IGPU_BL_EN_STATE iGpuBlenState;
} NV_MUX_IGPU_BL_EN_DATA_V1;
#define NV_MUX_IGPU_BL_EN_DATA_VER1 MAKE_NVAPI_VERSION(NV_MUX_IGPU_BL_EN_DATA_V1, 1)
#define NV_MUX_IGPU_BL_EN_DATA_VER NV_MUX_IGPU_BL_EN_DATA_VER1
typedef NV_MUX_IGPU_BL_EN_DATA_V1 NV_MUX_IGPU_BL_EN_DATA;
NVAPI_INTERFACE NvAPI_DISP_QueryIgpuBlenState(__in NvU32 displayId, __inout NV_MUX_IGPU_BL_EN_DATA *pMuxIgpuBlenState);
#define NVAPI_DYNAMIC_DISPLAY_MUX_OFFENDING_PID_COUNT 20
typedef enum _NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE {
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE_OK,
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE_OFFENDING_PROCESSES,
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE_MULTIHEAD_ACTIVE,
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE_MULTIHEAD_INACTIVE,
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE_IGPU_HEAD_UNAVAILABLE,
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE_IGPU_HEAD_RECOVERED,
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE_DGPU_HIDE_MODELIST,
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE_DGPU_HEAD_UNAVAILABLE,
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE_PSR_API_UNAVAILABLE,
} NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE;
typedef struct _NV_SET_DISPLAY_MUX_INFO_V1 {
  NvU32 version;
  NV_DISPLAY_MUX_SWITCH_NVSVC_RESPONSE nvsvcResponseCode;
  NV_DYNAMIC_DISPLAY_MUX_SWITCH_TYPE muxSwitchType;
  NV_MUX_STATE muxStateRequest;
  NvU32 offendingPIDCount;
  NvU32 offendingPIDs[NVAPI_DYNAMIC_DISPLAY_MUX_OFFENDING_PID_COUNT];
} NV_SET_DISPLAY_MUX_INFO_V1;
#define NV_SET_DISPLAY_MUX_INFO_VER1 MAKE_NVAPI_VERSION(NV_SET_DISPLAY_MUX_INFO_V1, 1)
#define NV_SET_DISPLAY_MUX_INFO_VER NV_SET_DISPLAY_MUX_INFO_VER1
typedef NV_SET_DISPLAY_MUX_INFO_V1 NV_SET_DISPLAY_MUX_INFO;
NVAPI_INTERFACE NvAPI_DISP_SetDisplayMux(__in NvU32 displayId, __in NV_SET_DISPLAY_MUX_INFO *pDisplayMuxInfo);
#define NVAPI_DYNAMIC_DISPLAY_MUX_PID_COUNT 20
#define NVAPI_DYNAMIC_DISPLAY_MUX_PERF_HIST_SIZE 30
typedef enum _NV_DISPLAY_MUX_PERF_CTR_ID {
  NV_DISPLAY_MUX_PERF_CTR_ID_TOTAL_MUX_SWITCH_LATENCY,
  NV_DISPLAY_MUX_PERF_CTR_ID_NVSVC_EVENT_RESPONSE_LATENCY,
  NV_DISPLAY_MUX_PERF_CTR_ID_HW_SR_ENTRY_LATENCY,
  NV_DISPLAY_MUX_PERF_CTR_ID_HW_MUX_SWITCH_LATENCY,
  NV_DISPLAY_MUX_PERF_CTR_ID_HW_SR_EXIT_LATENCY,
  NV_DISPLAY_MUX_PERF_CTR_ID_USERMODE_OS_OVERHEAD,
  NV_DISPLAY_MUX_PERF_CTR_ID_MODESET_LATENCY,
  NV_DISPLAY_MUX_PERF_CTR_ID_DD_MUX_SWITCH_LATENCY,
  NV_DISPLAY_MUX_PERF_CTR_ID_HW_SR_EXIT_TRANS_INACTIVE_LATENCY,
  NV_DISPLAY_MUX_PERF_CTR_ID_MAX
} NV_DISPLAY_MUX_PERF_CTR_ID;
typedef struct _NV_DISPLAY_MUX_PROCESS_INFO_V1 {
  NvU32 processCount;
  NvU64 processHandles[NVAPI_DYNAMIC_DISPLAY_MUX_PID_COUNT];
} NV_DISPLAY_MUX_PROCESS_INFO_V1;
typedef struct _NV_DISPLAY_MUX_PERF_COUNT_V1 {
  NvU32 latency[NV_DISPLAY_MUX_PERF_CTR_ID_DD_MUX_SWITCH_LATENCY + 1][NVAPI_DYNAMIC_DISPLAY_MUX_PERF_HIST_SIZE];
  NvU32 min[NV_DISPLAY_MUX_PERF_CTR_ID_DD_MUX_SWITCH_LATENCY + 1];
  NvU32 max[NV_DISPLAY_MUX_PERF_CTR_ID_DD_MUX_SWITCH_LATENCY + 1];
  NvU32 avg[NV_DISPLAY_MUX_PERF_CTR_ID_DD_MUX_SWITCH_LATENCY + 1];
} NV_DISPLAY_MUX_PERF_COUNT_V1;
typedef struct _NV_DISPLAY_MUX_PERF_COUNT_V2 {
  NvU32 latency[NV_DISPLAY_MUX_PERF_CTR_ID_MAX][NVAPI_DYNAMIC_DISPLAY_MUX_PERF_HIST_SIZE];
  NvU32 min[NV_DISPLAY_MUX_PERF_CTR_ID_MAX];
  NvU32 max[NV_DISPLAY_MUX_PERF_CTR_ID_MAX];
  NvU32 avg[NV_DISPLAY_MUX_PERF_CTR_ID_MAX];
} NV_DISPLAY_MUX_PERF_COUNT_V2;
typedef struct _NV_GET_DISPLAY_MUX_STATS_V1 {
  NvU32 version;
  NV_DISPLAY_MUX_PROCESS_INFO_V1 offendingProcesses;
  NV_DISPLAY_MUX_PROCESS_INFO_V1 pendingProcesses;
  NV_DISPLAY_MUX_PROCESS_INFO_V1 dMuxProcesses;
  NV_DISPLAY_MUX_PERF_COUNT_V1 perfCounts;
} NV_GET_DISPLAY_MUX_STATS_V1;
typedef struct _NV_GET_DISPLAY_MUX_STATS_V2 {
  NvU32 version;
  NV_DISPLAY_MUX_PROCESS_INFO_V1 offendingProcesses;
  NV_DISPLAY_MUX_PROCESS_INFO_V1 pendingProcesses;
  NV_DISPLAY_MUX_PROCESS_INFO_V1 dMuxProcesses;
  NV_DISPLAY_MUX_PERF_COUNT_V2 perfCounts;
} NV_GET_DISPLAY_MUX_STATS_V2;
#define NV_GET_DISPLAY_MUX_STATS_VER1 MAKE_NVAPI_VERSION(NV_GET_DISPLAY_MUX_STATS_V1, 1)
#define NV_GET_DISPLAY_MUX_STATS_VER2 MAKE_NVAPI_VERSION(NV_GET_DISPLAY_MUX_STATS_V2, 2)
#define NV_GET_DISPLAY_MUX_STATS_VER NV_GET_DISPLAY_MUX_STATS_VER2
typedef NV_GET_DISPLAY_MUX_STATS_V2 NV_GET_DISPLAY_MUX_STATS;
NVAPI_INTERFACE NvAPI_DISP_GetDisplayMuxStats(__in NvU32 displayId, __inout NV_GET_DISPLAY_MUX_STATS *pMuxStatData);
typedef enum _NV_DISP_MUX_SB_I2C_CMD {
  NV_DISP_MUX_SB_I2C_CMD_INVALID = 0,
  NV_DISP_MUX_SB_I2C_CMD_WRITE,
  NV_DISP_MUX_SB_I2C_CMD_READ,
} NV_DISP_MUX_SB_I2C_CMD;
#define NV_DISP_SIDEBAND_I2C_CTRL_MAX_DATA_SIZE 1
typedef struct _NV_DISP_MUX_SB_I2C_CONTROL_DATA_V1 {
  NvU32 version;
  NV_DISP_MUX_SB_I2C_CMD cmd;
  NvU16 addr;
  NvU8 data[NV_DISP_SIDEBAND_I2C_CTRL_MAX_DATA_SIZE];
  NvU32 size;
} NV_DISP_MUX_SB_I2C_CONTROL_DATA_V1;
#define NV_DISP_MUX_SB_I2C_CONTROL_DATA_VER1 MAKE_NVAPI_VERSION(NV_DISP_MUX_SB_I2C_CONTROL_DATA_V1, 1)
#define NV_DISP_MUX_SB_I2C_CONTROL_DATA_VER NV_DISP_MUX_SB_I2C_CONTROL_DATA_VER1
typedef NV_DISP_MUX_SB_I2C_CONTROL_DATA_V1 NV_DISP_MUX_SB_I2C_CONTROL_DATA;
NVAPI_INTERFACE NvAPI_DISP_Mux_SB_I2C_Control(__in NvU32 displayId,
                                              __inout NV_DISP_MUX_SB_I2C_CONTROL_DATA *pSbI2cData);
typedef enum _NV_DISP_PSR_CMD {
  NV_DISP_PSR_CMD_INVALID = 0,
  NV_DISP_PSR_CMD_QUERY_CAPS,
  NV_DISP_PSR_CMD_QUERY_STATUS,
  NV_DISP_PSR_CMD_ENTER_BLOCKING,
  NV_DISP_PSR_CMD_ENTER_NON_BLOCKING,
  NV_DISP_PSR_CMD_EXIT_BLOCKING,
  NV_DISP_PSR_CMD_EXIT_NON_BLOCKING,
} NV_DISP_PSR_CMD;
typedef enum _NV_DISP_PSR_CAPS {
  NV_DISP_PSR_CAPS_NONE = 0x0,
  NV_DISP_PSR_CAPS_SB_SUPPORT = NV_BIT(0),
} NV_DISP_PSR_CAPS;
typedef enum _NV_DISP_PSR_STATUS {
  NV_DISP_PSR_STATUS_NONE = 0x0,
  NV_DISP_PSR_PSR_STATUS_SR_ENTERED = NV_BIT(0),
} NV_DISP_PSR_STATUS;
typedef struct _NV_PSR_CONTROL_DATA_V1 {
  NvU32 version;
  NV_DISP_PSR_CMD cmd;
  NvU32 caps;
  NvU32 status;
} NV_PSR_CONTROL_DATA_V1;
typedef struct _NV_PSR_CONTROL_DATA_V2 {
  NvU32 version;
  NV_DISP_PSR_CMD cmd;
  NvU32 caps;
  NvU32 status;
  NvU32 psrTransitionToInactiveMs;
} NV_PSR_CONTROL_DATA_V2;
#define NV_PSR_CONTROL_DATA_VER1 MAKE_NVAPI_VERSION(NV_PSR_CONTROL_DATA_V1, 1)
#define NV_PSR_CONTROL_DATA_VER2 MAKE_NVAPI_VERSION(NV_PSR_CONTROL_DATA_V2, 2)
#define NV_PSR_CONTROL_DATA_VER NV_PSR_CONTROL_DATA_VER2
typedef NV_PSR_CONTROL_DATA_V2 NV_PSR_CONTROL_DATA;
NVAPI_INTERFACE NvAPI_DISP_PSR_Control(__in NvU32 displayId, __inout NV_PSR_CONTROL_DATA *pPSRData);
typedef struct _NV_TEST_MUX_AUX_SETTLE_LATENCY_DATA {
  NvU32 version;
  NvU32 auxSettleDelayMs;
} NV_TEST_MUX_AUX_SETTLE_LATENCY_DATA_V1;
#define NV_TEST_MUX_AUX_SETTLE_LATENCY_DATA_VER1 MAKE_NVAPI_VERSION(NV_TEST_MUX_AUX_SETTLE_LATENCY_DATA_V1, 1)
#define NV_TEST_MUX_AUX_SETTLE_LATENCY_DATA_VER NV_TEST_MUX_AUX_SETTLE_LATENCY_DATA_VER1
typedef NV_TEST_MUX_AUX_SETTLE_LATENCY_DATA_V1 NV_TEST_MUX_AUX_SETTLE_LATENCY_DATA;
NVAPI_INTERFACE NvAPI_DISP_TestMuxAuxSettleDelay(__in NvU32 displayId,
                                                 __in NV_TEST_MUX_AUX_SETTLE_LATENCY_DATA *pMuxAuxSettleData);
typedef struct _NV_GET_DISPLAY_MUX_TCON_INFO_V1 {
  NvU32 version;
  NvU32 vendorOUI;
  NvU16 ddsFirmwareRev;
  NvU16 hardwareRev;
  NvU16 softwareRev;
  NvAPI_ShortString deviceName;
  NvU32 reserved[4];
} NV_GET_DISPLAY_MUX_TCON_INFO_V1;
#define NV_GET_DISPLAY_MUX_TCON_INFO_VER1 MAKE_NVAPI_VERSION(NV_GET_DISPLAY_MUX_TCON_INFO_V1, 1)
#define NV_GET_DISPLAY_MUX_TCON_INFO_VER NV_GET_DISPLAY_MUX_TCON_INFO_VER1
typedef NV_GET_DISPLAY_MUX_TCON_INFO_V1 NV_GET_DISPLAY_MUX_TCON_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetDisplayMuxTconInfo(__in NvU32 displayId, __inout NV_GET_DISPLAY_MUX_TCON_INFO *pTconInfo);
typedef struct _NV_GET_DISPLAY_MUX_DEVICE_ID_V1 {
  NvU32 version;
  NvU16 vendorId;
  NvU16 deviceId;
  NvAPI_ShortString vendorName;
  NvAPI_ShortString deviceName;
  NvU32 auxSettleDelayMs;
  NvU32 reserved[4];
} NV_GET_DISPLAY_MUX_DEVICE_ID_V1;
#define NV_GET_DISPLAY_MUX_DEVICE_ID_VER1 MAKE_NVAPI_VERSION(NV_GET_DISPLAY_MUX_DEVICE_ID_V1, 1)
#define NV_GET_DISPLAY_MUX_DEVICE_ID_VER NV_GET_DISPLAY_MUX_DEVICE_ID_VER1
typedef NV_GET_DISPLAY_MUX_DEVICE_ID_V1 NV_GET_DISPLAY_MUX_DEVICE_ID;
NVAPI_INTERFACE NvAPI_DISP_GetDisplayMuxDeviceId(__in NvU32 displayId, __inout NV_GET_DISPLAY_MUX_DEVICE_ID *pMuxId);
#define NV_DISP_MAX_MERGED_DISPLAYS 16
typedef enum {
  NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_CMD_INVALID = 0,
  NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_CMD_DISABLE,
  NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_CMD_ENABLE,
  NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_CMD_VALIDATE_ONLY,
} NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_CMD;
typedef enum {
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_NONE = 0x0,
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_MISMATCH_SOURCE_TIMINGS = NV_BIT(0),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_UNSUPPORTED_SCALING = NV_BIT(1),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_INVALID_SOURCE_COUNT = NV_BIT(2),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_INVALID_TARGET_COUNT = NV_BIT(3),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_DISPLAYS_NOT_ON_SAME_GPU = NV_BIT(4),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_INVALID_VIEWPORT = NV_BIT(5),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_INVALID_SOURCE = NV_BIT(6),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_INVALID_TARGET = NV_BIT(7),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_UNSUPPORTED_CONFIG = NV_BIT(8),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_INVALID_SOURCE_TIMING = NV_BIT(9),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_INVALID_TARGET_TIMING = NV_BIT(10),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_MODESET_FAILED = NV_BIT(11),
  NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_UNKNOWN = NV_BIT(30),
} NV_DISP_SET_MERGED_DISPLAYS_TOPO_ERROR_FLAG;
typedef struct _NV_DISP_MERGED_DISPLAYS_SOURCE_V1 {
  NvU32 displayId;
  NVAPI_VIEWPORT viewPort;
} NV_DISP_MERGED_DISPLAYS_SOURCE_V1;
typedef struct _NV_DISP_MERGED_DISPLAYS_TARGET_V1 {
  NvU32 displayId;
  NV_SCALING scaling;
} NV_DISP_MERGED_DISPLAYS_TARGET_V1;
typedef struct _NV_DISP_MERGED_DISPLAYS_TOPOLOGY_CONFIG_V1 {
  NvPhysicalGpuHandle hPhysicalGpu;
  NvU32 targetCount;
  NV_DISP_MERGED_DISPLAYS_TARGET_V1 targetDisplays[NV_DISP_MAX_MERGED_DISPLAYS];
  NvU32 sourceCount;
  NV_DISP_MERGED_DISPLAYS_SOURCE_V1 sourceDisplays[NV_DISP_MAX_MERGED_DISPLAYS];
} NV_DISP_MERGED_DISPLAYS_TOPOLOGY_CONFIG_V1;
typedef struct _NV_DISP_MERGED_DISPLAYS_TOPOLOGY_CONFIG_V2 {
  NvPhysicalGpuHandle hPhysicalGpu;
  NvU32 targetCount;
  NV_DISP_MERGED_DISPLAYS_TARGET_V1 targetDisplays[NV_DISP_MAX_MERGED_DISPLAYS];
  NvU32 sourceCount;
  NV_DISP_MERGED_DISPLAYS_SOURCE_V1 sourceDisplays[NV_DISP_MAX_MERGED_DISPLAYS];
  NvU32 bViewportSpanningAcrossSources : 1;
  NvU32 reserved : 31;
} NV_DISP_MERGED_DISPLAYS_TOPOLOGY_CONFIG_V2;
typedef struct _NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_V1 {
  NvU32 version;
  NvU32 errorFlags;
  NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_CMD cmd;
  NV_DISP_MERGED_DISPLAYS_TOPOLOGY_CONFIG_V1 data;
} NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_V1;
typedef struct _NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_V2 {
  NvU32 version;
  NvU32 errorFlags;
  NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_CMD cmd;
  NV_DISP_MERGED_DISPLAYS_TOPOLOGY_CONFIG_V2 data;
} NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_V2;
typedef NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_V2 NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA;
#define NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_V1, 1)
#define NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_VER2                                                                 \
  MAKE_NVAPI_VERSION(NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_V2, 2)
#define NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_VER NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA_VER2
NVAPI_INTERFACE NvAPI_DISP_SetMergedDisplaysTopology(
    __inout NV_DISP_SET_MERGED_DISPLAYS_TOPOLOGY_DATA *pMergedDisplaysTopoData);
typedef struct _NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V1 {
  NvU32 version;
  NvU32 bEnabled : 1;
  NvU32 bNeedForceModeset : 1;
  NvU32 reserved : 30;
  NV_DISP_MERGED_DISPLAYS_TOPOLOGY_CONFIG_V1 data;
} NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V1;
typedef struct _NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V2 {
  NvU32 version;
  NvU32 bEnabled : 1;
  NvU32 bNeedForceModeset : 1;
  NvU32 reserved : 30;
  NV_DISP_MERGED_DISPLAYS_TOPOLOGY_CONFIG_V2 data;
} NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V2;
typedef struct _NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V3 {
  NvU32 version;
  NvU32 bEnabled : 1;
  NvU32 bNeedForceModeset : 1;
  NvU32 reserved : 30;
  NV_DISP_MERGED_DISPLAYS_TOPOLOGY_CONFIG_V2 data;
  NV_RESOLUTION_EX targetResolution[NV_DISP_MAX_MERGED_DISPLAYS];
} NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V3;
typedef NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V3 NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA;
#define NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V1, 1)
#define NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_VER2                                                                 \
  MAKE_NVAPI_VERSION(NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V2, 2)
#define NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_VER3                                                                 \
  MAKE_NVAPI_VERSION(NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_V3, 3)
#define NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_VER NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA_VER3
NVAPI_INTERFACE NvAPI_DISP_GetMergedDisplaysTopology(
    __inout NV_DISP_GET_MERGED_DISPLAYS_TOPOLOGY_DATA *pMergedDisplaysTopoData);
typedef enum _NV_IMP_PARAMS_INDEX {
  NV_IMP_PARAMS_INDEX_NONE = 0,
  NV_IMP_PARAMS_INDEX_IMP_ENABLE = 1,
  NV_IMP_PARAMS_INDEX_IS_ASR_ALLOWED = 2,
  NV_IMP_PARAMS_INDEX_IS_ASR_ALLOWED_PER_PSTATE = 3,
  NV_IMP_PARAMS_INDEX_IS_MSCG_ALLOWED_PER_PSTATE = 4,
  NV_IMP_PARAMS_INDEX_STUTTER_FEATURE_PER_PSTATE = 5,
  NV_IMP_PARAMS_INDEX_STUTTER_FEATURE_PREDICTED_EFFICIENCY_PER_PSTATE = 6,
  NV_IMP_PARAMS_INDEX_MCLK_SWITCH_FEATURE_OUTPUTS = 7,
  NV_IMP_PARAMS_INDEX_FORCE_MIN_MEMPOOL = 8,
  NV_IMP_PARAMS_INDEX_MEMPOOL_COMPRESSION = 9,
  NV_IMP_PARAMS_INDEX_CURSOR_SIZE = 10,
  NV_IMP_PARAMS_INDEX_ISOFBLATENCY_TEST_ENABLE = 11,
  NV_IMP_PARAMS_INDEX_ISOFBLATENCY_TEST_WC_TOTAL_LATENCY = 12,
  NV_IMP_PARAMS_INDEX_ISOFBLATENCY_TEST_MAX_LATENCY = 13,
  NV_IMP_PARAMS_INDEX_ISOFBLATENCY_TEST_MAX_TEST_PERIOD = 14,
  NV_IMP_PARAMS_INDEX_GLITCHLESS_MODESET_ENABLE = 15
} NV_IMP_PARAMS_INDEX;
typedef enum _NV_IMP_PARAMS_OPERATION {
  NV_IMP_PARAMS_OPERATION_GET = 0,
  NV_IMP_PARAMS_OPERATION_SET = 1,
  NV_IMP_PARAMS_OPERATION_RESET = 2
} NV_IMP_PARAMS_OPERATION;
typedef enum _NV_IMP_PARAMS_INDEX_ISOHUB_STUTTER_FEATURE {
  NV_IMP_PARAMS_INDEX_ISOHUB_STUTTER_FEATURE_NONE = 0,
  NV_IMP_PARAMS_INDEX_ISOHUB_STUTTER_FEATURE_ASR = 1,
  NV_IMP_PARAMS_INDEX_ISOHUB_STUTTER_FEATURE_MSCG = 2
} NV_IMP_PARAMS_INDEX_ISOHUB_STUTTER_FEATURE;
#define NV_IMP_PARAMS_INDEX_MCLK_SWITCH_FEATURE_OUTPUTS_VALUE_POSSIBLE NV_BIT(0)
#define NV_IMP_PARAMS_INDEX_MCLK_SWITCH_FEATURE_OUTPUTS_VALUE_OVERRIDE_MEMPOOL NV_BIT(1)
#define NV_IMP_PARAMS_INDEX_MCLK_SWITCH_FEATURE_OUTPUTS_VALUE_MID_WATERMARK NV_BIT(2)
#define NV_IMP_PARAMS_INDEX_MCLK_SWITCH_FEATURE_OUTPUTS_VALUE_DWCF NV_BIT(3)
typedef struct _NV_IMP_SET_GET_PARAMS_V1 {
  NvU32 version;
  NvU32 gpuId;
  NvU32 pstateApi;
  NvU32 head;
  NvU32 value;
  NV_IMP_PARAMS_OPERATION operation;
  NV_IMP_PARAMS_INDEX index;
} NV_IMP_SET_GET_PARAMS_V1;
#define NV_IMP_SET_GET_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_IMP_SET_GET_PARAMS_V1, 1)
#define NV_IMP_SET_GET_PARAMS_VER NV_IMP_SET_GET_PARAMS_VER_1
typedef NV_IMP_SET_GET_PARAMS_V1 NV_IMP_SET_GET_PARAMS;
NVAPI_INTERFACE NvAPI_DISP_IMPSetGetParams(__inout NV_IMP_SET_GET_PARAMS *pImpSetGetParams);
#define NVAPI_LUT_SIZE 1024
typedef enum _NV_DISP_SET_TARGET_GAMMA_CALLER_IDENTIFIER {
  NV_DISP_SET_TARGET_GAMMA_CALLER_INVALID = 0,
  NV_DISP_SET_TARGET_GAMMA_CALLER_NVCPL = 1,
} NV_DISP_SET_TARGET_GAMMA_CALLER_IDENTIFIER;
typedef struct _NV_SET_TARGET_GAMMA_V1 {
  NvU32 version;
  NV_COLOR_RGB correctionGammaLut[NVAPI_LUT_SIZE];
  NV_DISP_SET_TARGET_GAMMA_CALLER_IDENTIFIER gammaSetByNVApp;
} NV_SET_TARGET_GAMMA_V1;
#define NV_SET_TARGET_GAMMA_VER1 MAKE_NVAPI_VERSION(NV_SET_TARGET_GAMMA_V1, 1)
#define NV_SET_TARGET_GAMMA_VER NV_SET_TARGET_GAMMA_VER1
typedef NV_SET_TARGET_GAMMA_V1 NV_SET_TARGET_GAMMA;
NVAPI_INTERFACE NvAPI_DISP_SetTargetGammaCorrection(__in NvU32 displayId, __in NV_SET_TARGET_GAMMA *ptargetGamma);
typedef enum _NV_DISP_COLOR_ACCURACY_MODE {
  NV_DISP_COLOR_ACCURACY_MODE_INVALID = 0,
  NV_DISP_COLOR_ACCURACY_MODE_AUTO,
  NV_DISP_COLOR_ACCURACY_MODE_REFERENCE,
  NV_DISP_COLOR_ACCURACY_MODE_ACCURATE,
  NV_DISP_COLOR_ACCURACY_MODE_ENHANCED,
} NV_DISP_COLOR_ACCURACY_MODE;
typedef enum _NV_DISP_COLOR_ACCURACY_MODE_CMD {
  NV_DISP_COLOR_ACCURACY_MODE_CMD_INVALID = 0,
  NV_DISP_COLOR_ACCURACY_MODE_CMD_GET,
  NV_DISP_COLOR_ACCURACY_MODE_CMD_SET,
} NV_DISP_COLOR_ACCURACY_MODE_CMD;
typedef struct _NV_COLOR_ACCURACY_MODE_V1 {
  NvU32 version;
  NV_DISP_COLOR_ACCURACY_MODE_CMD cmd;
  NV_DISP_COLOR_ACCURACY_MODE colorAccuracyMode;
} NV_COLOR_ACCURACY_MODE_V1;
#define NV_COLOR_ACCURACY_MODE_VER1 MAKE_NVAPI_VERSION(NV_COLOR_ACCURACY_MODE_V1, 1)
#define NV_COLOR_ACCURACY_MODE_VER NV_COLOR_ACCURACY_MODE_VER1
typedef NV_COLOR_ACCURACY_MODE_V1 NV_COLOR_ACCURACY_MODE;
NVAPI_INTERFACE NvAPI_DISP_ColorAccuracyMode(__in NvU32 displayId, __inout NV_COLOR_ACCURACY_MODE *pColorAccuracyMode);
#define NV_MSFT_DIRECT_DISPLAY_VSDB_CONTAINER_ID_SIZE (16)
typedef enum _NV_MSFT_DIRECT_DISPLAY_VSDB_PRIMARY_USE_CASE {
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_UNDEFINED = 0,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_TEST_EQUIPMENT = 0x1,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_GENERIC_DISPLAY = 0x2,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_TELEVISION_DISPLAY = 0x3,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_DESKTOP_PRODUCTIVITY_DISPLAY = 0x4,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_DESKTOP_GAMING_DISPLAY = 0x5,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_PRESENTATION_DISPLAY = 0x6,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_VIRTUAL_REALITY_HEADSETS = 0x7,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_AUGMENTED_REALITY = 0x8,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_VIDEO_WALL_DISPLAY = 0x10,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_MEDICAL_IMAGING_DISPLAY = 0x11,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_DEDICATED_GAMING_DISPLAY = 0x12,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_DEDICATED_VIDEO_MONITOR_DISPLAY = 0x13,
  NV_MSFT_DIRECT_DISPLAY_VSDB_FOR_ACCESSORY_DISPLAY = 0X14
} NV_MSFT_DIRECT_DISPLAY_VSDB_PRIMARY_USE_CASE;
typedef enum _NV_OS_DIRECT_DISPLAY_USAGE_HINT {
  NV_OS_DIRECT_DISPLAY_USAGE_HINT_NOT_HIDDEN = 0,
  NV_OS_DIRECT_DISPLAY_USAGE_HINT_HIDDEN = 1
} NV_OS_DIRECT_DISPLAY_USAGE_HINT;
typedef enum _NV_MSFT_DIRECT_DISPLAY_VSDB_ORIGIN {
  NV_MSFT_DIRECT_DISPLAY_VSDB_ORIGIN_NOT_PRESENT = 0,
  NV_MSFT_DIRECT_DISPLAY_VSDB_ORIGIN_HW_EDID = 1,
  NV_MSFT_DIRECT_DISPLAY_VSDB_ORIGIN_FAKE_EDID = 2
} NV_MSFT_DIRECT_DISPLAY_VSDB_ORIGIN;
typedef struct _NV_MSFT_DIRECT_DISPLAY_VSDB_INFO {
  NvU8 version;
  NvBool valid;
  struct {
    NvU32 desktopUsage : 1;
    NvU32 thirdPartyUsage : 1;
    NvU32 reserved : 30;
  } flags;
  NV_MSFT_DIRECT_DISPLAY_VSDB_PRIMARY_USE_CASE primaryUseCase;
  NvU8 containerId[NV_MSFT_DIRECT_DISPLAY_VSDB_CONTAINER_ID_SIZE];
  NV_MSFT_DIRECT_DISPLAY_VSDB_ORIGIN origin;
} NV_MSFT_DIRECT_DISPLAY_VSDB_INFO;
typedef struct _NV_GET_OS_DIRECT_DISPLAY_INFO_V1 {
  NvU32 version;
  NV_MSFT_DIRECT_DISPLAY_VSDB_INFO msftVsdbInfo;
  NV_OS_DIRECT_DISPLAY_USAGE_HINT osUsageHint;
} NV_GET_OS_DIRECT_DISPLAY_INFO_V1;
#define NV_GET_OS_DIRECT_DISPLAY_INFO_VER1 MAKE_NVAPI_VERSION(NV_GET_OS_DIRECT_DISPLAY_INFO_V1, 1)
#define NV_GET_OS_DIRECT_DISPLAY_INFO_VER NV_GET_OS_DIRECT_DISPLAY_INFO_VER1
typedef NV_GET_OS_DIRECT_DISPLAY_INFO_V1 NV_GET_OS_DIRECT_DISPLAY_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetOsDDisplayInfo(__in NvU32 displayId,
                                             __inout NV_GET_OS_DIRECT_DISPLAY_INFO *pDirectDisplayInfo);
typedef struct _NV_SET_OS_DIRECT_DISPLAY_INFO_V1 {
  NvU32 version;
  struct {
    NvU32 desktopUsage : 1;
    NvU32 thirdPartyUsage : 1;
    NvU32 reserved : 30;
  } flags;
  NV_MSFT_DIRECT_DISPLAY_VSDB_PRIMARY_USE_CASE primaryUseCase;
  NvBool bPersistChange;
} NV_SET_OS_DIRECT_DISPLAY_INFO_V1;
#define NV_SET_OS_DIRECT_DISPLAY_INFO_VER1 MAKE_NVAPI_VERSION(NV_SET_OS_DIRECT_DISPLAY_INFO_V1, 1)
#define NV_SET_OS_DIRECT_DISPLAY_INFO_VER NV_SET_OS_DIRECT_DISPLAY_INFO_VER1
typedef NV_SET_OS_DIRECT_DISPLAY_INFO_V1 NV_SET_OS_DIRECT_DISPLAY_INFO;
NVAPI_INTERFACE NvAPI_DISP_SetOsDDisplayProperties(__in NvU32 displayId,
                                                   __inout NV_SET_OS_DIRECT_DISPLAY_INFO *pDirectDisplayInfo);
typedef struct {
  NvU32 version;
  NvU32 displayId;
  NvU32 reserved;
} NV_SET_PREFERRED_STEREO_DISPLAY_V1;
typedef NV_SET_PREFERRED_STEREO_DISPLAY_V1 NV_SET_PREFERRED_STEREO_DISPLAY;
#define NV_SET_PREFERRED_STEREO_DISPLAY_VER1 MAKE_NVAPI_VERSION(NV_SET_PREFERRED_STEREO_DISPLAY_V1, 1)
#define NV_SET_PREFERRED_STEREO_DISPLAY_VER NV_SET_PREFERRED_STEREO_DISPLAY_VER1
NVAPI_INTERFACE NvAPI_DISP_SetPreferredStereoDisplay(__in NV_SET_PREFERRED_STEREO_DISPLAY *pPreferredStereoDisplay);
typedef struct {
  NvU32 version;
  NvU32 displayId;
  NvU32 reserved;
} NV_GET_PREFERRED_STEREO_DISPLAY_V1;
typedef NV_GET_PREFERRED_STEREO_DISPLAY_V1 NV_GET_PREFERRED_STEREO_DISPLAY;
#define NV_GET_PREFERRED_STEREO_DISPLAY_VER1 MAKE_NVAPI_VERSION(NV_GET_PREFERRED_STEREO_DISPLAY_V1, 1)
#define NV_GET_PREFERRED_STEREO_DISPLAY_VER NV_GET_PREFERRED_STEREO_DISPLAY_VER1
NVAPI_INTERFACE NvAPI_DISP_GetPreferredStereoDisplay(__inout NV_GET_PREFERRED_STEREO_DISPLAY *pPreferredStereoDisplay);
#define NV_DP_GENERIC_INFOFRAME_MAX_PACKET_SIZE 36
typedef struct _NV_GET_DP_GENERIC_INFOFRAME_V1 {
  NvU32 version;
  NvU32 infoframeIndex;
  NvU8 packet[NV_DP_GENERIC_INFOFRAME_MAX_PACKET_SIZE];
  NvBool bTransmitControl;
} NV_GET_DP_GENERIC_INFOFRAME_V1;
typedef NV_GET_DP_GENERIC_INFOFRAME_V1 NV_GET_DP_GENERIC_INFOFRAME;
#define NV_GET_DP_GENERIC_INFOFRAME_VER1 MAKE_NVAPI_VERSION(NV_GET_DP_GENERIC_INFOFRAME_V1, 1)
#define NV_GET_DP_GENERIC_INFOFRAME_VER NV_GET_DP_GENERIC_INFOFRAME_VER1
NVAPI_INTERFACE NvAPI_DISP_GetDpGenericInfoframe(__in NvU32 displayId,
                                                 __inout NV_GET_DP_GENERIC_INFOFRAME *pDpGenericInfoframe);
typedef struct _NV_GET_DP_MSA_ATTRIBUTES_V1 {
  NvU32 version;
  NvU32 mvid;
  NvU32 nvid;
  NvU8 misc0;
  NvU8 misc1;
  NvU16 hTotal;
  NvU16 vTotal;
  NvU16 hActiveStart;
  NvU16 vActiveStart;
  NvU16 hActiveWidth;
  NvU16 vActiveWidth;
  NvU16 hSyncWidth;
  NvU16 vSyncWidth;
  NvBool hSyncPolarity;
  NvBool vSyncPolarity;
  NvU32 reserved1;
  NvU32 reserved2;
} NV_GET_DP_MSA_ATTRIBUTES_V1;
typedef NV_GET_DP_MSA_ATTRIBUTES_V1 NV_GET_DP_MSA_ATTRIBUTES;
#define NV_GET_DP_MSA_ATTRIBUTES_VER1 MAKE_NVAPI_VERSION(NV_GET_DP_MSA_ATTRIBUTES_V1, 1)
#define NV_GET_DP_MSA_ATTRIBUTES_VER NV_GET_DP_MSA_ATTRIBUTES_VER1
NVAPI_INTERFACE NvAPI_DISP_GetDpMsaAttributes(__in NvU32 displayId, __inout NV_GET_DP_MSA_ATTRIBUTES *pDpMsaData);
typedef enum _NV_SET_PSR_CMD {
  NV_SET_PSR_INVALID_CMD = 0,
  NV_SET_PSR_STATE = 1,
  NV_SET_PSR_POLICY = 2,
} NV_SET_PSR_CMD;
typedef enum _NV_PSR_STATE {
  NV_PSR_STATE_INVALID = 0,
  NV_PSR_STATE_INACTIVE,
  NV_PSR_STATE_ACTIVE_NO_RFB_UPDATE,
  NV_PSR_STATE_ACTIVE_RFB_UPDATE,
  NV_PSR_STATE_ACTIVE_SINGLE_FRAME_UPDATE_IMMEDIATE_EXIT,
} NV_PSR_STATE;
typedef struct _NV_PSR_POLICY {
  NvU32 psrPolicyVersion;
  NvU32 ulCaptureActiveFrame;
  NvU32 bValid : 1;
  NvU32 bEnable : 1;
  NvU32 bSrcLinkOnInPsr : 1;
  NvU32 bPartialFrameUpdYcoordSupport : 1;
  NvU32 bPartialFrameRectSupport : 1;
  NvU32 bIsPsr2Supported : 1;
  NvU32 bIsCrcSupported : 1;
  NvU32 reserved : 25;
} NV_PSR_POLICY;
typedef struct _NV_SET_PSR_INFO_V1 {
  NvU32 version;
  NV_SET_PSR_CMD cmd;
  NV_PSR_STATE sinkPsrState;
  NV_PSR_POLICY psrPolicy;
  NvU32 errorCode;
  NvU32 flags;
  NvU32 reserved[4];
} NV_SET_PSR_INFO_V1;
#define NV_SET_PSR_INFO_VER1 MAKE_NVAPI_VERSION(NV_SET_PSR_INFO_V1, 1)
#define NV_SET_PSR_INFO_VER NV_SET_PSR_INFO_VER1
typedef NV_SET_PSR_INFO_V1 NV_SET_PSR_INFO;
NVAPI_INTERFACE NvAPI_DISP_SetPsrInfo(__in NvU32 displayId, __inout NV_SET_PSR_INFO *pSetPsrInfo);
typedef struct _NV_GET_PSR_INFO_V1 {
  NvU32 version;
  NV_PSR_STATE sinkPsrState;
  NvU32 psrVersion;
  NV_PSR_POLICY psrPolicy;
  NvU32 suXGranularity;
  NvU32 suYGranularity;
  NvU32 bLinkTrainingRequired : 1;
  NvU32 psrSetupTime : 3;
  NvU32 bYCoordinateRequired : 1;
  NvU32 bPsr2UpdateGranularityRequired : 1;
  NvU32 reserved : 26;
  NvU32 flags;
  NvU32 reservedEx[4];
} NV_GET_PSR_INFO_V1;
#define NV_GET_PSR_INFO_VER1 MAKE_NVAPI_VERSION(NV_GET_PSR_INFO_V1, 1)
#define NV_GET_PSR_INFO_VER NV_GET_PSR_INFO_VER1
typedef NV_GET_PSR_INFO_V1 NV_GET_PSR_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetPsrInfo(__in NvU32 displayId, __inout NV_GET_PSR_INFO *pGetPsrInfo);
typedef struct _NV_PSR_DEBUG_INFO_V1 {
  NvU32 version;
  NvU32 maxResyncFrames;
  NvU32 actualResyncFrames;
  NvU32 bLastSdpPsrState : 1;
  NvU32 bLastSdpUpdateRfb : 1;
  NvU32 bLastSdpCrcValid : 1;
  NvU32 bLastSdpSuValid : 1;
  NvU32 bLastSdpFirstSURcvd : 1;
  NvU32 bLastSdpLastSURcvd : 1;
  NvU32 bLastSdpYCoordValid : 1;
  NvU32 reserved : 25;
  NvU32 reservedEx[4];
} NV_PSR_DEBUG_INFO_V1;
#define NV_PSR_DEBUG_INFO_VER1 MAKE_NVAPI_VERSION(NV_PSR_DEBUG_INFO_V1, 1)
#define NV_PSR_DEBUG_INFO_VER NV_PSR_DEBUG_INFO_VER1
typedef NV_PSR_DEBUG_INFO_V1 NV_PSR_DEBUG_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetPsrDebugData(__in NvU32 displayId, __inout NV_PSR_DEBUG_INFO *pPsrDebugInfo);
#if defined(__cplusplus)
typedef struct _NV_MANAGED_DEDICATED_DISPLAY_INFO {
  NvU32 version;
  NvU32 displayId;
  NvU32 isAcquired : 1;
  NvU32 isMosaic : 1;
  NvU32 reserved : 30;
} NV_MANAGED_DEDICATED_DISPLAY_INFO_V1;
#define NV_MANAGED_DEDICATED_DISPLAY_INFO_VER1 MAKE_NVAPI_VERSION(NV_MANAGED_DEDICATED_DISPLAY_INFO_V1, 1)
#define NV_MANAGED_DEDICATED_DISPLAY_INFO_VER NV_MANAGED_DEDICATED_DISPLAY_INFO_VER1
typedef NV_MANAGED_DEDICATED_DISPLAY_INFO_V1 NV_MANAGED_DEDICATED_DISPLAY_INFO;
NVAPI_INTERFACE NvAPI_DISP_GetNvManagedDedicatedDisplays(__inout NvU32 *pDedicatedDisplayCount,
                                                         __inout NV_MANAGED_DEDICATED_DISPLAY_INFO *pDedicatedDisplays);
#endif
#if defined(__cplusplus)
NVAPI_INTERFACE NvAPI_DISP_AcquireDedicatedDisplay(__in NvU32 displayId, __inout NvU64 *pDisplaySourceHandle);
#endif
#if defined(__cplusplus)
NVAPI_INTERFACE NvAPI_DISP_ReleaseDedicatedDisplay(__in NvU32 displayId);
#endif
typedef enum _NV_TWO_HEAD_ONE_OR_ERROR_FLAG {
  NV_TWO_HEAD_ONE_OR_ERROR_NONE = NV_BIT(0),
  NV_TWO_HEAD_ONE_OR_ERROR_NOT_CONNECTED = NV_BIT(1),
  NV_TWO_HEAD_ONE_OR_ERROR_DYNAMIC_SWITCH_NOT_SUPPORTED_ON_THE_DISPLAY = NV_BIT(2),
  NV_TWO_HEAD_ONE_OR_ERROR_DYNAMIC_SWITCH_NOT_SUPPORTED_ON_THE_GPU = NV_BIT(3),
  NV_TWO_HEAD_ONE_OR_ERROR_MODE_TRANSITION_NOT_SUPPORTED_ON_THE_CURRENT_TIMING = NV_BIT(4),
  NV_TWO_HEAD_ONE_OR_ERROR_MODESET_FAILED = NV_BIT(5),
  NV_TWO_HEAD_ONE_OR_ERROR_UNKNOWN = NV_BIT(30),
} NV_TWO_HEAD_ONE_OR_ERROR_FLAG;
typedef struct _NV_TWO_HEAD_ONE_OR_DATA_V1 {
  NvU32 version;
  NVAPI_CMD cmd;
  NvU32 errorFlags;
  NvU32 bTwoHeadOneORDynamicSwitchSupportedDisplay : 1;
  NvU32 bTwoHeadOneORState : 1;
  NvU32 reserved : 30;
} NV_TWO_HEAD_ONE_OR_DATA_V1;
#define NV_TWO_HEAD_ONE_OR_DATA_VER1 MAKE_NVAPI_VERSION(NV_TWO_HEAD_ONE_OR_DATA_V1, 1)
#define NV_TWO_HEAD_ONE_OR_DATA_VER NV_TWO_HEAD_ONE_OR_DATA_VER1
typedef NV_TWO_HEAD_ONE_OR_DATA_V1 NV_TWO_HEAD_ONE_OR_DATA;
NVAPI_INTERFACE NvAPI_DISP_TwoHeadOneORDynamicSwitchControl(__in NvU32 displayId,
                                                            __inout NV_TWO_HEAD_ONE_OR_DATA *pTwoHeadOneORData);
typedef enum _NV_OD_CTRL_CMD {
  NV_OD_CTRL_CMD_INVALID = 0,
  NV_OD_CTRL_CMD_QUERY_OD_CAPABLE,
  NV_OD_CTRL_CMD_QUERY_OD_CTRL_CAPABLE,
  NV_OD_CTRL_CMD_QUERY_OD_STATUS,
  NV_OD_CTRL_CMD_SET_OD_CTRL,
} NV_OD_CTRL_CMD;
typedef enum _NV_OD_CTRL_VAL {
  NV_OD_CTRL_VAL_AUTONOMOUS = 0x0,
  NV_OD_CTRL_VAL_DISABLE = 0x2,
  NV_OD_CTRL_VAL_ENABLE = 0x3,
} NV_OD_CTRL_VAL;
typedef struct _NV_OD_CTRL_DATA_V1 {
  NvU32 version;
  NV_OD_CTRL_CMD cmd;
  NV_OD_CTRL_VAL control;
  NvU32 bOdCapable : 1;
  NvU32 bOdControlCapable : 1;
  NvU32 bOdStatus : 1;
  NvU32 reserved : 29;
} NV_OD_CTRL_DATA_V1;
#define NV_OD_CTRL_DATA_VER1 MAKE_NVAPI_VERSION(NV_OD_CTRL_DATA_V1, 1)
#define NV_OD_CTRL_DATA_VER NV_OD_CTRL_DATA_VER1
typedef NV_OD_CTRL_DATA_V1 NV_OD_CTRL_DATA;
NVAPI_INTERFACE NvAPI_DISP_LCDOverDriveControl(__in NvU32 displayId, __inout NV_OD_CTRL_DATA *pOdCtrlData);
#define NVAPI_MAX_MOSAIC_DISPLAY_ROWS 8
#define NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS 8
#define NV_MOSAIC_MAX_DISPLAYS (64)
#define NV_MOSAIC_TOPO_VALIDITY_VALID 0x00000000
#define NV_MOSAIC_TOPO_VALIDITY_MISSING_GPU 0x00000001
#define NV_MOSAIC_TOPO_VALIDITY_MISSING_DISPLAY 0x00000002
#define NV_MOSAIC_TOPO_VALIDITY_MIXED_DISPLAY_TYPES 0x00000004
typedef struct {
  NvU32 version;
  NvLogicalGpuHandle hLogicalGPU;
  NvU32 validityMask;
  NvU32 rowCount;
  NvU32 colCount;
  struct {
    NvPhysicalGpuHandle hPhysicalGPU;
    NvU32 displayOutputId;
    NvS32 overlapX;
    NvS32 overlapY;
  } gpuLayout[NVAPI_MAX_MOSAIC_DISPLAY_ROWS][NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS];
} NV_MOSAIC_TOPO_DETAILS;
#define NVAPI_MOSAIC_TOPO_DETAILS_VER MAKE_NVAPI_VERSION(NV_MOSAIC_TOPO_DETAILS, 1)
typedef enum {
  NV_MOSAIC_TOPO_TYPE_ALL,
  NV_MOSAIC_TOPO_TYPE_BASIC,
  NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO,
  NV_MOSAIC_TOPO_TYPE_SCALED_CLONE,
  NV_MOSAIC_TOPO_TYPE_PASSIVE_STEREO_SCALED_CLONE,
  NV_MOSAIC_TOPO_TYPE_MAX,
} NV_MOSAIC_TOPO_TYPE;
typedef enum {
  NV_MOSAIC_TOPO_NONE,
  NV_MOSAIC_TOPO_BEGIN_BASIC,
  NV_MOSAIC_TOPO_1x2_BASIC = NV_MOSAIC_TOPO_BEGIN_BASIC,
  NV_MOSAIC_TOPO_2x1_BASIC,
  NV_MOSAIC_TOPO_1x3_BASIC,
  NV_MOSAIC_TOPO_3x1_BASIC,
  NV_MOSAIC_TOPO_1x4_BASIC,
  NV_MOSAIC_TOPO_4x1_BASIC,
  NV_MOSAIC_TOPO_2x2_BASIC,
  NV_MOSAIC_TOPO_2x3_BASIC,
  NV_MOSAIC_TOPO_2x4_BASIC,
  NV_MOSAIC_TOPO_3x2_BASIC,
  NV_MOSAIC_TOPO_4x2_BASIC,
  NV_MOSAIC_TOPO_1x5_BASIC,
  NV_MOSAIC_TOPO_1x6_BASIC,
  NV_MOSAIC_TOPO_7x1_BASIC,
  NV_MOSAIC_TOPO_END_BASIC = NV_MOSAIC_TOPO_7x1_BASIC + 9,
  NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO,
  NV_MOSAIC_TOPO_1x2_PASSIVE_STEREO = NV_MOSAIC_TOPO_BEGIN_PASSIVE_STEREO,
  NV_MOSAIC_TOPO_2x1_PASSIVE_STEREO,
  NV_MOSAIC_TOPO_1x3_PASSIVE_STEREO,
  NV_MOSAIC_TOPO_3x1_PASSIVE_STEREO,
  NV_MOSAIC_TOPO_1x4_PASSIVE_STEREO,
  NV_MOSAIC_TOPO_4x1_PASSIVE_STEREO,
  NV_MOSAIC_TOPO_2x2_PASSIVE_STEREO,
  NV_MOSAIC_TOPO_END_PASSIVE_STEREO = NV_MOSAIC_TOPO_2x2_PASSIVE_STEREO + 4,
  NV_MOSAIC_TOPO_MAX
} NV_MOSAIC_TOPO;
typedef struct {
  NvU32 version;
  NV_MOSAIC_TOPO topo;
  NvU32 enabled;
  NvU32 isPossible;
} NV_MOSAIC_TOPO_BRIEF;
#define NVAPI_MOSAIC_TOPO_BRIEF_VER MAKE_NVAPI_VERSION(NV_MOSAIC_TOPO_BRIEF, 1)
typedef struct _NV_MOSAIC_DISPLAY_SETTING_V1 {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NvU32 bpp;
  NvU32 freq;
} NV_MOSAIC_DISPLAY_SETTING_V1;
typedef struct NV_MOSAIC_DISPLAY_SETTING_V2 {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NvU32 bpp;
  NvU32 freq;
  NvU32 rrx1k;
} NV_MOSAIC_DISPLAY_SETTING_V2;
typedef NV_MOSAIC_DISPLAY_SETTING_V2 NV_MOSAIC_DISPLAY_SETTING;
#define NVAPI_MOSAIC_DISPLAY_SETTING_VER1 MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_SETTING_V1, 1)
#define NVAPI_MOSAIC_DISPLAY_SETTING_VER2 MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_SETTING_V2, 2)
#define NVAPI_MOSAIC_DISPLAY_SETTING_VER NVAPI_MOSAIC_DISPLAY_SETTING_VER2
#define NV_MOSAIC_DISPLAY_SETTINGS_MAX 40
typedef struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V1 {
  NvU32 version;
  NvU32 topoBriefsCount;
  NV_MOSAIC_TOPO_BRIEF topoBriefs[NV_MOSAIC_TOPO_MAX];
  NvU32 displaySettingsCount;
  NV_MOSAIC_DISPLAY_SETTING_V1 displaySettings[NV_MOSAIC_DISPLAY_SETTINGS_MAX];
} NV_MOSAIC_SUPPORTED_TOPO_INFO_V1;
typedef struct _NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 {
  NvU32 version;
  NvU32 topoBriefsCount;
  NV_MOSAIC_TOPO_BRIEF topoBriefs[NV_MOSAIC_TOPO_MAX];
  NvU32 displaySettingsCount;
  NV_MOSAIC_DISPLAY_SETTING_V2 displaySettings[NV_MOSAIC_DISPLAY_SETTINGS_MAX];
} NV_MOSAIC_SUPPORTED_TOPO_INFO_V2;
typedef NV_MOSAIC_SUPPORTED_TOPO_INFO_V2 NV_MOSAIC_SUPPORTED_TOPO_INFO;
#define NVAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER1 MAKE_NVAPI_VERSION(NV_MOSAIC_SUPPORTED_TOPO_INFO_V1, 1)
#define NVAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER2 MAKE_NVAPI_VERSION(NV_MOSAIC_SUPPORTED_TOPO_INFO_V2, 2)
#define NVAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER NVAPI_MOSAIC_SUPPORTED_TOPO_INFO_VER2
#define NV_MOSAIC_TOPO_IDX_DEFAULT 0
#define NV_MOSAIC_TOPO_IDX_LEFT_EYE 0
#define NV_MOSAIC_TOPO_IDX_RIGHT_EYE 1
#define NV_MOSAIC_TOPO_NUM_EYES 2
#define NV_MOSAIC_MAX_TOPO_PER_TOPO_GROUP 2
typedef struct {
  NvU32 version;
  NV_MOSAIC_TOPO_BRIEF brief;
  NvU32 count;
  NV_MOSAIC_TOPO_DETAILS topos[NV_MOSAIC_MAX_TOPO_PER_TOPO_GROUP];
} NV_MOSAIC_TOPO_GROUP;
#define NVAPI_MOSAIC_TOPO_GROUP_VER MAKE_NVAPI_VERSION(NV_MOSAIC_TOPO_GROUP, 1)
NVAPI_INTERFACE NvAPI_Mosaic_GetSupportedTopoInfo(NV_MOSAIC_SUPPORTED_TOPO_INFO *pSupportedTopoInfo,
                                                  NV_MOSAIC_TOPO_TYPE type);
NVAPI_INTERFACE NvAPI_Mosaic_GetSupportedTopoInfoEx(NV_MOSAIC_TOPO_TYPE type, NV_MOSAIC_TOPO_GROUP *pTopoGroups,
                                                    NvU32 *pTopoGroupCount, NV_MOSAIC_DISPLAY_SETTING *pDisplaySettings,
                                                    NvU32 *pDisplaySettingsCount);
NVAPI_INTERFACE NvAPI_Mosaic_GetTopoGroup(NV_MOSAIC_TOPO_BRIEF *pTopoBrief, NV_MOSAIC_TOPO_GROUP *pTopoGroup);
NVAPI_INTERFACE NvAPI_Mosaic_GetOverlapLimits(NV_MOSAIC_TOPO_BRIEF *pTopoBrief,
                                              NV_MOSAIC_DISPLAY_SETTING *pDisplaySetting, NvS32 *pMinOverlapX,
                                              NvS32 *pMaxOverlapX, NvS32 *pMinOverlapY, NvS32 *pMaxOverlapY);
NVAPI_INTERFACE NvAPI_Mosaic_SetCurrentTopo(NV_MOSAIC_TOPO_BRIEF *pTopoBrief,
                                            NV_MOSAIC_DISPLAY_SETTING *pDisplaySetting, NvS32 overlapX, NvS32 overlapY,
                                            NvU32 enable);
NVAPI_INTERFACE NvAPI_Mosaic_GetCurrentTopo(NV_MOSAIC_TOPO_BRIEF *pTopoBrief,
                                            NV_MOSAIC_DISPLAY_SETTING *pDisplaySetting, NvS32 *pOverlapX,
                                            NvS32 *pOverlapY);
NVAPI_INTERFACE NvAPI_Mosaic_EnableCurrentTopo(NvU32 enable);
typedef struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V1 {
  NvU32 displayId;
  NvS32 overlapX;
  NvS32 overlapY;
  NV_ROTATE rotation;
  NvU32 cloneGroup;
} NV_MOSAIC_GRID_TOPO_DISPLAY_V1;
typedef struct _NV_MOSAIC_DISPLAY {
  NvS32 positionX;
  NvS32 positionY;
  NvU32 width;
  NvU32 height;
} NV_MOSAIC_DISPLAY;
typedef enum _NV_MIRRORING_TYPE {
  NV_MIRRORING_TYPE_NONE = 0,
  NV_MIRRORING_TYPE_VERTICAL = 1,
  NV_MIRRORING_TYPE_HORIZONTAL = 2,
  NV_MIRRORING_TYPE_VERTICAL_AND_HORIZONTAL = 3,
} NV_MIRRORING_TYPE;
typedef enum _NV_PIXEL_SHIFT_TYPE {
  NV_PIXEL_SHIFT_TYPE_NO_PIXEL_SHIFT = 0,
  NV_PIXEL_SHIFT_TYPE_2x2_TOP_LEFT_PIXELS = 1,
  NV_PIXEL_SHIFT_TYPE_2x2_BOTTOM_RIGHT_PIXELS = 2,
  NV_PIXEL_SHIFT_TYPE_2x2_TOP_RIGHT_PIXELS = 4,
  NV_PIXEL_SHIFT_TYPE_2x2_BOTTOM_LEFT_PIXELS = 8,
} NV_PIXEL_SHIFT_TYPE;
typedef struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V2 {
  NvU32 version;
  NvU32 displayId;
  NvS32 overlapX;
  NvS32 overlapY;
  NV_ROTATE rotation;
  NvU32 cloneGroup;
  NV_PIXEL_SHIFT_TYPE pixelShiftType;
} NV_MOSAIC_GRID_TOPO_DISPLAY_V2;
typedef struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V3 {
  NvU32 version;
  NvU32 displayId;
  NvS32 overlapX;
  NvS32 overlapY;
  NV_ROTATE rotation;
  NvU32 cloneGroup;
  NV_PIXEL_SHIFT_TYPE pixelShiftType;
  NV_MOSAIC_DISPLAY physicalDimensions;
  NV_MOSAIC_DISPLAY logicalDimensions;
  NV_MOSAIC_DISPLAY physicalDisplayRegion;
  NV_MOSAIC_DISPLAY logicalDisplayRegion;
  NvU32 rotationReserved;
} NV_MOSAIC_GRID_TOPO_DISPLAY_V3;
typedef struct _NV_MOSAIC_GRID_TOPO_DISPLAY_V4 {
  NvU32 version;
  NvU32 displayId;
  NvS32 overlapX;
  NvS32 overlapY;
  NV_ROTATE rotation;
  NvU32 cloneGroup;
  NV_PIXEL_SHIFT_TYPE pixelShiftType : 8;
  NV_MIRRORING_TYPE mirroring : 8;
  NvU32 reserved : 16;
  NV_MOSAIC_DISPLAY physicalDimensions;
  NV_MOSAIC_DISPLAY logicalDimensions;
  NV_MOSAIC_DISPLAY physicalDisplayRegion;
  NV_MOSAIC_DISPLAY logicalDisplayRegion;
  NvU32 rotationReserved;
} NV_MOSAIC_GRID_TOPO_DISPLAY_V4;
typedef NV_MOSAIC_GRID_TOPO_DISPLAY_V4 NV_MOSAIC_GRID_TOPO_DISPLAY;
#define NV_MOSAIC_GRID_TOPO_DISPLAY_VER MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_DISPLAY_V4, 4)
typedef struct _NV_MOSAIC_SURFACE_V1 {
  NvU32 version;
  NV_MOSAIC_DISPLAY physicalDimensions;
  NV_MOSAIC_DISPLAY logicalDimensions;
} NV_MOSAIC_SURFACE_V1;
typedef NV_MOSAIC_SURFACE_V1 NV_MOSAIC_SURFACE;
#define NV_MOSAIC_SURFACE_VER MAKE_NVAPI_VERSION(NV_MOSAIC_SURFACE, 1)
#ifndef NV_MOSAIC_GRID_TOPO_DISPLAY_VER
typedef NV_MOSAIC_GRID_TOPO_DISPLAY_V1 NV_MOSAIC_GRID_TOPO_DISPLAY;
#endif
typedef struct _NV_MOSAIC_GRID_TOPO_V1 {
  NvU32 version;
  NvU32 rows;
  NvU32 columns;
  NvU32 displayCount;
  NvU32 applyWithBezelCorrect : 1;
  NvU32 immersiveGaming : 1;
  NvU32 baseMosaic : 1;
  NvU32 driverReloadAllowed : 1;
  NvU32 acceleratePrimaryDisplay : 1;
  NvU32 reserved : 27;
  NV_MOSAIC_GRID_TOPO_DISPLAY_V1 displays[NV_MOSAIC_MAX_DISPLAYS];
  NV_MOSAIC_DISPLAY_SETTING_V1 displaySettings;
} NV_MOSAIC_GRID_TOPO_V1;
typedef struct _NV_MOSAIC_GRID_TOPO_V2 {
  NvU32 version;
  NvU32 rows;
  NvU32 columns;
  NvU32 displayCount;
  NvU32 applyWithBezelCorrect : 1;
  NvU32 immersiveGaming : 1;
  NvU32 baseMosaic : 1;
  NvU32 driverReloadAllowed : 1;
  NvU32 acceleratePrimaryDisplay : 1;
  NvU32 pixelShift : 1;
  NvU32 reserved : 26;
  NV_MOSAIC_GRID_TOPO_DISPLAY_V2 displays[NV_MOSAIC_MAX_DISPLAYS];
  NV_MOSAIC_DISPLAY_SETTING_V1 displaySettings;
} NV_MOSAIC_GRID_TOPO_V2;
typedef struct _NV_MOSAIC_GRID_TOPO_V3 {
  NvU32 version;
  NvU32 rows;
  NvU32 columns;
  NvU32 displayCount;
  NvU32 applyWithBezelCorrect : 1;
  NvU32 immersiveGaming : 1;
  NvU32 baseMosaic : 1;
  NvU32 driverReloadAllowed : 1;
  NvU32 acceleratePrimaryDisplay : 1;
  NvU32 pixelShift : 1;
  NvU32 usePrimaryDisplayIndex : 1;
  NvU32 bAllowOsVirtualModeSupport : 1;
  NvU32 isSpecializedDisplay : 1;
  NvU32 reserved : 23;
  NV_MOSAIC_GRID_TOPO_DISPLAY_V3 displays[NV_MOSAIC_MAX_DISPLAYS];
  NV_MOSAIC_DISPLAY_SETTING_V2 displaySettings;
  NvU32 primaryDisplayIndex;
  NV_MOSAIC_SURFACE spanSurface;
  NvU32 virtualDisplayId;
} NV_MOSAIC_GRID_TOPO_V3;
typedef struct _NV_MOSAIC_GRID_TOPO_V4 {
  NvU32 version;
  NvU32 rows;
  NvU32 columns;
  NvU32 displayCount;
  NvU32 applyWithBezelCorrect : 1;
  NvU32 immersiveGaming : 1;
  NvU32 baseMosaic : 1;
  NvU32 driverReloadAllowed : 1;
  NvU32 acceleratePrimaryDisplay : 1;
  NvU32 pixelShift : 1;
  NvU32 usePrimaryDisplayIndex : 1;
  NvU32 bAllowOsVirtualModeSupport : 1;
  NvU32 bDisallowOSPixelLimitRearrangement : 1;
  NvU32 isSpecializedDisplay : 1;
  NvU32 reserved : 22;
  NV_MOSAIC_GRID_TOPO_DISPLAY_V3 displays[NV_MOSAIC_MAX_DISPLAYS];
  NV_MOSAIC_DISPLAY_SETTING_V2 displaySettings;
  NvU32 primaryDisplayIndex;
  NV_MOSAIC_SURFACE spanSurface;
  NvU32 virtualDisplayId;
  NV_MOSAIC_DISPLAY physicalDimension;
} NV_MOSAIC_GRID_TOPO_V4;
typedef struct _NV_MOSAIC_GRID_TOPO_V5 {
  NvU32 version;
  NvU32 rows;
  NvU32 columns;
  NvU32 displayCount;
  NvU32 applyWithBezelCorrect : 1;
  NvU32 immersiveGaming : 1;
  NvU32 baseMosaic : 1;
  NvU32 driverReloadAllowed : 1;
  NvU32 acceleratePrimaryDisplay : 1;
  NvU32 pixelShift : 1;
  NvU32 usePrimaryDisplayIndex : 1;
  NvU32 bAllowOsVirtualModeSupport : 1;
  NvU32 bDisallowOSPixelLimitRearrangement : 1;
  NvU32 isSpecializedDisplay : 1;
  NvU32 mirroring : 1;
  NvU32 reserved : 21;
  NV_MOSAIC_GRID_TOPO_DISPLAY_V4 displays[NV_MOSAIC_MAX_DISPLAYS];
  NV_MOSAIC_DISPLAY_SETTING_V2 displaySettings;
  NvU32 primaryDisplayIndex;
  NV_MOSAIC_SURFACE spanSurface;
  NvU32 virtualDisplayId;
  NV_MOSAIC_DISPLAY physicalDimension;
} NV_MOSAIC_GRID_TOPO_V5;
typedef NV_MOSAIC_GRID_TOPO_V5 NV_MOSAIC_GRID_TOPO;
#define NV_MOSAIC_GRID_TOPO_VER1 MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_V1, 1)
#define NV_MOSAIC_GRID_TOPO_VER2 MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_V2, 2)
#define NV_MOSAIC_GRID_TOPO_VER3 MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_V3, 3)
#define NV_MOSAIC_GRID_TOPO_VER4 MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_V4, 4)
#define NV_MOSAIC_GRID_TOPO_VER5 MAKE_NVAPI_VERSION(NV_MOSAIC_GRID_TOPO_V5, 5)
#define NV_MOSAIC_GRID_TOPO_VER NV_MOSAIC_GRID_TOPO_VER5
#ifndef NV_MOSAIC_GRID_TOPO_VER
typedef NV_MOSAIC_GRID_TOPO_V2 NV_MOSAIC_GRID_TOPO;
#define NV_MOSAIC_GRID_TOPO_VER NV_MOSAIC_GRID_TOPO_VER2
#endif
NVAPI_INTERFACE NvAPI_Mosaic_SetGridTopology(NV_MOSAIC_GRID_TOPO *pGridTopology, NvU32 enable);
typedef struct {
  NvU32 version;
  NvU32 bSupportsImmersiveGaming : 1;
  NvU32 bSupportsMosaicSli : 1;
  NvU32 bSupportsGlobalRotation : 1;
  NvU32 bSupportsPerDisplayRotation : 1;
  NvU32 bSupportsPerDisplaySettings : 1;
  NvU32 bSupportsOverlap : 1;
  NvU32 bSupportsGaps : 1;
  NvU32 bSupportsUnevenGapping : 1;
  NvU32 bSupportsBaseMosaic : 1;
  NvU32 reserved : 23;
} NV_MOSAIC_CAPS_V1;
typedef struct {
  NvU32 version;
  NvU32 bSupportsImmersiveGaming : 1;
  NvU32 bSupportsMosaic : 1;
  NvU32 bSupportsGlobalRotation : 1;
  NvU32 bSupportsPerDisplayRotation : 1;
  NvU32 bSupportsPerDisplaySettings : 1;
  NvU32 bSupportsOverlap : 1;
  NvU32 bSupportsGaps : 1;
  NvU32 bSupportsUnevenGapping : 1;
  NvU32 bSupportsPassiveStereo : 1;
  NvU32 bSupportsPixelShift : 1;
  NvU32 reserved : 22;
} NV_MOSAIC_CAPS_V2;
typedef struct {
  NvU32 version;
  NvU32 bSupportsImmersiveGaming : 1;
  NvU32 bSupportsMosaic : 1;
  NvU32 bSupportsGlobalRotation : 1;
  NvU32 bSupportsPerDisplayRotation : 1;
  NvU32 bSupportsPerDisplaySettings : 1;
  NvU32 bSupportsOverlap : 1;
  NvU32 bSupportsGaps : 1;
  NvU32 bSupportsUnevenGapping : 1;
  NvU32 bSupportsPassiveStereo : 1;
  NvU32 bSupportsPixelShift : 1;
  NvU32 bSupports4QuadrantPixelShift : 1;
  NvU32 bSupportsPerDisplayMirroring : 1;
  NvU32 reserved : 20;
} NV_MOSAIC_CAPS_V3;
typedef NV_MOSAIC_CAPS_V3 NV_MOSAIC_CAPS;
#define NV_MOSAIC_CAPS_VER1 MAKE_NVAPI_VERSION(NV_MOSAIC_CAPS_V1, 1)
#define NV_MOSAIC_CAPS_VER2 MAKE_NVAPI_VERSION(NV_MOSAIC_CAPS_V2, 2)
#define NV_MOSAIC_CAPS_VER3 MAKE_NVAPI_VERSION(NV_MOSAIC_CAPS_V3, 3)
#define NV_MOSAIC_CAPS_VER NV_MOSAIC_CAPS_VER3
NVAPI_INTERFACE NvAPI_Mosaic_GetMosaicCapabilities(NV_GPU_VALID_GPU_TOPOLOGIES *pSliTopology, NV_MOSAIC_CAPS *pCaps);
NVAPI_INTERFACE NvAPI_Mosaic_GetMosaicCapabilitiesEx(NV_GPU_TOPOLOGY *pTopology, NV_MOSAIC_CAPS *pCaps);
NVAPI_INTERFACE NvAPI_Mosaic_GetSingleGpuMosaicCaps(NvPhysicalGpuHandle hPhysGpu, NV_MOSAIC_CAPS *pCaps);
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_INVALID_GPU NV_BIT(0)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_DISPLAY_ON_WRONG_CONNECTOR NV_BIT(1)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_COMMON_TIMINGS NV_BIT(2)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_EDID_AVAILABLE NV_BIT(3)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_MISMATCHED_OUTPUT_TYPE NV_BIT(4)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_DISPLAY_CONNECTED NV_BIT(5)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_GPU_TOPOLOGY NV_BIT(6)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NOT_SUPPORTED NV_BIT(7)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_NO_SLI_BRIDGE NV_BIT(8)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_ECC_ENABLED NV_BIT(9)
#define NV_MOSAIC_DISPLAYCAPS_PROBLEM_GPU_TOPOLOGY_NOT_SUPPORTED NV_BIT(10)
typedef struct {
  NvU32 displayId;
  NvU32 problemFlags;
  NvU32 supportsRotation : 1;
  NvU32 reserved : 31;
} NV_MOSAIC_DISPLAY_DETAILS;
typedef struct _NV_MOSAIC_DISPLAY_CAPS_V1 {
  NvU32 version;
  NvU32 displayCount;
  NV_MOSAIC_DISPLAY_DETAILS displays[NVAPI_MAX_DISPLAYS];
  NvU32 displaySettingsCount;
  NV_MOSAIC_DISPLAY_SETTING_V1 displaySettings[NV_MOSAIC_DISPLAY_SETTINGS_MAX];
  NvU32 problemFlags;
} NV_MOSAIC_DISPLAY_CAPS_V1;
#define NV_MOSAIC_DISPLAY_CAPS_MAX 1600
typedef struct _NV_MOSAIC_DISPLAY_CAPS_V2 {
  NvU32 version;
  NvU32 displayCount;
  NV_MOSAIC_DISPLAY_DETAILS displays[NVAPI_MAX_DISPLAYS];
  NvU32 displaySettingsCount;
  NV_MOSAIC_DISPLAY_SETTING_V1 displaySettings[NV_MOSAIC_DISPLAY_CAPS_MAX];
  NvU32 problemFlags;
} NV_MOSAIC_DISPLAY_CAPS_V2;
typedef struct _NV_MOSAIC_DISPLAY_CAPS_V3 {
  NvU32 version;
  NvU32 displayCount;
  NV_MOSAIC_DISPLAY_DETAILS displays[NVAPI_MAX_DISPLAYS];
  NvU32 displaySettingsCount;
  NV_MOSAIC_DISPLAY_SETTING_V2 displaySettings[NV_MOSAIC_DISPLAY_CAPS_MAX];
  NvU32 problemFlags;
} NV_MOSAIC_DISPLAY_CAPS_V3;
typedef NV_MOSAIC_DISPLAY_CAPS_V3 NV_MOSAIC_DISPLAY_CAPS;
#define NV_MOSAIC_DISPLAY_CAPS_VER1 MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_CAPS_V1, 1)
#define NV_MOSAIC_DISPLAY_CAPS_VER2 MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_CAPS_V2, 2)
#define NV_MOSAIC_DISPLAY_CAPS_VER3 MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_CAPS_V3, 3)
#define NV_MOSAIC_DISPLAY_CAPS_VER NV_MOSAIC_DISPLAY_CAPS_VER3
NVAPI_INTERFACE NvAPI_Mosaic_GetDisplayCapabilities(NV_MOSAIC_DISPLAY_CAPS *pDisplayCaps);
typedef struct {
  NvU32 version;
  NvS32 minDispX;
  NvS32 maxDispX;
  NvS32 minDispY;
  NvS32 maxDispY;
  NvS32 minTotalX;
  NvS32 maxTotalX;
  NvS32 minTotalY;
  NvS32 maxTotalY;
} NV_MOSAIC_OVERLAP_LIMITS;
#define NV_MOSAIC_OVERLAP_LIMITS_VER MAKE_NVAPI_VERSION(NV_MOSAIC_OVERLAP_LIMITS, 1)
NVAPI_INTERFACE NvAPI_Mosaic_GetGridOverlapLimits(NV_MOSAIC_GRID_TOPO *pGridTopology,
                                                  NV_MOSAIC_OVERLAP_LIMITS *pOverlapLimits);
#define NVAPI_MOSAIC_ENUMGRIDTOPOS_FLAG_ACTIVE_ONLY NV_BIT(0)
#define NVAPI_MOSAIC_ENUMGRIDTOPOS_FLAG_NO_VALIDATION NV_BIT(1)
NVAPI_INTERFACE NvAPI_Mosaic_EnumGridTopologies(NvU32 index, NvU32 flags, NV_MOSAIC_GRID_TOPO *pGridTopology,
                                                NvU8 *bEnabled);
NVAPI_INTERFACE NvAPI_Mosaic_GetDisplayViewportsByResolution(NvU32 displayId, NvU32 srcWidth, NvU32 srcHeight,
                                                             NV_RECT viewports[NV_MOSAIC_MAX_DISPLAYS],
                                                             NvU8 *bezelCorrected);
NVAPI_INTERFACE NvAPI_Mosaic_GetBezelPeeking(NvU32 displayId, NvU8 *pActive);
NVAPI_INTERFACE NvAPI_Mosaic_SetBezelPeeking(NvU32 displayId, NvU8 active);
#define NV_MOSAIC_RESOLUTION_PRUNING_MAX_RESOLUTIONS 100
typedef struct {
  NvU32 version;
  NvU32 count;
  NvU32 skipModeEnumeration : 1;
  NvU32 reserved : 31;
  struct {
    NvU16 width;
    NvU16 height;
    NvU32 allowMosaicResolution : 1;
    NvU32 allowBezelCorrectedMosaicResolution : 1;
    NvU32 isDefaultResolution : 1;
    NvU32 isCurrentResolution : 1;
    NvU32 reserved : 28;
  } resolutionList[NV_MOSAIC_RESOLUTION_PRUNING_MAX_RESOLUTIONS];
} NV_MOSAIC_RESOLUTION_PRUNING;
#define NV_MOSAIC_RESOLUTION_PRUNING_VER1 MAKE_NVAPI_VERSION(NV_MOSAIC_RESOLUTION_PRUNING, 1)
#define NV_MOSAIC_RESOLUTION_PRUNING_VER NV_MOSAIC_RESOLUTION_PRUNING_VER1
NVAPI_INTERFACE NvAPI_Mosaic_GetResolutionPruning(NvU32 displayId, NV_MOSAIC_RESOLUTION_PRUNING *resList);
NVAPI_INTERFACE NvAPI_Mosaic_SetResolutionPruning(NvU32 displayId, NV_MOSAIC_RESOLUTION_PRUNING *resList);
NVAPI_INTERFACE NvAPI_Mosaic_GetMosaicViewports(NV_MOSAIC_GRID_TOPO *pGridTopology, NvU32 baseWidth, NvU32 baseHeight,
                                                NvU8 bezelCorrected, NvU32 *totalWidth, NvU32 *totalHeight,
                                                NV_RECT viewports[NV_MOSAIC_MAX_DISPLAYS]);
#define NV_MOSAIC_SETDISPLAYTOPO_FLAG_CURRENT_GPU_TOPOLOGY NV_BIT(0)
#define NV_MOSAIC_SETDISPLAYTOPO_FLAG_NO_DRIVER_RELOAD NV_BIT(1)
#define NV_MOSAIC_SETDISPLAYTOPO_FLAG_MAXIMIZE_PERFORMANCE NV_BIT(2)
#define NV_MOSAIC_SETDISPLAYTOPO_FLAG_ALLOW_INVALID NV_BIT(3)
#define NV_MOSAIC_SETDISPLAYTOPO_FLAG_NO_START_EVENT NV_BIT(7)
NVAPI_INTERFACE NvAPI_Mosaic_SetDisplayGrids(__in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies,
                                             __in NvU32 gridCount, __in NvU32 setTopoFlags);
NVAPI_INTERFACE NvAPI_Mosaic_SetDisplayGridsWithSLI(__in NV_GPU_VALID_GPU_TOPOLOGIES *pGpuTopologies,
                                                    __in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies,
                                                    __in NvU32 gridCount);
#define NV_MOSAIC_DISPLAYTOPO_WARNING_DISPLAY_POSITION NV_BIT(0)
#define NV_MOSAIC_DISPLAYTOPO_WARNING_DRIVER_RELOAD_REQUIRED NV_BIT(1)
typedef struct {
  NvU32 version;
  NvU32 errorFlags;
  NvU32 warningFlags;
  NvU32 displayCount;
  struct {
    NvU32 displayId;
    NvU32 errorFlags;
    NvU32 warningFlags;
    NvU32 supportsRotation : 1;
    NvU32 reserved : 31;
  } displays[NVAPI_MAX_DISPLAYS];
} NV_MOSAIC_DISPLAY_TOPO_STATUS;
#define NV_MOSAIC_DISPLAY_TOPO_STATUS_VER MAKE_NVAPI_VERSION(NV_MOSAIC_DISPLAY_TOPO_STATUS, 1)
NVAPI_INTERFACE NvAPI_Mosaic_ValidateDisplayGridsWithSLI(__in NV_GPU_VALID_GPU_TOPOLOGIES *pGpuTopologies,
                                                         __in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies,
                                                         __inout_ecount_full(gridCount)
                                                             NV_MOSAIC_DISPLAY_TOPO_STATUS *pTopoStatus,
                                                         __in NvU32 gridCount);
NVAPI_INTERFACE NvAPI_Mosaic_ValidateDisplayGrids(__in NvU32 setTopoFlags,
                                                  __in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies,
                                                  __inout_ecount_full(gridCount)
                                                      NV_MOSAIC_DISPLAY_TOPO_STATUS *pTopoStatus,
                                                  __in NvU32 gridCount);
NVAPI_INTERFACE NvAPI_Mosaic_EnumDisplayModes(__in NV_MOSAIC_GRID_TOPO *pGridTopology,
                                              __inout_ecount_part_opt(*pDisplayCount, *pDisplayCount)
                                                  NV_MOSAIC_DISPLAY_SETTING *pDisplaySettings,
                                              __inout NvU32 *pDisplayCount);
NVAPI_INTERFACE NvAPI_Mosaic_ChooseGpuTopologies(__in_ecount(gridCount) NV_MOSAIC_GRID_TOPO *pGridTopologies,
                                                 __in NvU32 gridCount, __in NvU32 setTopoFlags,
                                                 __inout NV_GPU_VALID_GPU_TOPOLOGIES *pGpuTopologies);
NVAPI_INTERFACE NvAPI_Mosaic_EnumDisplayGrids(__inout_ecount_part_opt(*pGridCount, *pGridCount)
                                                  NV_MOSAIC_GRID_TOPO *pGridTopologies,
                                              __inout NvU32 *pGridCount);
typedef struct {
  NvU32 version;
  NvU32 isValid : 1;
  NvU32 includesDisplays : 1;
  NvU32 excludesDisplays : 1;
  NvU32 includesGpus : 1;
  NvU32 excludesGpus : 1;
  NvU32 supportsSurround : 1;
  NvU32 supportsMosaic : 1;
  NvU32 noReloadRequired : 1;
  NvU32 noRewireRequired : 1;
  NvU32 noBridgeChangeRequired : 1;
  NvU32 reserved : 22;
  NvS32 minDisplayCount;
  NvS32 maxDisplayCount;
  NvU32 suppliedDisplays;
  NvU32 displayIds[NV_MOSAIC_MAX_DISPLAYS];
  NvS32 minGpuCount;
  NvS32 maxGpuCount;
  NvU32 suppliedGpus;
  NvPhysicalGpuHandle gpus[NVAPI_MAX_GPU_PER_TOPOLOGY];
} NV_MOSAIC_CONFIG_FILTER;
#define NV_MOSAIC_FILTER_NONE ((NV_MOSAIC_CONFIG_FILTER *)0)
#define NV_MOSAIC_FILTER_VALID ((NV_MOSAIC_CONFIG_FILTER *)1)
#define NV_MOSAIC_FILTER_SURROUND ((NV_MOSAIC_CONFIG_FILTER *)2)
#define NV_MOSAIC_FILTER_MOSAIC ((NV_MOSAIC_CONFIG_FILTER *)3)
#define NV_MOSAIC_CONFIG_FILTER_VER1 MAKE_NVAPI_VERSION(NV_MOSAIC_CONFIG_FILTER, 1)
#define NV_MOSAIC_CONFIG_FILTER_VER NV_MOSAIC_CONFIG_FILTER_VER1
#define NV_MOSAIC_FLAGS_CACHED NV_BIT(0)
typedef struct {
  NvU32 displayId;
  NvU32 problemFlags;
  NvU32 requiredGpuId;
  NvU32 requiredConnector;
  NvU32 supportsSingleRotation : 1;
  NvU32 supportsUniqueSettings : 1;
  NvU32 canBePrimary : 1;
  NvU32 reserved : 29;
} NV_MOSAIC_CONFIG_DISPLAY;
typedef struct {
  NvU32 version;
  NvU32 displayCount;
  NV_MOSAIC_CONFIG_DISPLAY displays[NV_MOSAIC_MAX_DISPLAYS];
  NV_GPU_TOPOLOGY gpuTopology;
  NvU32 problemFlags;
  NvU32 mosaic : 1;
  NvU32 surround : 1;
  NvU32 supportsRotation : 1;
  NvU32 supportsPassiveStereo : 1;
  NvU32 reserved : 28;
} NV_MOSAIC_CONFIG;
#define NV_MOSAIC_CONFIG_VER1 MAKE_NVAPI_VERSION(NV_MOSAIC_CONFIG, 1)
#define NV_MOSAIC_CONFIG_VER NV_MOSAIC_CONFIG_VER1
NVAPI_INTERFACE NvAPI_Mosaic_EnumPossibleConfigs(NV_MOSAIC_CONFIG *configs, NvU32 *configCount, NvU32 *maxConfigCount,
                                                 NV_MOSAIC_CONFIG_FILTER *filter, NvU32 flags);
typedef struct {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NvU32 freq;
  NvU32 singleWide : 1;
  NvU32 mosaic : 1;
  NvU32 bezelCorrected : 1;
  NvU32 defaultResolution : 1;
  NvU32 isVisible : 1;
  NvU32 isPreferred : 1;
  NvU32 reserved : 26;
} NV_MOSAIC_RESOLUTION;
#define NV_MOSAIC_RESOLUTION_VER1 MAKE_NVAPI_VERSION(NV_MOSAIC_RESOLUTION, 1)
#define NV_MOSAIC_RESOLUTION_VER NV_MOSAIC_RESOLUTION_VER1
NVAPI_INTERFACE NvAPI_Mosaic_GetResolutions(__in NvU32 displayId,
                                            __inout_ecount(*resListCount) NV_MOSAIC_RESOLUTION *resList,
                                            __inout NvU32 *resListCount, __in_opt NV_MOSAIC_GRID_TOPO *pGridTopo);
NVAPI_INTERFACE NvAPI_Mosaic_SetResolutions(__in NvU32 displayId,
                                            __in_ecount(resListCount) NV_MOSAIC_RESOLUTION *resList,
                                            __in NvU32 resListCount);
#define NVAPI_MAX_MOSAIC_DISPLAY_ROWS 8
#define NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS 8
#define NVAPI_MAX_MOSAIC_TOPOS 16
typedef struct {
  NvU32 version;
  NvU32 rowCount;
  NvU32 colCount;
  struct {
    NvPhysicalGpuHandle hPhysicalGPU;
    NvU32 displayOutputId;
    NvS32 overlapX;
    NvS32 overlapY;
  } gpuLayout[NVAPI_MAX_MOSAIC_DISPLAY_ROWS][NVAPI_MAX_MOSAIC_DISPLAY_COLUMNS];
} NV_MOSAIC_TOPOLOGY;
#define NVAPI_MOSAIC_TOPOLOGY_VER MAKE_NVAPI_VERSION(NV_MOSAIC_TOPOLOGY, 1)
typedef struct {
  NvU32 version;
  NvU32 totalCount;
  NV_MOSAIC_TOPOLOGY topos[NVAPI_MAX_MOSAIC_TOPOS];
} NV_MOSAIC_SUPPORTED_TOPOLOGIES;
#define NVAPI_MOSAIC_SUPPORTED_TOPOLOGIES_VER MAKE_NVAPI_VERSION(NV_MOSAIC_SUPPORTED_TOPOLOGIES, 1)
NVAPI_INTERFACE NvAPI_GetSupportedMosaicTopologies(NV_MOSAIC_SUPPORTED_TOPOLOGIES *pMosaicTopos);
NVAPI_INTERFACE NvAPI_GetCurrentMosaicTopology(NV_MOSAIC_TOPOLOGY *pMosaicTopo, NvU32 *pEnabled);
NVAPI_INTERFACE NvAPI_SetCurrentMosaicTopology(NV_MOSAIC_TOPOLOGY *pMosaicTopo);
NVAPI_INTERFACE NvAPI_EnableCurrentMosaicTopology(NvU32 enable);
NVAPI_INTERFACE NvAPI_Mosaic_GetSymmetricOrderedDisplayIds(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                           __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount)
                                                               NV_GPU_DISPLAYIDS *pDisplayIds,
                                                           __inout NvU32 *pDisplayIdCount);
typedef enum _NV_SPAN_CONFIG_FLAGS {
  NV_SPAN_CONFIG_NONE = 0x00000000,
  NV_SPAN_CONFIG_GET_PREFERRED_CONFIG = 0x00000001,
  NV_SPAN_CONFIG_GET_SURFACE_LOGICAL_RESOLUTION = 0x00000002,
} NV_SPAN_CONFIG_FLAGS;
NVAPI_INTERFACE NvAPI_Mosaic_GetDisplayPhysicalArrangement(__in_ecount(displayCount)
                                                               NV_MOSAIC_GRID_TOPO_DISPLAY *pTopoDisplays,
                                                           __in NvU32 displayCount);
NVAPI_INTERFACE NvAPI_Mosaic_GetPossibleConfig(__inout NV_MOSAIC_GRID_TOPO *pGridTopo, __in NvU32 flag);
#define NVAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE 8
#define NVAPI_MAX_VISUAL_COMPUTING_DEVICES 8
#define NVAPI_MAX_HIC_DEVICES 4
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_EnumVisualComputingDevices(NvVisualComputingDeviceHandle nvComputeHandles[NVAPI_MAX_VISUAL_COMPUTING_DEVICES],
                                     NvU32 *pSystemCount);
typedef enum _NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE {
  NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_ON = 1,
  NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_OFF = 2,
  NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE_NOT_SUPPORTED = -1,
} NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE;
typedef struct _NV_VISUAL_COMPUTING_DEVICE_INFO {
  NvU32 version;
  NvAPI_LongString productName;
  NvAPI_LongString serialNumber;
  NvAPI_ShortString firmwareVersion;
  NvU32 buildDateYear;
  NvU32 buildDateWeek;
  NvAPI_ShortString hardwareVersion;
  NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE perfMode;
  NvPhysicalGpuHandle gpuHandle[NVAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE];
} NV_VISUAL_COMPUTING_DEVICE_INFO;
#define NV_VISUAL_COMPUTING_DEVICE_INFO_VER MAKE_NVAPI_VERSION(NV_VISUAL_COMPUTING_DEVICE_INFO, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VCD_GetDeviceInfo(NvVisualComputingDeviceHandle nvComputingHandle, NV_VISUAL_COMPUTING_DEVICE_INFO *pVisInfo);
typedef enum _NV_HIC_TYPE {
  NV_HIC_TYPE_UNKNOWN = 0,
  NV_HIC_TYPE_SHIC,
  NV_HIC_TYPE_DOHIC,
  NV_HIC_TYPE_GHIC
} NV_HIC_TYPE;
typedef struct _NV_VCD_TOPOLOGY_TARGET {
  NvU32 version;
  NvVisualComputingDeviceHandle nvComputingHandle;
  NvU32 gpuCount;
  NvPhysicalGpuHandle nvGpuHandles[NVAPI_MAX_GPUS_PER_VISUAL_COMPUTING_DEVICE];
} NV_VCD_TOPOLOGY_TARGET;
#define NV_VCD_TOPOLOGY_TARGET_VER MAKE_NVAPI_VERSION(NV_VCD_TOPOLOGY_TARGET, 1)
typedef struct _NV_HIC_TOPOLOGY {
  NvU32 version;
  NvHICHandle nvHICHandle;
  NvU32 vcdCount;
  NV_VCD_TOPOLOGY_TARGET vcdTarget[NVAPI_MAX_VISUAL_COMPUTING_DEVICES];
  NV_HIC_TYPE nvHICType;
} NV_HIC_TOPOLOGY;
#define NV_HIC_TOPOLOGY_VER MAKE_NVAPI_VERSION(NV_HIC_TOPOLOGY, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_HIC_QueryTopology(NV_HIC_TOPOLOGY nvHICTopologies[NVAPI_MAX_HIC_DEVICES], NvU32 *pTopoCount);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VCD_UpdatePerformanceMode(NvVisualComputingDeviceHandle nvComputingHandle,
                                    NV_VISUAL_COMPUTING_DEVICE_PERFORMANCE_MODE systemPerfMode);
#define NV_POWER_SUPPLY_STATE_NORMAL 0x00000001
#define NV_POWER_SUPPLY_STATE_ABNORMAL 0x00000002
#define NV_POWER_SUPPLY_STATE_ABNORMAL_HIGH_VOLTAGE 0x00000008
#define NV_POWER_SUPPLY_STATE_ABNORMAL_FAN_FAILURE 0x00000010
#define NV_POWER_SUPPLY_STATE_ABNORMAL_HEATSINK 0x00000040
#define NV_POWER_SUPPLY_STATE_ABNORMAL_LIMIT_REACHED 0x00000080
#define NV_POWER_SUPPLY_STATE_ABNORMAL_OUTPUT_THRESHOLD 0x00000100
#define NV_POWER_SUPPLY_STATE_ABNORMAL_LOW_VOLTAGE 0x00000200
#define NV_POWER_SUPPLY_STATE_ABNORMAL_I2C_REMOTE_OFF 0x00001000
#define NV_POWER_SUPPLY_STATE_ABNORMAL_DISABLE 0x00002000
#define NV_POWER_SUPPLY_STATE_ABNORMAL_SHORT_PIN 0x00004000
typedef enum _NV_POWER_SUPPLY_TYPE {
  NV_POWER_SUPPLY_VALERE = 1,
  NV_POWER_SUPPLY_DELTA,
} NV_POWER_SUPPLY_TYPE;
typedef struct _NV_POWER_SUPPLY_INFO {
  NvU32 version;
  NV_POWER_SUPPLY_TYPE psuType;
  NvU32 voltage;
  NvU32 current;
  NvU32 stateFlags;
} NV_POWER_SUPPLY_INFO;
#define NV_POWER_SUPPLY_INFO_VER MAKE_NVAPI_VERSION(NV_POWER_SUPPLY_INFO, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VCD_GetPowerSupplyInfo(NvVisualComputingDeviceHandle nvComputingHandle, NV_POWER_SUPPLY_INFO *pPowerInfo);
#define NVAPI_MAX_GSYNC_DEVICES 4
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VCD_GetAssociatedGSyncs(NvVisualComputingDeviceHandle nvComputingHandle,
                                  NvGSyncDeviceHandle nvGSyncHandles[NVAPI_MAX_GSYNC_DEVICES], NvU32 *gsyncCount);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VCD_GetThermalInfo(NvVisualComputingDeviceHandle nvComputingHandle,
                             NV_GPU_THERMAL_SETTINGS *pThermalSettings);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VCD_GetCoolerSettings(NvVisualComputingDeviceHandle nvComputingHandle, NV_GPU_GETCOOLER_SETTINGS *pCoolerInfo,
                                NvU32 *pRequestedFanLevel);
NVAPI_INTERFACE NvAPI_GSync_EnumSyncDevices(__out NvGSyncDeviceHandle nvGSyncHandles[NVAPI_MAX_GSYNC_DEVICES],
                                            __out NvU32 *gsyncCount);
#define NVAPI_GSYNC_BOARD_ID_P358 856
#define NVAPI_GSYNC_BOARD_ID_P2060 8288
#define NVAPI_GSYNC_BOARD_ID_P2061 8289
typedef struct _NV_GSYNC_CAPABILITIES_V1 {
  NvU32 version;
  NvU32 revId;
  NvU32 boardId;
  NvU32 revision;
  NvU32 capFlags;
  NvU32 maxSyncSkew;
  NvU32 syncSkewResolution;
  NvU32 maxStartDelay;
  NvU32 startDelayResolution;
} NV_GSYNC_CAPABILITIES_V1;
typedef struct _NV_GSYNC_CAPABILITIES_V2 {
  NvU32 version;
  NvU32 revId;
  NvU32 boardId;
  NvU32 revision;
  NvU32 capFlags;
  NvU32 maxSyncSkew;
  NvU32 syncSkewResolution;
  NvU32 maxStartDelay;
  NvU32 startDelayResolution;
  NvU32 extendedRevision;
} NV_GSYNC_CAPABILITIES_V2;
typedef NV_GSYNC_CAPABILITIES_V2 NV_GSYNC_CAPABILITIES;
#define NV_GSYNC_CAPABILITIES_VER1 MAKE_NVAPI_VERSION(NV_GSYNC_CAPABILITIES_V1, 1)
#define NV_GSYNC_CAPABILITIES_VER2 MAKE_NVAPI_VERSION(NV_GSYNC_CAPABILITIES_V2, 2)
#define NV_GSYNC_CAPABILITIES_VER NV_GSYNC_CAPABILITIES_VER2
NVAPI_INTERFACE NvAPI_GSync_QueryCapabilities(__in NvGSyncDeviceHandle hNvGSyncDevice,
                                              __inout NV_GSYNC_CAPABILITIES *pNvGSyncCapabilities);
typedef enum _NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR {
  NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_NONE = 0,
  NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_PRIMARY = 1,
  NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_SECONDARY = 2,
  NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_TERTIARY = 3,
  NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR_QUARTERNARY = 4,
} NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR;
typedef enum _NVAPI_GSYNC_DISPLAY_SYNC_STATE {
  NVAPI_GSYNC_DISPLAY_SYNC_STATE_UNSYNCED = 0,
  NVAPI_GSYNC_DISPLAY_SYNC_STATE_SLAVE = 1,
  NVAPI_GSYNC_DISPLAY_SYNC_STATE_MASTER = 2,
} NVAPI_GSYNC_DISPLAY_SYNC_STATE;
typedef struct _NV_GSYNC_GPU {
  NvU32 version;
  NvPhysicalGpuHandle hPhysicalGpu;
  NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR connector;
  NvPhysicalGpuHandle hProxyPhysicalGpu;
  NvU32 isSynced : 1;
  NvU32 reserved : 31;
} NV_GSYNC_GPU;
typedef struct _NV_GSYNC_DISPLAY {
  NvU32 version;
  NvU32 displayId;
  NvU32 isMasterable : 1;
  NvU32 reserved : 31;
  NVAPI_GSYNC_DISPLAY_SYNC_STATE syncState;
} NV_GSYNC_DISPLAY;
#define NV_GSYNC_DISPLAY_VER MAKE_NVAPI_VERSION(NV_GSYNC_DISPLAY, 1)
#define NV_GSYNC_GPU_VER MAKE_NVAPI_VERSION(NV_GSYNC_GPU, 1)
NVAPI_INTERFACE NvAPI_GSync_GetTopology(__in NvGSyncDeviceHandle hNvGSyncDevice, __inout_opt NvU32 *gsyncGpuCount,
                                        __inout_ecount_part_opt(*gsyncGpuCount, *gsyncGpuCount) NV_GSYNC_GPU *gsyncGPUs,
                                        __inout_opt NvU32 *gsyncDisplayCount,
                                        __inout_ecount_part_opt(*gsyncDisplayCount, *gsyncDisplayCount)
                                            NV_GSYNC_DISPLAY *gsyncDisplays);
typedef enum _NV_SET_SYNC_FLAGS {
  NV_SET_SYNC_FLAGS_INVALID = 0,
  NV_SET_SYNC_FLAGS_NO_VALIDATION = NV_BIT(5),
  NV_SET_SYNC_FLAGS_SEND_START_EVENT = NV_BIT(7),
} NV_SET_SYNC_FLAGS;
NVAPI_INTERFACE NvAPI_GSync_SetSyncStateSettings(__in NvU32 gsyncDisplayCount,
                                                 __in_ecount(gsyncDisplayCount) NV_GSYNC_DISPLAY *pGsyncDisplays,
                                                 __in NvU32 flags);
typedef enum _NVAPI_GSYNC_POLARITY {
  NVAPI_GSYNC_POLARITY_RISING_EDGE = 0,
  NVAPI_GSYNC_POLARITY_FALLING_EDGE = 1,
  NVAPI_GSYNC_POLARITY_BOTH_EDGES = 2,
} NVAPI_GSYNC_POLARITY;
typedef enum _NVAPI_GSYNC_VIDEO_MODE {
  NVAPI_GSYNC_VIDEO_MODE_NONE = 0,
  NVAPI_GSYNC_VIDEO_MODE_TTL = 1,
  NVAPI_GSYNC_VIDEO_MODE_NTSCPALSECAM = 2,
  NVAPI_GSYNC_VIDEO_MODE_HDTV = 3,
  NVAPI_GSYNC_VIDEO_MODE_COMPOSITE = 4,
} NVAPI_GSYNC_VIDEO_MODE;
typedef enum _NVAPI_GSYNC_SYNC_SOURCE {
  NVAPI_GSYNC_SYNC_SOURCE_VSYNC = 0,
  NVAPI_GSYNC_SYNC_SOURCE_HOUSESYNC = 1,
} NVAPI_GSYNC_SYNC_SOURCE;
typedef struct _NV_GSYNC_DELAY {
  NvU32 version;
  NvU32 numLines;
  NvU32 numPixels;
  NvU32 maxLines;
  NvU32 minPixels;
} NV_GSYNC_DELAY;
#define NV_GSYNC_DELAY_VER MAKE_NVAPI_VERSION(NV_GSYNC_DELAY, 1)
typedef struct _NV_GSYNC_CONTROL_PARAMS {
  NvU32 version;
  NVAPI_GSYNC_POLARITY polarity;
  NVAPI_GSYNC_VIDEO_MODE vmode;
  NvU32 interval;
  NvS32 skew;
  NvS32 startDelay;
  NVAPI_GSYNC_SYNC_SOURCE source;
  NvU32 interlaceMode : 1;
  NvU32 syncSourceIsOutput : 1;
  NvU32 reserved : 30;
  NV_GSYNC_DELAY syncSkew;
  NV_GSYNC_DELAY startupDelay;
} NV_GSYNC_CONTROL_PARAMS;
#define NV_GSYNC_CONTROL_PARAMS_VER MAKE_NVAPI_VERSION(NV_GSYNC_CONTROL_PARAMS, 1)
NVAPI_INTERFACE NvAPI_GSync_GetControlParameters(__in NvGSyncDeviceHandle hNvGSyncDevice,
                                                 __inout NV_GSYNC_CONTROL_PARAMS *pGsyncControls);
NVAPI_INTERFACE NvAPI_GSync_SetControlParameters(__in NvGSyncDeviceHandle hNvGSyncDevice,
                                                 __inout NV_GSYNC_CONTROL_PARAMS *pGsyncControls);
typedef enum _NVAPI_GSYNC_DELAY_TYPE {
  NVAPI_GSYNC_DELAY_TYPE_UNKNOWN = 0,
  NVAPI_GSYNC_DELAY_TYPE_SYNC_SKEW = 1,
  NVAPI_GSYNC_DELAY_TYPE_STARTUP = 2
} NVAPI_GSYNC_DELAY_TYPE;
NVAPI_INTERFACE NvAPI_GSync_AdjustSyncDelay(__in NvGSyncDeviceHandle hNvGSyncDevice,
                                            __in NVAPI_GSYNC_DELAY_TYPE delayType, __inout NV_GSYNC_DELAY *pGsyncDelay,
                                            __out_opt NvU32 *syncSteps);
typedef struct _NV_GSYNC_STATUS {
  NvU32 version;
  NvU32 bIsSynced;
  NvU32 bIsStereoSynced;
  NvU32 bIsSyncSignalAvailable;
} NV_GSYNC_STATUS;
#define NV_GSYNC_STATUS_VER MAKE_NVAPI_VERSION(NV_GSYNC_STATUS, 1)
NVAPI_INTERFACE NvAPI_GSync_GetSyncStatus(__in NvGSyncDeviceHandle hNvGSyncDevice,
                                          __in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_GSYNC_STATUS *status);
#define NVAPI_MAX_RJ45_PER_GSYNC 2
typedef enum _NVAPI_GSYNC_RJ45_IO {
  NVAPI_GSYNC_RJ45_OUTPUT = 0,
  NVAPI_GSYNC_RJ45_INPUT = 1,
  NVAPI_GSYNC_RJ45_UNUSED = 2
} NVAPI_GSYNC_RJ45_IO;
typedef struct _NV_GSYNC_STATUS_PARAMS_V1 {
  NvU32 version;
  NvU32 refreshRate;
  NVAPI_GSYNC_RJ45_IO RJ45_IO[NVAPI_MAX_RJ45_PER_GSYNC];
  NvU32 RJ45_Ethernet[NVAPI_MAX_RJ45_PER_GSYNC];
  NvU32 houseSyncIncoming;
  NvU32 bHouseSync;
} NV_GSYNC_STATUS_PARAMS_V1;
typedef struct _NV_GSYNC_STATUS_PARAMS_V2 {
  NvU32 version;
  NvU32 refreshRate;
  NVAPI_GSYNC_RJ45_IO RJ45_IO[NVAPI_MAX_RJ45_PER_GSYNC];
  NvU32 RJ45_Ethernet[NVAPI_MAX_RJ45_PER_GSYNC];
  NvU32 houseSyncIncoming;
  NvU32 bHouseSync;
  NvU32 bInternalSlave : 1;
  NvU32 reserved : 31;
} NV_GSYNC_STATUS_PARAMS_V2;
typedef NV_GSYNC_STATUS_PARAMS_V2 NV_GSYNC_STATUS_PARAMS;
#define NV_GSYNC_STATUS_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_GSYNC_STATUS_PARAMS_V1, 1)
#define NV_GSYNC_STATUS_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_GSYNC_STATUS_PARAMS_V2, 2)
#define NV_GSYNC_STATUS_PARAMS_VER NV_GSYNC_STATUS_PARAMS_VER2
NVAPI_INTERFACE NvAPI_GSync_GetStatusParameters(NvGSyncDeviceHandle hNvGSyncDevice,
                                                NV_GSYNC_STATUS_PARAMS *pStatusParams);
NVAPI_INTERFACE NvAPI_EnumGSyncDevices(NvGSyncDeviceHandle nvGSyncHandles[NVAPI_MAX_GSYNC_DEVICES], NvU32 *gsyncCount);
#define NVAPI_GSYNC_CAPS_FLAG_FREQ_ACCURACY_2DPS (0x00000001)
#define NVAPI_GSYNC_CAPS_FLAG_FREQ_ACCURACY_3DPS (0x00000002)
#define NVAPI_GSYNC_CAPS_FLAG_FREQ_ACCURACY_4DPS (0x00000004)
#define NVAPI_GSYNC_CAPS_FLAG_SYNC_LOCK_EVENT (0x80000000)
#define NVAPI_GSYNC_CAPS_FLAG_HOUSE_SYNC_EVENT (0x40000000)
#define NVAPI_GSYNC_CAPS_FLAG_FRAME_COUNT_EVENT (0x20000000)
#define NVAPI_GSYNC_CAPS_FLAG_REVISION_OUT_OF_DATE (0x00000010)
#define NVAPI_GSYNC_CAPS_FLAG_FIRMWARE_REVISION_NOT_SUPPORTED (0x00000020)
#define NVAPI_GSYNC_BOARD_ID_P154 340
#define NVAPI_GSYNC_BOARD_ID_P294 660
#define NVAPI_MAX_GPUS_PER_GSYNC 4
typedef struct _NV_GSYNC_TOPOLOGY_TARGET {
  NvU32 version;
  NvPhysicalGpuHandle hPhysicalGpu;
  NVAPI_GSYNC_GPU_TOPOLOGY_CONNECTOR connector;
  NvPhysicalGpuHandle hProxyPhysicalGpu;
  NvU32 bIsSynced;
  NvU32 displayCount;
  struct {
    NvDisplayHandle hNvDisplay;
    NvU32 displayMask;
    NvU32 bIsMasterable;
    NVAPI_GSYNC_DISPLAY_SYNC_STATE syncState;
  } nvDisplays[NV_MAX_HEADS];
} NV_GSYNC_TOPOLOGY_TARGET;
#define NV_GSYNC_TOPOLOGY_TARGET_VER MAKE_NVAPI_VERSION(NV_GSYNC_TOPOLOGY_TARGET, 1)
typedef struct _NV_GSYNC_TOPOLOGY {
  NvU32 version;
  NvU32 gsyncTargetCount;
  NV_GSYNC_TOPOLOGY_TARGET gsyncTarget[NVAPI_MAX_GPUS_PER_GSYNC];
} NV_GSYNC_TOPOLOGY;
#define NV_GSYNC_TOPOLOGY_VER MAKE_NVAPI_VERSION(NV_GSYNC_TOPOLOGY, 1)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_GetTopology.") NVAPI_INTERFACE
    NvAPI_GSync_QueryTopology(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY *pNvGPUTopology);
typedef struct _NV_GSYNC_STATUS_SIGNALS {
  NvU32 version;
  NvU32 RJ45[NVAPI_MAX_RJ45_PER_GSYNC];
  NvU32 house;
} NV_GSYNC_STATUS_SIGNALS;
#define NV_GSYNC_STATUS_SIGNALS_VER MAKE_NVAPI_VERSION(NV_GSYNC_STATUS_SIGNALS, 1)
NVAPI_INTERFACE NvAPI_GSync_QueryStatusSignals(NvGSyncDeviceHandle hNvGSyncDevice,
                                               NV_GSYNC_STATUS_SIGNALS *pNvGSyncStatusSignals);
NVAPI_INTERFACE NvAPI_GSync_Signal_Event(__in_opt NvGSyncDeviceHandle hNvGSyncDevice, __in NvU32 eventFlags);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetSyncStateSettings.")
    NVAPI_INTERFACE NvAPI_GSync_EnableSync(NvGSyncDeviceHandle hNvGSyncDevice,
                                           NV_GSYNC_TOPOLOGY_TARGET *pNvGTopologyTarget, NvU32 refreshRate);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetSyncStateSettings.")
    NVAPI_INTERFACE NvAPI_GSync_DisableSync(NvGSyncDeviceHandle hNvGSyncDevice,
                                            NV_GSYNC_TOPOLOGY_TARGET *pNvGTopologyTarget, NvU32 retainMaster);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetSyncStateSettings.")
    NVAPI_INTERFACE
    NvAPI_GSync_SetSyncState(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_TOPOLOGY *pNvGPUTopology, NvU32 refreshRate);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
    NVAPI_INTERFACE NvAPI_GSync_UpdateSyncPolarity(NvGSyncDeviceHandle hNvGSyncDevice, NVAPI_GSYNC_POLARITY polarity);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
    NVAPI_INTERFACE NvAPI_GSync_UpdateVideoMode(NvGSyncDeviceHandle hNvGSyncDevice, NVAPI_GSYNC_VIDEO_MODE vmode);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
    NVAPI_INTERFACE NvAPI_GSync_UpdateSyncInterval(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 interval);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
    NVAPI_INTERFACE NvAPI_GSync_UpdateSyncSkew(NvGSyncDeviceHandle hNvGSyncDevice, NvS32 skew);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
    NVAPI_INTERFACE NvAPI_GSync_UpdateSyncStartDelay(NvGSyncDeviceHandle hNvGSyncDevice, NvS32 startDelay);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
    NVAPI_INTERFACE NvAPI_GSync_UpdateSyncSource(NvGSyncDeviceHandle hNvGSyncDevice, NVAPI_GSYNC_SYNC_SOURCE source);
typedef struct _NV_GSYNC_PARAMS {
  NvU32 version;
  NVAPI_GSYNC_POLARITY polarity;
  NVAPI_GSYNC_VIDEO_MODE vmode;
  NvU32 interval;
  NvS32 skew;
  NvS32 startDelay;
  NVAPI_GSYNC_SYNC_SOURCE source;
  NvU32 refreshRate;
  NVAPI_GSYNC_RJ45_IO RJ45_IO[NVAPI_MAX_RJ45_PER_GSYNC];
  NvU32 RJ45_Ethernet[NVAPI_MAX_RJ45_PER_GSYNC];
} NV_GSYNC_PARAMS;
#define NV_GSYNC_PARAMS_VER MAKE_NVAPI_VERSION(NV_GSYNC_PARAMS, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 313. Instead, use following "
                            "functions: NvAPI_GSync_GetStatusParameters, and, NvAPI_GSync_GetControlParameters.")
    NVAPI_INTERFACE NvAPI_GSync_QuerySyncParameters(NvGSyncDeviceHandle hNvGSyncDevice, NV_GSYNC_PARAMS *pVals);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_GetSyncStatus.")
    NVAPI_INTERFACE NvAPI_GSync_QuerySyncStatus(NvGSyncDeviceHandle hNvGSyncDevice,
                                                NV_GSYNC_TOPOLOGY_TARGET gsyncTarget, NV_GSYNC_STATUS *pStatus);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_SetControlParameters.")
    NVAPI_INTERFACE NvAPI_GSync_UpdateInterlaceMode(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 state);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 307. Instead, use NvAPI_GSync_GetControlParameters.")
    NVAPI_INTERFACE NvAPI_GSync_QueryInterlaceMode(NvGSyncDeviceHandle hNvGSyncDevice, NvU32 *pState);
typedef enum _NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE {
  NVAPI_GSYNC_DIAGNOSTIC_LOCK_NONE = 0,
  NVAPI_GSYNC_DIAGNOSTIC_LOCK_FRAMELOCK = 1,
  NVAPI_GSYNC_DIAGNOSTIC_LOCK_RASTERLOCK = 3,
} NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE;
typedef enum _NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE {
  NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_NONE = 0,
  NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_MASTER = 1,
  NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_SLAVE = 2,
} NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE;
typedef enum _NVAPI_GSYNC_DIAGNOSTIC_PIN {
  NVAPI_GSYNC_DIAGNOSTIC_PIN_INTERNAL = 0,
  NVAPI_GSYNC_DIAGNOSTIC_PIN_0 = 1,
  NVAPI_GSYNC_DIAGNOSTIC_PIN_1 = 2,
  NVAPI_GSYNC_DIAGNOSTIC_PIN_2 = 3,
  NVAPI_GSYNC_DIAGNOSTIC_PIN_3 = 4,
} NVAPI_GSYNC_DIAGNOSTIC_PIN;
typedef struct _NVAPI_GSYNC_DIAGNOSTIC_PARAMS {
  NvU32 version;
  NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE masterLockState;
  NVAPI_GSYNC_DIAGNOSTIC_PIN masterLockPin;
  NVAPI_GSYNC_DIAGNOSTIC_LOCK_STATE slaveLockState;
  NVAPI_GSYNC_DIAGNOSTIC_PIN slaveLockPin;
  NVAPI_GSYNC_DIAGNOSTIC_PIN stereoPin;
  NvU8 modeTweaking;
  NVAPI_GSYNC_DIAGNOSTIC_RM_LOCK_STATE rmFramelockState;
  NvU8 stereoLock;
  NvU8 syncLock;
  NvU8 primary;
  NvU32 refreshRateX10k;
  NvU32 hBlankStart;
  NvU32 hSyncEnd;
  NvU32 hBlankEnd;
  NvU32 hTotal;
  NvU32 vBlankStart;
  NvU32 vSyncEnd;
  NvU32 vBlankEnd;
  NvU32 vTotal;
  NvU32 vInterlacedBlankEnd;
  NvU32 vInterlacedBlankStart;
  NvU32 pixelClockHz;
  NvU8 interlaced;
} NVAPI_GSYNC_DIAGNOSTIC_PARAMS;
#define NV_GSYNC_DIAGNOSTIC_PARAMS_VER MAKE_NVAPI_VERSION(NVAPI_GSYNC_DIAGNOSTIC_PARAMS, 1)
NVAPI_INTERFACE NvAPI_GSync_Get_DiagnosticSettings(NvDisplayHandle hNvDisplay, NvU32 outputId,
                                                   NVAPI_GSYNC_DIAGNOSTIC_PARAMS *pDiagParams);
typedef enum _NV_GSYNC_REG_OP_CMD {
  NV_GSYNC_REG_OP_READ = 0x00000001,
  NV_GSYNC_REG_OP_WRITE = 0x00000002,
} NV_GSYNC_REG_OP_CMD;
typedef enum _NV_GSYNC_REG {
  NV_GSYNC_REG_FLASH_BOOT_STATUS = 0x00000001,
  NV_GSYNC_REG_FLASH_CMD = 0x00000002,
  NV_GSYNC_REG_FLASH_ADDRESS = 0x00000003,
  NV_GSYNC_REG_FLASH_DATA = 0x00000004,
  NV_GSYNC_REG_FLASH_CHECKSUM = 0x00000005,
  NV_GSYNC_REG_SOFT_RESET = 0x00000006,
} NV_GSYNC_REG;
typedef struct _NV_GSYNC_REG_DATA {
  NvU32 version;
  NV_GSYNC_REG_OP_CMD cmd;
  NV_GSYNC_REG reg;
  NvU32 value : 8;
  NvU32 reserved : 24;
} NV_GSYNC_REG_DATA;
#define NV_GSYNC_REG_DATA_VER MAKE_NVAPI_VERSION(NV_GSYNC_REG_DATA, 1)
NVAPI_INTERFACE NvAPI_GSync_RegOp(__in NvGSyncDeviceHandle hNvGSyncDevice, __inout NV_GSYNC_REG_DATA *regData);
NVAPI_INTERFACE NvAPI_GSync_FPGAFlashHelper(__in NvGSyncDeviceHandle hNvGSyncDevice, __in NvU8 isPreFlash);
typedef struct _fdStatsReport {
  NvU32 structVersion;
} fdStatsReport;
#define FD_STATS_REPORT_STRUCT_VERSION_V0 MAKE_NVAPI_VERSION(fdStatsReport, 0)
typedef void(__cdecl *fdStatsReportsCompletedCallback)(void *pCallbackData, fdStatsReport *pStartReport,
                                                       NvU32 reportCount);
typedef struct {
  NvU32 version;
  NvU32 maxNumAFRGroups;
  NvU32 numAFRGroups;
  NvU32 currentAFRIndex;
  NvU32 nextFrameAFRIndex;
  NvU32 previousFrameAFRIndex;
  NvU32 bIsCurAFRGroupNew;
} NV_GET_CURRENT_SLI_STATE_V1;
typedef struct {
  NvU32 version;
  NvU32 maxNumAFRGroups;
  NvU32 numAFRGroups;
  NvU32 currentAFRIndex;
  NvU32 nextFrameAFRIndex;
  NvU32 previousFrameAFRIndex;
  NvU32 bIsCurAFRGroupNew;
  NvU32 numVRSLIGpus;
} NV_GET_CURRENT_SLI_STATE_V2;
#define NV_GET_CURRENT_SLI_STATE_VER1 MAKE_NVAPI_VERSION(NV_GET_CURRENT_SLI_STATE_V1, 1)
#define NV_GET_CURRENT_SLI_STATE_VER2 MAKE_NVAPI_VERSION(NV_GET_CURRENT_SLI_STATE_V2, 1)
#define NV_GET_CURRENT_SLI_STATE_VER NV_GET_CURRENT_SLI_STATE_VER2
#define NV_GET_CURRENT_SLI_STATE NV_GET_CURRENT_SLI_STATE_V2
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef enum {
  NVAPI_DEVICE_FEATURE_LEVEL_NULL = -1,
  NVAPI_DEVICE_FEATURE_LEVEL_10_0 = 0,
  NVAPI_DEVICE_FEATURE_LEVEL_10_0_PLUS = 1,
  NVAPI_DEVICE_FEATURE_LEVEL_10_1 = 2,
  NVAPI_DEVICE_FEATURE_LEVEL_11_0 = 3,
} NVAPI_DEVICE_FEATURE_LEVEL;
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NV_DECLARE_HANDLE(NVDX_ObjectHandle);
static const NVDX_ObjectHandle NVDX_OBJECT_NONE = 0;
#endif
typedef enum {
  PCD_NEXUS_FRAME_AND_DC_INDEX,
  PCD_NEXUS_DC_EXTRA_INFO,
  PCD_NEXUS_TRAP_HANDLER_DUMP_GPU_VIRTUAL_ADDRESS,
  PCD_NEXUS_COMPUTE_START,
  PCD_NEXUS_COMPUTE_FRAME_AND_DC_INDEX = PCD_NEXUS_COMPUTE_START,
  PCD_NEXUS_COMPUTE_DC_EXTRA_INFO,
  PCD_COUNT
} NvAPIPrivateConstDataSlot;
typedef struct _sdRmHandlesCollection {
  NvU32 structVersion;
} sdRmHandlesCollection;
#define SD_RM_HANDLES_COLLECTION_STRUCT_VERSION_V0 MAKE_NVAPI_VERSION(sdRmHandlesCollection, 0)
typedef struct _sdWarpSemaphoreReport {
  NvU32 structVersion;
} sdWarpSemaphoreReport;
#define SD_WARP_SEMAPHORE_REPORT_VERSION_V0 MAKE_NVAPI_VERSION(sdWarpSemaphoreReport, 0)
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_GetCurrentSLIState(IUnknown *pDevice, NV_GET_CURRENT_SLI_STATE *pSliState);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_RegisterResource(IDirect3DResource9 *pResource);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_UnregisterResource(IDirect3DResource9 *pResource);
#endif
#if defined(_D3D9_H_)
typedef enum {
  NVAPI_ALIAS_SURFACE_FLAG_NONE = 0x00000000,
  NVAPI_ALIAS_SURFACE_FLAG_USE_SUPER = 0x00000001,
  NVAPI_ALIAS_SURFACE_FLAG_MASK = 0x00000001
} NVAPI_ALIAS_SURFACE_FLAG;
NVAPI_INTERFACE NvAPI_D3D9_AliasSurfaceAsTexture(IDirect3DDevice9 *pDev, IDirect3DSurface9 *pSurface,
                                                 IDirect3DTexture9 **ppTexture, DWORD dwFlag);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_StretchRectEx(IDirect3DDevice9 *pDevice, IDirect3DResource9 *pSourceResource,
                                         CONST RECT *pSourceRect, IDirect3DResource9 *pDestResource,
                                         CONST RECT *pDestRect, D3DTEXTUREFILTERTYPE Filter);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_ClearRT(IDirect3DDevice9 *pDevice, NvU32 dwNumRects, CONST RECT *pRects, float r, float g,
                                   float b, float a);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D_GetObjectHandleForResource(IUnknown *pDevice, IUnknown *pResource,
                                                     NVDX_ObjectHandle *pHandle);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_SetDriverDebugState(IUnknown *pDev, NvU32 stateEnum, NvU32 stateValue);
#endif
#if defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SetDriverDebugState(ID3D11DeviceContext *pDc, NvU32 stateEnum, NvU32 stateValue);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_SetDriverDebugString(IUnknown *pDev, NvU32 stateEnum, const wchar_t *pStateString);
#endif
#if defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SetDriverDebugString(ID3D11DeviceContext *pDc, NvU32 stateEnum,
                                                 const wchar_t *pStateString);
#endif
#if defined(__d3d10_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
typedef enum _NVAPI_D3D_SETDEVICEHINT_CATEGORY { NVAPI_D3D_SDH_CATEGORY_CORE = 1 } NVAPI_D3D_SETDEVICEHINT_CATEGORY;
typedef enum _NVAPI_D3D_SETDEVICEHINT_CORE {
  NVAPI_D3D_SRH_CORE_TREAT_DISCARD_AS_L2_INVALIDATE = 1,
  NVAPI_D3D_SRH_CORE_ALLOW_IMPLICIT_MSAA_DEPTH_PROMOTION = 2,
  NVAPI_D3D_SRH_CORE_ENABLE_TIRWITHDEPTH_SUPERSAMPLE_PROMOTION = 3,
  NVAPI_D3D_SRH_CORE_ENABLE_DLSS_METACOMMAND_SUBSTITUTION = 4,
} NVAPI_D3D_SETDEVICEHINT_CORE;
NVAPI_INTERFACE NvAPI_D3D_SetDeviceHint(IUnknown *pDev, NVAPI_D3D_SETDEVICEHINT_CATEGORY dwHintCategory,
                                        NvU32 dwHintName, NvU32 *pdwHintValue);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
typedef enum _NVAPI_D3D_SETRESOURCEHINT_CATEGORY { NVAPI_D3D_SRH_CATEGORY_SLI = 1 } NVAPI_D3D_SETRESOURCEHINT_CATEGORY;
typedef enum _NVAPI_D3D_SETRESOURCEHINT_SLI {
  NVAPI_D3D_SRH_SLI_APP_CONTROLLED_INTERFRAME_CONTENT_SYNC = 1,
  NVAPI_D3D_SRH_SLI_ASK_FOR_BROADCAST_USAGE = 2,
  NVAPI_D3D_SRH_SLI_RESPECT_DRIVER_INTERFRAME_CONTENT_SYNC = 3
} NVAPI_D3D_SETRESOURCEHINT_SLI;
NVAPI_INTERFACE NvAPI_D3D_SetResourceHint(IUnknown *pDev, NVDX_ObjectHandle obj,
                                          NVAPI_D3D_SETRESOURCEHINT_CATEGORY dwHintCategory, NvU32 dwHintName,
                                          NvU32 *pdwHintValue);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
typedef enum _NVAPI_D3D_RESOURCERENDERING_FLAG {
  NVAPI_D3D_RR_FLAG_DEFAULTS = 0x00000000,
  NVAPI_D3D_RR_FLAG_FORCE_DISCARD_CONTENT = 0x00000001,
  NVAPI_D3D_RR_FLAG_FORCE_KEEP_CONTENT = 0x00000002,
  NVAPI_D3D_RR_FLAG_MULTI_FRAME = 0x00000004
} NVAPI_D3D_RESOURCERENDERING_FLAG;
NVAPI_INTERFACE NvAPI_D3D_BeginResourceRendering(IUnknown *pDeviceOrContext, NVDX_ObjectHandle obj, NvU32 Flags);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_EndResourceRendering(IUnknown *pDeviceOrContext, NVDX_ObjectHandle obj, NvU32 Flags);
#endif
typedef enum _NVAPI_D3D_QUERY_TYPE {
  NVAPI_D3D_QUERY_TYPE_RESERVED0 = 0,
  NVAPI_D3D_QUERY_TYPE_RESERVED1 = 1,
  NVAPI_D3D_QUERY_TYPE_RESERVED2 = 2,
  NVAPI_D3D_QUERY_TYPE_RESERVED3 = 3,
  NVAPI_D3D_QUERY_TYPE_PMTRIGGER = 0,
  NVAPI_D3D_QUERY_TYPE_ZCULL_STATS = 1,
  NVAPI_D3D_QUERY_TYPE_FE_TIMESTAMP = 2,
  NVAPI_D3D_QUERY_TYPE_DA_TIMESTAMP = 3,
  NVAPI_D3D_QUERY_TYPE_ROP_TIMESTAMP = 4,
} NVAPI_D3D_QUERY_TYPE;
typedef enum _NVAPI_D3D_QUERY_GETDATA_FLAGS {
  NVAPI_D3D_QUERY_GETDATA_FLUSH = 0,
  NVAPI_D3D_QUERY_GETDATA_DONOTFLUSH = 1
} NVAPI_D3D_QUERY_GETDATA_FLAGS;
#if defined(_D3D9_H_) || defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D_CreateQuery(IUnknown *pDeviceOrContext, NVAPI_D3D_QUERY_TYPE type,
                                      NVDX_ObjectHandle *pHandle);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D_DestroyQuery(NVDX_ObjectHandle queryHandle);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D_Query_Begin(NVDX_ObjectHandle queryHandle);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D_Query_End(NVDX_ObjectHandle queryHandle);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D_Query_GetData(NVDX_ObjectHandle queryHandle, void *pData, UINT dwSize, UINT dwGetDataFlags);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D_Query_GetDataSize(NVDX_ObjectHandle queryHandle, UINT *pDwSize);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D_Query_GetType(NVDX_ObjectHandle queryHandle, NVAPI_D3D_QUERY_TYPE *pType);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D_GetDeviceKmtHandle(IUnknown *pDev, NvU64 *phDevice);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D_CudaInteropFunction(IUnknown *pDev, UINT dwFunction, void *pData);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D_CudaInteropGetObjectHandle(IUnknown *pDevice, IUnknown *pResource,
                                                     NVDX_ObjectHandle *pHandle);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D_RegisterApp(IUnknown *pDev, NvU32 userAppId);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum _NV_PATH_DATATYPE {
  NV_BYTE = 0,
  NV_UNSIGNED_BYTE,
  NV_SHORT,
  NV_UNSIGNED_SHORT,
  NV_INT,
  NV_UNSIGNED_INT,
  NV_FLOAT,
  NV_FIXED
} NvPathDataType;
typedef enum _NV_PATH_PARAMTYPE {
  PATH_QUALITY_NV = 0x8ED8,
  FILL_RULE_NV = 0x8ED9,
  STROKE_CAP0_STYLE_NV = 0x8EE0,
  STROKE_CAP1_STYLE_NV = 0x8EE1,
  STROKE_CAP2_STYLE_NV = 0x8EE2,
  STROKE_CAP3_STYLE_NV = 0x8EE3,
  STROKE_JOIN_STYLE_NV = 0x8EE8,
  STROKE_MITER_LIMIT_NV = 0x8EE9
} NVPathParamType;
typedef enum _NV_PATH_FILLRULE { EVEN_ODD_NV = 0x8EF0, NON_ZERO_NV = 0x8EF1 } NVPathFillRule;
typedef enum _NV_PATH_CAPSTYLE {
  CAP_BUTT_NV = 0x8EF4,
  CAP_ROUND_NV = 0x8EF5,
  CAP_SQUARE_NV = 0x8EF6,
  CAP_TRIANGLE_NV = 0x8EF7
} NVPathCapStyle;
typedef enum _NV_PATH_JOINSTYLE {
  JOIN_MITER_NV = 0x8EFC,
  JOIN_ROUND_NV = 0x8EFD,
  JOIN_BEVEL_NV = 0x8EFE,
  JOIN_CLIPPED_MITER_NV = 0x8EFF
} NVPathJoinStyle;
typedef enum _NV_PATH_TARGETTYPE {
  MATRIX_PATH_TO_CLIP_NV = 0x8F04,
  MATRIX_STROKE_TO_PATH_NV = 0x8F05,
  MATRIX_PATH_COORD0_NV = 0x8F08,
  MATRIX_PATH_COORD1_NV = 0x8F09,
  MATRIX_PATH_COORD2_NV = 0x8F0A,
  MATRIX_PATH_COORD3_NV = 0x8F0B
} NVPathTargetType;
typedef enum _NV_PATH_MODE { FILL_PATH_NV = 0x8F18, STROKE_PATH_NV = 0x8F19 } NVPathMode;
typedef enum _NV_PATH_CMD {
  MOVE_TO_NV = 0x00,
  LINE_TO_NV = 0x01,
  QUADRATIC_BEZIER_TO_NV = 0x02,
  CUBIC_BEZIER_TO_NV = 0x03,
  START_MARKER_NV = 0x20,
  CLOSE_NV = 0x21,
  STROKE_CAP0_NV = 0x40,
  STROKE_CAP1_NV = 0x41,
  STROKE_CAP2_NV = 0x42,
  STROKE_CAP3_NV = 0x43,
} NVPathCmd;
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_CreatePathContextNV(IDirect3DDevice9 *pDevice, NvU32 *context);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_DestroyPathContextNV(NvU32 context);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_CreatePathNV(NvU32 context, NvPathDataType datatype, NvU32 numCommands, const NvU8 *commands,
                                        NvU32 *path);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_DeletePathNV(NvU32 path);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_PathVerticesNV(NvU32 path, const void *vertices);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_PathParameterfNV(NvU32 path, NVPathParamType paramType, float param);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_PathParameteriNV(NvU32 path, NVPathParamType paramType, int param);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_PathMatrixNV(NvU32 context, NVPathTargetType paramType, const float *value);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_PathDepthNV(NvU32 context, float value);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_PathClearDepthNV(NvU32 context, float value);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_PathEnableDepthTestNV(NvU32 context, bool enable);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_PathEnableColorWriteNV(NvU32 context, bool enable);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_DrawPathNV(NvU32 path, NVPathMode mode);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GetSurfaceHandle(IDirect3DSurface9 *pSurface, NVDX_ObjectHandle *pHandle);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
#define MAX_OVLY_SURFS 6
typedef struct _NV_OVLY_SURFS_INFO {
  NVDX_ObjectHandle handle[MAX_OVLY_SURFS];
  unsigned int numSurfs;
} NV_OVLY_SURFS_INFO;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 515.") NVAPI_INTERFACE
    NvAPI_D3D9_GetOverlaySurfaceHandles(IDirect3DDevice9 *pDev, NV_OVLY_SURFS_INFO *pInfo);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GetTextureHandle(IDirect3DTexture9 *pTexture, NVDX_ObjectHandle *pHandle);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncGetHandleSize(IDirect3DDevice9 *pDev, unsigned int *pInitHandleSize,
                                                unsigned int *pMapHandleSize);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncInit(IDirect3DDevice9 *pDev, void *syncInitData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncEnd(IDirect3DDevice9 *pDev, void *syncData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapTexBuffer(IDirect3DDevice9 *pDev, IDirect3DTexture9 *pTexture, void *syncData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapSurfaceBuffer(IDirect3DDevice9 *pDev, IDirect3DSurface9 *pSurface, void *syncData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapVertexBuffer(IDirect3DDevice9 *pDev, IDirect3DVertexBuffer9 *pVertexBuffer,
                                                  void *syncData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncMapIndexBuffer(IDirect3DDevice9 *pDev, IDirect3DIndexBuffer9 *pIndexBuffer,
                                                 void *syncData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_SetPitchSurfaceCreation(IDirect3DDevice9 *pDev, NvU32 Signature);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncAcquire(IDirect3DDevice9 *pDev, void *syncData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GpuSyncRelease(IDirect3DDevice9 *pDev, void *syncData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GetCurrentRenderTargetHandle(IDirect3DDevice9 *pDev, NVDX_ObjectHandle *pHandle);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GetCurrentZBufferHandle(IDirect3DDevice9 *pDev, NVDX_ObjectHandle *pHandle);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GetIndexBufferHandle(IDirect3DIndexBuffer9 *pIndexBuffer, NVDX_ObjectHandle *pHandle);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GetVertexBufferHandle(IDirect3DVertexBuffer9 *pVertexBuffer, NVDX_ObjectHandle *pHandle);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
#define NV_SURFACEFLAG_FORCEVIDMEM 0x00000001
#define NV_SURFACEFLAG_FORCELINEAR 0x00000010
#define NV_SURFACEFLAG_NOTMOVABLE 0x00000100
NVAPI_INTERFACE NvAPI_D3D9_CreateTexture(IDirect3DDevice9 *pDev, NvU32 Width, NvU32 Height, NvU32 Level, NvU32 Flags,
                                         D3DFORMAT Format, IDirect3DTexture9 **ppTexture,
                                         NVDX_ObjectHandle *pHandle = 0);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_AliasPrimaryAsTexture(IDirect3DDevice9 *pDev, NvU32 dwIndex, IDirect3DTexture9 **ppTexture,
                                                 NVDX_ObjectHandle *pHandle = 0);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
#define NV_FLIPFLAG_VSYNC 0x00000001
#define NV_FLIPFLAG_HSYNC 0x00000002
#define NV_FLIPFLAG_TRIPLEBUFFERING 0x00000004
NVAPI_INTERFACE NvAPI_D3D9_PresentSurfaceToDesktop(IDirect3DDevice9 *pDev, NVDX_ObjectHandle surfaceHandle,
                                                   NvU32 dwFlipFlags, NvU32 dwExcludeDevices = 0);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 375. Instead, use NvAPI_D3D9_CreateVideoBegin.")
    NVAPI_INTERFACE NvAPI_D3D9_CreateVideoBegin(IDirect3DDevice9 *pDev);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 375. Instead, use NvAPI_D3D9_CreateVideoEnd.")
    NVAPI_INTERFACE NvAPI_D3D9_CreateVideoEnd(IDirect3DDevice9 *pDev);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
#define NV_CVFLAG_OVERLAY 0x00000001
#define NV_CVFLAG_OVERLAY_REINIT 0x00000002
#define NV_CVFLAG_EXTERNAL_OVERLAY 0x00000004
#define NV_CVFLAG_2ND_FORCE_DISABLE 0x00010000
#define NV_CVFLAG_2ND_FORCE_ENABLE 0x00020000
#define NV_CVFLAG_2ND_FORCE_ENABLE1 0x00040000
#define NV_CVFLAG_2ND_COMMANDEER 0x00100000
#define NV_CVFLAG_SECONDARY_DISPLAY 0x01000000
typedef struct {
  NvU32 version;
  NvU32 cvFlags;
  NvU32 flipQueueHint;
  NvU32 maxSrcWidth;
  NvU32 maxSrcHeight;
} NV_DX_CREATE_VIDEO_PARAMS1;
#define NV_CV_MIN_OVERLAY_SURFACE_NUMBER 2
#define NV_CV_MAX_OVERLAY_SURFACE_NUMBER 6
typedef struct {
  NvU32 version;
  NvU32 cvFlags;
  NvU32 flipQueueHint;
  NvU32 maxSrcWidth;
  NvU32 maxSrcHeight;
  NvU32 dwNumOvlSurfs;
  NVDX_ObjectHandle hOvlSurfs[NV_CV_MAX_OVERLAY_SURFACE_NUMBER];
} NV_DX_CREATE_VIDEO_PARAMS2;
typedef NV_DX_CREATE_VIDEO_PARAMS2 NV_DX_CREATE_VIDEO_PARAMS;
#define NV_DX_CREATE_VIDEO_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_DX_CREATE_VIDEO_PARAMS1, 1)
#define NV_DX_CREATE_VIDEO_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_DX_CREATE_VIDEO_PARAMS2, 2)
#define NV_DX_CREATE_VIDEO_PARAMS_VER NV_DX_CREATE_VIDEO_PARAMS_VER2
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 375. Instead, use NvAPI_D3D9_CreateVideo.") NVAPI_INTERFACE
    NvAPI_D3D9_CreateVideo(IDirect3DDevice9 *pDev, NV_DX_CREATE_VIDEO_PARAMS *pCVParams);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 375. Instead, use NvAPI_D3D9_FreeVideo.") NVAPI_INTERFACE
    NvAPI_D3D9_FreeVideo(IDirect3DDevice9 *pDev);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
#define NV_PVFLAG_ODD 0x00000001
#define NV_PVFLAG_EVEN 0x00000002
#define NV_PVFLAG_PROTECTED 0x00000004
#define NV_PVFLAG_PROGRESSIVE 0x00000008
#define NV_PVFLAG_SHOW 0x00000010
#define NV_PVFLAG_FAST_MOVE 0x00000020
#define NV_PVFLAG_WAIT 0x00000040
#define NV_PVFLAG_REPEAT 0x00000080
#define NV_PVFLAG_DST_KEY 0x00000100
#define NV_PVFLAG_FULLSCREEN 0x00000200
#define NV_PVFLAG_SET_STAMP 0x00001000
#define NV_PVFLAG_USE_STAMP 0x00002000
#define NV_PVFLAG_SRC_KEY 0x00004000
typedef struct {
  NvU32 version;
  NVDX_ObjectHandle surfaceHandle;
  NvU32 pvFlags;
  NvU32 colourKey;
  NvU32 timeStampLow;
  NvU32 timeStampHigh;
  NvU32 flipRate;
  NvSBox srcUnclipped;
  NvSBox srcClipped;
  NvSBox dst;
} NV_DX_PRESENT_VIDEO_PARAMS1;
typedef NV_DX_PRESENT_VIDEO_PARAMS1 NV_DX_PRESENT_VIDEO_PARAMS;
#ifdef _WIN32
#define NV_DX_PRESENT_VIDEO_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_DX_PRESENT_VIDEO_PARAMS1, 1)
#endif
#define NV_DX_PRESENT_VIDEO_PARAMS_VER MAKE_NVAPI_VERSION(NV_DX_PRESENT_VIDEO_PARAMS1, 2)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 375. Instead, use NvAPI_D3D9_PresentVideo.") NVAPI_INTERFACE
    NvAPI_D3D9_PresentVideo(IDirect3DDevice9 *pDev, NV_DX_PRESENT_VIDEO_PARAMS *pPVParams);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
#ifndef NV_STEREO_VIDEO_FORMAT_DEFINE
#define NV_STEREO_VIDEO_FORMAT_DEFINE
typedef enum _NV_STEREO_VIDEO_FORMAT {
  NV_STEREO_VIDEO_FORMAT_NOT_STEREO = 0,
  NV_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_LR = 1,
  NV_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_RL = 2,
  NV_STEREO_VIDEO_FORMAT_TOP_BOTTOM_LR = 3,
  NV_STEREO_VIDEO_FORMAT_TOP_BOTTOM_RL = 4,
  NV_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_LR = 5,
  NV_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_RL = 6,
  NV_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR = 7,
  NV_STEREO_VIDEO_FORMAT_MONO_PLUS_OFFSET = 8,
  NV_STEREO_VIDEO_FORMAT_LAST = 9,
} NV_STEREO_VIDEO_FORMAT;
#endif
typedef struct _NV_DX_VIDEO_STEREO_INFO {
  NvU32 dwVersion;
  NVDX_ObjectHandle hSurface;
  NVDX_ObjectHandle hLinkedSurface;
  NV_STEREO_VIDEO_FORMAT eFormat;
  NvS32 sViewOffset;
  BOOL bStereoEnable;
} NV_DX_VIDEO_STEREO_INFO;
#define NV_DX_VIDEO_STEREO_INFO_VER MAKE_NVAPI_VERSION(NV_DX_VIDEO_STEREO_INFO, 1)
NVAPI_INTERFACE NvAPI_D3D9_VideoSetStereoInfo(IDirect3DDevice9 *pDev, NV_DX_VIDEO_STEREO_INFO *pStereoInfo);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum _NV_GAMUT_FORMAT {
  NV_GAMUT_FORMAT_VERTICES = 0,
  NV_GAMUT_FORMAT_RANGE,
} NV_GAMUT_FORMAT;
typedef struct _NV_GAMUT_METADATA_RANGE {
  NvU32 GBD_Color_Space : 3;
  NvU32 GBD_Color_Precision : 2;
  NvU32 Rsvd : 2;
  NvU32 Format_Flag : 1;
  NvU32 Min_Red_Data : 12;
  NvU32 Max_Red_Data : 12;
  NvU32 Min_Green_Data : 12;
  NvU32 Max_Green_Data : 12;
  NvU32 Min_Blue_Data : 12;
  NvU32 Max_Blue_Data : 12;
} NV_GAMUT_METADATA_RANGE;
typedef struct _NV_GAMUT_METADATA_VERTICES {
  NvU32 GBD_Color_Space : 3;
  NvU32 GBD_Color_Precision : 2;
  NvU32 Rsvd : 1;
  NvU32 Facet_Mode : 1;
  NvU32 Format_Flag : 1;
  NvU32 Number_Vertices_H : 8;
  NvU32 Number_Vertices_L : 8;
  NvU32 Black_Y_R : 12;
  NvU32 Black_Cb_G : 12;
  NvU32 Black_Cr_B : 12;
  NvU32 Red_Y_R : 12;
  NvU32 Red_Cb_G : 12;
  NvU32 Red_Cr_B : 12;
  NvU32 Green_Y_R : 12;
  NvU32 Green_Cb_G : 12;
  NvU32 Green_Cr_B : 12;
  NvU32 Blue_Y_R : 12;
  NvU32 Blue_Cb_G : 12;
  NvU32 Blue_Cr_B : 12;
} NV_GAMUT_METADATA_VERTICES;
typedef struct _NV_GAMUT_METADATA {
  union {
    NV_GAMUT_METADATA_RANGE rangeData;
    NV_GAMUT_METADATA_VERTICES verticesData;
  } data;
} NV_GAMUT_METADATA;
NVAPI_INTERFACE NvAPI_D3D9_SetGamutData(IDirect3DDevice9 *pDev, NvU32 outputId, NV_GAMUT_FORMAT format,
                                        NV_GAMUT_METADATA *pGamutData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum _NVAPI_SURFACE_LAYOUT {
  NVAPI_SURFACE_LAYOUT_BL = 0,
  NVAPI_SURFACE_LAYOUT_PL = 1,
  NVAPI_SURFACE_LAYOUT_TILED = 2,
} NVAPI_SURFACE_LAYOUT;
typedef struct _NVAPI_SURFACE_LAYOUT_STRUCT {
  BOOL bEnableLayoutOverride;
  NVAPI_SURFACE_LAYOUT slLayout;
  DWORD reserved[4];
} NVAPI_SURFACE_LAYOUT_STRUCT;
NVAPI_INTERFACE NvAPI_D3D9_SetSurfaceCreationLayout(IDirect3DDevice9 *pDev,
                                                    NVAPI_SURFACE_LAYOUT_STRUCT *pSurfaceLayout);
#endif
typedef enum _NV_CODEC {
  NV_CODEC_TYPE_NONE,
  NV_CODEC_TYPE_MPEG2,
  NV_CODEC_TYPE_H264,
  NV_CODEC_TYPE_VC1,
  NV_CODEC_TYPE_MVC,
} NV_CODEC;
typedef struct _NVAPI_VIDEO_SRC_INFO {
  NvU32 srcWidth;
  NvU32 srcHeight;
  NV_CODEC codecType;
  NvU32 avgBitrate;
  NvU64 reserved1;
  NvU64 reserved2;
} NVAPI_VIDEO_SRC_INFO;
typedef struct _NVAPI_DESKTOP_RES {
  NvU32 width;
  NvU32 height;
  NvU32 bitsPerPixel;
  NvU32 refreshRate;
  NvU64 reserved1;
  NvU64 reserved2;
} NVAPI_DESKTOP_RES;
#define NV_DEINTERLACE_PIXADAPTIVE_BIT 0
#define NV_VID_ENHANCE_EDGE_ENHANCE_BIT 0
#define NV_VID_ENHANCE_NOISE_REDUCTION_BIT 1
#define NV_COLOR_CTRL_PROCAMP_BIT 0
#define NV_COLOR_CTRL_COLOR_TEMP_BIT 1
#define NV_COLOR_CTRL_COLORSPACE_601_BIT 2
#define NV_COLOR_CTRL_COLORSPACE_709_BIT 3
#define NV_COLOR_CTRL_COLORSPACE_RGB_BIT 4
#define NV_GAMMA_Y_BIT 0
#define NV_GAMMA_RGB_BIT 1
#define NV_MISC_CAPS_INV_TELECINE_BIT 0
typedef struct _NVAPI_VIDEO_PROCESSING_CAPS {
  NvU64 deinterlaceMode;
  NvU64 videoEnhance;
  NvU64 colorControl;
  NvU64 gamma;
  NvU64 miscCaps;
  NvU64 reserved1;
  NvU64 reserved2;
  NvU64 reserved3;
} NVAPI_VIDEO_PROCESSING_CAPS;
#define NV_VID_FEATURE_NO_SYNC_FLIPS_BIT 0
#define NV_VID_FEATURE_HALF_RES_ON_INTERLACED_BIT 1
#define NV_VID_FEATURE_DX_PROTECTION_VERSION_2 2
#define NV_VID_FEATURE_STEREO_VIDEO_BIT 3
#define NV_VID_FEATURE_STEREO_OVERLAY_VIDEO_BIT 4
#define NV_PERF_LEVEL_RED_BIT 0
#define NV_PERF_LEVEL_YELLOW_BIT 1
#define NV_PERF_LEVEL_GREEN_BIT 2
#define NV_PERF_LEVEL_AERO_BIT 3
#define NV_PERF_LEVEL_FRUC_BIT 4
#define NV_PERF_LEVEL_3DBD_COMPOSITE_BIT 6
typedef struct _NVAPI_VIDEO_CAPS {
  NvU32 maxFlipRate;
  NV_CODEC hwDecode;
  NvU64 vidFeature;
  NvU32 perfLevel;
  NvU32 numVidProfiles;
  NvU32 maxResPixels;
  NvU32 reserved1;
  NVAPI_VIDEO_PROCESSING_CAPS vidProcCaps[NV_MAX_VID_PROFILES];
} NVAPI_VIDEO_CAPS;
#define RENDER_MODE_DWM_BIT 0
#define RENDER_MODE_OVERLAY_BIT 1
#define RENDER_MODE_STEREO_FULLSCREEN_BIT 2
typedef struct _NVAPI_VIDEO_CAPS_PACKET_V1 {
  NvU32 packetVer;
  NvU32 numVidStreams;
  NVAPI_VIDEO_SRC_INFO vidSrcInfo[NV_MAX_VID_STREAMS];
  NVAPI_DESKTOP_RES res[NV_MAX_HEADS];
  NvU64 renderMode;
  NvU64 totalFB;
  NvU16 NumExtOvlBufNeeded;
  NvU16 reserved1;
  NvU32 reserved2;
  NVAPI_VIDEO_CAPS videoCaps[NV_MAX_VID_STREAMS];
} NVAPI_VIDEO_CAPS_PACKET_V1;
typedef NVAPI_VIDEO_CAPS_PACKET_V1 NVAPI_VIDEO_CAPS_PACKET;
#define NVAPI_VIDEO_CAPS_PACKET_VER_1 2
#define NVAPI_VIDEO_CAPS_PACKET_VER NVAPI_VIDEO_CAPS_PACKET_VER_1
typedef struct _NV_DX_VIDEO_CAPS_V1 {
  NvU32 version;
  NVAPI_VIDEO_CAPS_PACKET_V1 videoCapsPacket;
} NV_DX_VIDEO_CAPS_V1;
typedef NV_DX_VIDEO_CAPS_V1 NV_DX_VIDEO_CAPS;
#define NV_DX_VIDEO_CAPS_VER_1 MAKE_NVAPI_VERSION(NV_DX_VIDEO_CAPS_V1, 1)
#define NV_DX_VIDEO_CAPS_VER NV_DX_VIDEO_CAPS_VER_1
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GetVideoCapabilities(IDirect3DDevice9 *pDev, NV_DX_VIDEO_CAPS *pVideoCaps);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum _NVAPI_D3D9_QUERY_COMMAND {
  NVAPI_D3D9_QUERY_NULL_CMD = 0,
  NVAPI_D3D9_QUERY_STEREO_INFO_CMD = 1,
  NVAPI_D3D9_QUERY_COLOR_INFO_CMD = 2,
} NVAPI_D3D9_QUERY_COMMAND;
typedef enum _NV_QUERY_STEREO_INFO_FORMAT {
  NVAPI_QUERY_STEREO_INFO_FORMAT_NOT_STEREO = 0x00000000,
  NVAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_LR = 0x00000001,
  NVAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_RL = 0x00000002,
  NVAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_LR = 0x00000004,
  NVAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_RL = 0x00000008,
  NVAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_LR = 0x00000010,
  NVAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_RL = 0x00000020,
  NVAPI_QUERY_STEREO_INFO_FORMAT_TWO_FRAMES_LR = 0x00000040,
  NVAPI_QUERY_STEREO_INFO_FORMAT_MONO_PLUS_OFFSET = 0x00000080,
} NV_QUERY_STEREO_INFO_FORMAT;
#define NVAPI_QUERY_STEREO_INFO_FORMAT_ALL                                                                             \
  NVAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_LR | NVAPI_QUERY_STEREO_INFO_FORMAT_SIDE_BY_SIDE_RL |                    \
      NVAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_LR | NVAPI_QUERY_STEREO_INFO_FORMAT_TOP_BOTTOM_RL |                    \
      NVAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_LR | NVAPI_QUERY_STEREO_INFO_FORMAT_ROW_INTERLEAVE_RL |            \
      NVAPI_QUERY_STEREO_INFO_FORMAT_TWO_FRAMES_LR | NVAPI_QUERY_STEREO_INFO_FORMAT_MONO_PLUS_OFFSET
typedef struct _NVAPI_QUERY_STEREO_INFO {
  NvU32 dwFormats;
  NvU32 bIsSupported : 1;
  NvU32 bIsEnabled : 1;
  NvU32 dwReserved1 : 30;
  NvU32 dwReserved2[4];
} NVAPI_QUERY_STEREO_INFO;
typedef enum _NVAPI_QUERY_COLOR_INFO_COLORSPACE {
  NVAPI_QUERY_COLOR_INFO_COLORSPACE_NONE = 0x00000000,
  NVAPI_QUERY_COLOR_INFO_COLORSPACE_601 = 0x00000001,
  NVAPI_QUERY_COLOR_INFO_COLORSPACE_709 = 0x00000002,
  NVAPI_QUERY_COLOR_INFO_COLORSPACE_RGB = 0x00000004,
} NVAPI_QUERY_COLOR_INFO_COLORSPACE;
#define NVAPI_QUERY_COLOR_INFO_COLORSPACE_ALL                                                                          \
  NVAPI_QUERY_COLOR_INFO_COLORSPACE_601 | NVAPI_QUERY_COLOR_INFO_COLORSPACE_709 | NVAPI_QUERY_COLOR_INFO_COLORSPACE_RGB
typedef struct _NVAPI_QUERY_COLOR_INFO {
  NvU32 dwColorSpaces;
  NvU32 dwReserved[4];
} NVAPI_QUERY_COLOR_INFO;
typedef struct _NVAPI_DX_QUERY_VIDEO_INFO {
  NvU32 dwVersion;
  NVAPI_D3D9_QUERY_COMMAND eQueryCommand;
  union {
    NVAPI_QUERY_STEREO_INFO stStereoInfo;
    NVAPI_QUERY_COLOR_INFO stColorInfo;
  };
} NVAPI_D3D9_QUERY_VIDEO_INFO;
#define NVAPI_D3D9_QUERY_VIDEO_INFO_VER MAKE_NVAPI_VERSION(NVAPI_D3D9_QUERY_VIDEO_INFO, 1)
NVAPI_INTERFACE NvAPI_D3D9_QueryVideoInfo(IDirect3DDevice9 *pDev, NVAPI_D3D9_QUERY_VIDEO_INFO *pQueryInfo);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_EnableStereoOverlay(IDirect3DDevice9 *pDev);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
inline int NvAPI_D3D9_RestoreDesktop(IDirect3DDevice9 *pDev) {
  return NvAPI_D3D9_PresentSurfaceToDesktop(pDev, NVDX_OBJECT_NONE, 0);
}
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_AliasPrimaryFromDevice(IDirect3DDevice9 *pDevTo, IDirect3DDevice9 *pDevFrom, NvU32 dwIndex,
                                                  IDirect3DSurface9 **ppSurf, NVDX_ObjectHandle *pHandle = 0);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum _NVAPI_SETRESOURCEHINT_CATEGORY {
  NvApiHints_Sli = 1,
} NVAPI_SETRESOURCEHINT_CATEGORY;
typedef enum _NVAPI_SETRESOURCEHINT_SLI_HINTS {
  NvApiHints_Sli_InterframeAwareForTexturing = 1,
} NVAPI_SETRESOURCEHINT_SLI_HINTS;
NVAPI_INTERFACE NvAPI_D3D9_SetResourceHint(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj,
                                           NVAPI_SETRESOURCEHINT_CATEGORY dwHintCategory, NvU32 dwHintName,
                                           NvU32 *pdwHintValue);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
#define NV_ACCESSFLAG_READONLY 0x00000001
#define NV_ACCESSFLAG_DISCARD 0x00000002
NVAPI_INTERFACE NvAPI_D3D9_Lock(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj, NvU32 dwLockFlags, void **ppAddress,
                                NvU32 *pPitch);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_Unlock(IDirect3DDevice9 *pDev, NVDX_ObjectHandle obj);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
#ifndef NV_VIDEO_COMPONENTS_DEFINE
#define NV_VIDEO_COMPONENTS_DEFINE
typedef enum _NVAPI_VIDEO_STATE_COMPONENT_ID {
  NVAPI_VIDEO_STATE_COMPONENT_ID_NONE = -1,
  NVAPI_VIDEO_STATE_COMPONENT_BRIGHTNESS,
  NVAPI_VIDEO_STATE_COMPONENT_CONTRAST,
  NVAPI_VIDEO_STATE_COMPONENT_HUE,
  NVAPI_VIDEO_STATE_COMPONENT_SATURATION,
  NVAPI_VIDEO_STATE_COMPONENT_COLORTEMP,
  NVAPI_VIDEO_STATE_COMPONENT_Y_GAMMA,
  NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_R,
  NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_G,
  NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_B,
  NVAPI_VIDEO_STATE_COMPONENT_COLOR_SPACE,
  NVAPI_VIDEO_STATE_COMPONENT_COLOR_RANGE,
  NVAPI_VIDEO_STATE_COMPONENT_PLAYBACK_PROFILE,
  NVAPI_VIDEO_STATE_COMPONENT_DEINTERLACE,
  NVAPI_VIDEO_STATE_COMPONENT_SCALING,
  NVAPI_VIDEO_STATE_COMPONENT_CADENCE,
  NVAPI_VIDEO_STATE_COMPONENT_NOISE_REDUCE,
  NVAPI_VIDEO_STATE_COMPONENT_EDGE_ENHANCE,
  NVAPI_VIDEO_STATE_COMPONENT_OVERDRIVE,
  NVAPI_VIDEO_STATE_COMPONENT_SPLITSCREEN,
  NVAPI_VIDEO_STATE_COMPONENT_DEBLOCKING,
  NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST,
  NVAPI_VIDEO_STATE_COMPONENT_GREEN_STRETCH,
  NVAPI_VIDEO_STATE_COMPONENT_BLUE_STRETCH,
  NVAPI_VIDEO_STATE_COMPONENT_SKIN_TONE_CORRECTION,
  NVAPI_VIDEO_STATE_COMPONENT_GAMUT_REMAPPING,
  NVAPI_VIDEO_STATE_COMPONENT_2DTO3D,
  NVAPI_VIDEO_STATE_COMPONENT_3D_ANALYSIS,
  NVAPI_VIDEO_STATE_COMPONENT_FRC,
  NVAPI_VIDEO_STATE_COMPONENT_BEN,
  NVAPI_VIDEO_STATE_COMPONENT_ID_LAST,
} NVAPI_VIDEO_STATE_COMPONENT_ID;
#define NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONSTRAST NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST
#define VIDEO_COMP_ALGO_CUSTOM_BASE 64
typedef enum _NVAPI_VIDEO_COMPONENT_ALGORITHM {
  VIDEO_COMP_ALGO_COLOR_SPACE_601 = 0,
  VIDEO_COMP_ALGO_COLOR_SPACE_709 = 1,
  VIDEO_COMP_ALGO_COLOR_SPACE_CUSTOM_04 = VIDEO_COMP_ALGO_CUSTOM_BASE + 4,
  VIDEO_COMP_ALGO_COLOR_RANGE_STD = 0,
  VIDEO_COMP_ALGO_COLOR_RANGE_EXT = 1,
  VIDEO_COMP_ALGO_PLAYBACK_PROFILE_NONE = 0,
  VIDEO_COMP_ALGO_PLAYBACK_PROFILE_ADOBE_FLASH_9 = 1,
  VIDEO_COMP_ALGO_DEINTERLACE_NONE = 0,
  VIDEO_COMP_ALGO_DEINTERLACE_BOB = 1,
  VIDEO_COMP_ALGO_DEINTERLACE_WEAVE = 2,
  VIDEO_COMP_ALGO_DEINTERLACE_SIMPLE_ADAPTIVE = 3,
  VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_SIMPLE = 4,
  VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_FULL = 5,
  VIDEO_COMP_ALGO_DEINTERLACE_ADAPTIVE_FOUR_FIELD = 6,
  VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL = 7,
  VIDEO_COMP_ALGO_DEINTERLACE_ADVANCED = 8,
  VIDEO_COMP_ALGO_DEINTERLACE_GPU_CAPABLE = 9,
  VIDEO_COMP_ALGO_DEINTERLACE_MEDIAN = 10,
  VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_LIGHT = 11,
  VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_SD = 12,
  VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL_HD = 13,
  VIDEO_COMP_ALGO_DEINTERLACE_ONE_PASS = 14,
  VIDEO_COMP_ALGO_DEINTERLACE_COMPUTE = 15,
  VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_SCALING_ALG_SIMPLE = 0,
  VIDEO_COMP_ALGO_SCALING_ALG_4x4FILTER = 1,
  VIDEO_COMP_ALGO_SCALING_ALG_8x8FILTER = 2,
  VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_CADENCE_NONE = 0,
  VIDEO_COMP_ALGO_CADENCE_SIMPLE = 1,
  VIDEO_COMP_ALGO_CADENCE_VOF = 2,
  VIDEO_COMP_ALGO_CADENCE_COMPUTE = 3,
  VIDEO_COMP_ALGO_CADENCE_GPU_CAPABLE = 4,
  VIDEO_COMP_ALGO_NOISE_REDUCE_PUREVIDEO = 0,
  VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_EDGE_ENHANCE_PUREVIDEO = 0,
  VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_OVERDRIVE_SIMPLE = 0,
  VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_NORMAL = 0,
  VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_REPEATED = 1,
  VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_ON_MIRROR = 2,
  VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_NONE = 0,
  VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_LOW = 1,
  VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_MEDIUM = 2,
  VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_HIGH = 3,
  VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_NONE = 0,
  VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_LOW = 1,
  VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_MEDIUM = 2,
  VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_HIGH = 3,
  VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_NONE = 0,
  VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_LOW = 1,
  VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_MEDIUM = 2,
  VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_HIGH = 3,
  VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_NONE = 0,
  VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_SQUEEZE = 1,
  VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_RED = 2,
  VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_YELLOW = 3,
  VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_2DTO3D_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_2DTO3D_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_3D_ANALYSIS_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_3D_ANALYSIS_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_FRC_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_FRC_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_BEN_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_BEN_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
} NVAPI_VIDEO_COMPONENT_ALGORITHM;
typedef enum _NVAPI_VIDEO_COMPONENT_ENABLE {
  VIDEO_COMP_ENA_480i = 0x00000001,
  VIDEO_COMP_ENA_480p = 0x00000002,
  VIDEO_COMP_ENA_576i = 0x00000004,
  VIDEO_COMP_ENA_576p = 0x00000008,
  VIDEO_COMP_ENA_720p = 0x00000010,
  VIDEO_COMP_ENA_1080i = 0x00000020,
  VIDEO_COMP_ENA_1080p = 0x00000040,
} NVAPI_VIDEO_COMPONENT_ENABLE;
typedef struct _NVAPI_GET_VIDEO_STATE_COMPONENT {
  NvU32 version;
  NvU32 componentID;
  NvU32 bIsSupported : 1;
  NvU32 bIsOverridenByUser : 1;
  NvU32 reserved1 : 30;
  NvU32 isEnabled;
  NvU32 minValue;
  NvU32 maxValue;
  NvU32 totalSteps;
  NvU32 defaultValue;
  NvU32 unityValue;
  NvU32 currentValueActive;
  NvU64 defaultAlgo;
  NvU64 currentAlgoActive;
  union {
    NvU64 qwReserved[9];
    struct {
      NvU32 dwAppKey;
      NvU32 bTopPriority : 1;
      NvU32 bHasCustomAlgo : 1;
      NvU32 bReserved : 30;
      struct {
        NvU64 pData;
        NvU32 dwSize;
      } customAlgo;
    } appInfo;
  };
} NVAPI_GET_VIDEO_STATE_COMPONENT;
#define NVAPI_GET_VIDEO_STATE_COMPONENT_VER MAKE_NVAPI_VERSION(NVAPI_GET_VIDEO_STATE_COMPONENT, 1)
typedef enum _NVAPI_VIDEO_COMP_RETURN_STATUS {
  VIDEO_COMP_STATUS_SUCCESS = 0x00000000,
  VIDEO_COMP_STATUS_UNSUCCESSFUL = 0x00000001,
  VIDEO_COMP_STATUS_COMPONENT_NOT_SUPPORTED = 0x00000002,
  VIDEO_COMP_STATUS_VALUE_OUT_OF_RANGE = 0x00000004,
  VIDEO_COMP_STATUS_ALGO_NOT_RECOGNIZED = 0x00000008,
  VIDEO_COMP_STATUS_OVERRIDDEN_BY_USER = 0x00000010,
  VIDEO_COMP_STATUS_Y_GAMMA_ENABLED = 0x00000020,
  VIDEO_COMP_STATUS_RGB_GAMMA_ENABLED = 0x00000040,
} NVAPI_VIDEO_COMP_RETURN_STATUS;
#define NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE 128
typedef struct _NVAPI_SET_VIDEO_STATE_COMPONENT {
  NvU32 version;
  NvU32 componentID;
  NvU32 enable;
  NvU32 setToValue;
  NvU64 setToAlgo;
  NvU32 retStatus;
  NvU32 reserved;
  union {
    NvU64 qwReserved[4];
    struct {
      NvU32 dwAppKey;
      NvU32 bTopPriority : 1;
      NvU32 bHasCustomAlgo : 1;
      NvU32 bReserved : 30;
      struct {
        NvU64 pData;
        NvU32 dwSize;
      } customAlgo;
    } appInfo;
  };
} NVAPI_SET_VIDEO_STATE_COMPONENT;
#define NVAPI_SET_VIDEO_STATE_COMPONENT_VER MAKE_NVAPI_VERSION(NVAPI_SET_VIDEO_STATE_COMPONENT, 1)
#endif
NVAPI_INTERFACE NvAPI_D3D9_GetVideoState(IDirect3DDevice9 *pDev, NVAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_SetVideoState(IDirect3DDevice9 *pDev, NVAPI_SET_VIDEO_STATE_COMPONENT *pSetVidStateComp);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
#define NVAPI_MAX_FEATURES_PER_PACKET 3
typedef enum _NVAPI_VIDEO_FEATURE {
  NVAPI_VF_UNKNOWN = 0,
  NVAPI_VF_MPEG2SDDecodeAcceleration,
  NVAPI_VF_MPEG2HDDecodeAcceleration,
  NVAPI_VF_VC1SDDecodeAcceleration,
  NVAPI_VF_VC1HDDecodeAcceleration,
  NVAPI_VF_H264SDDecodeAcceleration,
  NVAPI_VF_H264HDDecodeAcceleration,
  NVAPI_VF_WMV9SDDecodeAcceleration,
  NVAPI_VF_WMV9HDDecodeAcceleration,
  NVAPI_VF_ProcAmp,
  NVAPI_VF_ColorTemperatureCorrection,
  NVAPI_VF_ColorSpaceConversion,
  NVAPI_VF_GammaCorrection,
  NVAPI_VF_OverDrive,
  NVAPI_VF_DynamicContrastEnhancement,
  NVAPI_VF_StretchBlueGreenSkin,
  NVAPI_VF_AdaptiveDeInterlacing,
  NVAPI_VF_NoiseReduction,
  NVAPI_VF_EdgeEnhancement,
  NVAPI_VF_InverseTelecine,
  NVAPI_VF_Scaling,
  NVAPI_VF_VideoMirror,
  NVAPI_VF_Blend,
  NVAPI_VF_DxvaHDTest,
  NVAPI_VF_GamutRemap,
  NVAPI_VF_MftXcode,
  NVAPI_VF_SkinToneCorrection,
  NVAPI_VF_MftYUY2Xcode,
  NVAPI_VF_MftDivxXcode,
  NVAPI_VF_MftWmv9Encode,
  NVAPI_VF_DynamicPState,
  NVAPI_VF_PostProcessVIC,
  NVAPI_VF_MVCHDDecodeAcceleration,
  NVAPI_VF_SVCHDDecodeAcceleration,
  NVAPI_VF_SimpleScaling,
  NVAPI_VF_VP8HDDecodeAcceleration,
  NVAPI_VF_VP9HDDecodeAcceleration,
  NVAPI_VF_ID_LAST,
} NVAPI_VIDEO_FEATURE;
typedef enum _NVAPI_VIDEO_ENGINES {
  NVAPI_VE_UNKNOWN = 0,
  NVAPI_VE_PixelShader,
  NVAPI_VE_MPEG2Decoder,
  NVAPI_VE_VideoProcessor1,
  NVAPI_VE_VideoProcessor2,
  NVAPI_VE_MSDEC,
  NVAPI_VE_VIC,
} NVAPI_VIDEO_ENGINES;
typedef enum _NVAPI_VIDEO_DRIVER_ENTRY_POINT {
  NVAPI_EP_UNKNOWN = 0,
  NVAPI_EP_DecodeEndFrame,
  NVAPI_EP_OverlayTransfer,
  NVAPI_EP_DIBlitEx,
  NVAPI_EP_VideoProcessBlt,
  NVAPI_EP_D3DBlt,
  NVAPI_EP_Blit32,
  NVAPI_EP_VPBltHD,
} NVAPI_VIDEO_DRIVER_ENTRY_POINT;
typedef enum _NVAPI_VIDEO_FEATURE_GET_FLAG {
  NVAPI_VF_GET_COUNT = 0,
  NVAPI_VF_GET_DETAILS,
} NVAPI_VIDEO_FEATURE_GET_FLAG;
typedef struct _NVAPI_VIDEO_FEATURE_DETAILS {
  NVAPI_VIDEO_FEATURE eFeature;
  NVAPI_VIDEO_ENGINES eEngine;
  NVAPI_VIDEO_DRIVER_ENTRY_POINT eEntryPoint;
  NvU32 dwReserved;
} NVAPI_VIDEO_FEATURE_DETAILS;
typedef struct _NVAPI_VID_FEATURE_STRINGS {
  NVAPI_VIDEO_FEATURE eFeature;
  NvAPI_ShortString szFeature;
  NvAPI_ShortString szEngine;
  NvAPI_ShortString szDrvEntryPoint;
  NvAPI_ShortString szReserved1;
} NVAPI_VID_FEATURE_STRINGS;
#define NVAPI_VIDEO_FEATURE_DESCRIPTOR_VER 1
typedef struct _NVAPI_VIDEO_FEATURE_DESCRIPTOR {
  NvU32 version;
  NVAPI_VIDEO_FEATURE_GET_FLAG eVideoFeatureGetID;
  NvU32 dwVFCount;
  NvU32 dwStartVFCount;
  NVAPI_VIDEO_FEATURE_DETAILS astFeatureDetails[NVAPI_MAX_FEATURES_PER_PACKET];
  NvU32 adwReserved[4];
} NVAPI_VIDEO_FEATURE_DESCRIPTOR;
typedef struct _NVAPI_DX_VIDEO_FEATURE_DETAILS {
  NvU32 version;
  NVAPI_VIDEO_FEATURE_DESCRIPTOR videoFeaturesPacket;
  NVAPI_VID_FEATURE_STRINGS astFeatureDescNames[NVAPI_MAX_FEATURES_PER_PACKET];
} NVAPI_DX_VIDEO_FEATURE_DETAILS;
#define NVAPI_DX_VIDEO_FEATURE_DETAILS_VER MAKE_NVAPI_VERSION(NVAPI_DX_VIDEO_FEATURE_DETAILS, 1)
NVAPI_INTERFACE NvAPI_D3D9_EnumVideoFeatures(IDirect3DDevice9 *pDev,
                                             NVAPI_DX_VIDEO_FEATURE_DETAILS *pVideoFeatureDetails);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum _NV_SLI_MODE {
  NV_SLI_RENDERING_MODE_AUTOSELECT = 0,
  NV_SLI_RENDERING_MODE_AFR = 1,
  NV_SLI_RENDERING_MODE_SFR = 2,
  NV_SLI_RENDERING_MODE_SINGLE = 3,
  NV_SLI_RENDERING_MODE_AFR_OF_SFR = 4
} NV_SLI_MODE;
typedef struct {
  NvU32 version;
  NV_SLI_MODE mode;
  NvU32 gpus;
} NV_SLI_INFO;
#define NV_SLI_INFO_VER MAKE_NVAPI_VERSION(NV_SLI_INFO, 1)
NVAPI_INTERFACE NvAPI_D3D9_GetSLIInfo(IDirect3DDevice9 *pDev, NV_SLI_INFO *pSliInfo);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_SetSLIMode(IDirect3DDevice9 *pDev, NV_SLI_MODE SliMode);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
enum { NVAPI_AAMODE_VCAA = 0x00000001, NVAPI_AAMODE_SLIAA = 0x00000002, NVAPI_AAMODE_VCAA_HIGHQUALITY = 0x00000004 };
NVAPI_INTERFACE NvAPI_D3D9_QueryAAOverrideMode(IDirect3DDevice9 *pDev, NvU32 *pRenderingSampleCount,
                                               NvU32 *pBufferSampleCount, NvU32 *pAAMode);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum {
  NVAPI_VIDSURF_ENCRYPT_CMD_NULL = 0x00,
  NVAPI_VIDSURF_ENCRYPT_CMD_GET_GUID_COUNT = 0x01,
  NVAPI_VIDSURF_ENCRYPT_CMD_GET_GUIDS = 0x02,
  NVAPI_VIDSURF_ENCRYPT_CMD_SET_GUID = 0x03,
  NVAPI_VIDSURF_ENCRYPT_CMD_ENABLE = 0x04,
  NVAPI_VIDSURF_ENCRYPT_CMD_SET_KEY = 0x05,
  NVAPI_VIDSURF_ENCRYPT_CMD_SET_IV = 0x06
} NVAPI_VIDSURF_ENCRYPT_COMMANDS;
#define NVAPI_VIDSURF_ENCRYPT_MAX_GUIDS (4)
typedef struct {
  NvU32 dwGuidCount;
} NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUID_COUNT;
typedef struct {
  GUID guids[NVAPI_VIDSURF_ENCRYPT_MAX_GUIDS];
} NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS;
typedef struct {
  GUID guid;
} NVAPI_VIDSURF_ENCRYPT_CTRL_SET_GUID;
typedef struct {
  IDirect3DSurface9 *pSurface;
  NvU32 bEnable;
} NVAPI_VIDSURF_ENCRYPT_CTRL_ENABLE;
typedef struct {
  NvU32 dwEncryptKeyProtectionMode;
  NvU32 dwEncryptKeyProtectionIdentifier;
  NvU32 dwKey[4];
} NVAPI_VIDSURF_ENCRYPT_CTRL_SET_KEY;
typedef struct {
  NvU32 dwEncryptKeyProtectionMode;
  NvU32 dwEncryptKeyProtectionIdentifier;
  NvU32 dwIV[4];
} NVAPI_VIDSURF_ENCRYPT_CTRL_SET_IV;
typedef struct {
  NvU32 version;
  NvU32 dwCommand;
  union {
    NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUID_COUNT GetGuidCount;
    NVAPI_VIDSURF_ENCRYPT_CTRL_GET_GUIDS GetGuids;
    NVAPI_VIDSURF_ENCRYPT_CTRL_SET_GUID SetGuid;
    NVAPI_VIDSURF_ENCRYPT_CTRL_ENABLE Enable;
    NVAPI_VIDSURF_ENCRYPT_CTRL_SET_KEY SetKey;
    NVAPI_VIDSURF_ENCRYPT_CTRL_SET_IV SetIV;
  };
} NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS;
#define NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS_VER MAKE_NVAPI_VERSION(NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS, 1)
NVAPI_INTERFACE NvAPI_D3D9_VideoSurfaceEncryptionControl(IDirect3DDevice9 *pDev,
                                                         NVAPI_VIDSURF_ENCRYPT_CTRL_PARAMS *pVidSurfEncrCtrlParams);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum _NVAPI_D3D9_DMA_COMMANDS {
  NVAPI_D3D9_DMA_CMD_NULL = 0x00,
  NVAPI_D3D9_DMA_CMD_DESCRIBE = 0x01,
  NVAPI_D3D9_DMA_CMD_MAP = 0x02,
  NVAPI_D3D9_DMA_CMD_UNMAP = 0x03,
  NVAPI_D3D9_DMA_CMD_REG_EVENT = 0x04,
  NVAPI_D3D9_DMA_CMD_UNREG_EVENT = 0x05,
  NVAPI_D3D9_DMA_CMD_TRANSFER = 0x06,
  NVAPI_D3D9_DMA_CMD_COLOR_MATRIX = 0x07,
} NVAPI_D3D9_DMA_COMMANDS;
typedef enum _NVAPI_D3D9_DMA_TRANSFER_DIR {
  NVAPI_D3D9_DMA_TRANSFER_DIR_UPLOAD = 0x00,
  NVAPI_D3D9_DMA_TRANSFER_DIR_DOWNLOAD = 0x01,
} NVAPI_D3D9_DMA_TRANSFER_DIR;
typedef enum _NVAPI_D3D9_DMA_TRANSFER_TYPE {
  NVAPI_D3D9_DMA_TRANSFER_TYPE_PROGRESSIVE = 0x00,
  NVAPI_D3D9_DMA_TRANSFER_TYPE_INTERLACED = 0x01,
  NVAPI_D3D9_DMA_TRANSFER_TYPE_BOB_TOP_FIELD = 0x02,
  NVAPI_D3D9_DMA_TRANSFER_TYPE_BOB_BTM_FIELD = 0x03,
} NVAPI_D3D9_DMA_TRANSFER_TYPE;
#define NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_MASK                                                                     \
  (NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_601 | NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_709 |                             \
   NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_240 | NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_CUSTOM)
#define NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_MASK                                                                   \
  (NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_FULL | NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_LIM)
typedef enum _NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS {
  NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_601 = 0x01,
  NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_709 = 0x02,
  NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_240 = 0x04,
  NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_STD_CUSTOM = 0x08,
  NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_FULL = 0x10,
  NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS_RANGE_LIM = 0x20,
} NVAPI_D3D9_DMA_COLOR_MATRIX_FLAGS;
typedef struct _NVAPI_D3D9_DMA_DESCRIBE_PARAMS {
  NvU32 dwWidth;
  NvU32 dwHeight;
  NvU32 dwFormat;
  NvU32 dwPitch;
  NvU32 dwSize;
  NvU32 dwAlignment;
} NVAPI_D3D9_DMA_DESCRIBE_PARAMS;
typedef struct _NVAPI_D3D9_DMA_MAP_PARAMS {
  NvU32 dwWidth;
  NvU32 dwHeight;
  NvU32 dwFormat;
  void *pMemory;
  NVDX_ObjectHandle hSysmemSurface;
} NVAPI_D3D9_DMA_MAP_PARAMS;
typedef struct _NVAPI_D3D9_DMA_UNMAP_PARAMS {
  NVDX_ObjectHandle hSysmemSurface;
} NVAPI_D3D9_DMA_UNMAP_PARAMS;
typedef struct _NVAPI_D3D9_DMA_EVENT_PARAMS {
  HANDLE hCompletionEvent;
} NVAPI_D3D9_DMA_EVENT_PARAMS;
typedef struct _NVAPI_D3D9_DMA_TRANSFER_PARAMS {
  NVAPI_D3D9_DMA_TRANSFER_DIR direction;
  NVDX_ObjectHandle hSysmemSurface;
  RECT *pSysmemSurfaceRect;
  NVDX_ObjectHandle hD3D9Surface;
  RECT *pD3D9SurfaceRect;
  HANDLE hCompletionEvent;
  NVAPI_D3D9_DMA_TRANSFER_TYPE transferType;
  NvU32 floatSrcRectFlag : 1;
  NvU32 smoothingLevel : 2;
  NvU32 reserved : 17;
  NvU32 reservedFlagValid : 12;
} NVAPI_D3D9_DMA_TRANSFER_PARAMS;
#define NVAPI_D3D9_DMA_COLOR_MATRIX_SIZE 12
typedef struct _NVAPI_D3D9_DMA_COLOR_MATRIX_PARAMS {
  NvU32 colorMatrixFlags;
  float *colorMatrix;
} NVAPI_D3D9_DMA_COLOR_MATRIX_PARAMS;
typedef struct _NVAPI_D3D9_DMA_PARAMS {
  NvU32 version;
  NvU32 dwCommand;
  union {
    NVAPI_D3D9_DMA_DESCRIBE_PARAMS DescribeParams;
    NVAPI_D3D9_DMA_MAP_PARAMS MapParams;
    NVAPI_D3D9_DMA_UNMAP_PARAMS UnmapParams;
    NVAPI_D3D9_DMA_EVENT_PARAMS EventParams;
    NVAPI_D3D9_DMA_TRANSFER_PARAMS TransferParams;
    NVAPI_D3D9_DMA_COLOR_MATRIX_PARAMS ColorMatrixParams;
  };
} NVAPI_D3D9_DMA_PARAMS;
#define NVAPI_D3D9_DMA_PARAMS_VER MAKE_NVAPI_VERSION(NVAPI_D3D9_DMA_PARAMS, 1)
NVAPI_INTERFACE NvAPI_D3D9_DMA(IDirect3DDevice9 *pDev, NVAPI_D3D9_DMA_PARAMS *pVideoDMAParams);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum _NVAPI_D3D9_ENABLE_STEREO_COMMANDS {
  NVAPI_D3D9_ENABLE_STEREO_CMD_CHALLENGE = 0x01,
  NVAPI_D3D9_ENABLE_STEREO_CMD_RESPONSE = 0x02,
} NVAPI_D3D9_ENABLE_STEREO_COMMANDS;
#define NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_SIZE 16
#define NVAPI_D3D9_ENABLE_STEREO_RESPONSE_SIZE 20
typedef struct _NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_PARAMS {
  NvU8 challenge[NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_SIZE];
} NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_PARAMS;
typedef struct _NVAPI_D3D9_ENABLE_STEREO_RESPONSE_PARAMS {
  NvGUID vendorGUID;
  NvU8 response[NVAPI_D3D9_ENABLE_STEREO_RESPONSE_SIZE];
} NVAPI_D3D9_ENABLE_STEREO_RESPONSE_PARAMS;
typedef struct _NVAPI_D3D9_ENABLE_STEREO_PARAMS {
  NvU32 version;
  NvU32 dwCommand;
  union {
    NVAPI_D3D9_ENABLE_STEREO_CHALLENGE_PARAMS ChallengeParams;
    NVAPI_D3D9_ENABLE_STEREO_RESPONSE_PARAMS ResponseParams;
  };
} NVAPI_D3D9_ENABLE_STEREO_PARAMS_V1;
typedef NVAPI_D3D9_ENABLE_STEREO_PARAMS_V1 NVAPI_D3D9_ENABLE_STEREO_PARAMS;
#define NVAPI_D3D9_ENABLE_STEREO_PARAMS_VER1 MAKE_NVAPI_VERSION(NVAPI_D3D9_ENABLE_STEREO_PARAMS_V1, 1)
#define NVAPI_D3D9_ENABLE_STEREO_PARAMS_VER NVAPI_D3D9_ENABLE_STEREO_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D9_EnableStereo(IDirect3DDevice9 *pDev, NVAPI_D3D9_ENABLE_STEREO_PARAMS *pEnableStereoParams);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_StretchRect(IDirect3DDevice9 *pDev, NVDX_ObjectHandle hSrcObj, CONST RECT *pSourceRect,
                                       NVDX_ObjectHandle hDstObj, CONST RECT *pDestRect, D3DTEXTUREFILTERTYPE Filter);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_CreateRenderTarget(IDirect3DDevice9 *pDev, UINT Width, UINT Height, D3DFORMAT Format,
                                              D3DMULTISAMPLE_TYPE MultiSample, DWORD MultisampleQuality, BOOL Lockable,
                                              IDirect3DSurface9 **ppSurface, NVDX_ObjectHandle *pHandle = NULL);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  NvU32 version;
  NvU32 dwFunction;
  NvU32 dwSize;
  NvU32 hAllocHandle;
  NvU64 qwPhysVidOffset;
  void *pCPUPtr;
  void *pMemAllocPtr;
  NvU32 ulPageSize;
} NV_BDVMA_INFO;
NVAPI_INTERFACE NvAPI_D3D9_BDVMA(IDirect3DDevice9 *pDev, NV_BDVMA_INFO *pBDVMAInfo);
#endif
#if defined(__cplusplus)
typedef enum {
  NVFBC_FORMAT_ARGB = 0,
  NVFBC_FORMAT_RGB = 1,
  NVFBC_FORMAT_YUV_420 = 2,
  NVFBC_FORMAT_RGB_PLANAR = 3,
  NVFBC_FORMAT_RGB_XOR = 4,
  NVFBC_FORMAT_YUV_444 = 5,
  NVFBC_FORMAT_NV12 = 6,
  NVFBC_FORMAT_ARGB10 = 7,
  NVFBC_FORMAT_NOT_SUPPORTED = 8
} NVFBC_BUFFER_FORMAT;
typedef enum { NVFBC_CAPS_YUV444_NATIVE_SUPPORT = 0 } NVFBC_CAPS_TYPE;
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  NvU32 version;
  NvU32 dwSize;
} NV_NVFBC_INFO;
typedef struct _NV_NVFBC_INFO4 : public NV_NVFBC_INFO {
  NvU32 dwFlags;
} NV_NVFBC_INFO4;
typedef struct _NV_NVFBC_INFO5 : public NV_NVFBC_INFO4 {
  NvU32 dwAllocSize;
} NV_NVFBC_INFO5;
typedef struct _NV_NVFBC_INFO6 : public NV_NVFBC_INFO5 {
  NvU32 dwProcessId;
} NV_NVFBC_INFO6;
typedef enum _NVAPI_NV_NVFBC_CREATEFLAGS {
  NVAPI_NVFBC_FLAG_CREATESTEREO = 0x00000001,
  NVAPI_NVFBC_FLAG_ARGB_Z_HINTSDATA = 0x00000002,
  NVAPI_NVFBC_FLAG_ALIAS_ONLY = 0x00000004,
  NVAPI_NVFBC_FLAG_PID_MODE = 0x00000008,
  NVAPI_NVFBC_FLAG_RESERVED = 0x00000010,
  NVAPI_NVFBC_FLAG_GRAB_SCANOUT = 0x00000020,
} NVAPI_NV_NVFBC_CREATEFLAGS;
#define NVAPI_NV_NVFBC_INFO_VER5 MAKE_NVAPI_VERSION(NV_NVFBC_INFO5, 0x22)
#define NVAPI_NV_NVFBC_INFO_VER6 MAKE_NVAPI_VERSION(NV_NVFBC_INFO6, 0x50)
#define NVAPI_NV_NVFBC_INFO_VER NVAPI_NV_NVFBC_INFO_VER6
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CreateCaptureBuffer(IDirect3DDevice9 *pDev, NV_NVFBC_INFO *pNVFBCInfo);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_DestroyCaptureBuffer(IDirect3DDevice9 *pDev);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  NvU32 size;
  NvU32 numSurfaces;
  NvU32 surfaceSize;
  NvU64 oscSurfaceAddress;
  NvU64 oscControlAddress;
} NV_D3D9_OSC_SURFACEINFO, *PNV_D3D9_OSC_SURFACEINFO;
NVAPI_INTERFACE NvAPI_D3D9_GetOSCSurfaceInfo(IDirect3DDevice9 *pDev, NV_D3D9_OSC_SURFACEINFO *pOSCSurfaceInfo);
#endif
typedef struct {
  NvU32 size;
  NvU32 oscSurfaceAddress;
} NV_D3D9_OSC_RELEASESURFACE_INFO, *PNV_D3D9_OSC_RELEASESURFACE_INFO;
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_ReleaseOSCSurface(IDirect3DDevice9 *pDev,
                                             NV_D3D9_OSC_RELEASESURFACE_INFO *pOSCReleaseSurfaceInfo);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToCUDA(IDirect3DDevice9 *pDev, void *pNvFBCFrameGrabInfo,
                                                     IDirect3DVertexBuffer9 *pVertexBuffer, DWORD dwFlags);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToCUDAWithFormat(IDirect3DDevice9 *pDev, void *pNvFBCFrameGrabInfo,
                                                               IDirect3DVertexBuffer9 *pVertexBuffer, DWORD dwFlags,
                                                               NVFBC_BUFFER_FORMAT eFormat);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToNV12BLVideoSurface(IDirect3DDevice9 *pDev, void *pDataGrabInfo,
                                                                   DWORD dwBufferIndex, DWORD dwFlags = 0,
                                                                   DWORD dwGrabMode = 0, DWORD dwTargetWidth = 0,
                                                                   DWORD dwTargetHeight = 0, DWORD dwStartX = 0,
                                                                   DWORD dwStartY = 0);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetUpToNV12BLVideoSurface(IDirect3DDevice9 *pDev, BOOL bWithHWCursor, DWORD dwNBuffers,
                                                           HANDLE *ppBuffer, DWORD dwWidth, DWORD dwHeight);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct _NVAPI_D3D9_NVFBC_SETUP_Nv12BL_PARAMS_V1 {
  NvU32 version;
  NvU32 numBuffers;
  NvU32 width;
  NvU32 height;
  HANDLE *buffers;
  NvU32 withHWCursor : 1;
  NvU32 useYUV444 : 1;
  NvU32 reservedBits : 6;
} NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_V1;
typedef NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_V1 NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS;
#define NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_VER1 MAKE_NVAPI_VERSION(NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_V1, 1)
#define NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_VER NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetUpToNV12BLVideoSurfaceEx(__in IDirect3DDevice9 *pDev,
                                                             __inout NVAPI_D3D9_NVFBC_SETUP_NV12BL_PARAMS *pParams);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetHWCursorCapture(IDirect3DDevice9 *pDev, BOOL bWithHWCursor);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetUpToSys(IDirect3DDevice9 *pDev, BOOL bWithHWCursor, NVFBC_BUFFER_FORMAT eFormat,
                                            DWORD dwNBuffers, unsigned char **ppBuffer, unsigned char **ppDiffMap);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  NvU32 version;
  NvU32 withHWCursor : 1;
  NvU32 bHDRRequest : 1;
  NvU32 reservedBits : 30;
  NVFBC_BUFFER_FORMAT format;
  NvU32 numBuffers;
  void **ppBuffers;
  void **ppDiffMap;
  NvU32 dwReserved[32];
  void *pReserved[16];
} NVFBC_SETUP_TOSYS_PARAM;
#define NVFBC_SETUP_TOSYS_PARAM_VER MAKE_NVAPI_VERSION(NVFBC_SETUP_TOSYS_PARAM, 1)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_ToSys_SetUpEx(__in IDirect3DDevice9 *pDev, __inout NVFBC_SETUP_TOSYS_PARAM *pParam);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  NvU32 version;
  NVFBC_BUFFER_FORMAT format;
  HANDLE *handles;
  NvU32 numBuffers;
  NvU32 width;
  NvU32 height;
  NvU32 withHWCursor : 1;
  NvU32 reservedBits : 31;
} NVFBC_SETUP_DX9_VID_PARAM_V1;
#define NVFBC_SETUP_DX9_VID_PARAM_VER_1 MAKE_NVAPI_VERSION(NVFBC_SETUP_DX9_VID_PARAM_V1, 1)
typedef struct {
  NvU32 version;
  NVFBC_BUFFER_FORMAT format;
  HANDLE *handles;
  NvU32 numBuffers;
  NvU32 width;
  NvU32 height;
  NvU32 withHWCursor : 1;
  NvU32 HDRRequest : 1;
  NvU32 reservedBits : 30;
  NvU32 dwDiffMapBuffSize;
  void **ppDiffMap;
  NvU32 dwReserved[32];
  void *pReserved[16];
} NVFBC_SETUP_DX9_VID_PARAM_V2;
#define NVFBC_SETUP_DX9_VID_PARAM_VER_2 MAKE_NVAPI_VERSION(NVFBC_SETUP_DX9_VID_PARAM_V2, 2)
#define NVFBC_SETUP_DX9_VID_PARAM_VER NVFBC_SETUP_DX9_VID_PARAM_VER_2
typedef NVFBC_SETUP_DX9_VID_PARAM_V2 NVFBC_SETUP_DX9_VID_PARAM;
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetUpToDX9Vid(__in IDirect3DDevice9 *pDev, __inout NVFBC_SETUP_DX9_VID_PARAM *pParam);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToSys(IDirect3DDevice9 *pDev, void *pNvFBCFrameGrabInfo,
                                                    DWORD dwFlags = 0, DWORD dwGrabMode = 0, DWORD dwTargetWidth = 0,
                                                    DWORD dwTargetHeight = 0, DWORD dwStartX = 0, DWORD dwStartY = 0);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  NvU32 version;
  NvU32 bufferIndex;
  NvU32 flags;
  NvU32 grabMode;
  NvU32 targetWidth;
  NvU32 targetHeight;
  NvU32 startX;
  NvU32 startY;
  void *nvFBCFrameGrabInfoPtr;
} NVFBC_CAPTURE_DX9_VID_PARAM_V1;
#define NVFBC_CAPTURE_DX9_VID_PARAM_VER_1 MAKE_NVAPI_VERSION(NVFBC_CAPTURE_DX9_VID_PARAM_V1, 1)
typedef struct {
  NvU32 version;
  NvU32 bufferIndex;
  NvU32 flags;
  NvU32 grabMode;
  NvU32 targetWidth;
  NvU32 targetHeight;
  NvU32 startX;
  NvU32 startY;
  NvU32 dwWaitTime;
  void *nvFBCFrameGrabInfoPtr;
} NVFBC_CAPTURE_DX9_VID_PARAM_V2;
#define NVFBC_CAPTURE_DX9_VID_PARAM_VER_2 MAKE_NVAPI_VERSION(NVFBC_CAPTURE_DX9_VID_PARAM_V2, 2)
typedef struct {
  NvU32 version;
  NvU32 bufferIndex;
  NvU32 flags;
  NvU32 grabMode;
  NvU32 targetWidth;
  NvU32 targetHeight;
  NvU32 startX;
  NvU32 startY;
  NvU32 dwWaitTime;
  NvU32 dwMinInterframeInterval;
  void *nvFBCFrameGrabInfoPtr;
} NVFBC_CAPTURE_DX9_VID_PARAM_V3;
#define NVFBC_CAPTURE_DX9_VID_PARAM_VER_3 MAKE_NVAPI_VERSION(NVFBC_CAPTURE_DX9_VID_PARAM_V3, 3)
#define NVFBC_CAPTURE_DX9_VID_PARAM_VER NVFBC_CAPTURE_DX9_VID_PARAM_VER_3
typedef NVFBC_CAPTURE_DX9_VID_PARAM_V3 NVFBC_CAPTURE_DX9_VID_PARAM;
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToDX9Vid(__in IDirect3DDevice9 *pDev,
                                                       __inout NVFBC_CAPTURE_DX9_VID_PARAM *pParam);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_GetStatus(void *pNvFBCStatus);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  NvU32 version;
  NvU32 isCapturePossible : 1;
  NvU32 isCurrentlyCapturing : 1;
  NvU32 isPIDCaptureModeSupported : 1;
  NvU32 canCreatePIDSession : 1;
  NvU32 isConcurrentCaptureSupported : 1;
  NvU32 reservedFlags : 27;
  NvU32 nvfbcDriverVersion;
  NvU32 vidPnSrcId;
  NvDisplayHandle displayHandle;
} NVFBC_NVAPI_GET_STATUS_EX_PARAM;
typedef struct _NVFBC_NVAPI_GET_STATUS_EX_PARAM2 : public NVFBC_NVAPI_GET_STATUS_EX_PARAM {
  NvU32 dwCurrentCapturePID;
  NvU32 eCurrentCaptureMode;
} NVFBC_NVAPI_GET_STATUS_EX_PARAM2;
typedef struct _NVFBC_NVAPI_GET_STATUS_EX_PARAM3 : public NVFBC_NVAPI_GET_STATUS_EX_PARAM2 {
  NvU32 dwTargetCapturePID;
} NVFBC_NVAPI_GET_STATUS_EX_PARAM3;
#define NVFBC_NVAPI_GET_STATUS_EX_PARAM_VER1 MAKE_NVAPI_VERSION(NVFBC_NVAPI_GET_STATUS_EX_PARAM, 1)
#define NVFBC_NVAPI_GET_STATUS_EX_PARAM_VER2 MAKE_NVAPI_VERSION(NVFBC_NVAPI_GET_STATUS_EX_PARAM2, 2)
#define NVFBC_NVAPI_GET_STATUS_EX_PARAM_VER3 MAKE_NVAPI_VERSION(NVFBC_NVAPI_GET_STATUS_EX_PARAM3, 3)
#define NVFBC_NVAPI_GET_STATUS_EX_PARAM_VER NVFBC_NVAPI_GET_STATUS_EX_PARAM_VER3
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_GetStatusEx(__inout NVFBC_NVAPI_GET_STATUS_EX_PARAM *nvFBCStatusParam);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D9_IFR_SetUpTargetBufferToSys(IDirect3DDevice9 *pDev, NVFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers,
                                          unsigned char **ppBuffer);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_GPUBasedCPUSleep(IDirect3DDevice9 *pDev, NvU64 qwMicroSeconds);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef void *PNVFBCPARAMS;
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_NextGen_Entry(__in IDirect3DDevice9 *dev, __in_opt void *nvfbc, __in NvU32 api,
                                               __in_opt PNVFBCPARAMS inparams, __out_opt PNVFBCPARAMS outparams);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D9_IFR_TransferRenderTarget(IDirect3DDevice9 *pDev, HANDLE *pEvent, DWORD dwBufferIndex,
                                        DWORD dwTargetWidth, DWORD dwTargetHeight);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D9_IFR_SetUpTargetBufferToNV12BLVideoSurface(IDirect3DDevice9 *pDev, DWORD dwNBuffers, HANDLE *aHandles,
                                                         DWORD dwTargetWidth, DWORD dwTargetHeight);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D9_IFR_TransferRenderTargetToNV12BLVideoSurface(IDirect3DDevice9 *pDev, DWORD dwBufferIndex,
                                                            DWORD dwTargetWidth, DWORD dwTargetHeight);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef void *IFRSharedSurfaceHandle;
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D9_IFR_CreateSharedSurface(IDirect3DDevice9 *pDev, DWORD dwWidth, DWORD dwHeight,
                                       IFRSharedSurfaceHandle *phNvIFRSharedSurface);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D9_IFR_DestroySharedSurface(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hNvIFRSharedSurface);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D9_IFR_CopyToSharedSurface(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hNvIFRSharedSurface,
                                       IDirect3DSurface9 *pSurface);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D9_IFR_CopyFromSharedSurface(IDirect3DDevice9 *pDev, IFRSharedSurfaceHandle hNvIFRSharedSurface,
                                         IDirect3DSurface9 *pSurface);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef struct _NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1 {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NvU32 pitch;
  NvU32 linearSize;
  NvU32 driverAllocationSize;
  NvU64 framebufOffset;
  NvU64 masterMemAllocPtr;
  NvU32 pageSize;
} NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1;
typedef NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1 NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS;
#define NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER1                                                               \
  MAKE_NVAPI_VERSION(NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_V1, 1)
#define NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_IFR_CreateCrossProcessSharedSurface(
    __in IUnknown *pDev, __inout NVIFR_CROSSPROC_SHAREDSURFACE_CREATE_PARAMS *pParams);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef struct _NVIFR_CROSSPROC_COPY_PARAMS {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NvU32 pitch;
  NvU64 sharedAlloc;
  NvU64 surface;
  NvU64 hCursor;
  NvU32 bComposeCursor;
  NvS32 cursorPosX;
  NvS32 cursorPosY;
} NVIFR_CROSSPROC_COPY_PARAMS_V1;
typedef NVIFR_CROSSPROC_COPY_PARAMS_V1 NVIFR_CROSSPROC_COPY_PARAMS;
#define NVIFR_CROSSPROC_COPY_PARAMS_VER1 MAKE_NVAPI_VERSION(NVIFR_CROSSPROC_COPY_PARAMS_V1, 1)
#define NVIFR_CROSSPROC_COPY_PARAMS_VER NVIFR_CROSSPROC_COPY_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_IFR_CopyFromCrossProcessSharedSurface(__in IUnknown *pDevice,
                                                                __in NVIFR_CROSSPROC_COPY_PARAMS *pParams);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef struct _NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1 {
  NvU32 version;
  NvU32 linearSize;
  NvU32 width;
  NvU32 height;
  NvU64 framebufOffset;
  NvU64 clientMasterMirrorMemAllocPtr;
  NvU64 clientMemAllocPtr;
  NvU32 pageSize;
} NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1;
typedef NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1 NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS;
#define NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER1                                                           \
  MAKE_NVAPI_VERSION(NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_V1, 1)
#define NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_IFR_ConnectToCrossProcessSharedSurface(
    __in IUnknown *pDevice, __inout NVIFR_CONNECT_TO_CROSSPROC_SHAREDSURFACE_PARAMS *pParams);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_IFR_CopyToCrossProcessSharedSurface(__in IUnknown *pDevice,
                                                              __in NVIFR_CROSSPROC_COPY_PARAMS *pParams);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_IFR_DisconnectCrossProcessSharedSurface(__in IUnknown *pDevice, __in void *pSharedAlloc);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_IFR_DestroyCrossProcessSharedSurface(__in IUnknown *pDevice, __in void *pSharedAlloc);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  DWORD dwVersion;
  DWORD dwType;
  DWORD bSupported : 1;
  DWORD bNvEncLogoNeeded : 1;
  DWORD bNonQualifiedHW : 1;
  DWORD bCustomerApp : 1;
  DWORD bSessionLimitExceeded : 1;
  DWORD bEnableGrabTimeStampReporting : 1;
  DWORD bVRActive : 1;
  DWORD bNVIFREndOfLife : 1;
  DWORD bReservedBits : 24;
  DWORD dwPrivateDataSize;
  void *pPrivateData;
  DWORD dwReserved[60];
  void *pReserved[31];
} NvFBCCheckSupportParams;
NVAPI_INTERFACE NvAPI_D3D9_FBC_CheckSupport(IDirect3DDevice9 *pDev, void *pParam);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  NvU32 version;
  NvU64 forceGrabFullFrame : 1;
  NvU64 ReservedBits : 63;
  NvU64 Reserved[5];
} NVFBC_FORCE_GRAB_FULL_FRAME;
#define NVFBC_FORCE_GRAB_FULL_FRAME_VER MAKE_NVAPI_VERSION(NVFBC_FORCE_GRAB_FULL_FRAME, 1)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_FORCE_GRAB_FULL_FRAME(__inout NVFBC_FORCE_GRAB_FULL_FRAME *pParam);
#endif
typedef enum {
  DECREMENT_COUNT = -1,
  FETCH_COUNT = 0,
  INCREMENT_COUNT = 1,
} NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_ACTION;
typedef struct _NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_V1 {
  NvU32 version;
  NvU32 processID;
  NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_ACTION action;
  NvU32 currentSessionCount;
} NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_V1;
typedef NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_V1 NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS;
#define NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_VER1                                                                 \
  MAKE_NVAPI_VERSION(NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_V1, 1)
#define NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_VER NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_IFR_UpdateSessionCount(__inout NVAPI_D3D_IFR_UPDATE_SESSION_COUNT_PARAMS *pParams);
typedef enum {
  NVFBC_ENABLE = 1,
  NVFBC_DISABLE = 2,
} NVAPI_D3D_NVFBC_STATE_ENUM;
typedef struct _NVAPI_D3D_NVFBC_CHANGE_STATE_PARAMS_V1 {
  NvU32 version;
  NVAPI_D3D_NVFBC_STATE_ENUM action;
} NVAPI_D3D_NVFBC_CHANGE_STATE_PARAMS_V1;
typedef NVAPI_D3D_NVFBC_CHANGE_STATE_PARAMS_V1 NVAPI_D3D_NVFBC_CHANGE_STATE_PARAMS;
#define NVAPI_D3D_NVFBC_CHANGE_STATE_PARAMS_VER1 MAKE_NVAPI_VERSION(NVAPI_D3D_NVFBC_CHANGE_STATE_PARAMS_V1, 1)
#define NVAPI_D3D_NVFBC_CHANGE_STATE_PARAMS_VER NVAPI_D3D_NVFBC_CHANGE_STATE_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_NVFBC_ChangeState(__inout NVAPI_D3D_NVFBC_CHANGE_STATE_PARAMS *pParams);
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_GetCaps(IDirect3DDevice9 *pDev, __in NVFBC_CAPS_TYPE dwCaptype, __out int *pResult);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D1X_NVIFR_GetCaps(__in IUnknown *pDev, __in NVFBC_CAPS_TYPE dwCaptype, __out int *pResult);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct _NVFBC_MOUSE_CAPTURE_SETUP {
  NvU32 dwVersion;
  HANDLE handle;
  DWORD vidPnSourceId;
} NVFBC_MOUSE_CAPTURE_SETUP;
#define NVFBC_MOUSE_CAPTURE_SETUP_VER MAKE_NVAPI_VERSION(NVFBC_MOUSE_CAPTURE_SETUP, 1)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_MOUSE_CAPTURE_SETUP(__in NVFBC_MOUSE_CAPTURE_SETUP *pParam);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct _NVFBC_MOUSE_CAPTURE_V1 {
  NvU32 dwVersion;
  NvU32 bIsHwCursor;
  NvU32 width;
  NvU32 height;
  NvU32 pitch;
  BYTE *pPixels;
} NVFBC_MOUSE_CAPTURE_V1;
#define NVFBC_MOUSE_CAPTURE_VER_1 MAKE_NVAPI_VERSION(NVFBC_MOUSE_CAPTURE, 1)
typedef struct _NVFBC_MOUSE_CAPTURE_V2 {
  NvU32 version;
  NvU32 isHwCursor;
  NvU32 width;
  NvU32 height;
  NvU32 pitch;
  NvU8 *pixels;
  NvU32 hotSpotX;
  NvU32 hotSpotY;
  NvU32 flags;
} NVFBC_MOUSE_CAPTURE_V2;
#define NVFBC_MOUSE_CAPTURE_VER_2 MAKE_NVAPI_VERSION(NVFBC_MOUSE_CAPTURE, 2)
typedef struct _NVFBC_MOUSE_CAPTURE_V3 {
  NvU32 version;
  NvU32 isHwCursor;
  NvU32 width;
  NvU32 height;
  NvU32 pitch;
  NvU8 *pixels;
  NvU32 hotSpotX;
  NvU32 hotSpotY;
  NvU32 flags;
  NvU32 mouseCounter;
} NVFBC_MOUSE_CAPTURE_V3;
#define NVFBC_MOUSE_CAPTURE_VER_3 MAKE_NVAPI_VERSION(NVFBC_MOUSE_CAPTURE, 3)
typedef struct _NVFBC_MOUSE_CAPTURE_V4 {
  NvU32 version;
  NvU32 isHwCursor;
  NvU32 width;
  NvU32 height;
  NvU32 pitch;
  NvU8 *pixels;
  NvU32 hotSpotX;
  NvU32 hotSpotY;
  NvU32 flags;
  NvU32 mouseCounter;
  NvU32 vidPnSrcId;
} NVFBC_MOUSE_CAPTURE_V4;
#define NVFBC_MOUSE_CAPTURE_VER_4 MAKE_NVAPI_VERSION(NVFBC_MOUSE_CAPTURE, 4)
#define NVFBC_MOUSE_CAPTURE_VER NVFBC_MOUSE_CAPTURE_VER_4
typedef NVFBC_MOUSE_CAPTURE_V4 NVFBC_MOUSE_CAPTURE;
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_MOUSE_CAPTURE(__in IDirect3DDevice9 *pDev, __inout NVFBC_MOUSE_CAPTURE *pParam);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVIFR_ReleaseSession(__in IDirect3DDevice9 *pDev);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
enum NVAPI_SHARE_RESOURCE_FLAGS {
  NVAPI_SHARE_RESOURCE_FLAGS_NONE = 0x0,
  NVAPI_SHARE_RESOURCE_FLAGS_DISCARD = 0x1,
  NVAPI_SHARE_RESOURCE_FLAGS_FAIL_IF_RELOCATED = 0x2,
  NVAPI_SHARE_RESOURCE_FLAGS_DISABLE_CPU_ACCESS = 0x4,
};
enum NVAPI_SHARE_RESOURCE_LOCATION {
  NVAPI_SHARE_RESOURCE_LOCATION_UNKNOWN = 0,
  NVAPI_SHARE_RESOURCE_LOCATION_VIDMEM = 1,
  NVAPI_SHARE_RESOURCE_LOCATION_SYSMEM = 2
};
NVAPI_INTERFACE NvAPI_D3D9_BeginShareResource(IDirect3DDevice9 *pDev, IDirect3DResource9 *pResource, UINT32 flags,
                                              HANDLE *pHandle);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_EndShareResource(IDirect3DDevice9 *pDev, IDirect3DResource9 *pResource);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_D3D10_AliasPrimaryAsTexture(ID3D10Device *pDev, NvU32 headIndex, ID3D10Texture2D **ppTexture);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
typedef void (*NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK)(NvU32);
typedef struct {
  NvU32 version;
  NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryFlipped;
  NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryFlipChainModified;
  NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryAliasInvalid;
  NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pPrimaryAliasOperationDropped;
  NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pCursorVisibleUpdated;
  NVAPI_PRIMARY_FLIP_CHAIN_CALLBACK pCursorShapeUpdated;
} NVAPI_FLIP_CHAIN_CALLBACK_PARAMS;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_D3D10_SetPrimaryFlipChainCallbacks(ID3D10Device *pDev,
                                             const NVAPI_FLIP_CHAIN_CALLBACK_PARAMS *pCallbackParams);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_D3D10_ProcessCallbacks(ID3D10Device *pDev, NvU32 dwMilliseconds);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
typedef enum {
  NV_HW_CURSOR_COLOR_FORMAT_MONOCHROME = 0,
  NV_HW_CURSOR_COLOR_FORMAT_COLOR = 1,
  NV_HW_CURSOR_COLOR_FORMAT_MASKED_COLOR = 2
} NV_HW_CURSOR_COLOR_FORMAT_FLAGS;
typedef struct _NVAPI_RENDERED_CURSOR_BITMAP_DATA {
  NvU32 version;
  NvU32 headIndex;
  NvU32 bufferSize;
  PBITMAP pBitmap;
  NvU32 xHot;
  NvU32 yHot;
  NV_HW_CURSOR_COLOR_FORMAT_FLAGS formatFlag;
  NvU32 bVisible;
} NVAPI_RENDERED_CURSOR_BITMAP_DATA;
#define NVAPI_RENDERED_CURSOR_BITMAP_DATA_VER MAKE_NVAPI_VERSION(NVAPI_RENDERED_CURSOR_BITMAP_DATA, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_D3D10_GetRenderedCursorAsBitmap(ID3D10Device *pDev,
                                          NVAPI_RENDERED_CURSOR_BITMAP_DATA *pRenderedCursorBitmapData);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_BeginShareResource(ID3D10Resource *pResource, HANDLE *pHandle);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_BeginShareResourceEx(ID3D10Resource *pResource, UINT32 flags, HANDLE *pHandle);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_EndShareResource(ID3D10Resource *pResource);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_SetDepthBoundsTest(ID3D10Device *pDev, NvU32 bEnable, float fMinDepth, float fMaxDepth);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetResourceHandle(ID3D10Device *pDev, ID3D10Resource *pResource,
                                              NVDX_ObjectHandle *phObject);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetVertexShaderHandle(ID3D10Device *pDev, ID3D10VertexShader *pD3D10VertexShader,
                                                  NVDX_ObjectHandle *phShader);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetGeometryShaderHandle(ID3D10Device *pDev, ID3D10GeometryShader *pD3D10GeometryShader,
                                                    NVDX_ObjectHandle *phShader);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetPixelShaderHandle(ID3D10Device *pDev, ID3D10PixelShader *pD3D10PixelShader,
                                                 NVDX_ObjectHandle *phShader);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetShaderUCodeAllocationInfo(ID3D10Device *pDev, NVDX_ObjectHandle hShader,
                                                         NvU32 *phAllocation, NvU32 *pBlockOffset,
                                                         NvU32 *pProgramOffset, NvU32 *pLength);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetShaderLocalMemoryAllocationInfo(__in ID3D10Device *pDev, __out NvU32 *phAllocation,
                                                               __out NvU32 *pBlockOffset, __out NvU32 *pLength,
                                                               __out NvU32 *pMaxWarpsPerSm,
                                                               __out NvU32 *pLmemBytesPerThread);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetResourceAllocationInfoSize(__in ID3D10Device *pDev, __out NvU32 *pSize);
#endif
typedef struct _sdResourceAttributes {
  NvU32 structVersion;
} sdResourceAttributes;
#define SD_RESOURCE_ATTRIBUTES_STRUCT_VERSION_V0 MAKE_NVAPI_VERSION(sdResourceAttributes, 0)
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D10_GetResourceAllocationInfo(__in ID3D10Device *pDev, __in NVDX_ObjectHandle hResource,
                                                      __out NvU32 *phAllocation, __out NvU32 *pBlockOffset,
                                                      __out NvU32 *pLength,
                                                      __inout sdResourceAttributes *pResourceAttributes);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetResourceAllocationInfo2(__in ID3D10Device *pDev, __in NVDX_ObjectHandle hResource,
                                                       __out NvU32 *phAllocation, __out NvU64 *pBlockOffset,
                                                       __out NvU64 *pLength,
                                                       __inout sdResourceAttributes *pResourceAttributes);
#endif
typedef struct _sdBuildDebugShaderInstanceParamsIn {
  NvU32 structVersion;
} sdBuildDebugShaderInstanceParamsIn;
#define SD_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_IN_VERSION_V0 MAKE_NVAPI_VERSION(sdBuildDebugShaderInstanceParamsIn, 0)
typedef struct _sdBuildDebugShaderInstanceParamsOut {
  NvU32 structVersion;
} sdBuildDebugShaderInstanceParamsOut;
#define SD_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_OUT_VERSION_V0 MAKE_NVAPI_VERSION(sdBuildDebugShaderInstanceParamsOut, 0)
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D10_BuildDebugShaderInstance2(__in ID3D10Device *pDev,
                                                      __in sdBuildDebugShaderInstanceParamsIn *pParamsIn,
                                                      __inout sdBuildDebugShaderInstanceParamsOut *pParamsOut);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D1x_NsightEnableDebugMode(__in IUnknown *pDev, __in bool bEnable);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D1x_NsightCommunication(__in IUnknown *pDev, __in void *pInternalDev, __inout void *pPayload);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
typedef struct _sdPushMethodIntoPushBufferArguments {
  NvU32 structVersion;
} sdPushMethodIntoPushBufferArguments;
#define SD_PUSH_METHOD_INTO_PUSH_BUFFER_ARGUMENTS_VERSION_V0 MAKE_NVAPI_VERSION(sdPushMethodIntoPushBufferArguments, 0)
NVAPI_INTERFACE NvAPI_D3D1x_NsightPushMethodIntoPushBuffer(__in IUnknown *pDev,
                                                           __in sdPushMethodIntoPushBufferArguments *pArgs);
#endif
#ifndef _HRESULT_DEFINED
#define HRESULT long
#endif
typedef HRESULT(__cdecl *SHADERDEBUGGER_CALLBACK)(__in void *pCallbackData, __in_opt void *pParam);
#ifndef _HRESULT_DEFINED
#undef HRESULT
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_SetShaderDebuggerCallback(__in ID3D10Device *pDev, __in NvU32 cbType,
                                                      __in_opt SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                      __in_opt void *pParam);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D1x_MoveShaderCacheBetweenVidAndSys(__in IUnknown *pDev, __in NvU32 cacheLocation,
                                                            __in NvU32 shaderTypeFlags);
#endif
typedef enum {
  D3D_SHADER_TYPE_VERTEX = 0,
  D3D_SHADER_TYPE_GEOMETRY = 1,
  D3D_SHADER_TYPE_PIXEL = 2,
  D3D_SHADER_TYPE_COMPUTE = 3,
  D3D_SHADER_TYPE_HULL = 4,
  D3D_SHADER_TYPE_DOMAIN = 5,
} D3D_SHADER_TYPE;
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_SetShaderDebuggerHeapSize(__in ID3D10Device *pDev, __in NvU32 newSize,
                                                      __in D3D_SHADER_TYPE shaderType, __out_opt NvU32 *pNewOffset);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_SetDeviceStateSaveBuffer(__in ID3D10Device *pDev, __in NvU32 newSize,
                                                     __in D3D_SHADER_TYPE shaderType, __out_opt NvU64 *phAllocation);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_LockCb(ID3D10Device *pDev, NvU32 hMemory, NvU32 **ppBuffer);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_UnlockCb(ID3D10Device *pDev, NvU32 hMemory);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetAllContextRmHandles(__in ID3D10Device *pDev,
                                                   __inout sdRmHandlesCollection *pRmHandlesCollection);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetAllocDebugInfo(__in ID3D10Device *pDev, __in NvU32 hKmtAlloc, __in NvU32 hAllocType,
                                              __in NvU32 hAllocIsDeviceSpecific, __out NvU32 *phClient,
                                              __out NvU32 *phDevice, __out NvU64 *pAllocPAddr, __out NvU32 *pAllocSize);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetPixelShaderInstructions(__in ID3D10Device *pDev, __in ID3D10PixelShader *pShader,
                                                       __out_bcount(*pBufferSize) NvU32 **ppInstructions,
                                                       __out NvU32 *pBufferSize);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_SetPixelShaderInstructions(__in ID3D10Device *pDev, __in ID3D10PixelShader *pShader,
                                                       __in_bcount(bufferSize) NvU32 *pInstructions,
                                                       __in NvU32 bufferSize);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_NsightEnableReporting(__in ID3D10Device *pDev, __in bool bEnable,
                                                  __in fdStatsReportsCompletedCallback completedReportsCallback,
                                                  __in_opt void *pCallbackData);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_NsightFlushReporting(__in ID3D10Device *pDev);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_NsightSetCustomReportData(__in ID3D10Device *pDev, __in NvU32 customData);
#endif
typedef enum {
  NVAPI_D3D_DRAW = 0,
  NVAPI_D3D_DISPATCH = 1,
  NVAPI_D3D_PRESENT = 2,
  NVAPI_D3D_COPY = 3,
} NVAPI_NSIGHT_D3DCALLTYPE;
#define NVAPI_NSIGHT_CALLTYPE_VERSION 1
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_NsightSetCurrentContextAndD3DCallCount(__in ID3D10Device *pDev, __in NvU64 contextHandle,
                                                                   __in NVAPI_NSIGHT_D3DCALLTYPE d3dCallIdType,
                                                                   __in NvU64 count);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_GetIDXGIAdapter(__in NvPhysicalGpuHandle hPhysicalGpu, __out IDXGIAdapter **ppAdapter);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_CreateDevice(IDXGIAdapter *pAdapter, D3D10_DRIVER_TYPE DriverType, HMODULE Software,
                                         UINT32 Flags, D3D10_FEATURE_LEVEL1 HardwareLevel, UINT SDKVersion,
                                         ID3D10Device1 **ppDevice, NVAPI_DEVICE_FEATURE_LEVEL *pLevel);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_CreateDeviceAndSwapChain(IDXGIAdapter *pAdapter, D3D10_DRIVER_TYPE DriverType,
                                                     HMODULE Software, UINT32 Flags, D3D10_FEATURE_LEVEL1 HardwareLevel,
                                                     UINT SDKVersion, DXGI_SWAP_CHAIN_DESC *pSwapChainDesc,
                                                     IDXGISwapChain **ppSwapChain, ID3D10Device1 **ppDevice,
                                                     NVAPI_DEVICE_FEATURE_LEVEL *pLevel);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetBufferStreamOutBytesWritten(ID3D10Device *pDev, ID3D10Buffer *pBuffer, NvU32 *pCount);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_SetBufferStreamOutBytesWritten(ID3D10Device *pDev, ID3D10Buffer *pBuffer, NvU32 Count);
#endif
#if defined(__cplusplus) && defined(__d3d10_1_h__)
NVAPI_INTERFACE NvAPI_D3D10_CreateDevice_McCompat(IDXGIAdapter *pAdapter, D3D10_DRIVER_TYPE DriverType,
                                                  HMODULE Software, UINT32 Flags, D3D10_FEATURE_LEVEL1 HardwareLevel,
                                                  UINT SDKVersion, ID3D10Device1 **ppDevice,
                                                  NVAPI_DEVICE_FEATURE_LEVEL *pLevel, UINT32 mccompat,
                                                  UINT32 mccompatHybrid);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_RegisterDevice(ID3D10Device *pDev);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_UnregisterDevice(ID3D10Device *pDev);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_SetPrivateConstData(__in ID3D10Device *pDev, __in NvAPIPrivateConstDataSlot dataslot,
                                                __in NvU32 data);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_GetPrivateConstDataSlotAndOffset(__in ID3D10Device *pDev, __in NVDX_ObjectHandle *phShader,
                                                             __in NvAPIPrivateConstDataSlot dataslot,
                                                             __out NvU32 *pOutConstSlot, __out NvU32 *pOutScalarOffset);
#endif
typedef struct _NvAPI_D3DResourceSubresourceInfo {
  NvU32 ArraySlice;
  NvU32 MipLevel;
  NvU32 OffsetInBytes;
} NvAPI_D3DResourceSubresourceInfo;
#define NVAPI_GET_RESOURCE_SUBRESOURCE_INFO_VERSION 1
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D10_GetResourceSubresourceInfo(__in ID3D10Device *pDev, __in NVDX_ObjectHandle hResource,
                                                       __in NvU32 Version, __inout NvU32 *pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount)
                                                           NvAPI_D3DResourceSubresourceInfo **ppInfoBuffer);
#endif
typedef struct _sdD3DResourceSubresourceInfo {
  NvU32 structVersion;
} sdD3DResourceSubresourceInfo;
#define SD_D3D_RESOURCE_SUBRESOURCE_INFO_STRUCT_VERSION_V0 MAKE_NVAPI_VERSION(sdD3DResourceSubresourceInfo, 0)
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D10_GetResourceSubresourceInfo2(__in ID3D10Device *pDev, __in NVDX_ObjectHandle hResource,
                                                        __in NvU32 Version, __inout NvU32 *pSubresourceCount,
                                                        __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount)
                                                            sdD3DResourceSubresourceInfo **ppInfoBuffer);
#endif
#if defined(__cplusplus) && defined(__d3d10_h__)
NVAPI_INTERFACE NvAPI_D3D10_EnableWarpSemaphoreReports(__in ID3D10Device *pDev, __in bool enable,
                                                       __in NvU32 requestedVersion,
                                                       __out volatile sdWarpSemaphoreReport **ppOutMappedMemory);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_CreateDevice(IDXGIAdapter *pAdapter, D3D_DRIVER_TYPE DriverType, HMODULE Software,
                                         UINT Flags, CONST D3D_FEATURE_LEVEL *pFeatureLevels, UINT FeatureLevels,
                                         UINT SDKVersion, ID3D11Device **ppDevice, D3D_FEATURE_LEVEL *pFeatureLevel,
                                         ID3D11DeviceContext **ppImmediateContext,
                                         NVAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_CreateDeviceAndSwapChain(IDXGIAdapter *pAdapter, D3D_DRIVER_TYPE DriverType,
                                                     HMODULE Software, UINT Flags,
                                                     CONST D3D_FEATURE_LEVEL *pFeatureLevels, UINT FeatureLevels,
                                                     UINT SDKVersion, CONST DXGI_SWAP_CHAIN_DESC *pSwapChainDesc,
                                                     IDXGISwapChain **ppSwapChain, ID3D11Device **ppDevice,
                                                     D3D_FEATURE_LEVEL *pFeatureLevel,
                                                     ID3D11DeviceContext **ppImmediateContext,
                                                     NVAPI_DEVICE_FEATURE_LEVEL *pSupportedLevel);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_CreateComputeOnlyDevice(__in ID3D11Device *pBase3DDevice, __in UINT Flags,
                                                    __in UINT SDKVersion, __out ID3D11Device **ppDevice,
                                                    __out D3D_FEATURE_LEVEL *pFeatureLevel,
                                                    __out ID3D11DeviceContext **ppImmediateContext);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SetAsyncComputeControlData(__in ID3D11DeviceContext *pNvAPIComputeOnlyDeviceContext,
                                                       __in UINT maxSMCount, __in UINT minSMCount,
                                                       __in bool bUseAllSMsInAllComputeMode);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_SetAsyncComputeControlData(__in ID3D12CommandQueue *pCommandQueue, __in UINT maxSMCount,
                                                       __in UINT minSMCount, __in bool bUseAllSMsInAllComputeMode);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_GetExperimentalFeatureEtbl(__in struct ID3D12Device5 *pDevice, __in const NvU32 *uuid,
                                                       __out void **etbl);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef struct _NVAPI_D3D11_ASYNC_COMPUTE_SM_DISABLE_MASK {
  NvU32 Version;
  UINT64 SMDisableMask;
  UINT64 Reserved;
} NVAPI_D3D11_ASYNC_COMPUTE_SM_DISABLE_MASK_V1;
typedef NVAPI_D3D11_ASYNC_COMPUTE_SM_DISABLE_MASK_V1 NVAPI_D3D11_ASYNC_COMPUTE_SM_DISABLE_MASK;
#define NVAPI_D3D11_ASYNC_COMPUTE_SM_DISABLE_MASK_VER1                                                                 \
  MAKE_NVAPI_VERSION(NVAPI_D3D11_ASYNC_COMPUTE_SM_DISABLE_MASK_V1, 1)
#define NVAPI_D3D11_ASYNC_COMPUTE_SM_DISABLE_MASK_VER NVAPI_D3D11_ASYNC_COMPUTE_SM_DISABLE_MASK_VER1
NVAPI_INTERFACE NvAPI_D3D11_SetSMDisableMask(__in ID3D11DeviceContext *pNvAPIComputeOnlyDeviceContext,
                                             __in NVAPI_D3D11_ASYNC_COMPUTE_SM_DISABLE_MASK *pSMDisableMask);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_EnableAsyncComputePerfCounters(__in ID3D11DeviceContext *pNvAPIComputeOnlyDeviceContext,
                                                           bool bEnable);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetAsyncComputePerfCounters(__in ID3D11DeviceContext *pNvAPIComputeOnlyDeviceContext,
                                                        __out UINT64 *pData);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_CreateSharedSynchronizationObject(__in ID3D11Device *pDevice, __in NvU64 fenceValue,
                                                              __out NvU64 *phSharedHandle, __out HANDLE *phFence);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_OpenSharedSynchronizationObject(__in ID3D11Device *pDevice, __in NvU64 hSharedHandle,
                                                            __out HANDLE *phFence, __out NvU64 *pFenceValue);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_DestroySharedSynchronizationObject(__in HANDLE hFence);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SignalSharedSynchronizationObject(__in ID3D11DeviceContext *pDeviceContext,
                                                              __in HANDLE hFence, __in UINT64 valueToSignal,
                                                              __in NvU32 gpuIndex = 0);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_WaitSharedSynchronizationObject(__in ID3D11DeviceContext *pDeviceContext,
                                                            __in HANDLE hFence, __in UINT64 valueToWait,
                                                            __in NvU32 gpuIndex = 0);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_CreateSynchronizationObject(__in ID3D11Device *pNvAPIComputeOnlyDevice,
                                                        __out NVDX_ObjectHandle *pHandle, __out UINT64 *pInitialValue);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_DestroySynchronizationObject(__in ID3D11Device *pNvAPIComputeOnlyDevice,
                                                         __in NVDX_ObjectHandle pHandle);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SignalSynchronizationObjectGpu(__in ID3D11DeviceContext *pDeviceContext,
                                                           __in NVDX_ObjectHandle pHandle, __in UINT64 valueToSignal);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SignalSynchronizationObjectCpu(__in ID3D11Device *pDevice, __in NVDX_ObjectHandle pHandle,
                                                           __in UINT64 valueToSignal);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_WaitForSynchronizationObjectGpu(__in ID3D11DeviceContext *pDeviceContext,
                                                            __in NVDX_ObjectHandle pHandle, __in UINT64 valueToWait);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_WaitForSynchronizationObjectCpu(__in ID3D11Device *pDevice, __in NVDX_ObjectHandle pHandle,
                                                            __in UINT64 valueToWait);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_OpenResourceOnComputeDevice(__in ID3D11Device *pComputeDevice,
                                                        __in ID3D11Resource *pSrcResource, __out void **ppResource);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_QueryAsyncComputeHint(__in ID3D11Device *pDevice, __out NvU32 *pIsRecommended);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_BeginShareResource(ID3D11Resource *pResource, UINT32 flags, HANDLE *pHandle);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_EndShareResource(ID3D11Resource *pResource);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SetDepthBoundsTest(IUnknown *pDeviceOrContext, NvU32 bEnable, float fMinDepth,
                                               float fMaxDepth);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D11_IsNvShaderExtnOpCodeSupported(__in IUnknown *pDev, __in NvU32 opCode,
                                                          __out bool *pSupported);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D11_SetNvShaderExtnSlot(__in IUnknown *pDev, __in NvU32 uavSlot);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_SetNvShaderExtnSlotSpace(__in IUnknown *pDev, __in NvU32 uavSlot, __in NvU32 uavSpace);
NVAPI_INTERFACE NvAPI_D3D12_SetNvShaderExtnSlotSpaceLocalThread(__in IUnknown *pDev, __in NvU32 uavSlot,
                                                                __in NvU32 uavSpace);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D11_SetNvShaderExtnSlotLocalThread(__in IUnknown *pDev, __in NvU32 uavSlot);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D_ForcePerSampleInterlock(__in IUnknown *pDeviceOrContext, __in bool bForcePerSample);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
typedef enum _NVAPI_D3D11_INSERTWFI_FLAG {
  NVAPI_D3D_BEGIN_UAV_OVERLAP_NO_WFI = 0x00000000,
  NVAPI_D3D_BEGIN_UAV_OVERLAP_GFX_WFI = 0x00000001,
  NVAPI_D3D_BEGIN_UAV_OVERLAP_COMP_WFI = 0x00000002,
} NVAPI_D3D11_INSERTWFI_FLAG;
NVAPI_INTERFACE NvAPI_D3D11_BeginUAVOverlapEx(__in IUnknown *pDeviceOrContext, __in NvU32 insertWFIFlags);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D11_BeginUAVOverlap(__in IUnknown *pDeviceOrContext);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D11_EndUAVOverlap(__in IUnknown *pDeviceOrContext);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
typedef enum {
  NVAPI_SHADER_ATTRIB_EVAL_AT_SAMPLE_LOCATION = 0x00000001,
} NVAPI_CREATE_PIXEL_SHADER_FLAGS;
NVAPI_INTERFACE NvAPI_D3D11_CreatePixelShaderEx(__in ID3D11Device *pDevice, __in const void *pShaderBytecode,
                                                __in SIZE_T BytecodeLength, __in ID3D11ClassLinkage *pClassLinkage,
                                                __in NVAPI_CREATE_PIXEL_SHADER_FLAGS flags,
                                                __out ID3D11PixelShader **ppPixelShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetBufferStreamOutBytesWritten(ID3D11Device *pDev, ID3D11Buffer *pBuffer, NvU32 *pCount);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SetBufferStreamOutBytesWritten(ID3D11Device *pDev, ID3D11Buffer *pBuffer, NvU32 Count);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetResourceHandle(ID3D11Device *pDev, ID3D11Resource *pResource,
                                              NVDX_ObjectHandle *phObject);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SetPrivateConstData(__in ID3D11DeviceContext *pContext,
                                                __in NvAPIPrivateConstDataSlot dataslot, __in NvU32 data);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetPrivateConstDataSlotAndOffset(__in ID3D11DeviceContext *pContext,
                                                             __in NVDX_ObjectHandle *phShader,
                                                             __in NvAPIPrivateConstDataSlot dataslot,
                                                             __out NvU32 *pOutConstSlot, __out NvU32 *pOutScalarOffset);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetResourceAllocationInfoSize(__in ID3D11DeviceContext *pContext, __out NvU32 *pSize);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetResourceAllocationInfo(__in ID3D11DeviceContext *pContext,
                                                      __in NVDX_ObjectHandle hResource, __out NvU32 *phAllocation,
                                                      __out NvU32 *pBlockOffset, __out NvU32 *pLength,
                                                      __inout sdResourceAttributes *pResourceAttributes);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetResourceAllocationInfo2(__in ID3D11Device *pDev, __in NVDX_ObjectHandle hResource,
                                                       __out NvU32 *phAllocation, __out NvU64 *pBlockOffset,
                                                       __out NvU64 *pLength,
                                                       __inout sdResourceAttributes *pResourceAttributes);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetAllContextRmHandles(__in ID3D11DeviceContext *pContext,
                                                   __inout sdRmHandlesCollection *pRmHandlesCollection);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetAllocDebugInfo(__in ID3D11DeviceContext *pContext, __in NvU32 hKmtAlloc,
                                              __in NvU32 hAllocType, __in NvU32 hAllocIsDeviceSpecific,
                                              __out NvU32 *phClient, __out NvU32 *phDevice, __out NvU64 *pAllocPAddr,
                                              __out NvU32 *pAllocSize);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetVertexShaderHandle(ID3D11DeviceContext *pContext, ID3D11VertexShader *pD3D11VertexShader,
                                                  ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                  UINT NumClassInstances, NVDX_ObjectHandle *phShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetGeometryShaderHandle(ID3D11DeviceContext *pContext,
                                                    ID3D11GeometryShader *pD3D11GeometryShader,
                                                    ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                    UINT NumClassInstances, NVDX_ObjectHandle *phShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetPixelShaderHandle(ID3D11DeviceContext *pContext, ID3D11PixelShader *pD3D11PixelShader,
                                                 ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                 UINT NumClassInstances, NVDX_ObjectHandle *phShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetComputeShaderHandle(ID3D11DeviceContext *pContext,
                                                   ID3D11ComputeShader *pD3D11ComputeShader,
                                                   ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                   UINT NumClassInstances, NVDX_ObjectHandle *phShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetHullShaderHandle(ID3D11DeviceContext *pContext, ID3D11HullShader *pD3D11HullShader,
                                                ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                UINT NumClassInstances, NVDX_ObjectHandle *phShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetDomainShaderHandle(ID3D11DeviceContext *pContext, ID3D11DomainShader *pD3D11DomainShader,
                                                  ID3D11ClassInstance *const *ppD3D11ClassInstance,
                                                  UINT NumClassInstances, NVDX_ObjectHandle *phShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SetShaderDebuggerHeapSize(__in ID3D11Device *pDev, __in NvU32 newSize,
                                                      __in D3D_SHADER_TYPE shaderType, __out_opt NvU32 *pNewOffset);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SetDeviceStateSaveBuffer(__in ID3D11Device *pDev, __in NvU32 newSize,
                                                     __in D3D_SHADER_TYPE shaderType, __out_opt NvU64 *phAllocation);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetShaderUCodeAllocationInfo(ID3D11DeviceContext *pContext, NVDX_ObjectHandle hShader,
                                                         NvU32 *phAllocation, NvU32 *pBlockOffset,
                                                         NvU32 *pProgramOffset, NvU32 *pLength);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef struct {
  NvU32 version;
  NvU32 smemSize;
  NvU32 tmpRegCount;
} NV_COMPUTE_SHADER_INFO;
#define NV_COMPUTE_SHADER_INFO_VER MAKE_NVAPI_VERSION(NV_COMPUTE_SHADER_INFO, 1)
NVAPI_INTERFACE NvAPI_D3D11_GetComputeShaderInfo(__in ID3D11DeviceContext *pContext, __in NVDX_ObjectHandle hShader,
                                                 __inout NV_COMPUTE_SHADER_INFO *pComputeShaderInfo);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetShaderLocalMemoryAllocationInfo(__in ID3D11DeviceContext *pContext,
                                                               __out NvU32 *phAllocation, __out NvU32 *pBlockOffset,
                                                               __out NvU32 *pLength, __out NvU32 *pMaxWarpsPerSm,
                                                               __out NvU32 *pLmemBytesPerThread);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_BuildDebugShaderInstance2(__in ID3D11Device *pDev,
                                                      __in sdBuildDebugShaderInstanceParamsIn *pParamsIn,
                                                      __inout sdBuildDebugShaderInstanceParamsOut *pParamsOut);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_SetShaderDebuggerCallback(__in ID3D11DeviceContext *pContext, __in NvU32 cbType,
                                                      __in_opt SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                      __in_opt void *pParam);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetResourceSubresourceInfo(__in ID3D11Device *pDev, __in NVDX_ObjectHandle hResource,
                                                       __in NvU32 Version, __inout NvU32 *pSubresourceCount,
                                                       __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount)
                                                           NvAPI_D3DResourceSubresourceInfo **ppInfoBuffer);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetResourceSubresourceInfo2(__in ID3D11Device *pDev, __in NVDX_ObjectHandle hResource,
                                                        __in NvU32 Version, __inout NvU32 *pSubresourceCount,
                                                        __out_ecount_part_opt(*pSubresourceCount, *pSubresourceCount)
                                                            sdD3DResourceSubresourceInfo **ppInfoBuffer);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_EnableWarpSemaphoreReports(__in ID3D11Device *pDev, __in bool enable,
                                                       __in NvU32 requestedVersion,
                                                       __out volatile sdWarpSemaphoreReport **ppOutMappedMemory);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_NsightEnableReporting(__in ID3D11Device *pDev, __in bool bEnable,
                                                  __in fdStatsReportsCompletedCallback completedReportsCallback,
                                                  __in_opt void *pCallbackData);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_NsightCommunication(__in ID3D11DeviceContext *pContext, __in void *pInternalDev,
                                                __inout void *pPayload);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_NsightFlushReporting(__in ID3D11Device *pDev);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_NsightSetCustomReportData(__in ID3D11DeviceContext *pContext, __in NvU32 customData);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_NsightSetCurrentContextAndD3DCallCount(__in ID3D11DeviceContext *pContext,
                                                                   __in NvU64 contextHandle,
                                                                   __in NVAPI_NSIGHT_D3DCALLTYPE d3dCallIdType,
                                                                   __in NvU64 count);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_DevtoolsInvokeFunctor(__in ID3D11DeviceContext *pDeviceContext, __in void *userdata,
                                                  __in size_t userdataSize);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef void(__stdcall *NVAPI_D3D12_PATCHABLE_NOP_SUBMIT_CALLBACK)(void *pUserData, struct DTA_DriverContext *drvCtx,
                                                                   NvU32 *pMethodWords, size_t numMethodWords);
NVAPI_INTERFACE NvAPI_D3D12_DevtoolsPushPatchableNops(__in ID3D12GraphicsCommandList *pCommandList,
                                                      __in NvU32 numMethodWords, __in void *pUserData,
                                                      __in NvU32 userDataSize,
                                                      __in NVAPI_D3D12_PATCHABLE_NOP_SUBMIT_CALLBACK pfnSubmitCallback);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef struct _NVAPI_D3D12_GET_RAYTRACING_STATEOBJECT_CUMODULES_PARAMS {
  size_t structSizeIn;
  size_t structSizeOut;
  struct ID3D12Device *pDevice;
  struct ID3D12StateObject *pStateObject;
  NvU64 numModules;
  void **pModules;
  const struct CUetblToolsModule_st *pEtblToolsModule;
} NVAPI_D3D12_GET_RAYTRACING_STATEOBJECT_CUMODULES_PARAMS;
NVAPI_INTERFACE NvAPI_D3D12_GetRayTracingStateObjectCuModules(
    __inout NVAPI_D3D12_GET_RAYTRACING_STATEOBJECT_CUMODULES_PARAMS *params);
#define NVAPI_STRUCT_SIZE(type_, lastfield_) (offsetof(type_, lastfield_) + sizeof(((type_ *)0)->lastfield_))
#define NVAPI_D3D12_GET_RAYTRACING_STATEOBJECT_CUMODULES_PARAMS_STRUCT_SIZE                                            \
  NVAPI_STRUCT_SIZE(NVAPI_D3D12_GET_RAYTRACING_STATEOBJECT_CUMODULES_PARAMS, pEtblToolsModule)
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef enum {
  NVAPI_RTX_OUTPUT_TYPE_NONE,
  NVAPI_RTX_OUTPUT_TYPE_RAYGENTIMING,
  NVAPI_RTX_OUTPUT_TYPE_RAYCOUNTER,
  NVAPI_RTX_OUTPUT_TYPE_RAYDATA,
  NVAPI_RTX_OUTPUT_TYPE_COUNT
} NVAPI_RTX_OUTPUT_TYPE;
#define NVAPI_RTX_OUTPUT_VERSION_INVALID 0
typedef struct {
  NvU32 duration;
} NVAPI_D3D12_RTXToolsOutputRaygenTiming_V1;
typedef struct {
  NvU64 rayCounter;
} NVAPI_D3D12_RTXToolsOutputRayCounter_V1;
typedef struct {
  NvU64 rayCountLimit;
  NvU64 rayCounter;
  NvU32 launchDim[3];
  NvU32 launchCoordShift[3];
  NvU32 launchCoordMask[3];
} NVAPI_D3D12_RTXToolsOutputRaysHeader_V1;
typedef struct {
  NvU64 tlasPackedVA : 42;
  NvU64 rayFlags : 16;
  NvU64 activeThreadsInWarp : 6;
  NvU64 geometryIndex : 24;
  NvU64 primitiveIndex : 29;
  NvU64 isHit : 1;
  NvU64 traceDepth : 5;
  NvU64 pad0 : 5;
  NvU64 instanceIndex : 24;
  NvU64 hitMissStateId : 16;
  NvU64 rayMask : 8;
  NvU64 pad1 : 16;
  NvU32 launchIdx;
  NvF32 origX, origY, origZ;
  NvF32 dirX, dirY, dirZ;
  NvF32 minT, maxT, hitT;
} NVAPI_D3D12_RTXToolsOutputRay_V1;
typedef struct _NVAPI_D3D12_RTX_SET_INSTRUMENTED_PIPELINE_CREATION_PARAMS_V1 {
  NvU32 version;
  IUnknown *pDevice;
  NVAPI_RTX_OUTPUT_TYPE type;
  NvU32 outputVersion;
} NVAPI_D3D12_RTX_SET_INSTRUMENTED_PIPELINE_CREATION_PARAMS_V1;
typedef NVAPI_D3D12_RTX_SET_INSTRUMENTED_PIPELINE_CREATION_PARAMS_V1
    NVAPI_D3D12_RTX_SET_INSTRUMENTED_PIPELINE_CREATION_PARAMS;
#define NVAPI_D3D12_RTX_SET_INSTRUMENTED_PIPELINE_CREATION_PARAMS_VER1                                                 \
  MAKE_NVAPI_VERSION(NVAPI_D3D12_RTX_SET_INSTRUMENTED_PIPELINE_CREATION_PARAMS_V1, 1)
#define NVAPI_D3D12_RTX_SET_INSTRUMENTED_PIPELINE_CREATION_PARAMS_VER                                                  \
  NVAPI_D3D12_RTX_SET_INSTRUMENTED_PIPELINE_CREATION_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D12_RTXSetInstrumentedPipelineCreation(
    __inout NVAPI_D3D12_RTX_SET_INSTRUMENTED_PIPELINE_CREATION_PARAMS *params);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef struct _NVAPI_D3D12_RTX_SET_DISPATCH_RESLT_BUFFER_PARAMS_V1 {
  NvU32 version;
  ID3D12GraphicsCommandList *pCommandList;
  NvU64 gpuAddress;
  NvU64 size;
  NvU32 indexBegin;
  NvU32 indexEnd;
} NVAPI_D3D12_RTX_SET_DISPATCH_RESLT_BUFFER_PARAMS_V1;
typedef NVAPI_D3D12_RTX_SET_DISPATCH_RESLT_BUFFER_PARAMS_V1 NVAPI_D3D12_RTX_SET_DISPATCH_RESLT_BUFFER_PARAMS;
#define NVAPI_D3D12_RTX_SET_DISPATCH_RESLT_BUFFER_PARAMS_VER1                                                          \
  MAKE_NVAPI_VERSION(NVAPI_D3D12_RTX_SET_DISPATCH_RESLT_BUFFER_PARAMS_V1, 1)
#define NVAPI_D3D12_RTX_SET_DISPATCH_RESLT_BUFFER_PARAMS_VER NVAPI_D3D12_RTX_SET_DISPATCH_RESLT_BUFFER_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D12_RTXSetDispatchResultBuffer(__in NVAPI_D3D12_RTX_SET_DISPATCH_RESLT_BUFFER_PARAMS *params);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
struct DTA_CmdList;
NVAPI_INTERFACE NvAPI_D3D12_DevtoolsGetCommandList(__in ID3D12GraphicsCommandList *pCL, __in DTA_CmdList **ppCmdList);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef struct _NV_MSHYBRID_ACTIVITIES_INFO_V1 {
  NvU64 numCeEnabledFsPresents;
  NvU64 numCeEnabledCopy;
} NV_MSHYBRID_ACTIVITIES_INFO_V1;
typedef NV_MSHYBRID_ACTIVITIES_INFO_V1 NV_MSHYBRID_ACTIVITIES_INFO;
#define NV_MSHYBRID_ACTIVITIES_INFO_VER1 MAKE_NVAPI_VERSION(NV_MSHYBRID_ACTIVITIES_INFO_V1, 1)
#define NV_MSHYBRID_ACTIVITIES_INFO_VER NV_MSHYBRID_ACTIVITIES_INFO_VER1
NVAPI_INTERFACE NvAPI_D3D11_GetMsHybridActivitiesInfo(__in ID3D11Device *pDev,
                                                      __out NV_MSHYBRID_ACTIVITIES_INFO *pMsHybridActivitiesInfo);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_SetFPSIndicatorState(IUnknown *pDev, NvU8 doEnable);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 450. Instead, use NvAPI_D3D_TagFrameWithAnimationTime.")
    NVAPI_INTERFACE NvAPI_D3D_TagFrameWithAnimationTime(__in IUnknown *pDev, __in NvU32 animationTimeUs);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 450. Instead, use NvAPI_D3D_GetSmoothAnimationTime.")
    NVAPI_INTERFACE NvAPI_D3D_GetSmoothAnimationTime(__in IUnknown *pDev, __out NvU32 *pAnimationTimeUs);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 450. Instead, use NvAPI_D3D_EnableSilk.") NVAPI_INTERFACE
    NvAPI_D3D_EnableSilk(__in IUnknown *pDev);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 450. Instead, use NvAPI_D3D_DisableSilk.") NVAPI_INTERFACE
    NvAPI_D3D_DisableSilk(__in IUnknown *pDev);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_Present(IDirect3DDevice9 *pDevice, IDirect3DSwapChain9 *pSwapChain, const RECT *pSourceRect,
                                   const RECT *pDestRect, HWND hDestWindowOverride, const RGNDATA *pDirtyRegion);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_QueryFrameCount(IDirect3DDevice9 *pDevice, NvU32 *pFrameCount);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_ResetFrameCount(IDirect3DDevice9 *pDevice);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_QueryMaxSwapGroup(IDirect3DDevice9 *pDevice, NvU32 *pMaxGroups, NvU32 *pMaxBarriers);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_QuerySwapGroup(IDirect3DDevice9 *pDevice, IDirect3DSwapChain9 *pSwapChain, NvU32 *pSwapGroup,
                                          NvU32 *pSwapBarrier);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_JoinSwapGroup(IDirect3DDevice9 *pDevice, IDirect3DSwapChain9 *pSwapChain, NvU32 group,
                                         BOOL blocking);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_BindSwapBarrier(IDirect3DDevice9 *pDevice, NvU32 group, NvU32 barrier);
#endif
typedef enum {
  NVAPI_VSYNC_DEFAULT,
  NVAPI_VSYNC_OFF,
  NVAPI_VSYNC_ON,
  NVAPI_VSYNC_ADAPTIVE,
  NVAPI_VSYNC_ADAPTIVE_HALF_REFRESH_RATE
} NVAPI_VSYNC_MODE;
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_SetVerticalSyncMode(__in IUnknown *pDevice, __in NVAPI_VSYNC_MODE vsyncMode);
#endif
#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D1x_Present(IUnknown *pDevice, IDXGISwapChain *pSwapChain, UINT SyncInterval, UINT Flags);
#endif
#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D1x_QueryFrameCount(IUnknown *pDevice, NvU32 *pFrameCount);
#endif
#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D1x_ResetFrameCount(IUnknown *pDevice);
#endif
#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D1x_QueryMaxSwapGroup(IUnknown *pDevice, NvU32 *pMaxGroups, NvU32 *pMaxBarriers);
#endif
#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D1x_QuerySwapGroup(IUnknown *pDevice, IDXGISwapChain *pSwapChain, NvU32 *pSwapGroup,
                                           NvU32 *pSwapBarrier);
#endif
#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D1x_JoinSwapGroup(IUnknown *pDevice, IDXGISwapChain *pSwapChain, NvU32 group, BOOL blocking);
#endif
#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D1x_BindSwapBarrier(IUnknown *pDevice, NvU32 group, NvU32 barrier);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D_SetCurrentSwapChain(IUnknown *pDevice, void *params);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_QueryPresentBarrierSupport(__in ID3D12Device *pDevice, __out bool *pSupported);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CreatePresentBarrierClient(__in ID3D12Device *pDevice, __in IDXGISwapChain *pSwapChain,
                                                       __out NvPresentBarrierClientHandle *pPresentBarrierClient);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_RegisterPresentBarrierResources(__in NvPresentBarrierClientHandle presentBarrierClient,
                                                            __in ID3D12Fence *pFence, __in ID3D12Resource **ppResources,
                                                            __in NvU32 numResources);
#endif
#if defined(__cplusplus)
NVAPI_INTERFACE NvAPI_DestroyPresentBarrierClient(__in NvPresentBarrierClientHandle presentBarrierClient);
#endif
#if defined(__cplusplus)
typedef struct _NV_JOIN_PRESENT_BARRIER_PARAMS {
  NvU32 dwVersion;
} NV_JOIN_PRESENT_BARRIER_PARAMS;
#define NV_JOIN_PRESENT_BARRIER_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_JOIN_PRESENT_BARRIER_PARAMS, 1)
NVAPI_INTERFACE NvAPI_JoinPresentBarrier(__in NvPresentBarrierClientHandle presentBarrierClient,
                                         __in NV_JOIN_PRESENT_BARRIER_PARAMS *pParams);
#endif
#if defined(__cplusplus)
NVAPI_INTERFACE NvAPI_LeavePresentBarrier(__in NvPresentBarrierClientHandle presentBarrierClient);
#endif
#if defined(__cplusplus)
#define NV_PRESENT_BARRIER_FRAME_STATICS_VER1 MAKE_NVAPI_VERSION(NV_PRESENT_BARRIER_FRAME_STATISTICS, 1)
typedef enum _NV_PRESENT_BARRIER_SYNC_MODE {
  PRESENT_BARRIER_NOT_JOINED = 0x00000000,
  PRESENT_BARRIER_SYNC_CLIENT = 0x00000001,
  PRESENT_BARRIER_SYNC_SYSTEM = 0x00000002,
  PRESENT_BARRIER_SYNC_CLUSTER = 0x00000003,
} NV_PRESENT_BARRIER_SYNC_MODE;
typedef struct _NV_PRESENT_BARRIER_FRAME_STATISTICS {
  NvU32 dwVersion;
  NV_PRESENT_BARRIER_SYNC_MODE SyncMode;
  NvU32 PresentCount;
  NvU32 PresentInSyncCount;
  NvU32 FlipInSyncCount;
  NvU32 RefreshCount;
} NV_PRESENT_BARRIER_FRAME_STATISTICS;
NVAPI_INTERFACE NvAPI_QueryPresentBarrierFrameStatistics(__in NvPresentBarrierClientHandle presentBarrierClient,
                                                         __out NV_PRESENT_BARRIER_FRAME_STATISTICS *pFrameStats);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CreateDDisplayPresentBarrierClient(
    __in ID3D12Device *pDevice, __in NvU32 sourceId, __out NvPresentBarrierClientHandle *pPresentBarrierClient);
#endif
NVAPI_INTERFACE NvAPI_OGL_NsightAttach(void);
NVAPI_INTERFACE NvAPI_OGL_NsightAttachEx(__in NvU32 componentMask);
NVAPI_INTERFACE NvAPI_OGL_NsightDetach(void);
NVAPI_INTERFACE NvAPI_OGL_NsightEnableReporting(__in fdStatsReportsCompletedCallback completedReportsCallback,
                                                __in_opt void *pCallbackData);
NVAPI_INTERFACE NvAPI_OGL_NsightDisableReporting(void);
NVAPI_INTERFACE NvAPI_OGL_NsightFlushReporting(void);
NVAPI_INTERFACE NvAPI_OGL_NsightSetGlobalCustomReportData(__in NvU32 customData);
NVAPI_INTERFACE NvAPI_OGL_NsightSetCustomReportData(__in NvU32 customData);
NVAPI_INTERFACE NvAPI_OGL_NsightSetDrawCallId(__in NvU64 id);
NVAPI_INTERFACE NvAPI_OGL_NsightPushTag(__in NvU32 tag, __in NvU64 id);
NVAPI_INTERFACE NvAPI_OGL_NsightPop();
NVAPI_INTERFACE NvAPI_OGL_NsightGetDeviceHandles(__out NvU32 *adapterHandle, __out NvU32 *deviceHandle,
                                                 __out NvU32 *contextHandle);
NVAPI_INTERFACE NvAPI_OGL_NsightGetPrivateHandle(__out NvU64 *handle);
NVAPI_INTERFACE NvAPI_OGL_NsightGetContextRmHandles(__inout sdRmHandlesCollection *pRmHandlesCollection);
NVAPI_INTERFACE NvAPI_OGL_NsightSetShaderDebuggerCallback(__in NvU32 callbackType,
                                                          __in SHADERDEBUGGER_CALLBACK pCallbackFunction,
                                                          __in_opt void *pParam);
NVAPI_INTERFACE NvAPI_OGL_NsightGetPrivateConstDataSlotAndOffset(__in NvAPIPrivateConstDataSlot dataslot,
                                                                 __out NvU32 *pOutConstSlot,
                                                                 __out NvU32 *pOutScalarOffset);
NVAPI_INTERFACE NvAPI_OGL_NsightSetPrivateConstData(__in NvAPIPrivateConstDataSlot dataslot, __in NvU32 data);
NVAPI_INTERFACE NvAPI_OGL_NsightEnableWarpSemaphoreReports(__in NvU32 bEnable, __in NvU32 requestedVersion,
                                                           __out volatile sdWarpSemaphoreReport **ppOutMappedMemory);
NVAPI_INTERFACE NvAPI_OGL_NsightSetShaderDebuggerHeapSize(__in NvU32 newSize, __in NvU32 shaderType,
                                                          __out NvU32 *pNewOffset);
NVAPI_INTERFACE NvAPI_OGL_NsightSetDeviceStateSaveBuffer(__in NvU32 newSize, __in NvU32 shaderType,
                                                         __out NvU64 *phAllocation);
NVAPI_INTERFACE NvAPI_OGL_NsightMoveShaderCacheBetweenVidAndSys(__in NvU32 cacheLocation, __in NvU32 shaderTypeFlags);
NVAPI_INTERFACE NvAPI_OGL_NsightGetDeviceKmtHandle(__out NvU64 *phDevice);
NVAPI_INTERFACE NvAPI_OGL_NsightEnableDebugMode(__in NvU32 bEnable);
typedef struct _sdGlBuildDebugShaderInstanceParamsIn {
  NvU32 structVersion;
} sdGlBuildDebugShaderInstanceParamsIn;
#define SD_GL_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_IN_VERSION_V0 MAKE_SD_VERSION(sdGlBuildDebugShaderInstanceParamsIn, 0)
typedef struct _sdGlBuildDebugShaderInstanceParamsOut {
  NvU32 structVersion;
} sdGlBuildDebugShaderInstanceParamsOut;
#define SD_GL_BUILD_DEBUG_SHADER_INSTANCE_PARAMS_OUT_VERSION_V0                                                        \
  MAKE_SD_VERSION(sdGlBuildDebugShaderInstanceParamsOut_v0, 0)
NVAPI_INTERFACE NvAPI_OGL_NsightBuildDebugShaderInstance(__in sdGlBuildDebugShaderInstanceParamsIn *pParamsIn,
                                                         __inout sdGlBuildDebugShaderInstanceParamsOut *pParamsOut);
NVAPI_INTERFACE NvAPI_OGL_NsightGetProgramiv(__in NvU32 id, __in NvU32 pname, __out NvU32 *params);
NVAPI_INTERFACE NvAPI_OGL_NsightGetDriverResourceInfoSize(__in NvU32 version, __out NvU32 *size);
typedef struct _sdOpenGLDriverResourceInfo {
  NvU32 structVersion;
} sdOpenGLDriverResourceInfo;
#define SD_OPENGL_DRIVER_RESOURCE_INFO_VERSION_V0 MAKE_SD_VERSION(sdOpenGLDriverResourceInfo_v0, 0)
NVAPI_INTERFACE NvAPI_OGL_NsightGetDriverResourceInfo(__in NvU32 version,
                                                      __out sdOpenGLDriverResourceInfo *resourceInfo);
NVAPI_INTERFACE NvAPI_OGL_NsightCommunication(__inout void *pPayload);
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D1x_IFR_SetUpTargetBufferToSys(IUnknown *pDevice, NVFBC_BUFFER_FORMAT eFormat, DWORD dwNBuffers,
                                           void **ppBuffers);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D1x_IFR_TransferRenderTarget(IUnknown *pDevice, HANDLE *pEvent, DWORD dwBufferIndex, DWORD dwTargetWidth,
                                         DWORD dwTargetHeight, DWORD dwRenderTargetIndex,
                                         DWORD dwRenderTargetArraySlice);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef struct {
  DWORD bSupported : 1;
  DWORD bNvEncLogoNeeded : 1;
  DWORD bNonQualifiedHW : 1;
  DWORD bCustomerApp : 1;
  DWORD bSessionLimitExceeded : 1;
  DWORD bNVIFREndOfLife : 1;
  DWORD bReservedBits : 26;
  DWORD dwPrivateDataSize;
  void *pPrivateData;
  IUnknown *pDevice;
  DWORD dwVersion;
  DWORD dwReserved[29];
  void *pReserved[30];
} NvIFRCheckDeviceSupportParams;
NVAPI_INTERFACE NvAPI_D3D1x_IFR_CheckDeviceSupport(NvIFRCheckDeviceSupportParams *pParams);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D1x_IFR_SetUpTargetBufferToNV12BLVideoSurface(IUnknown *pDevice, DWORD dwNBuffers, HANDLE *aHandles,
                                                          DWORD dwTargetWidth, DWORD dwTargetHeight);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
__nvapi_deprecated_function("Deprecated from r331, GRID SDK 2.2") NVAPI_INTERFACE
    NvAPI_D3D1x_IFR_TransferRenderTargetToNV12BLVideoSurface(IUnknown *pDevice, DWORD dwBufferIndex,
                                                             DWORD dwTargetWidth, DWORD dwTargetHeight,
                                                             DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D1x_IFR_ReleaseSession(__in IUnknown *pDev);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__) || defined(__d3d12_h__))
enum NVAPI_QUAD_FILLMODE {
  NVAPI_QUAD_FILLMODE_DISABLED = 0,
  NVAPI_QUAD_FILLMODE_BBOX = 1,
  NVAPI_QUAD_FILLMODE_FULL_VIEWPORT = 2,
};
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
typedef struct NvAPI_D3D11_RASTERIZER_DESC_EX {
  D3D11_FILL_MODE FillMode;
  D3D11_CULL_MODE CullMode;
  BOOL FrontCounterClockwise;
  INT DepthBias;
  FLOAT DepthBiasClamp;
  FLOAT SlopeScaledDepthBias;
  BOOL DepthClipEnable;
  BOOL ScissorEnable;
  BOOL MultisampleEnable;
  BOOL AntialiasedLineEnable;
  NvU32 ForcedSampleCount;
  bool ProgrammableSamplePositionsEnable;
  bool InterleavedSamplingEnable;
  NvU8 SampleCount;
  NvU8 SamplePositionsX[16];
  NvU8 SamplePositionsY[16];
  bool ConservativeRasterEnable;
  NVAPI_QUAD_FILLMODE QuadFillMode;
  bool PostZCoverageEnable;
  bool CoverageToColorEnable;
  NvU8 CoverageToColorRTIndex;
  bool TargetIndepentRasterWithDepth;
  NvU8 reserved[63];
} NvAPI_D3D11_RASTERIZER_DESC_EX;
NVAPI_INTERFACE NvAPI_D3D11_CreateRasterizerState(__in ID3D11Device *pDevice,
                                                  __in const NvAPI_D3D11_RASTERIZER_DESC_EX *pRasterizerDesc,
                                                  __out ID3D11RasterizerState **ppRasterizerState);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D_PerformPostProcessOps(__in IUnknown *pDevice, __in IUnknown *pTex);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d11_h__) || defined(__d3d11_1_h__) || defined(__d3d12_h__))
typedef enum _NVAPI_ANSEL_FEATURE {
  NVAPI_ANSEL_FEATURE_UNKNOWN = 0,
  NVAPI_ANSEL_FEATURE_BLACK_AND_WHITE = 1,
  NVAPI_ANSEL_FEATURE_HUDLESS = 2
} NVAPI_ANSEL_FEATURE;
typedef enum _NVAPI_ANSEL_FEATURE_STATE {
  NVAPI_ANSEL_FEATURE_STATE_UNKNOWN = 0,
  NVAPI_ANSEL_FEATURE_STATE_ENABLE = 1,
  NVAPI_ANSEL_FEATURE_STATE_DISABLE = 2
} NVAPI_ANSEL_FEATURE_STATE;
typedef enum _NVAPI_ANSEL_HOTKEY_MODIFIER {
  NVAPI_ANSEL_HOTKEY_MODIFIER_UNKNOWN = 0,
  NVAPI_ANSEL_HOTKEY_MODIFIER_CTRL = 1,
  NVAPI_ANSEL_HOTKEY_MODIFIER_SHIFT = 2,
  NVAPI_ANSEL_HOTKEY_MODIFIER_ALT = 3
} NVAPI_ANSEL_HOTKEY_MODIFIER;
typedef struct NVAPI_ANSEL_FEATURE_CONFIGURATION_STRUCT {
  NVAPI_ANSEL_FEATURE featureId;
  NVAPI_ANSEL_FEATURE_STATE featureState;
  UINT hotkey;
} NVAPI_ANSEL_FEATURE_CONFIGURATION_STRUCT;
typedef struct NVAPI_ANSEL_CONFIGURATION_STRUCT_V1 {
  NvU32 version;
  NVAPI_ANSEL_HOTKEY_MODIFIER hotkeyModifier;
  UINT keyEnable;
  UINT numAnselFeatures;
  NVAPI_ANSEL_FEATURE_CONFIGURATION_STRUCT *pAnselFeatures;
} NVAPI_ANSEL_CONFIGURATION_STRUCT_V1;
typedef NVAPI_ANSEL_CONFIGURATION_STRUCT_V1 NVAPI_ANSEL_CONFIGURATION_STRUCT;
#define NVAPI_ANSEL_CONFIGURATION_STRUCT_VER1 MAKE_NVAPI_VERSION(NVAPI_ANSEL_CONFIGURATION_STRUCT_V1, 1)
#define NVAPI_ANSEL_CONFIGURATION_STRUCT_VER NVAPI_ANSEL_CONFIGURATION_STRUCT_VER1
NVAPI_INTERFACE NvAPI_D3D_ConfigureAnsel(__in IUnknown *pDevice, __in NVAPI_ANSEL_CONFIGURATION_STRUCT *pNLSConfig);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
typedef struct NVAPI_SLI_UPDATE_MASK_STRUCT_V1 {
  NvU32 version;
  NvU32 appActiveMask;
} NVAPI_SLI_UPDATE_MASK_STRUCT_V1;
typedef NVAPI_SLI_UPDATE_MASK_STRUCT_V1 NVAPI_SLI_UPDATE_MASK_STRUCT;
#define NVAPI_SLI_UPDATE_MASK_STRUCT_VER1 MAKE_NVAPI_VERSION(NVAPI_SLI_UPDATE_MASK_STRUCT_V1, 1)
#define NVAPI_SLI_UPDATE_MASK_STRUCT_VER NVAPI_SLI_UPDATE_MASK_STRUCT_VER1
NVAPI_INTERFACE NvAPI_D3D_UpdateSLIMask(__in IUnknown *pDevice, __in NVAPI_SLI_UPDATE_MASK_STRUCT *pUpdateSLIMaskData);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D11_CreateMultiSampledUAV(__in ID3D11Device *pDevice, __in ID3D11Texture2D *pTex,
                                                  __in const D3D11_UNORDERED_ACCESS_VIEW_DESC *pDesc,
                                                  __out ID3D11UnorderedAccessView **ppUAV);
#endif
#if defined(__cplusplus) && defined(__d3d11_2_h__)
NVAPI_INTERFACE NvAPI_D3D11_CreateTiledTexture2DArray(__in ID3D11Device *pDevice,
                                                      __in const D3D11_TEXTURE2D_DESC *pDesc,
                                                      __in const D3D11_SUBRESOURCE_DATA *pInitialData,
                                                      __out ID3D11Texture2D **ppTexture2D);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef enum _NV_D3D11_FEATURE {
  NV_D3D11_FEATURE_RASTERIZER,
} NV_D3D11_FEATURE;
typedef struct _NV_D3D11_FEATURE_DATA_RASTERIZER_SUPPORT {
  BOOL TargetIndependentRasterWithDepth;
  BOOL ProgrammableSamplePositions;
  BOOL InterleavedSampling;
  BOOL ConservativeRaster;
  BOOL PostZCoverage;
  BOOL CoverageToColor;
} NV_D3D11_FEATURE_DATA_RASTERIZER_SUPPORT;
NVAPI_INTERFACE NvAPI_D3D11_CheckFeatureSupport(__in ID3D11Device *pDevice, __in NV_D3D11_FEATURE Feature,
                                                __out void *pFeatureSupportData, __in UINT FeatureSupportDataSize);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_CreateImplicitMSAATexture2D(__in ID3D11Device *pDevice,
                                                        __in const D3D11_TEXTURE2D_DESC *pDesc,
                                                        __out ID3D11Texture2D **ppTexture2D);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CreateCommittedImplicitMSAATexture2D(
    __in ID3D12Device *pDevice, __in const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags,
    __in const D3D12_RESOURCE_DESC *pDesc, D3D12_RESOURCE_STATES InitialResourceState,
    __in_opt const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riidResource, __out void **ppvResource);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__))
struct NVAPI_D3D_SAMPLE_POSITION_STATE_DESC {
  bool InterleavedSamplingEnable;
  NvU8 SampleCount;
  NvU8 SamplePositionsX[16];
  NvU8 SamplePositionsY[16];
};
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_TagDepthTextureForImplicitMSAAPromotion(
    __in ID3D11Device *pDevice, __in NVDX_ObjectHandle hTexture2D,
    __in const NVAPI_D3D_SAMPLE_POSITION_STATE_DESC *pSamplePositions);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_TagDepthTextureForImplicitMSAAPromotion(
    __in ID3D12Device *pDevice, __in ID3D12Resource *pTexture,
    __in const NVAPI_D3D_SAMPLE_POSITION_STATE_DESC *pSamplePositions);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_CopyMSAADataForImplicitlyPromotedDepthTexture(
    __in IUnknown *pContextOrCommandList, __in NVDX_ObjectHandle hDstTexture, __in UINT DstSubresource, __in UINT DstX,
    __in UINT DstY, __in NVDX_ObjectHandle hSrcDepthTexture, __in const RECT *pSrcRect);
#endif
typedef enum _NV_RESOLVE_MODE {
  NV_RESOLVE_MODE_SAMPLE_0,
} NV_RESOLVE_MODE;
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_ResolveSubresourceRegion(__in ID3D11Device *pDevice, __in ID3D11Texture2D *pDstResource,
                                                     __in UINT DstSubresource, __in UINT DstX, __in UINT DstY,
                                                     __in ID3D11Texture2D *pSrcResource, __in UINT SrcSubresource,
                                                     __in_opt const RECT *pSrcRect, __in DXGI_FORMAT Format,
                                                     __in NV_RESOLVE_MODE ResolveMode);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_ResolveSubresourceRegion(__in ID3D12GraphicsCommandList1 *pCommandList,
                                                     __in ID3D12Resource *pDstResource, __in UINT DstSubresource,
                                                     __in UINT DstX, __in UINT DstY, __in ID3D12Resource *pSrcResource,
                                                     __in UINT SrcSubresource, __in_opt RECT *pSrcRect,
                                                     __in DXGI_FORMAT Format, __in NV_RESOLVE_MODE ResolveMode);
#endif
#if defined(__cplusplus) && defined(__d3d11_2_h__)
NVAPI_INTERFACE NvAPI_D3D11_TiledTexture2DArrayGetDesc(__in ID3D11Texture2D *pTiledTexture2DArray,
                                                       __out D3D11_TEXTURE2D_DESC *pDesc);
#endif
#if defined(__cplusplus) && defined(__d3d11_2_h__)
NVAPI_INTERFACE NvAPI_D3D11_UpdateTileMappings(
    __in ID3D11DeviceContext2 *pDeviceContext, __in ID3D11Resource *pTiledResource, __in UINT NumTiledResourceRegions,
    __in const D3D11_TILED_RESOURCE_COORDINATE *pTiledResourceRegionStartCoordinates,
    __in const D3D11_TILE_REGION_SIZE *pTiledResourceRegionSizes, __in ID3D11Buffer *pTilePool, __in UINT NumRanges,
    __in const UINT *pRangeFlags, __in const UINT *pTilePoolStartOffsets, __in const UINT *pRangeTileCounts,
    __in UINT Flags);
#endif
#if defined(__cplusplus) && defined(__d3d11_2_h__)
NVAPI_INTERFACE NvAPI_D3D11_CopyTileMappings(__in ID3D11DeviceContext *pDeviceContext,
                                             __in ID3D11Resource *pDestTiledResource,
                                             __in const D3D11_TILED_RESOURCE_COORDINATE *pDestRegionStartCoordinate,
                                             __in ID3D11Resource *pSourceTiledResource,
                                             __in const D3D11_TILED_RESOURCE_COORDINATE *pSourceRegionStartCoordinate,
                                             __in const D3D11_TILE_REGION_SIZE *pTileRegionSize, __in UINT Flags);
#endif
#if defined(__cplusplus) && defined(__d3d11_2_h__)
NVAPI_INTERFACE NvAPI_D3D11_TiledResourceBarrier(__in ID3D11DeviceContext *pDeviceContext,
                                                 __in ID3D11Resource *pTiledResourceAccessBeforeBarrier,
                                                 __in ID3D11Resource *pTiledResourceAccessAfterBarrier);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D11_AliasMSAATexture2DAsNonMSAA(__in ID3D11Device *pDevice, __in ID3D11Texture2D *pInputTex,
                                                        __out ID3D11Texture2D **ppOutTex);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__)) && (!defined(CINTERFACE))
typedef UINT NvAPI_D3D11_SWIZZLE_MODE;
typedef enum _NV_SWIZZLE_MODE {
  NV_SWIZZLE_POS_X = 0,
  NV_SWIZZLE_NEG_X = 1,
  NV_SWIZZLE_POS_Y = 2,
  NV_SWIZZLE_NEG_Y = 3,
  NV_SWIZZLE_POS_Z = 4,
  NV_SWIZZLE_NEG_Z = 5,
  NV_SWIZZLE_POS_W = 6,
  NV_SWIZZLE_NEG_W = 7
} NV_SWIZZLE_MODE;
typedef enum _NV_SWIZZLE_OFFSET {
  NV_SWIZZLE_OFFSET_X = 0,
  NV_SWIZZLE_OFFSET_Y = 4,
  NV_SWIZZLE_OFFSET_Z = 8,
  NV_SWIZZLE_OFFSET_W = 12
} NV_SWIZZLE_OFFSET;
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__)) && (!defined(CINTERFACE))
#define NV_CUSTOM_SEMANTIC_MAX_LIMIT 32
typedef enum NV_CUSTOM_SEMANTIC_TYPE {
  NV_NONE_SEMANTIC = 0,
  NV_X_RIGHT_SEMANTIC = 1,
  NV_VIEWPORT_MASK_SEMANTIC = 2,
  NV_XYZW_RIGHT_SEMANTIC = 3,
  NV_VIEWPORT_MASK_2_SEMANTIC = 4,
  NV_POSITION_SEMANTIC = 5,
  NV_CLIP_DISTANCE_0_SEMANTIC = 6,
  NV_CLIP_DISTANCE_1_SEMANTIC = 7,
  NV_CULL_DISTANCE_0_SEMANTIC = 8,
  NV_CULL_DISTANCE_1_SEMANTIC = 9,
  NV_GENERIC_ATTRIBUTE_SEMANTIC = 10,
  NV_PACKED_EYE_INDEX_SEMANTIC = 17,
  NV_CUSTOM_SEMANTIC_MAX = NV_CUSTOM_SEMANTIC_MAX_LIMIT,
} NV_CUSTOM_SEMANTIC_TYPE;
typedef struct _NV_CUSTOM_SEMANTIC {
  UINT version;
  NV_CUSTOM_SEMANTIC_TYPE NVCustomSemanticType;
  NvAPI_LongString NVCustomSemanticNameString;
  BOOL RegisterSpecified;
  NvU32 RegisterNum;
  NvU32 RegisterMask;
  NvU32 Reserved;
} NV_CUSTOM_SEMANTIC;
#define NV_CUSTOM_SEMANTIC_VERSION MAKE_NVAPI_VERSION(NV_CUSTOM_SEMANTIC, 1)
#endif
#if defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))
typedef struct NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX_V5 {
  UINT version;
  BOOL UseViewportMask;
  BOOL OffsetRtIndexByVpIndex;
  BOOL ForceFastGS;
  BOOL DontUseViewportOrder;
  BOOL UseAttributeSkipMask;
  BOOL UseCoordinateSwizzle;
  NvAPI_D3D11_SWIZZLE_MODE *pCoordinateSwizzling;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  BOOL ConvertToFastGS;
  BOOL UseSpecificShaderExt;
} NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX_V5;
typedef NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX_V5 NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX;
#define NVAPI_D3D11_CREATEGEOMETRYSHADEREX_2_VER_5 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX_V5, 5)
#define NVAPI_D3D11_CREATEGEOMETRYSHADEREX_2_VERSION NVAPI_D3D11_CREATEGEOMETRYSHADEREX_2_VER_5
NVAPI_INTERFACE NvAPI_D3D11_CreateGeometryShaderEx_2(
    __in ID3D11Device *pDevice, __in const void *pShaderBytecode, __in SIZE_T BytecodeLength,
    __in_opt ID3D11ClassLinkage *pClassLinkage,
    __in const NvAPI_D3D11_CREATE_GEOMETRY_SHADER_EX *pCreateGeometryShaderExArgs,
    __out ID3D11GeometryShader **ppGeometryShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))
typedef struct NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V1 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
} NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V1;
typedef struct NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V2 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  BOOL UseWithFastGS;
} NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V2;
typedef struct NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V3 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  BOOL UseWithFastGS;
  BOOL UseSpecificShaderExt;
} NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V3;
typedef NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V3 NvAPI_D3D11_CREATE_VERTEX_SHADER_EX;
#define NVAPI_D3D11_CREATEVERTEXSHADEREX_VER_1 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V1, 1)
#define NVAPI_D3D11_CREATEVERTEXSHADEREX_VER_2 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V2, 2)
#define NVAPI_D3D11_CREATEVERTEXSHADEREX_VER_3 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_VERTEX_SHADER_EX_V2, 3)
#define NVAPI_D3D11_CREATEVERTEXSHADEREX_VERSION NVAPI_D3D11_CREATEVERTEXSHADEREX_VER_3
NVAPI_INTERFACE NvAPI_D3D11_CreateVertexShaderEx(
    __in ID3D11Device *pDevice, __in const void *pShaderBytecode, __in SIZE_T BytecodeLength,
    __in_opt ID3D11ClassLinkage *pClassLinkage,
    __in const NvAPI_D3D11_CREATE_VERTEX_SHADER_EX *pCreateVertexShaderExArgs,
    __out ID3D11VertexShader **ppVertexShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))
typedef struct NvAPI_D3D11_CREATE_HULL_SHADER_EX_V1 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  BOOL UseWithFastGS;
} NvAPI_D3D11_CREATE_HULL_SHADER_EX_V1;
typedef struct NvAPI_D3D11_CREATE_HULL_SHADER_EX_V2 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  BOOL UseWithFastGS;
  BOOL UseSpecificShaderExt;
} NvAPI_D3D11_CREATE_HULL_SHADER_EX_V2;
typedef NvAPI_D3D11_CREATE_HULL_SHADER_EX_V2 NvAPI_D3D11_CREATE_HULL_SHADER_EX;
#define NVAPI_D3D11_CREATEHULLSHADEREX_VER_1 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_HULL_SHADER_EX_V1, 1)
#define NVAPI_D3D11_CREATEHULLSHADEREX_VER_2 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_HULL_SHADER_EX_V1, 2)
#define NVAPI_D3D11_CREATEHULLSHADEREX_VERSION NVAPI_D3D11_CREATEHULLSHADEREX_VER_2
NVAPI_INTERFACE NvAPI_D3D11_CreateHullShaderEx(__in ID3D11Device *pDevice, __in const void *pShaderBytecode,
                                               __in SIZE_T BytecodeLength, __in_opt ID3D11ClassLinkage *pClassLinkage,
                                               __in const NvAPI_D3D11_CREATE_HULL_SHADER_EX *pCreateHullShaderExArgs,
                                               __out ID3D11HullShader **ppHullShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))
typedef struct NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V1 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
} NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V1;
typedef struct NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V2 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  BOOL UseWithFastGS;
} NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V2;
typedef struct NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V3 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  BOOL UseWithFastGS;
  BOOL UseSpecificShaderExt;
} NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V3;
typedef NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V3 NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX;
#define NVAPI_D3D11_CREATEDOMAINSHADEREX_VER_1 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V1, 1)
#define NVAPI_D3D11_CREATEDOMAINSHADEREX_VER_2 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V2, 2)
#define NVAPI_D3D11_CREATEDOMAINSHADEREX_VER_3 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX_V3, 3)
#define NVAPI_D3D11_CREATEDOMAINSHADEREX_VERSION NVAPI_D3D11_CREATEDOMAINSHADEREX_VER_3
NVAPI_INTERFACE NvAPI_D3D11_CreateDomainShaderEx(
    __in ID3D11Device *pDevice, __in const void *pShaderBytecode, __in SIZE_T BytecodeLength,
    __in_opt ID3D11ClassLinkage *pClassLinkage,
    __in const NvAPI_D3D11_CREATE_DOMAIN_SHADER_EX *pCreateDomainShaderExArgs,
    __out ID3D11DomainShader **ppDomainShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))
typedef struct NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V1 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
} NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V1;
#define NVAPI_D3D11_CREATEPIXELSHADEREX_VER_1 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V1, 1)
typedef struct NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V2 {
  UINT version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  NvU32 bEnableSuperSamplingPredicationForVRS : 1;
  NvU32 bEnableSuperSamplingPredicationForVRSAllAttributes : 1;
  NvU32 reserved : 30;
} NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V2;
typedef NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V2 NvAPI_D3D11_CREATE_PIXEL_SHADER_EX;
#define NVAPI_D3D11_CREATEPIXELSHADEREX_VER_2 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_PIXEL_SHADER_EX_V2, 2)
#define NVAPI_D3D11_CREATEPIXELSHADEREX_VERSION NVAPI_D3D11_CREATEPIXELSHADEREX_VER_2
NVAPI_INTERFACE NvAPI_D3D11_CreatePixelShaderEx_2(
    __in ID3D11Device *pDevice, __in const void *pShaderBytecode, __in SIZE_T BytecodeLength,
    __in_opt ID3D11ClassLinkage *pClassLinkage, __in const NvAPI_D3D11_CREATE_PIXEL_SHADER_EX *pCreatePixelShaderExArgs,
    __out ID3D11PixelShader **ppPixelShader);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__)) && (!defined(CINTERFACE))
typedef enum _NV_FASTGS_FLAGS {
  NV_FASTGS_USE_VIEWPORT_MASK = 0x01,
  NV_FASTGS_OFFSET_RT_INDEX_BY_VP_INDEX = 0x02,
  NV_FASTGS_STRICT_API_ORDER = 0x04,
} NV_FASTGS_FLAGS;
#endif
#if defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))
struct NvAPI_D3D11_CREATE_FASTGS_EXPLICIT_DESC_V1 {
  NvU32 version;
  NvU32 flags;
  NvAPI_D3D11_SWIZZLE_MODE *pCoordinateSwizzling;
};
#define NVAPI_D3D11_CREATEFASTGSEXPLICIT_VER1 MAKE_NVAPI_VERSION(NvAPI_D3D11_CREATE_FASTGS_EXPLICIT_DESC_V1, 1)
#define NVAPI_D3D11_CREATEFASTGSEXPLICIT_VER NVAPI_D3D11_CREATEFASTGSEXPLICIT_VER1
typedef NvAPI_D3D11_CREATE_FASTGS_EXPLICIT_DESC_V1 NvAPI_D3D11_CREATE_FASTGS_EXPLICIT_DESC;
NVAPI_INTERFACE NvAPI_D3D11_CreateFastGeometryShaderExplicit(
    __in ID3D11Device *pDevice, __in const void *pShaderBytecode, __in SIZE_T BytecodeLength,
    __in_opt ID3D11ClassLinkage *pClassLinkage, __in const NvAPI_D3D11_CREATE_FASTGS_EXPLICIT_DESC *pCreateFastGSArgs,
    __out ID3D11GeometryShader **ppGeometryShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__) && (!defined(CINTERFACE))
NVAPI_INTERFACE NvAPI_D3D11_CreateFastGeometryShader(__in ID3D11Device *pDevice, __in const void *pShaderBytecode,
                                                     __in SIZE_T BytecodeLength,
                                                     __in_opt ID3D11ClassLinkage *pClassLinkage,
                                                     __out ID3D11GeometryShader **ppGeometryShader);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef struct NvAPI_D3D11_VIEWPORT_EX {
  FLOAT TopLeftX;
  FLOAT TopLeftY;
  FLOAT Width;
  FLOAT Height;
  FLOAT MinDepth;
  FLOAT MaxDepth;
  bool bUseSubpixelBits;
  UINT NumSubpixelBits;
} NvAPI_D3D11_VIEWPORT_PER_VIEWPORT_EX;
typedef struct NvAPI_D3D11_VIEWPORTS_EX_V1 {
  UINT version;
  UINT NumViewports;
  const NvAPI_D3D11_VIEWPORT_EX *pViewports;
} NvAPI_D3D11_VIEWPORTS_EX_V1;
typedef NvAPI_D3D11_VIEWPORTS_EX_V1 NvAPI_D3D11_VIEWPORTS_EX;
#define NVAPI_D3D11_RSSETVIEWPORTS_EX_VERSION MAKE_NVAPI_VERSION(NvAPI_D3D11_VIEWPORTS_EX, 1)
NVAPI_INTERFACE NvAPI_D3D11_RSSetViewportsEx(__in IUnknown *pDevice,
                                             __in const NvAPI_D3D11_VIEWPORTS_EX *pViewportsExArgs);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_DecompressView(__in ID3D11Device *pDevice, __in ID3D11DeviceContext *pDeviceContext,
                                           __in ID3D11View *pView);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef enum _NV_PSO_EXTENSION {
  NV_PSO_RASTER_EXTENSION = 0,
  NV_PSO_REQUEST_FASTGS_EXTENSION = 1,
  NV_PSO_GEOMETRY_SHADER_EXTENSION = 2,
  NV_PSO_ENABLE_DEPTH_BOUND_TEST_EXTENSION = 3,
  NV_PSO_EXPLICIT_FASTGS_EXTENSION = 4,
  NV_PSO_SET_SHADER_EXTNENSION_SLOT_AND_SPACE = 5,
  NV_PSO_SET_SHADER_EXTENSION_SLOT_AND_SPACE = 5,
  NV_PSO_VERTEX_SHADER_EXTENSION = 6,
  NV_PSO_DOMAIN_SHADER_EXTENSION = 7,
  NV_PSO_PIXEL_SHADER_EXTENSION = 8,
  NV_PSO_HULL_SHADER_EXTENSION = 9,
  NV_PSO_MESH_TASK_SHADER_EXTENSION = 10,
  NV_PSO_MESH_SHADER_EXTENSION = 11,
  NV_PSO_COMPUTE_SHADER_EXTENSION = 12,
  NV_PSO_REPRESENTATIVE_PIXEL_TEST_EXTENSION = 13,
} NV_PSO_EXTENSION;
struct NVAPI_D3D12_PSO_EXTENSION_DESC_V1 {
  NvU32 baseVersion;
  NV_PSO_EXTENSION psoExtension;
};
#define NV_PSO_EXTENSION_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_EXTENSION_DESC_V1, 1)
#define NV_PSO_EXTENSION_DESC_VER NV_PSO_EXTENSION_DESC_VER_1
typedef NVAPI_D3D12_PSO_EXTENSION_DESC_V1 NVAPI_D3D12_PSO_EXTENSION_DESC;
struct NVAPI_D3D12_PSO_RASTERIZER_STATE_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  bool ProgrammableSamplePositionsEnable;
  bool InterleavedSamplingEnable;
  NvU8 SampleCount;
  NvU8 SamplePositionsX[16];
  NvU8 SamplePositionsY[16];
  NVAPI_QUAD_FILLMODE QuadFillMode;
  bool PostZCoverageEnable;
  bool CoverageToColorEnable;
  NvU8 CoverageToColorRTIndex;
  bool TargetIndepentRasterWithDepth;
  NvU8 ForcedSampleCount;
  NvU8 reserved[62];
};
#define NV_RASTERIZER_PSO_EXTENSION_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_RASTERIZER_STATE_DESC_V1, 1)
#define NV_RASTERIZER_PSO_EXTENSION_DESC_VER_2 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_RASTERIZER_STATE_DESC_V1, 2)
#define NV_RASTERIZER_PSO_EXTENSION_DESC_VER NV_RASTERIZER_PSO_EXTENSION_DESC_VER_2
typedef NVAPI_D3D12_PSO_RASTERIZER_STATE_DESC_V1 NVAPI_D3D12_PSO_RASTERIZER_STATE_DESC;
struct NVAPI_D3D12_PSO_CREATE_FASTGS_EXPLICIT_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NvU32 flags;
  NvAPI_D3D11_SWIZZLE_MODE *pCoordinateSwizzling;
};
#define NV_FASTGS_EXPLICIT_PSO_EXTENSION_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_CREATE_FASTGS_EXPLICIT_DESC_V1, 1)
#define NV_FASTGS_EXPLICIT_PSO_EXTENSION_VER NV_FASTGS_EXPLICIT_PSO_EXTENSION_VER_1
typedef NVAPI_D3D12_PSO_CREATE_FASTGS_EXPLICIT_DESC_V1 NVAPI_D3D12_PSO_CREATE_FASTGS_EXPLICIT_DESC;
struct NVAPI_D3D12_PSO_REQUEST_FAST_GEOMETRY_SHADER_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
};
#define NV_FAST_GEOMETRY_SHADER_PSO_EXTENSION_VER_1                                                                    \
  MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_REQUEST_FAST_GEOMETRY_SHADER_DESC_V1, 1)
#define NV_FAST_GEOMETRY_SHADER_PSO_EXTENSION_VER NV_FAST_GEOMETRY_SHADER_PSO_EXTENSION_VER_1
typedef NVAPI_D3D12_PSO_REQUEST_FAST_GEOMETRY_SHADER_DESC_V1 NVAPI_D3D12_PSO_REQUEST_FAST_GEOMETRY_SHADER_DESC;
struct NVAPI_D3D12_PSO_GEOMETRY_SHADER_DESC_V5 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  BOOL UseViewportMask;
  BOOL OffsetRtIndexByVpIndex;
  BOOL ForceFastGS;
  BOOL DontUseViewportOrder;
  BOOL UseAttributeSkipMask;
  BOOL UseCoordinateSwizzle;
  NvAPI_D3D11_SWIZZLE_MODE *pCoordinateSwizzling;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  BOOL ConvertToFastGS;
  BOOL UseSpecificShaderExt;
};
#define NV_GEOMETRY_SHADER_PSO_EXTENSION_DESC_VER_5 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_GEOMETRY_SHADER_DESC_V5, 5)
#define NV_GEOMETRY_SHADER_PSO_EXTENSION_DESC_VER NV_GEOMETRY_SHADER_PSO_EXTENSION_DESC_VER_5
typedef NVAPI_D3D12_PSO_GEOMETRY_SHADER_DESC_V5 NVAPI_D3D12_PSO_GEOMETRY_SHADER_DESC;
struct NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
};
struct NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V2 : public NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V1 {
  BOOL UseWithFastGS;
};
struct NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V3 : public NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V2 {
  BOOL UseSpecificShaderExt;
};
#define NV_VERTEX_SHADER_PSO_EXTENSION_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V1, 1)
#define NV_VERTEX_SHADER_PSO_EXTENSION_DESC_VER_2 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V2, 2)
#define NV_VERTEX_SHADER_PSO_EXTENSION_DESC_VER_3 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V3, 3)
#define NV_VERTEX_SHADER_PSO_EXTENSION_DESC_VER NV_VERTEX_SHADER_PSO_EXTENSION_DESC_VER_3
typedef NVAPI_D3D12_PSO_VERTEX_SHADER_DESC_V3 NVAPI_D3D12_PSO_VERTEX_SHADER_DESC;
struct NVAPI_D3D12_PSO_HULL_SHADER_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  BOOL UseWithFastGS;
};
struct NVAPI_D3D12_PSO_HULL_SHADER_DESC_V2 : public NVAPI_D3D12_PSO_HULL_SHADER_DESC_V1 {
  BOOL UseSpecificShaderExt;
};
#define NV_HULL_SHADER_PSO_EXTENSION_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_HULL_SHADER_DESC_V1, 1)
#define NV_HULL_SHADER_PSO_EXTENSION_DESC_VER_2 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_HULL_SHADER_DESC_V2, 2)
#define NV_HULL_SHADER_PSO_EXTENSION_DESC_VER NV_HULL_SHADER_PSO_EXTENSION_DESC_VER_2
typedef NVAPI_D3D12_PSO_HULL_SHADER_DESC_V2 NVAPI_D3D12_PSO_HULL_SHADER_DESC;
struct NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
};
struct NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V2 : public NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V1 {
  BOOL UseWithFastGS;
};
struct NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V3 : public NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V2 {
  BOOL UseSpecificShaderExt;
};
#define NV_DOMAIN_SHADER_PSO_EXTENSION_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V1, 1)
#define NV_DOMAIN_SHADER_PSO_EXTENSION_DESC_VER_2 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V2, 2)
#define NV_DOMAIN_SHADER_PSO_EXTENSION_DESC_VER_3 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V3, 3)
#define NV_DOMAIN_SHADER_PSO_EXTENSION_DESC_VER NV_DOMAIN_SHADER_PSO_EXTENSION_DESC_VER_3
typedef NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC_V3 NVAPI_D3D12_PSO_DOMAIN_SHADER_DESC;
struct NVAPI_D3D12_PSO_MESH_TASK_SHADER_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  const void *pShaderBytecode;
  NvU32 bytecodeLength;
  NvU32 threadCount;
  NvU32 outputMemorySize;
  NvU32 sharedMemorySize;
};
#define NV_MESH_TASK_SHADER_PSO_EXTENSION_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_MESH_TASK_SHADER_DESC_V1, 1)
#define NV_MESH_TASK_SHADER_PSO_EXTENSION_DESC_VER NV_MESH_TASK_SHADER_PSO_EXTENSION_DESC_VER_1
typedef NVAPI_D3D12_PSO_MESH_TASK_SHADER_DESC_V1 NVAPI_D3D12_PSO_MESH_TASK_SHADER_DESC;
struct NVAPI_D3D12_PSO_MESH_SHADER_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  const void *pShaderBytecode;
  NvU32 bytecodeLength;
  NvU32 threadCount;
  NvU32 inputMemorySize;
  NvU32 sharedMemorySize;
  NvU32 usesTaskShader;
  NvU32 verticesPerPrimitive;
  NvU32 maxVertexCount;
  NvU32 maxPrimitiveCount;
};
#define NV_MESH_SHADER_PSO_EXTENSION_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_MESH_SHADER_DESC_V1, 1)
#define NV_MESH_SHADER_PSO_EXTENSION_DESC_VER NV_MESH_SHADER_PSO_EXTENSION_DESC_VER_1
typedef NVAPI_D3D12_PSO_MESH_SHADER_DESC_V1 NVAPI_D3D12_PSO_MESH_SHADER_DESC;
struct NVAPI_D3D12_PSO_PIXEL_SHADER_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
};
#define NV_PIXEL_SHADER_PSO_EXTENSION_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_PIXEL_SHADER_DESC_V1, 1)
struct NVAPI_D3D12_PSO_PIXEL_SHADER_DESC_V2 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NvU32 NumCustomSemantics;
  NV_CUSTOM_SEMANTIC *pCustomSemantics;
  NvU32 bEnableSuperSamplingPredicationForVRS : 1;
  NvU32 bEnableSuperSamplingPredicationForVRSAllAttributes : 1;
  NvU32 reserved : 30;
};
#define NV_PIXEL_SHADER_PSO_EXTENSION_DESC_VER_2 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_PIXEL_SHADER_DESC_V2, 2)
#define NV_PIXEL_SHADER_PSO_EXTENSION_DESC_VER NV_PIXEL_SHADER_PSO_EXTENSION_DESC_VER_2
typedef NVAPI_D3D12_PSO_PIXEL_SHADER_DESC_V2 NVAPI_D3D12_PSO_PIXEL_SHADER_DESC;
struct NVAPI_D3D12_PSO_ENABLE_DEPTH_BOUND_TEST_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  bool EnableDBT;
};
#define NV_ENABLE_DEPTH_BOUND_TEST_PSO_EXTENSION_DESC_VER_1                                                            \
  MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_ENABLE_DEPTH_BOUND_TEST_DESC_V1, 1)
#define NV_ENABLE_DEPTH_BOUND_TEST_PSO_EXTENSION_DESC_VER NV_ENABLE_DEPTH_BOUND_TEST_PSO_EXTENSION_DESC_VER_1
typedef NVAPI_D3D12_PSO_ENABLE_DEPTH_BOUND_TEST_DESC_V1 NVAPI_D3D12_PSO_ENABLE_DEPTH_BOUND_TEST_DESC;
struct NVAPI_D3D12_PSO_REPRESENTATIVE_PIXEL_TEST_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  bool EnableRPT;
};
#define NV_REPRESENTATIVE_PIXEL_TEST_PSO_EXTENSION_DESC_VER_1                                                          \
  MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_REPRESENTATIVE_PIXEL_TEST_DESC_V1, 1)
#define NV_REPRESENTATIVE_PIXEL_TEST_PSO_EXTENSION_DESC_VER NV_REPRESENTATIVE_PIXEL_TEST_PSO_EXTENSION_DESC_VER_1
typedef NVAPI_D3D12_PSO_REPRESENTATIVE_PIXEL_TEST_DESC_V1 NVAPI_D3D12_PSO_REPRESENTATIVE_PIXEL_TEST_DESC;
struct NVAPI_D3D12_PSO_SET_SHADER_EXTENSION_SLOT_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NvU32 uavSlot;
  NvU32 registerSpace;
};
#define NV_SET_SHADER_EXTENSION_SLOT_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_SET_SHADER_EXTENSION_SLOT_DESC_V1, 1)
#define NV_SET_SHADER_EXTENSION_SLOT_DESC_VER NV_SET_SHADER_EXTENSION_SLOT_DESC_VER_1
typedef NVAPI_D3D12_PSO_SET_SHADER_EXTENSION_SLOT_DESC_V1 NVAPI_D3D12_PSO_SET_SHADER_EXTENSION_SLOT_DESC;
typedef enum _NV_COMPUTE_SHADER_DERIVATIVES {
  NV_COMPUTE_SHADER_DERIVATIVE_NONE = 0,
  NV_COMPUTE_SHADER_DERIVATIVE_GROUP_LINEAR = 1,
  NV_COMPUTE_SHADER_DERIVATIVE_GROUP_QUADS = 2,
} NV_COMPUTE_SHADER_DERIVATIVES;
struct NVAPI_D3D12_PSO_COMPUTE_SHADER_DESC_V1 : public NVAPI_D3D12_PSO_EXTENSION_DESC {
  NvU32 version;
  NV_COMPUTE_SHADER_DERIVATIVES derivativesMode;
};
#define NV_COMPUTE_SHADER_PSO_EXTENSION_DESC_VER_1 MAKE_NVAPI_VERSION(NVAPI_D3D12_PSO_COMPUTE_SHADER_DESC_V1, 1)
#define NV_COMPUTE_SHADER_PSO_EXTENSION_DESC_VER NV_COMPUTE_SHADER_PSO_EXTENSION_DESC_VER_1
typedef NVAPI_D3D12_PSO_COMPUTE_SHADER_DESC_V1 NVAPI_D3D12_PSO_COMPUTE_SHADER_DESC;
typedef struct NvAPI_D3D12Device_st *NvAPI_D3D12Device;
typedef struct NvAPI_D3D12CommandList_st *NvAPI_D3D12CommandList;
typedef struct NvAPI_CblToUmdIf_st *NvAPI_CblToUmdIf;
NVAPI_INTERFACE NvAPI_D3D12_GetDevice(__in ID3D12Device *pDevice, __out NvAPI_D3D12Device *pNvAPID3D12Device);
NVAPI_INTERFACE NvAPI_D3D12_GetCommandList(__in ID3D12GraphicsCommandList *pCommandList,
                                           __out NvAPI_D3D12CommandList *pNvAPID3D12CommandList);
NVAPI_INTERFACE NvAPI_D3D12_GetCblToUmdIf(__out NvAPI_CblToUmdIf *pNvAPICblToUmdIf);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef struct NvAPI_D3D11Device_st *NvAPI_D3D11Device;
typedef struct NvAPI_D3D11CommandList_st *NvAPI_D3D11DeviceContext;
typedef struct NvAPI_CblToUmdIf_st *NvAPI_CblToUmdIf;
NVAPI_INTERFACE NvAPI_D3D11_GetDevice(__in ID3D11Device *pDevice, __out NvAPI_D3D11Device *pNvAPIDevice);
NVAPI_INTERFACE NvAPI_D3D11_GetCommandList(__in ID3D11DeviceContext *pDeviceContext,
                                           __out NvAPI_D3D11DeviceContext *pNvAPIDeviceContext);
NVAPI_INTERFACE NvAPI_D3D11_GetCblToUmdIf(__out NvAPI_CblToUmdIf *pNvAPICblToUmdIf);
#define NVAPI_MAX_DX11_CBL_RESOURCES 24
NVAPI_INTERFACE NvAPI_D3D11_BindCblResources(__in ID3D11DeviceContext *pDeviceContext, __in NvU32 startSlot,
                                             __in NvU32 numResources, __in const NVDX_ObjectHandle *pResources,
                                             __in const bool *pWriteAccess);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CreateGraphicsPipelineState(__in ID3D12Device *pDevice,
                                                        __in const D3D12_GRAPHICS_PIPELINE_STATE_DESC *pPSODesc,
                                                        NvU32 numExtensions,
                                                        __in const NVAPI_D3D12_PSO_EXTENSION_DESC **ppExtensions,
                                                        __out ID3D12PipelineState **ppPSO);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__) && defined(__ID3D12PipelineLibrary1_INTERFACE_DEFINED__)
NVAPI_INTERFACE NvAPI_D3D12_CreatePipelineState(__in IUnknown *pDevice,
                                                __in const D3D12_PIPELINE_STATE_STREAM_DESC *pDesc,
                                                __in NvU32 numExtensions,
                                                __in const NVAPI_D3D12_PSO_EXTENSION_DESC **ppExtensions,
                                                __out ID3D12PipelineState **ppPipelineState);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_QueryAsyncComputeHint(__in ID3D12Device *pDevice, __out NvU32 *pIsRecommended);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_DecompressDepthStencilView(__in ID3D12GraphicsCommandList *pCommandList,
                                                       __in D3D12_CPU_DESCRIPTOR_HANDLE *pDSVCpuHandle);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CreateComputePipelineState(__in ID3D12Device *pDevice,
                                                       __in const D3D12_COMPUTE_PIPELINE_STATE_DESC *pPSODesc,
                                                       NvU32 numExtensions,
                                                       __in const NVAPI_D3D12_PSO_EXTENSION_DESC **ppExtensions,
                                                       __out ID3D12PipelineState **ppPSO);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_SetDepthBoundsTestValues(__in ID3D12GraphicsCommandList *pCommandList,
                                                     __in const float minDepth, __in const float maxDepth);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CreateReservedResource(__in ID3D12Device *pDevice, __in const D3D12_RESOURCE_DESC *pDesc,
                                                   __in D3D12_RESOURCE_STATES InitialState,
                                                   __in const D3D12_CLEAR_VALUE *pOptimizedClearValue, __in REFIID riid,
                                                   __out void **ppvResource, __in bool bTexture2DArrayMipPack,
                                                   __in ID3D12Heap *pHeap);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CreateHeap(__in ID3D12Device *pDevice, __in const D3D12_HEAP_DESC *pDesc, __in REFIID riid,
                                       __out void **ppvHeap);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef enum {
  NV_D3D12_HEAP_FLAG_NONE = 0,
  NV_D3D12_HEAP_FLAG_CPUVISIBLE_VIDMEM = 1,
} NV_D3D12_HEAP_FLAGS;
typedef struct _NV_HEAP_PARAMS_V1 {
  NvU32 version;
  NV_D3D12_HEAP_FLAGS NVHeapFlags;
} NV_HEAP_PARAMS_V1;
#define NV_HEAP_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_HEAP_PARAMS_V1, 1)
#define NV_HEAP_PARAMS_VER NV_HEAP_PARAMS_VER_1
typedef NV_HEAP_PARAMS_V1 NV_HEAP_PARAMS;
NVAPI_INTERFACE NvAPI_D3D12_CreateHeap2(__in ID3D12Device *pDevice, __in const D3D12_HEAP_DESC *pDesc,
                                        __in const NV_HEAP_PARAMS *pNVHeapParams, __in REFIID riid,
                                        __out void **ppvHeap);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_QueryCpuVisibleVidmem(__in ID3D12Device *pDevice, __out NvU64 *pTotalBytes,
                                                  __out NvU64 *pFreeBytes);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CreatePlacedResource(__in ID3D12Device *pDevice, __in ID3D12Heap *pHeap,
                                                 __in UINT64 HeapOffset, __in const D3D12_RESOURCE_DESC *pDesc,
                                                 __in D3D12_RESOURCE_STATES InitialState,
                                                 __in const D3D12_CLEAR_VALUE *pOptimizedClearValue, __in REFIID riid,
                                                 __out void **ppvResource);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_ReservedResourceGetDesc(__in ID3D12Resource *pReservedResource,
                                                    __out D3D12_RESOURCE_DESC *pDesc);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_UpdateTileMappings(
    __in ID3D12CommandQueue *pCommandQueue, __in ID3D12Resource *pResource, __in UINT NumResourceRegions,
    __in const D3D12_TILED_RESOURCE_COORDINATE *pResourceRegionStartCoordinates,
    __in const D3D12_TILE_REGION_SIZE *pResourceRegionSizes, __in ID3D12Heap *pHeap, __in UINT NumRanges,
    __in const D3D12_TILE_RANGE_FLAGS *pRangeFlags, __in const UINT *pHeapRangeStartOffsets,
    __in const UINT *pRangeTileCounts, __in D3D12_TILE_MAPPING_FLAGS Flags);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CopyTileMappings(__in ID3D12CommandQueue *pCommandQueue, __in ID3D12Resource *pDstResource,
                                             __in const D3D12_TILED_RESOURCE_COORDINATE *pDstRegionStartCoordinate,
                                             __in ID3D12Resource *pSrcResource,
                                             __in const D3D12_TILED_RESOURCE_COORDINATE *pSrcRegionStartCoordinate,
                                             __in const D3D12_TILE_REGION_SIZE *pRegionSize,
                                             __in D3D12_TILE_MAPPING_FLAGS Flags);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_ResourceAliasingBarrier(__in ID3D12GraphicsCommandList *pCommandList, __in UINT NumBarriers,
                                                    __in const D3D12_RESOURCE_BARRIER *pBarriers);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef struct {
  NvU32 version;
  NvU32 surfaceHandle;
  NvU64 gpuVAStart;
  NvU64 gpuVASize;
} NVAPI_UAV_INFO_V1;
typedef enum { NVAPI_UAV_INFO_FLAG_ZBC_SUPPORTED = 1 } NVAPI_UAV_INFO_FLAGS;
typedef struct {
  NvU32 version;
  NvU32 surfaceHandle;
  NvU64 gpuVAStart;
  NvU64 gpuVASize;
  NvU64 outFlags;
} NVAPI_UAV_INFO_V2;
#define NVAPI_UAV_INFO_VER1 1
#define NVAPI_UAV_INFO_VER2 MAKE_NVAPI_VERSION(NVAPI_UAV_INFO_V2, 2)
#define NVAPI_UAV_INFO_VER NVAPI_UAV_INFO_VER2
typedef NVAPI_UAV_INFO_V2 NVAPI_UAV_INFO;
NVAPI_INTERFACE NvAPI_D3D12_CaptureUAVInfo(__in ID3D12Device *pDevice, __out NVAPI_UAV_INFO *pUAVInfo);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef struct {
  NvU32 version;
  NVDX_ObjectHandle hResource;
  NvU64 gpuVAStart;
  NvU64 gpuVASize;
} NV_GET_GPU_VIRTUAL_ADDRESS_V1;
#define NV_GET_GPU_VIRTUAL_ADDRESS_VER1 MAKE_NVAPI_VERSION(NV_GET_GPU_VIRTUAL_ADDRESS_V1, 1)
#define NV_GET_GPU_VIRTUAL_ADDRESS_VER NV_GET_GPU_VIRTUAL_ADDRESS_VER1
#define NV_GET_GPU_VIRTUAL_ADDRESS NV_GET_GPU_VIRTUAL_ADDRESS_V1
NVAPI_INTERFACE NvAPI_D3D11_GetResourceGPUVirtualAddressEx(__in ID3D11Device *pDevice,
                                                           __inout NV_GET_GPU_VIRTUAL_ADDRESS *pParams);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
#pragma pack(push, 4)
struct NvAPI_TaskParams {
  bool m_useRefcount;
  bool m_refcountIncrementEnable;
  bool m_refcountDecrementEnable;
  NvU16 m_refcountIndex;
  NvU16 m_refcountDeltaMinusOne;
  NvU32 m_blockDimX;
  NvU32 m_blockDimY;
  NvU32 m_blockDimZ;
  NvU32 m_dynamicSharedMemBytes;
  NvU8 m_queueEntriesPerCtaLog2;
  NvU8 m_coalescingTimeoutDiv32;
  NvAPI_TaskParams()
      : m_useRefcount(false), m_refcountIncrementEnable(false), m_refcountDecrementEnable(false), m_refcountIndex(0),
        m_refcountDeltaMinusOne(0), m_blockDimX(1), m_blockDimY(1), m_blockDimZ(1), m_dynamicSharedMemBytes(0),
        m_queueEntriesPerCtaLog2(0), m_coalescingTimeoutDiv32(16) {}
};
#pragma pack(pop)
NVAPI_INTERFACE NvAPI_D3D12_GetSkedReflectedVA(__in ID3D12Device *pDevice, __out NvU64 *pSkedReflectedVA);
NVAPI_INTERFACE NvAPI_D3D12_CreateCubinTask(__in ID3D12Device *pDevice, __in_bcount(cubinSize) const void *pCubin,
                                            __in NvU32 cubinSize, __in const char *pKernelName,
                                            __in const NvAPI_TaskParams *taskParams, __out NVDX_ObjectHandle *phTask);
NVAPI_INTERFACE NvAPI_D3D12_GetTaskScratchSize(__in ID3D12Device *pDevice, __in NvU32 argsSize,
                                               __out NvU32 *pScratchSize, __out NvU32 *pScratchAlignment);
NVAPI_INTERFACE NvAPI_D3D12_InitCubinTask(__in ID3D12GraphicsCommandList *pCommandList, __in NVDX_ObjectHandle hTask,
                                          __in_bcount(argsSize) const void *pTaskArgs, __in NvU32 argsSize,
                                          __in NvU64 taskScratchVA);
NVAPI_INTERFACE NvAPI_D3D12_DispatchTasks(__in ID3D12GraphicsCommandList *pCommandList, __in NVDX_ObjectHandle hTask,
                                          __in NvU64 taskScratchVA, __in NvU32 numInstances);
NVAPI_INTERFACE NvAPI_D3D12_InvalidateTask(__in ID3D12GraphicsCommandList *pCommandList, __in NVDX_ObjectHandle hTask,
                                           __in NvU64 taskScratchVA);
NVAPI_INTERFACE NvAPI_D3D12_DestroyCubinTask(__in ID3D12Device *pDevice, __in NVDX_ObjectHandle hTask);
NVAPI_INTERFACE NvAPI_D3D12_SetSkedVspanOverflowBuffer(__in ID3D12GraphicsCommandList *pCommandList,
                                                       __in NvU64 vspanBufferVA, __in NvU32 size);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_SetCWDRefcount(__in ID3D12GraphicsCommandList *pCommandList, __in NvU16 index,
                                           __in NvU16 value);
#pragma pack(push, 4)
struct NVAPI_D3D12_TASK_DESC {
  bool UseRefcount;
  NvU16 RefcountIndex;
  NvU16 RefcountDebitAmount;
  NvU32 InstanceCountPerCta;
  NVAPI_D3D12_TASK_DESC() : UseRefcount(false), RefcountIndex(0), RefcountDebitAmount(0), InstanceCountPerCta(1) {}
};
#pragma pack(pop)
NVAPI_INTERFACE NvAPI_D3D12_CreateHLSLTask(__in ID3D12Device *pDevice, __in ID3D12RootSignature *pRootSignature,
                                           __in NvU32 nodeMask, __in D3D12_SHADER_BYTECODE *pShaderByteCode,
                                           __in NvU32 numExtensions,
                                           __in const NVAPI_D3D12_PSO_EXTENSION_DESC **ppExtensions,
                                           __in const NVAPI_D3D12_TASK_DESC *pTaskDesc, __out NVDX_ObjectHandle *phTask,
                                           __out NVDX_ObjectHandle *phTaskGpuHandle);
NVAPI_INTERFACE NvAPI_D3D12_BindRootArgsToTask(__in ID3D12GraphicsCommandList *pCommandList,
                                               __in NVDX_ObjectHandle hTask,
                                               __in D3D12_GPU_VIRTUAL_ADDRESS rootTableVA);
NVAPI_INTERFACE NvAPI_D3D12_DispatchHLSLTasks(__in ID3D12GraphicsCommandList *pCommandList,
                                              __in NVDX_ObjectHandle hTask, __in NvU32 numInstances);
NVAPI_INTERFACE NvAPI_D3D12_DestroyHLSLTask(__in ID3D12Device *pDevice, __in NVDX_ObjectHandle hTask);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__))
#pragma pack(push, 4)
enum NV_D3D_GRAPHICS_STATES {
  NV_D3D_GRAPHICS_STATE_NONE = 0,
  NV_D3D_GRAPHICS_STATE_IA_VERTEX_BUFFERS = (1 << 0),
  NV_D3D_GRAPHICS_STATE_IA_INDEX_BUFFER = (1 << 1),
  NV_D3D_GRAPHICS_STATE_IA_PRIMITIVE_TOPOLOGY = (1 << 2),
  NV_D3D_GRAPHICS_STATE_DESCRIPTOR_HEAP = (1 << 3),
  NV_D3D_GRAPHICS_STATE_GRAPHICS_ROOT_SIGNATURE = (1 << 4),
  NV_D3D_GRAPHICS_STATE_COMPUTE_ROOT_SIGNATURE = (1 << 5),
  NV_D3D_GRAPHICS_STATE_RS_VIEWPORTS = (1 << 6),
  NV_D3D_GRAPHICS_STATE_RS_SCISSOR_RECTS = (1 << 7),
  NV_D3D_GRAPHICS_STATE_PREDICATION = (1 << 8),
  NV_D3D_GRAPHICS_STATE_OM_RENDER_TARGETS = (1 << 9),
  NV_D3D_GRAPHICS_STATE_OM_STENCIL_REF = (1 << 10),
  NV_D3D_GRAPHICS_STATE_OM_BLEND_FACTOR = (1 << 11),
  NV_D3D_GRAPHICS_STATE_PIPELINE_STATE = (1 << 12),
  NV_D3D_GRAPHICS_STATE_SO_TARGETS = (1 << 13),
  NV_D3D_GRAPHICS_STATE_OM_DEPTH_BOUNDS = (1 << 14),
  NV_D3D_GRAPHICS_STATE_SAMPLE_POSITIONS = (1 << 15),
  NV_D3D_GRAPHICS_STATE_VIEW_INSTANCE_MASK = (1 << 16),
};
struct NVAPI_META_COMMAND_DESC {
  GUID Id;
  LPCWSTR Name;
  NV_D3D_GRAPHICS_STATES InitializationDirtyState;
  NV_D3D_GRAPHICS_STATES ExecutionDirtyState;
};
typedef NvU64 NV_META_COMMAND_BOOL;
#define NV_META_COMMAND_MAX_TENSOR_DIM 5
#define NV_META_COMMAND_ACTIVATION_MAX_PARAMS 2
#if __cplusplus >= 201103L
#define compile_time_assert(b) static_assert((b), "Compile time assertion failed: " #b)
enum NV_META_COMMAND_TENSOR_DATA_TYPE : NvU64 {
  NV_META_COMMAND_TENSOR_DATA_TYPE_FLOAT32,
  NV_META_COMMAND_TENSOR_DATA_TYPE_FLOAT16,
  NV_META_COMMAND_TENSOR_DATA_TYPE_UINT32,
  NV_META_COMMAND_TENSOR_DATA_TYPE_COUNT,
};
enum NV_META_COMMAND_TENSOR_LAYOUT : NvU64 {
  NV_META_COMMAND_TENSOR_LAYOUT_UNKNOWN,
  NV_META_COMMAND_TENSOR_LAYOUT_STANDARD,
  NV_META_COMMAND_TENSOR_LAYOUT_COUNT,
};
enum NV_META_COMMAND_TENSOR_FLAGS : NvU64 {
  NV_META_COMMAND_TENSOR_FLAG_NONE = 0,
  NV_META_COMMAND_TENSOR_FLAG_DATA_STATIC = 0x1,
};
enum NV_META_COMMAND_PRECISION : NvU64 {
  NV_META_COMMAND_PRECISION_FLOAT32,
  NV_META_COMMAND_PRECISION_FLOAT16,
  NV_META_COMMAND_PRECISION_MUL_FLOAT16_ADD_FLOAT32,
  NV_META_COMMAND_PRECISION_COUNT,
};
struct NV_META_COMMAND_TENSOR_DESC {
  NV_META_COMMAND_TENSOR_DATA_TYPE DataType;
  NV_META_COMMAND_TENSOR_LAYOUT Layout;
  NV_META_COMMAND_TENSOR_FLAGS Flags;
  NvU64 DimensionCount;
  NvU64 Size[NV_META_COMMAND_MAX_TENSOR_DIM];
  NvU64 Stride[NV_META_COMMAND_MAX_TENSOR_DIM];
};
enum NV_META_COMMAND_ACTIVATION_FUNCTION : NvU64 {
  NV_META_COMMAND_ACTIVATION_FUNCTION_ELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_HARDMAX,
  NV_META_COMMAND_ACTIVATION_FUNCTION_HARD_SIGMOID,
  NV_META_COMMAND_ACTIVATION_FUNCTION_IDENTITY,
  NV_META_COMMAND_ACTIVATION_FUNCTION_LEAKY_RELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_LINEAR,
  NV_META_COMMAND_ACTIVATION_FUNCTION_LOG_SOFTMAX,
  NV_META_COMMAND_ACTIVATION_FUNCTION_PARAMETERIZED_RELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_PARAMETRIC_SOFTPLUS,
  NV_META_COMMAND_ACTIVATION_FUNCTION_RELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SCALED_ELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SCALED_TANH,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SIGMOID,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SOFTMAX,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SOFTPLUS,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SOFTSIGN,
  NV_META_COMMAND_ACTIVATION_FUNCTION_TANH,
  NV_META_COMMAND_ACTIVATION_FUNCTION_THRESHOLDED_RELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_COUNT,
};
struct NV_META_COMMAND_ACTIVATION_DESC {
  NV_META_COMMAND_ACTIVATION_FUNCTION Function;
  float Params[NV_META_COMMAND_ACTIVATION_MAX_PARAMS];
};
#else
#define compile_time_assert(b) typedef char compile_time_assertion_failed_in_line_##__LINE__[(b) ? 1 : -1]
enum NV_META_COMMAND_TENSOR_DATA_TYPE {
  NV_META_COMMAND_TENSOR_DATA_TYPE_FLOAT32,
  NV_META_COMMAND_TENSOR_DATA_TYPE_FLOAT16,
  NV_META_COMMAND_TENSOR_DATA_TYPE_UINT32,
  NV_META_COMMAND_TENSOR_DATA_TYPE_COUNT,
};
enum NV_META_COMMAND_TENSOR_LAYOUT {
  NV_META_COMMAND_TENSOR_LAYOUT_UNKNOWN,
  NV_META_COMMAND_TENSOR_LAYOUT_STANDARD,
  NV_META_COMMAND_TENSOR_LAYOUT_COUNT,
};
enum NV_META_COMMAND_TENSOR_FLAGS {
  NV_META_COMMAND_TENSOR_FLAG_NONE = 0,
  NV_META_COMMAND_TENSOR_FLAG_DATA_STATIC = 0x1,
};
enum NV_META_COMMAND_PRECISION {
  NV_META_COMMAND_PRECISION_FLOAT32,
  NV_META_COMMAND_PRECISION_FLOAT16,
  NV_META_COMMAND_PRECISION_MUL_FLOAT16_ADD_FLOAT32,
  NV_META_COMMAND_PRECISION_COUNT,
};
struct NV_META_COMMAND_TENSOR_DESC {
  NvU64 DataType;
  NvU64 Layout;
  NvU64 Flags;
  NvU64 DimensionCount;
  NvU64 Size[NV_META_COMMAND_MAX_TENSOR_DIM];
  NvU64 Stride[NV_META_COMMAND_MAX_TENSOR_DIM];
};
enum NV_META_COMMAND_ACTIVATION_FUNCTION {
  NV_META_COMMAND_ACTIVATION_FUNCTION_ELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_HARDMAX,
  NV_META_COMMAND_ACTIVATION_FUNCTION_HARD_SIGMOID,
  NV_META_COMMAND_ACTIVATION_FUNCTION_IDENTITY,
  NV_META_COMMAND_ACTIVATION_FUNCTION_LEAKY_RELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_LINEAR,
  NV_META_COMMAND_ACTIVATION_FUNCTION_LOG_SOFTMAX,
  NV_META_COMMAND_ACTIVATION_FUNCTION_PARAMETERIZED_RELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_PARAMETRIC_SOFTPLUS,
  NV_META_COMMAND_ACTIVATION_FUNCTION_RELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SCALED_ELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SCALED_TANH,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SIGMOID,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SOFTMAX,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SOFTPLUS,
  NV_META_COMMAND_ACTIVATION_FUNCTION_SOFTSIGN,
  NV_META_COMMAND_ACTIVATION_FUNCTION_TANH,
  NV_META_COMMAND_ACTIVATION_FUNCTION_THRESHOLDED_RELU,
  NV_META_COMMAND_ACTIVATION_FUNCTION_COUNT,
};
struct NV_META_COMMAND_ACTIVATION_DESC {
  NvU64 Function;
  float Params[NV_META_COMMAND_ACTIVATION_MAX_PARAMS];
};
#endif
struct NV_META_COMMAND_OPTIONAL_TENSOR_DESC : NV_META_COMMAND_TENSOR_DESC {
  NV_META_COMMAND_BOOL IsNull;
};
struct NV_META_COMMAND_OPTIONAL_ACTIVATION_DESC : NV_META_COMMAND_ACTIVATION_DESC {
  NV_META_COMMAND_BOOL IsNull;
};
enum NV_META_COMMAND_PADDING_MODE {
  NV_META_COMMAND_PADDING_ZEROS,
  NV_META_COMMAND_PADDING_MIRROR,
  NV_META_COMMAND_PADDING_CLAMP,
  NV_META_COMMAND_PADDING_CONSTANT,
  NV_META_COMMAND_PADDING_COUNT,
};
struct NV_META_COMMAND_PADDING_DESC {
  NV_META_COMMAND_PADDING_MODE Mode;
  float ConstantPadVal;
};
enum NV_META_COMMAND_RESOURCE_TYPE {
  NV_META_COMMAND_RESOURCE_TYPE_INPUT = 0,
  NV_META_COMMAND_RESOURCE_TYPE_OUTPUT = 1,
  NV_META_COMMAND_RESOURCE_TYPE_FILTER = 2,
  NV_META_COMMAND_RESOURCE_TYPE_WEIGHT = 2,
  NV_META_COMMAND_RESOURCE_TYPE_BIAS = 3,
  NV_META_COMMAND_RESOURCE_TYPE_MATRIX_A = 0,
  NV_META_COMMAND_RESOURCE_TYPE_MATRIX_B = 2,
  NV_META_COMMAND_RESOURCE_TYPE_MATRIX_C = 3,
  NV_META_COMMAND_RESOURCE_TYPE_PERSISTENT = 4,
  NV_META_COMMAND_RESOURCE_TYPE_TEMPORARY = 5,
};
static const GUID MetaCommand_ConvolutionEx = {
    0xa7666f1e, 0x9c55, 0x47ee, {0x9e, 0xb3, 0xe1, 0x62, 0x0, 0x92, 0xd1, 0xe9}};
#define NV_META_COMMAND_NUM_SPATIAL_DIM 3
#if __cplusplus >= 201103L
enum NV_META_COMMAND_CONVOLUTION_DIRECTION : NvU64 {
  NV_META_COMMAND_CONVOLUTION_DIRECTION_FORWARD,
  NV_META_COMMAND_CONVOLUTION_DIRECTION_BACKWARD,
  NV_META_COMMAND_CONVOLUTION_DIRECTION_COUNT,
};
enum NV_META_COMMAND_CONVOLUTION_MODE : NvU64 {
  NV_META_COMMAND_CONVOLUTION_MODE_CONVOLUTION,
  NV_META_COMMAND_CONVOLUTION_MODE_CROSS_CORRELATION,
  NV_META_COMMAND_CONVOLUTION_MODE_COUNT,
};
struct NV_META_COMMAND_CREATE_CONVOLUTION_EX_DESC {
  NV_META_COMMAND_TENSOR_DESC DescIn;
  NV_META_COMMAND_TENSOR_DESC DescFilter;
  NV_META_COMMAND_OPTIONAL_TENSOR_DESC DescBias;
  NV_META_COMMAND_TENSOR_DESC DescOut;
  NV_META_COMMAND_CONVOLUTION_MODE Mode;
  NV_META_COMMAND_CONVOLUTION_DIRECTION Direction;
  NV_META_COMMAND_PRECISION Precision;
  NV_META_COMMAND_OPTIONAL_ACTIVATION_DESC Activation;
  NV_META_COMMAND_PADDING_DESC Padding;
  NV_META_COMMAND_BOOL PerChannelScaling;
  float Alpha1;
  float Alpha2;
  NvU64 Stride[NV_META_COMMAND_NUM_SPATIAL_DIM];
  NvU64 Dilation[NV_META_COMMAND_NUM_SPATIAL_DIM];
  NvU64 StartPadding[NV_META_COMMAND_NUM_SPATIAL_DIM];
  NvU64 EndPadding[NV_META_COMMAND_NUM_SPATIAL_DIM];
  NvU64 DimensionCount;
  NvU64 GroupCount;
};
#else
enum NV_META_COMMAND_CONVOLUTION_DIRECTION {
  NV_META_COMMAND_CONVOLUTION_DIRECTION_FORWARD,
  NV_META_COMMAND_CONVOLUTION_DIRECTION_BACKWARD,
  NV_META_COMMAND_CONVOLUTION_DIRECTION_COUNT,
};
enum NV_META_COMMAND_CONVOLUTION_MODE {
  NV_META_COMMAND_CONVOLUTION_MODE_CONVOLUTION,
  NV_META_COMMAND_CONVOLUTION_MODE_CROSS_CORRELATION,
  NV_META_COMMAND_CONVOLUTION_MODE_COUNT,
};
struct NV_META_COMMAND_CREATE_CONVOLUTION_EX_DESC {
  NV_META_COMMAND_TENSOR_DESC DescIn;
  NV_META_COMMAND_TENSOR_DESC DescFilter;
  NV_META_COMMAND_OPTIONAL_TENSOR_DESC DescBias;
  NV_META_COMMAND_TENSOR_DESC DescOut;
  NvU64 Mode;
  NvU64 Direction;
  NvU64 Precision;
  NV_META_COMMAND_OPTIONAL_ACTIVATION_DESC Activation;
  NV_META_COMMAND_PADDING_DESC Padding;
  NV_META_COMMAND_BOOL PerChannelScaling;
  float Alpha1;
  float Alpha2;
  NvU64 Stride[NV_META_COMMAND_NUM_SPATIAL_DIM];
  NvU64 Dilation[NV_META_COMMAND_NUM_SPATIAL_DIM];
  NvU64 StartPadding[NV_META_COMMAND_NUM_SPATIAL_DIM];
  NvU64 EndPadding[NV_META_COMMAND_NUM_SPATIAL_DIM];
  NvU64 DimensionCount;
  NvU64 GroupCount;
};
#endif
static const GUID MetaCommand_ConvolutionExFused = {
    0xe1b112eb, 0xdecd, 0x4ff6, {0x85, 0xbb, 0x1f, 0xe, 0x3a, 0xb0, 0x4, 0x14}};
enum NV_META_COMMAND_CONVOLUTION_POOL_MODE {
  NV_META_COMMAND_CONVOLUTION_POOL_MODE_NONE,
  NV_META_COMMAND_CONVOLUTION_POOL_MODE_REDUCTION_MAX,
  NV_META_COMMAND_CONVOLUTION_POOL_MODE_REDUCTION_AVG,
  NV_META_COMMAND_CONVOLUTION_POOL_MODE_REDUCTION_MIN,
  NV_META_COMMAND_CONVOLUTION_POOL_MODE_COUNT,
};
enum NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE {
  NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE_NONE,
  NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE_REPLICATE,
  NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE_BILINEAR,
  NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE_COUNT,
};
enum NV_META_COMMAND_CONVOLUTION_SKIP_MODE {
  NV_META_COMMAND_CONVOLUTION_SKIP_MODE_NONE,
  NV_META_COMMAND_CONVOLUTION_SKIP_MODE_ADD,
  NV_META_COMMAND_CONVOLUTION_SKIP_MODE_CONCAT,
  NV_META_COMMAND_CONVOLUTION_SKIP_MODE_COUNT,
};
struct NV_META_COMMAND_CONVOLUTION_FUSE_DESC {
  NV_META_COMMAND_CONVOLUTION_POOL_MODE PoolMode;
  NV_META_COMMAND_CONVOLUTION_UPSAMPLE_MODE UpsampleMode;
  NV_META_COMMAND_CONVOLUTION_SKIP_MODE SkipMode;
  NV_META_COMMAND_BOOL OutputPrepool;
};
struct NV_META_COMMAND_CREATE_CONVOLUTION_EX_FUSED_DESC : NV_META_COMMAND_CREATE_CONVOLUTION_EX_DESC {
  NV_META_COMMAND_CONVOLUTION_FUSE_DESC FuseDesc;
};
compile_time_assert(sizeof(NV_META_COMMAND_TENSOR_DESC) == 112);
compile_time_assert(sizeof(NV_META_COMMAND_CREATE_CONVOLUTION_EX_DESC) == 640);
compile_time_assert(sizeof(NV_META_COMMAND_CONVOLUTION_FUSE_DESC) == 20);
compile_time_assert(sizeof(NV_META_COMMAND_CREATE_CONVOLUTION_EX_FUSED_DESC) == 660);
static const GUID MetaCommand_Gemm = {0x8f9ff059, 0xfe72, 0x488e, {0xa0, 0x66, 0xb1, 0x4e, 0x79, 0x48, 0xec, 0x8}};
#if __cplusplus >= 201103L
enum NV_META_COMMAND_MATRIX_TRANSFORM : NvU64 {
  NV_META_COMMAND_MATRIX_TRANSFORM_NONE,
  NV_META_COMMAND_MATRIX_TRANSFORM_TRANSPOSE,
  NV_META_COMMAND_MATRIX_TRANSFORM_COUNT,
};
struct NV_META_COMMAND_CREATE_GEMM_DESC {
  NV_META_COMMAND_TENSOR_DESC DescA;
  NV_META_COMMAND_TENSOR_DESC DescB;
  NV_META_COMMAND_OPTIONAL_TENSOR_DESC DescC;
  NV_META_COMMAND_TENSOR_DESC DescOut;
  NV_META_COMMAND_PRECISION Precision;
  NV_META_COMMAND_MATRIX_TRANSFORM TransA;
  NV_META_COMMAND_MATRIX_TRANSFORM TransB;
  float Alpha;
  float Beta;
  NV_META_COMMAND_OPTIONAL_ACTIVATION_DESC Activation;
};
#else
enum NV_META_COMMAND_MATRIX_TRANSFORM {
  NV_META_COMMAND_MATRIX_TRANSFORM_NONE,
  NV_META_COMMAND_MATRIX_TRANSFORM_TRANSPOSE,
  NV_META_COMMAND_MATRIX_TRANSFORM_COUNT,
};
struct NV_META_COMMAND_CREATE_GEMM_DESC {
  NV_META_COMMAND_TENSOR_DESC DescA;
  NV_META_COMMAND_TENSOR_DESC DescB;
  NV_META_COMMAND_OPTIONAL_TENSOR_DESC DescC;
  NV_META_COMMAND_TENSOR_DESC DescOut;
  NvU64 Precision;
  NvU64 TransA;
  NvU64 TransB;
  float Alpha;
  float Beta;
  NV_META_COMMAND_OPTIONAL_ACTIVATION_DESC Activation;
};
#endif
#pragma pack(pop)
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_EnumerateMetaCommands(__in ID3D11Device *pDevice, __inout NvU32 *pNumMetaCommands,
                                                  __out_ecount_opt(*pNumMetaCommands) NVAPI_META_COMMAND_DESC *pDescs);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
#pragma pack(push, 4)
struct NV_D3D11_META_COMMAND_RESOURCE {
  union {
    NVDX_ObjectHandle ResourceHandle;
    NvU64 unused;
  };
  NvU64 Offset;
};
struct NV_D3D11_META_COMMAND_INITIALIZE_CONVOLUTION_EX_DESC {
  NV_D3D11_META_COMMAND_RESOURCE PersistentResource;
};
struct NV_D3D11_META_COMMAND_EXECUTE_CONVOLUTION_EX_DESC {
  NV_D3D11_META_COMMAND_RESOURCE InputResource;
  NV_D3D11_META_COMMAND_RESOURCE FilterResource;
  NV_D3D11_META_COMMAND_RESOURCE BiasResource;
  NV_D3D11_META_COMMAND_RESOURCE OutputResource;
  NV_D3D11_META_COMMAND_RESOURCE Alpha1Resource;
  NV_D3D11_META_COMMAND_RESOURCE Alpha2Resource;
  NV_D3D11_META_COMMAND_RESOURCE SkipConnectionResource;
  NV_D3D11_META_COMMAND_RESOURCE PersistentResource;
  NV_D3D11_META_COMMAND_RESOURCE TemporaryResource;
};
compile_time_assert(sizeof(NV_D3D11_META_COMMAND_INITIALIZE_CONVOLUTION_EX_DESC) == 16);
compile_time_assert(sizeof(NV_D3D11_META_COMMAND_EXECUTE_CONVOLUTION_EX_DESC) == 144);
struct NV_D3D11_META_COMMAND_INITIALIZE_GEMM_DESC {
  NV_D3D11_META_COMMAND_RESOURCE PersistentResource;
};
struct NV_D3D11_META_COMMAND_EXECUTE_GEMM_DESC {
  NV_D3D11_META_COMMAND_RESOURCE AResource;
  NV_D3D11_META_COMMAND_RESOURCE BResource;
  NV_D3D11_META_COMMAND_RESOURCE CResource;
  NV_D3D11_META_COMMAND_RESOURCE OutputResource;
  NV_D3D11_META_COMMAND_RESOURCE PersistentResource;
  NV_D3D11_META_COMMAND_RESOURCE TemporaryResource;
};
compile_time_assert(sizeof(NV_D3D11_META_COMMAND_INITIALIZE_GEMM_DESC) == 16);
compile_time_assert(sizeof(NV_D3D11_META_COMMAND_EXECUTE_GEMM_DESC) == 96);
#pragma pack(pop)
DECLARE_INTERFACE_(__declspec(uuid("00BF193A-117B-42BC-BBCD-E964A0EA4F2B")) ID3D11NvMetaCommand_V1, IUnknown) {
  BEGIN_INTERFACE
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  STDMETHOD(GetRequiredParameterResourceSize)(THIS_ NV_META_COMMAND_RESOURCE_TYPE ResourceType, NvU64 * SizeInBytes)
      const PURE;
  END_INTERFACE
};
typedef ID3D11NvMetaCommand_V1 ID3D11NvMetaCommand;
#define ID3D11NvMetaCommand_VER1 MAKE_NVAPI_VERSION(IID3D11NvMetaCommand_V1, 1)
#define ID3D11NvMetaCommand_VER ID3D11NvMetaCommand_VER1
NVAPI_INTERFACE NvAPI_D3D11_CreateMetaCommand(__in ID3D11Device *pDevice, __in REFGUID CommandId,
                                              __in_bcount(CreationParametersDataSize)
                                                  const void *pCreationParametersData,
                                              __in NvU32 CreationParametersDataSize,
                                              __out ID3D11NvMetaCommand **ppMetaCommand);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_InitializeMetaCommand(__in ID3D11DeviceContext *pDeviceContext,
                                                  __in ID3D11NvMetaCommand *pMetaCommand,
                                                  __in_bcount(InitializationParametersDataSize)
                                                      const void *pInitializationParametersData,
                                                  __in NvU32 InitializationParametersDataSize);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_ExecuteMetaCommand(__in ID3D11DeviceContext *pDeviceContext,
                                               __in ID3D11NvMetaCommand *pMetaCommand,
                                               __in_bcount(ExecutionParametersDataSize)
                                                   const void *pExecutionParametersData,
                                               __in NvU32 ExecutionParametersDataSize);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_EnumerateMetaCommands(__in ID3D12Device *pDevice, __inout NvU32 *pNumMetaCommands,
                                                  __out_ecount_opt(*pNumMetaCommands) NVAPI_META_COMMAND_DESC *pDescs);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
#pragma pack(push, 4)
struct NV_D3D12_META_COMMAND_INITIALIZE_CONVOLUTION_EX_DESC {
  D3D12_GPU_VIRTUAL_ADDRESS PersistentResource;
};
struct NV_D3D12_META_COMMAND_EXECUTE_CONVOLUTION_EX_DESC {
  D3D12_GPU_VIRTUAL_ADDRESS InputResource;
  D3D12_GPU_VIRTUAL_ADDRESS FilterResource;
  D3D12_GPU_VIRTUAL_ADDRESS BiasResource;
  D3D12_GPU_VIRTUAL_ADDRESS OutputResource;
  D3D12_GPU_VIRTUAL_ADDRESS Alpha1Resource;
  D3D12_GPU_VIRTUAL_ADDRESS Alpha2Resource;
  D3D12_GPU_VIRTUAL_ADDRESS SkipConnectionResource;
  D3D12_GPU_VIRTUAL_ADDRESS PersistentResource;
  D3D12_GPU_VIRTUAL_ADDRESS TemporaryResource;
};
compile_time_assert(sizeof(NV_D3D12_META_COMMAND_INITIALIZE_CONVOLUTION_EX_DESC) == 8);
compile_time_assert(sizeof(NV_D3D12_META_COMMAND_EXECUTE_CONVOLUTION_EX_DESC) == 72);
struct NV_D3D12_META_COMMAND_INITIALIZE_GEMM_DESC {
  NvU64 PersistentResource;
};
struct NV_D3D12_META_COMMAND_EXECUTE_GEMM_DESC {
  NvU64 AResource;
  NvU64 BResource;
  NvU64 CResource;
  NvU64 OutputResource;
  NvU64 PersistentResource;
  NvU64 TemporaryResource;
};
compile_time_assert(sizeof(NV_D3D12_META_COMMAND_INITIALIZE_GEMM_DESC) == 8);
compile_time_assert(sizeof(NV_D3D12_META_COMMAND_EXECUTE_GEMM_DESC) == 48);
#pragma pack(pop)
DECLARE_INTERFACE_(__declspec(uuid("00BF193A-117B-42BC-BBCD-E964A0EA4F2B")) ID3D12NvMetaCommand_V1, IUnknown) {
  BEGIN_INTERFACE
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  STDMETHOD(GetRequiredParameterResourceSize)(THIS_ NV_META_COMMAND_RESOURCE_TYPE ResourceType, NvU64 * SizeInBytes)
      const PURE;
  END_INTERFACE
};
typedef ID3D12NvMetaCommand_V1 ID3D12NvMetaCommand;
#define ID3D12NvMetaCommand_VER1 MAKE_NVAPI_VERSION(IID3D12NvMetaCommand_V1, 1)
#define ID3D12NvMetaCommand_VER ID3D12NvMetaCommand_VER1
NVAPI_INTERFACE NvAPI_D3D12_CreateMetaCommand(__in ID3D12Device *pDevice, __in REFGUID CommandId, __in NvU32 NodeMask,
                                              __in_bcount(CreationParametersDataSize)
                                                  const void *pCreationParametersData,
                                              __in NvU32 CreationParametersDataSize,
                                              __out ID3D12NvMetaCommand **ppMetaCommand);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_InitializeMetaCommand(__in ID3D12GraphicsCommandList *pCommandlist,
                                                  __in ID3D12NvMetaCommand *pMetaCommand,
                                                  __in_bcount(InitializationParametersDataSize)
                                                      const void *pInitializationParametersData,
                                                  __in NvU32 InitializationParametersDataSize);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_ExecuteMetaCommand(__in ID3D12GraphicsCommandList *pCommandlist,
                                               __in ID3D12NvMetaCommand *pMetaCommand,
                                               __in_bcount(ExecutionParametersDataSize)
                                                   const void *pExecutionParametersData,
                                               __in NvU32 ExecutionParametersDataSize);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef enum {
  NV_D3D12_RESOURCE_FLAG_NONE = 0,
  NV_D3D12_RESOURCE_FLAG_HTEX = 1,
  NV_D3D12_RESOURCE_FLAG_CPUVISIBLE_VIDMEM = 2,
} NV_D3D12_RESOURCE_FLAGS;
typedef struct _NV_RESOURCE_PARAMS_V1 {
  NvU32 version;
  NV_D3D12_RESOURCE_FLAGS NVResourceFlags;
} NV_RESOURCE_PARAMS_V1;
#define NV_RESOURCE_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_RESOURCE_PARAMS_V1, 1)
#define NV_RESOURCE_PARAMS_VER NV_RESOURCE_PARAMS_VER_1
typedef NV_RESOURCE_PARAMS_V1 NV_RESOURCE_PARAMS;
NVAPI_INTERFACE NvAPI_D3D12_CreateCommittedResource(
    __in ID3D12Device *pDevice, __in const D3D12_HEAP_PROPERTIES *pHeapProperties, __in D3D12_HEAP_FLAGS HeapFlags,
    __in const D3D12_RESOURCE_DESC *pDesc, __in D3D12_RESOURCE_STATES InitialState,
    __in const D3D12_CLEAR_VALUE *pOptimizedClearValue, __in const NV_RESOURCE_PARAMS *pNVResourceParams,
    __in REFIID riid, __out_opt void **ppvResource, __out_opt bool *pSupported);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_GetCopyableFootprints(
    __in ID3D12Device *pDevice, __in const D3D12_RESOURCE_DESC *pResourceDesc,
    __in const NV_RESOURCE_PARAMS *pNVResourceParams, __in UINT FirstSubresource, __in UINT NumSubresources,
    __in UINT64 BaseOffset, __out_ecount_opt(NumSubresources) D3D12_PLACED_SUBRESOURCE_FOOTPRINT *pLayouts,
    __out_ecount_opt(NumSubresources) UINT *pNumRows, __out_ecount_opt(NumSubresources) UINT64 *pRowSizeInBytes,
    __out_opt UINT64 *pTotalBytes);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CopyTextureRegion(__in ID3D12GraphicsCommandList *pCommandList,
                                              __in const D3D12_TEXTURE_COPY_LOCATION *pDst, __in UINT DstX,
                                              __in UINT DstY, __in UINT DstZ,
                                              __in const D3D12_TEXTURE_COPY_LOCATION *pSrc,
                                              __in_opt const D3D12_BOX *pSrcBox);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_SetDriverDebugState(__in ID3D12GraphicsCommandList *pCommandList, __in NvU32 stateEnum,
                                                __in NvU32 stateValue);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_SetDriverDebugStateCQ(__in ID3D12CommandQueue *pCommandQueue, __in NvU32 stateEnum,
                                                  __in NvU32 stateValue);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_SetDriverDebugString(__in ID3D12GraphicsCommandList *pCommandList, __in NvU32 stateEnum,
                                                 __in const wchar_t *pStateString);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_SetDriverDebugStringCQ(__in ID3D12CommandQueue *pCommandQueue, __in NvU32 stateEnum,
                                                   __in const wchar_t *pStateString);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_IsNvShaderExtnOpCodeSupported(__in ID3D12Device *pDevice, __in NvU32 opCode,
                                                          __out bool *pSupported);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef enum _NVAPI_LOADBALANCE_MODE {
  NVAPI_LOADBALANCE_FORCE_CPU_LIMITED = 0,
  NVAPI_LOADBALANCE_FORCE_GPU_LIMITED = 1,
  NVAPI_LOADBALANCE_FORCE_LOADBALANCE = 2,
} NVAPI_LOADBALANCE_MODE;
typedef struct _NV_LOADBALANCER_PARAMS_V1 {
  NvU32 version;
  NVAPI_LOADBALANCE_MODE mode;
} NV_LOADBALANCER_PARAMS_V1;
#define NV_LOADBALANCER_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_LOADBALANCER_PARAMS_V1, 1)
#define NV_LOADBALANCER_PARAMS_VER NV_LOADBALANCER_PARAMS_VER_1
typedef NV_LOADBALANCER_PARAMS_V1 NV_LOADBALANCER_PARAMS;
NVAPI_INTERFACE NvAPI_D3D12_ForceLoadBalanceMode(__in ID3D12Device *pDevice,
                                                 __in const NV_LOADBALANCER_PARAMS *pNvLoadBalancerParams);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef enum _NVAPI_BACKGROUNDSHADERCOMPILES_MODE {
  NVAPI_BACKGROUND_SHADER_COMPILES_DISABLE = 0,
  NVAPI_BACKGROUND_SHADER_COMPILES_ENABLE = 1,
} NVAPI_BACKGROUNDSHADERCOMPILES_MODE;
typedef enum _NVAPI_BACKGROUNDSHADERCOMPILES_CONTROL_MASK {
  NVAPI_BACKGROUND_SHADER_COMPILES_NONE = 0,
  NVAPI_BACKGROUND_SHADER_COMPILES_NON_RT_OPTIONALS = 1,
  NVAPI_BACKGROUND_SHADER_COMPILES_RT_OPTIONALS = 2,
} NVAPI_BACKGROUNDSHADERCOMPILES_CONTROL_MASK;
typedef struct _NV_BACKGROUND_SHADER_COMPILES_PARAMS_V1 {
  NvU32 version;
  NVAPI_BACKGROUNDSHADERCOMPILES_MODE mode;
  NvU32 mask;
} NV_BACKGROUND_SHADER_COMPILES_PARAMS_V1;
#define NV_BACKGROUND_SHADER_COMPILES_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_BACKGROUND_SHADER_COMPILES_PARAMS_V1, 1)
#define NV_BACKGROUND_SHADER_COMPILES_PARAMS_VER NV_BACKGROUND_SHADER_COMPILES_PARAMS_VER_1
typedef NV_BACKGROUND_SHADER_COMPILES_PARAMS_V1 NV_BACKGROUND_SHADER_COMPILES_PARAMS;
NVAPI_INTERFACE NvAPI_D3D12_SetAllowBackgroundShaderCompiles(
    __in ID3D12Device *pDevice, __in NV_BACKGROUND_SHADER_COMPILES_PARAMS *pNvBackgroundShaderCompilesParams);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef struct _NV_PENDING_BACKGROUND_COMPILES_PARAMS_V1 {
  NvU32 version;
  bool bHasPendingBackgroundCompiles;
} NV_PENDING_BACKGROUND_COMPILES_PARAMS_V1;
#define NV_PENDING_BACKGROUND_COMPILES_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_PENDING_BACKGROUND_COMPILES_PARAMS_V1, 1)
#define NV_PENDING_BACKGROUND_COMPILES_PARAMS_VER NV_PENDING_BACKGROUND_COMPILES_PARAMS_VER_1
typedef NV_PENDING_BACKGROUND_COMPILES_PARAMS_V1 NV_PENDING_BACKGROUND_COMPILES_PARAMS;
NVAPI_INTERFACE NvAPI_D3D12_HasPendingBackgroundShaderCompiles(
    __in ID3D12Device *pDevice, __inout NV_PENDING_BACKGROUND_COMPILES_PARAMS *pNvPendingBackgroundCompilesParams);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_GetOptimalThreadCountForMesh(__in ID3D12Device *pDevice, __out NvU32 *pThreadCount);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_IsNvMeshShaderSupported(__in ID3D12Device *pDevice, __out bool *pSupported);
NVAPI_INTERFACE NvAPI_D3D12_DispatchGraphics(__in ID3D12GraphicsCommandList *pCommandList, __in NvU32 numDispatches);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct _NV_FBC_CAPTURE_PARAMS_V1 {
  NvU32 version;
  NvU32 dwBufferIndex;
  NvU32 dwFlags;
  NvU32 dwGrabMode;
  NvU32 dwTargetWidth;
  NvU32 dwTargetHeight;
  NvU32 dwBlend;
  NvU32 dwStartX;
  NvU32 dwStartY;
} NV_FBC_CAPTURE_PARAMS_V1;
#define NV_FBC_CAPTURE_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_FBC_CAPTURE_PARAMS_V1, 1)
typedef struct _NV_FBC_CAPTURE_PARAMS_V2 {
  NvU32 version;
  NvU32 dwBufferIndex;
  NvU32 dwFlags;
  NvU32 dwGrabMode;
  NvU32 dwTargetWidth;
  NvU32 dwTargetHeight;
  NvU32 dwBlend;
  NvU32 dwStartX;
  NvU32 dwStartY;
  NvU32 isSrcFromSysMem;
  NvU64 qwSysMemPointer;
  NvU32 dwSourceWidth;
  NvU32 dwSourceHeight;
} NV_FBC_CAPTURE_PARAMS_V2;
#define NV_FBC_CAPTURE_PARAMS_VER_2 MAKE_NVAPI_VERSION(NV_FBC_CAPTURE_PARAMS_V2, 2)
typedef struct _NV_FBC_CAPTURE_PARAMS_V3 {
  NvU32 version;
  NvU32 dwBufferIndex;
  NvU32 dwFlags;
  NvU32 dwGrabMode;
  NvU32 dwTargetWidth;
  NvU32 dwTargetHeight;
  NvU32 dwBlend;
  NvU32 dwStartX;
  NvU32 dwStartY;
  NvU32 isSrcFromSysMem;
  NvU64 qwSysMemPointer;
  NvU32 dwSourceWidth;
  NvU32 dwSourceHeight;
  NvU32 bIsYUV444;
} NV_FBC_CAPTURE_PARAMS_V3;
#define NV_FBC_CAPTURE_PARAMS_VER_3 MAKE_NVAPI_VERSION(NV_FBC_CAPTURE_PARAMS_V3, 3)
typedef struct _NV_FBC_CAPTURE_PARAMS_V4 {
  NvU32 version;
  NvU32 dwBufferIndex;
  NvU32 dwFlags;
  NvU32 dwGrabMode;
  NvU32 dwTargetWidth;
  NvU32 dwTargetHeight;
  NvU32 dwBlend;
  NvU32 dwStartX;
  NvU32 dwStartY;
  NvU32 isSrcFromSysMem;
  NvU64 qwSysMemPointer;
  NvU32 dwSourceWidth;
  NvU32 dwSourceHeight;
  NvU32 bIsYUV444;
  NvU32 dwWaitTime;
  NVFBC_BUFFER_FORMAT eFormat;
  NvU64 hVertexBuffer;
} NV_FBC_CAPTURE_PARAMS_V4;
#define NV_FBC_CAPTURE_PARAMS_VER_4 MAKE_NVAPI_VERSION(NV_FBC_CAPTURE_PARAMS_V4, 4)
#define NV_FBC_CAPTURE_PARAMS_VER NV_FBC_CAPTURE_PARAMS_VER_4
typedef NV_FBC_CAPTURE_PARAMS_V4 NV_FBC_CAPTURE_PARAMS;
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_Prefilter_CaptureBufferToNV12BLVideoSurface(
    __in IDirect3DDevice9 *pDev, __in NV_FBC_CAPTURE_PARAMS *pNvfbcCaptureParams, __out void *pDataGrabInfo);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToSys_2(__in IDirect3DDevice9 *pDev, __out void *pNvFBCFrameGrabInfo,
                                                      __in NV_FBC_CAPTURE_PARAMS *pNvfbcCaptureParams);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_CaptureBufferToCUDAWithFormat_2(__in IDirect3DDevice9 *pDev,
                                                                 __out void *pNvFBCFrameGrabInfo,
                                                                 __in NV_FBC_CAPTURE_PARAMS *pParams);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct _NV_FBC_CAPTURE_TO_CUDA_PARAMS_V1 {
  NvU32 version;
  NvU64 qwVertexBuffer;
  NvU32 dwFlags;
  NvU32 dwFormat;
  NvU32 isSrcFromSysMem;
  NvU64 qwSysMemPointer;
  NvU32 dwSourceWidth;
  NvU32 dwSourceHeight;
} NV_FBC_CAPTURE_TO_CUDA_PARAMS_V1;
#define NV_FBC_CAPTURE_TO_CUDA_PARAMS_VER_1 MAKE_NVAPI_VERSION(NV_FBC_CAPTURE_TO_CUDA_PARAMS_V1, 1)
#define NV_FBC_CAPTURE_TO_CUDA_PARAMS_VER NV_FBC_CAPTURE_TO_CUDA_PARAMS_VER_1
typedef NV_FBC_CAPTURE_TO_CUDA_PARAMS_V1 NV_FBC_CAPTURE_TO_CUDA_PARAMS;
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SysmemToCUDAWithFormat(__in IDirect3DDevice9 *pDev,
                                                        __in NV_FBC_CAPTURE_TO_CUDA_PARAMS *pNvFbcCaptureToCudaParams,
                                                        __out void *pNvFBCFrameGrabInfo);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef struct {
  NvU32 version;
  NVFBC_BUFFER_FORMAT format;
  NvU32 bHDRRequest : 1;
  NvU32 bReservedBits : 31;
  NvU32 dwReserved[32];
  void *pReserved[16];
} NVFBC_SETUP_TOCUDA_PARAM;
#define NVFBC_SETUP_TOCUDA_PARAM_VER MAKE_NVAPI_VERSION(NVFBC_SETUP_TOCUDA_PARAM, 1)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SetUpToCUDA(__in IDirect3DDevice9 *pDev, __inout NVFBC_SETUP_TOCUDA_PARAM *pParam);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_NVFBC_SysmemToNV12BLVideoSurface(__in IDirect3DDevice9 *pDev,
                                                            __in NV_FBC_CAPTURE_PARAMS *pNvfbcCaptureParams,
                                                            __out void *pDataGrabInfo);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_GetVRRState(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface,
                                      __out_opt BOOL *pisVrrEnabled, __out_opt BOOL *pisVrrRequested);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_IsGSyncCapable(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface,
                                         __out BOOL *pIsGsyncCapable);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_IsGSyncActive(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface,
                                        __out BOOL *pIsGsyncActive);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_SetVRRState(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface,
                                      __in BOOL enable);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
#define NV_FLIP_PATTERNS_BUFFER_SIZE 7
typedef struct _NV_FLIP_PATTERN_DATA_V1 {
  NvU32 version;
  NvU8 isLastCall;
  NvU32 lastQueriedFlip;
  NvU64 currentTimestamp;
  NvU64 timestampFrequency;
  NvU64 flipTimestamps[NV_FLIP_PATTERNS_BUFFER_SIZE];
  NvU32 numFlipsReturned;
  NvU8 hasMoreData;
} NV_FLIP_PATTERN_DATA_V1;
#define NV_FLIP_PATTERN_DATA_VER1 MAKE_NVAPI_VERSION(NV_FLIP_PATTERN_DATA_V1, 1)
typedef struct _NV_FLIP_PATTERN_DATA_V2 {
  NvU32 version;
  NvU8 isLastCall;
  NvU32 lastQueriedFlip;
  NvU64 currentTimestamp;
  NvU64 timestampFrequency;
  NvU64 flipTimestamps[NV_FLIP_PATTERNS_BUFFER_SIZE];
  NvU32 numFlipsReturned;
  NvU8 hasMoreData;
  NvU8 writeData;
} NV_FLIP_PATTERN_DATA_V2;
typedef struct _NV_FLIP_PATTERN_DATA_V3 {
  NvU32 version;
  NvU8 isLastCall;
  NvU32 lastQueriedFlip;
  NvU64 currentTimestamp;
  NvU64 timestampFrequency;
  NvU64 flipTimestamps[NV_FLIP_PATTERNS_BUFFER_SIZE];
  NvU32 numFlipsReturned;
  NvU8 hasMoreData;
  NvU8 writeData;
  float animTimes[NV_FLIP_PATTERNS_BUFFER_SIZE];
  NvU64 umdDecoupledFlipTS[NV_FLIP_PATTERNS_BUFFER_SIZE];
} NV_FLIP_PATTERN_DATA_V3;
#define NV_FLIP_PATTERN_DATA_VER3 MAKE_NVAPI_VERSION(NV_FLIP_PATTERN_DATA_V3, 3)
#define NV_FLIP_PATTERN_DATA_VER2 MAKE_NVAPI_VERSION(NV_FLIP_PATTERN_DATA_V2, 2)
#define NV_FLIP_PATTERN_DATA_VER NV_FLIP_PATTERN_DATA_VER3
typedef NV_FLIP_PATTERN_DATA_V3 NV_FLIP_PATTERN_DATA;
NVAPI_INTERFACE NvAPI_D3D_GetFlipPattern(__in IUnknown *pDeviceOrContext, __in NVDX_ObjectHandle primarySurface,
                                         __inout NV_FLIP_PATTERN_DATA *pFlipData);
#endif
#if defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_GetFlipPatternInCurrentMode(__in IUnknown *pDxDeviceOrContext, __in UINT vidpnSrcID,
                                                        __inout NV_FLIP_PATTERN_DATA *pFlipData);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_IFR_SetUpTargetBufferToSys_Pvt(IDirect3DDevice9 *pDev, NVFBC_BUFFER_FORMAT eFormat,
                                                          DWORD dwNBuffers, unsigned char **ppBuffer);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_IFR_TransferRenderTarget_Pvt(IDirect3DDevice9 *pDev, HANDLE *pEvent, DWORD dwBufferIndex,
                                                        DWORD dwTargetWidth, DWORD dwTargetHeight);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_IFR_SetUpTargetBufferToNV12BLVideoSurface_Pvt(IDirect3DDevice9 *pDev, DWORD dwNBuffers,
                                                                         HANDLE *aHandles, DWORD dwTargetWidth,
                                                                         DWORD dwTargetHeight, BOOL bUseYUV444 = 0);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_IFR_TransferRenderTargetToNV12BLVideoSurface_Pvt(IDirect3DDevice9 *pDev, DWORD dwBufferIndex,
                                                                            DWORD dwTargetWidth, DWORD dwTargetHeight,
                                                                            BOOL bUseYUV444 = 0);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef void *IFRSharedSurfaceHandle;
NVAPI_INTERFACE NvAPI_D3D9_IFR_CreateSharedSurface_Pvt(IDirect3DDevice9 *pDev, DWORD dwWidth, DWORD dwHeight,
                                                       IFRSharedSurfaceHandle *phNvIFRSharedSurface);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_IFR_DestroySharedSurface_Pvt(IDirect3DDevice9 *pDev,
                                                        IFRSharedSurfaceHandle hNvIFRSharedSurface);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_IFR_CopyToSharedSurface_Pvt(IDirect3DDevice9 *pDev,
                                                       IFRSharedSurfaceHandle hNvIFRSharedSurface,
                                                       IDirect3DSurface9 *pSurface);
#endif
#if defined(_D3D9_H_) && defined(__cplusplus)
NVAPI_INTERFACE NvAPI_D3D9_IFR_CopyFromSharedSurface_Pvt(IDirect3DDevice9 *pDev,
                                                         IFRSharedSurfaceHandle hNvIFRSharedSurface,
                                                         IDirect3DSurface9 *pSurface);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D1x_IFR_SetUpTargetBufferToSys_Pvt(IUnknown *pDevice, NVFBC_BUFFER_FORMAT eFormat,
                                                           DWORD dwNBuffers, void **ppBuffers);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D1x_IFR_TransferRenderTarget_Pvt(IUnknown *pDevice, HANDLE *pEvent, DWORD dwBufferIndex,
                                                         DWORD dwTargetWidth, DWORD dwTargetHeight,
                                                         DWORD dwRenderTargetIndex, DWORD dwRenderTargetArraySlice);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D1x_IFR_SetUpTargetBufferToNV12BLVideoSurface_Pvt(IUnknown *pDevice, DWORD dwNBuffers,
                                                                          HANDLE *aHandles, DWORD dwTargetWidth,
                                                                          DWORD dwTargetHeight);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef struct _NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_V1 {
  NvU32 version;
  NvU32 numBuffers;
  IUnknown *device;
  HANDLE *handles;
  NvU32 format;
  NvU32 width;
  NvU32 height;
} NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_V1;
typedef NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_V1 NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS;
#define NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_VER1 MAKE_NVAPI_VERSION(NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_V1, 1)
#define NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_VER NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D1x_IFR_SetUpVideoTargetBuffer_Pvt(NVIFR_SETUP_VIDEO_TARGET_BUFFER_PARAMS params);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D1x_IFR_TransferRenderTargetToNV12BLVideoSurface_Pvt(IUnknown *pDevice, DWORD dwBufferIndex,
                                                                             DWORD dwTargetWidth, DWORD dwTargetHeight,
                                                                             DWORD dwRenderTargetIndex,
                                                                             DWORD dwRenderTargetArraySlice);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D1x_DisableShaderDiskCache(IUnknown *pDevice);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 370. Instead, use NvAPI_D3D1x_CreateLowLatencyDeviceHint.")
    NVAPI_INTERFACE NvAPI_D3D1x_HintCreateLowLatencyDevice(bool bCreateLowLatencyDevice);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D1x_CreateLowLatencyDeviceHint(bool bCreateLowLatencyDevice);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef struct _NV_MULTIGPU_CAPS_V1 {
  NvU32 multiGPUVersion;
  NvU32 reserved;
  NvU32 nTotalGPUs;
  NvU32 nSLIGPUs;
  NvU32 videoBridgePresent;
} NV_MULTIGPU_CAPS_V1, *PNV_MULTIGPU_CAPS_V1;
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef struct _NV_MULTIGPU_CAPS_V2 {
  NvU32 multiGPUVersion;
  union {
    NvU32 reserved;
    NvU32 version;
  };
  NvU32 nTotalGPUs;
  NvU32 nSLIGPUs;
  NvU32 videoBridgePresent;
  NvU32 NvLinkPresent;
  NvU32 fastNvLinkReads;
} NV_MULTIGPU_CAPS_V2, *PNV_MULTIGPU_CAPS_V2;
#define NV_MULTIGPU_CAPS_VER1 MAKE_NVAPI_VERSION(NV_MULTIGPU_CAPS_V1, 1)
#define NV_MULTIGPU_CAPS_VER2 MAKE_NVAPI_VERSION(NV_MULTIGPU_CAPS_V2, 2)
#define NV_MULTIGPU_CAPS_VER NV_MULTIGPU_CAPS_VER2
typedef NV_MULTIGPU_CAPS_V2 NV_MULTIGPU_CAPS;
typedef PNV_MULTIGPU_CAPS_V2 PNV_MULTIGPU_CAPS;
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
#ifndef NV_MULTIGPU_CAPS_VER
typedef NV_MULTIGPU_CAPS_V1 NV_MULTIGPU_CAPS;
typedef PNV_MULTIGPU_CAPS_V1 PNV_MULTIGPU_CAPS;
#endif
NVAPI_INTERFACE NvAPI_D3D11_MultiGPU_GetCaps(__inout PNV_MULTIGPU_CAPS pMultiGPUCaps);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_MultiGPU_Init(__in bool bEnable);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
#define NVAPI_COPY_ASYNCHRONOUSLY 1
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
#define NVAPI_COPY_P2P_READ 2
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
#define NVAPI_CPU_RESOURCE 0xffffffff
DECLARE_INTERFACE(ID3D11MultiGPUDevice_V1) {
  STDMETHOD_(void, Destroy)(THIS) PURE;
  STDMETHOD_(UINT, SetGPUMask)(THIS_ __in UINT GPUMask) PURE;
  STDMETHOD_(NvAPI_Status, CopySubresourceRegion)(
      THIS_ __in ID3D11DeviceContext * pContext, __in ID3D11Resource * pDstResource, __in UINT DstSubresource,
      __in UINT DstGPUIndex, __in UINT DstX, __in UINT DstY, __in UINT DstZ, __in ID3D11Resource * pSrcResource,
      __in UINT SrcSubresource, __in UINT SrcGPUIndex, __in const D3D11_BOX *pSrcBox, __in UINT ExtendedFlags = 0) PURE;
#if defined(__d3d11_1_h__)
  STDMETHOD_(NvAPI_Status, CopySubresourceRegion1)(
      THIS_ __in ID3D11DeviceContext1 * pContext1, __in ID3D11Resource * pDstResource, __in UINT DstSubresource,
      __in UINT DstGPUIndex, __in UINT DstX, __in UINT DstY, __in UINT DstZ, __in ID3D11Resource * pSrcResource,
      __in UINT SrcSubresource, __in UINT SrcGPUIndex, __in const D3D11_BOX *pSrcBox, __in UINT CopyFlags,
      __in UINT ExtendedFlags = 0) PURE;
#else
  STDMETHOD_(NvAPI_Status, CopySubresourceRegion1)(
      THIS_ __in void *pContext1, __in ID3D11Resource *pDstResource, __in UINT DstSubresource, __in UINT DstGPUIndex,
      __in UINT DstX, __in UINT DstY, __in UINT DstZ, __in ID3D11Resource *pSrcResource, __in UINT SrcSubresource,
      __in UINT SrcGPUIndex, __in const D3D11_BOX *pSrcBox, __in UINT CopyFlags, __in UINT ExtendedFlags = 0) PURE;
#endif
  STDMETHOD_(NvAPI_Status,
             UpdateSubresource)(THIS_ __in ID3D11DeviceContext * pContext, __in ID3D11Resource * pDstResource,
                                __in UINT DstSubresource, __in UINT DstGPUIndex, __in const D3D11_BOX *pDstBox,
                                __in const void *pSrcData, __in UINT SrcRowPitch, __in UINT SrcDepthPitch) PURE;
  STDMETHOD_(NvAPI_Status,
             VSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT GPUMask, __in UINT StartSlot,
                                   __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                   __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
  STDMETHOD_(NvAPI_Status,
             PSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT GPUMask, __in UINT StartSlot,
                                   __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                   __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
  STDMETHOD_(NvAPI_Status,
             GSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT GPUMask, __in UINT StartSlot,
                                   __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                   __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
  STDMETHOD_(NvAPI_Status,
             DSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT GPUMask, __in UINT StartSlot,
                                   __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                   __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
  STDMETHOD_(NvAPI_Status,
             HSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT GPUMask, __in UINT StartSlot,
                                   __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                   __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
  STDMETHOD_(NvAPI_Status,
             CSSetConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT GPUMask, __in UINT StartSlot,
                                   __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers,
                                   __in UINT *const pFirstConstant = NULL, __in UINT *const pNumConstants = NULL) PURE;
  STDMETHOD_(NvAPI_Status, SetViewports)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT GPUMask,
                                         __in UINT NumViewports, __in const D3D11_VIEWPORT *pViewports) PURE;
  STDMETHOD_(NvAPI_Status, SetScissorRects)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT GPUMask,
                                            __in UINT NumRects, __in const D3D11_RECT *pRects) PURE;
  STDMETHOD_(HRESULT, GetData)(THIS_ __in ID3D11DeviceContext * pContext, __in ID3D11Asynchronous * pAsync,
                               __in UINT GPUIndex, __out void *pData, __in UINT DataSize, __in UINT GetDataFlags) PURE;
#if defined(__d3d11_2_h__)
  STDMETHOD_(NvAPI_Status, UpdateTiles)(
      THIS_ __in ID3D11DeviceContext2 * pContext2, __in ID3D11Resource * pDestTiledResource, __in UINT GPUMask,
      __in const D3D11_TILED_RESOURCE_COORDINATE *pDestTileRegionStartCoordinate,
      __in const D3D11_TILE_REGION_SIZE *pDestTileRegionSize, __in const void *pSourceTileData, __in UINT Flags) PURE;
#else
  STDMETHOD_(NvAPI_Status, UpdateTiles)(THIS_ __in void *pContext2, __in ID3D11Resource *pDestTiledResource,
                                        __in UINT GPUMask, __in const void *pDestTileRegionStartCoordinate,
                                        __in const void *pDestTileRegionSize, __in const void *pSourceTileData,
                                        __in UINT Flags) PURE;
#endif
  STDMETHOD_(NvAPI_Status, CreateFences)(THIS_ __in UINT count, __out void **ppFences) PURE;
  STDMETHOD_(NvAPI_Status, SetFence)(THIS_ __in UINT GPUIndex, __in void *hFence, __in UINT64 value) PURE;
  STDMETHOD_(NvAPI_Status, WaitForFence)(THIS_ __in UINT GPUIMask, __in void *hFence, __in UINT64 value) PURE;
  STDMETHOD_(NvAPI_Status, FreeFences)(THIS_ __in UINT count, __in void **ppFences) PURE;
  STDMETHOD_(NvAPI_Status, PresentCompositingConfig)(THIS_ __in IUnknown * pSwapChain, __in UINT GPUMask,
                                                     __in const D3D11_RECT *pRects, __in UINT flags) PURE;
  STDMETHOD_(NvAPI_Status, SetContextGPUMask)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT GPUMask) PURE;
  STDMETHOD_(NvAPI_Status, GetVideoBridgeStatus)(THIS_ __in IUnknown * pSwapChain, __in UINT * pVideoBridgeStatus) PURE;
  STDMETHOD_(NvAPI_Status, CreateMultiGPUConstantBuffer)(THIS_ __in const D3D11_BUFFER_DESC *pDesc,
                                                         __in_opt const D3D11_SUBRESOURCE_DATA **ppInitialData,
                                                         __out ID3D11Buffer **ppBuffer) PURE;
  STDMETHOD_(NvAPI_Status, ReleaseMultiGPUConstantBuffer)(THIS_ __in ID3D11Buffer * pBuffer) PURE;
  STDMETHOD_(NvAPI_Status, VSSetMGPUConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT StartSlot,
                                                     __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers)
      PURE;
  STDMETHOD_(NvAPI_Status, PSSetMGPUConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT StartSlot,
                                                     __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers)
      PURE;
  STDMETHOD_(NvAPI_Status, GSSetMGPUConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT StartSlot,
                                                     __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers)
      PURE;
  STDMETHOD_(NvAPI_Status, DSSetMGPUConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT StartSlot,
                                                     __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers)
      PURE;
  STDMETHOD_(NvAPI_Status, HSSetMGPUConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT StartSlot,
                                                     __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers)
      PURE;
  STDMETHOD_(NvAPI_Status, CSSetMGPUConstantBuffers)(THIS_ __in ID3D11DeviceContext * pContext, __in UINT StartSlot,
                                                     __in UINT NumBuffers, __in ID3D11Buffer *const *ppConstantBuffers)
      PURE;
  STDMETHOD_(NvAPI_Status, UpdateConstantBuffer)(__in ID3D11DeviceContext * pContext, __in ID3D11Buffer * pBuffer,
                                                 __in const void *pSrcData, __in_opt UINT GPUMask = 0) PURE;
};
#define FENCE_SYNCHRONIZATION_START(pMultiGPUDevice, hFence, Value, srcGpu, dstGpu)                                    \
  pMultiGPUDevice->SetFence(dstGpu, hFence, Value);                                                                    \
  pMultiGPUDevice->WaitForFence(1 << (srcGpu), hFence, Value);                                                         \
  Value++;
#define FENCE_SYNCHRONIZATION_END(pMultiGPUDevice, hFence, Value, srcGpu, dstGpu)                                      \
  pMultiGPUDevice->SetFence(srcGpu, hFence, Value);                                                                    \
  pMultiGPUDevice->WaitForFence(1 << (dstGpu), hFence, Value);                                                         \
  Value++;
#define NVAPI_PRESENT_COMPOSITING_CONFIG_FLAG_USE_VIDEO_BRIDGE 0x01
#define NVAPI_PRESENT_COMPOSITING_CONFIG_FLAG_CLEAR_OUTBANDS 0x02
#define NVAPI_PRESENT_COMPOSITING_CONFIG_FLAG_GET_VIDEO_BRIDGE_STATUS 0x80000000
#define NVAPI_VIDEO_BRIDGE_STATUS_AVAILABLE 0
#define NVAPI_VIDEO_BRIDGE_STATUS_NOT_AVAILABLE 1
#define NVAPI_VIDEO_BRIDGE_STATUS_FAILED_ACCESS 2
#define NVAPI_VIDEO_BRIDGE_STATUS_UNKNOWN 3
#define NVAPI_ALL_GPUS 0
typedef ID3D11MultiGPUDevice_V1 ID3D11MultiGPUDevice;
#define ID3D11MultiGPUDevice_VER1 MAKE_NVAPI_VERSION(ID3D11MultiGPUDevice_V1, 1)
#define ID3D11MultiGPUDevice_VER2 MAKE_NVAPI_VERSION(ID3D11MultiGPUDevice_V1, 2)
#define ID3D11MultiGPUDevice_VER3 MAKE_NVAPI_VERSION(ID3D11MultiGPUDevice_V1, 3)
#define ID3D11MultiGPUDevice_VER ID3D11MultiGPUDevice_VER3
#define ALL_GPUS 0
NVAPI_INTERFACE NvAPI_D3D11_CreateMultiGPUDevice(__in ID3D11Device *pDevice, __in ULONG version,
                                                 __out ULONG *currentVersion,
                                                 __out ID3D11MultiGPUDevice **ppD3D11MultiGPUDevice,
                                                 __in UINT maxGpus = ALL_GPUS);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef NvU32 NV_DIRECT_MODE_SURFACE_HANDLE;
typedef enum _NV_DIRECT_MODE_DSC_MODE {
  NV_DIRECT_MODE_DSC_MODE_DRIVER_CONTROLLED = 0,
  NV_DIRECT_MODE_DSC_MODE_FORCE_ENABLED = 1,
  NV_DIRECT_MODE_DSC_MODE_FORCE_DISABLED = 2,
} NV_DIRECT_MODE_DSC_MODE;
typedef enum _NV_DIRECT_MODE_DSC_VERSION {
  NV_DIRECT_MODE_DSC_VERSION_INVALID = 0,
  NV_DIRECT_MODE_DSC_VERSION_V11 = 0x11,
  NV_DIRECT_MODE_DSC_VERSION_V12 = 0x12,
} NV_DIRECT_MODE_DSC_VERSION;
typedef enum _NV_DIRECT_MODE_DSC_SLICE_COUNT {
  NV_DIRECT_MODE_DSC_SLICE_COUNT_INVALID = 0,
  NV_DIRECT_MODE_DSC_SLICE_COUNT_1 = 1,
  NV_DIRECT_MODE_DSC_SLICE_COUNT_2 = 2,
  NV_DIRECT_MODE_DSC_SLICE_COUNT_4 = 4,
  NV_DIRECT_MODE_DSC_SLICE_COUNT_8 = 8,
} NV_DIRECT_MODE_DSC_SLICE_COUNT;
typedef struct _NV_DIRECT_MODE_DSC_PARAMS_V1 {
  NV_DIRECT_MODE_DSC_MODE dscMode;
  NV_DIRECT_MODE_DSC_VERSION dscVersion;
  NV_DIRECT_MODE_DSC_SLICE_COUNT sliceCount;
  NvU32 outputBPPx16;
} NV_DIRECT_MODE_DSC_PARAMS_V1;
typedef struct _NV_DIRECT_MODE_INFO_V1 {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NV_DISPLAY_REFRESH_RATE refresh;
  NV_FORMAT format;
  NvU32 ScanlineOrdering;
  NV_SCALING scaling;
} NV_DIRECT_MODE_INFO_V1;
typedef struct _NV_DIRECT_MODE_INFO_V2 {
  NvU32 version;
  NvU32 width;
  NvU32 height;
  NV_DISPLAY_REFRESH_RATE refresh;
  NV_FORMAT format;
  NvU32 ScanlineOrdering;
  NV_SCALING scaling;
  NV_DIRECT_MODE_DSC_PARAMS_V1 dscParams;
} NV_DIRECT_MODE_INFO_V2;
#define NV_DIRECT_MODE_INFO_VER1 MAKE_NVAPI_VERSION(NV_DIRECT_MODE_INFO_V1, 1)
#define NV_DIRECT_MODE_INFO_VER2 MAKE_NVAPI_VERSION(NV_DIRECT_MODE_INFO_V2, 2)
#define NV_DIRECT_MODE_INFO_VER NV_DIRECT_MODE_INFO_VER2
typedef NV_DIRECT_MODE_INFO_V2 NV_DIRECT_MODE_INFO;
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef enum {
  NVAPI_VR_PROCESS_NONE = 0x00000000,
  NVAPI_VR_PROCESS_APPLICATION = 0x00000001,
  NVAPI_VR_PROCESS_COMPOSITOR = 0x00000002,
  NVAPI_VR_PROCESS_APPLICATION_COMPOSITOR = NVAPI_VR_PROCESS_APPLICATION | NVAPI_VR_PROCESS_COMPOSITOR,
} NVAPI_VR_PROCESS_TYPE;
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D1x_DeclareVRProcessType(__in NVAPI_VR_PROCESS_TYPE ProcessType);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_AcquireDirectModeDisplay(__in NvU32 vendorId, __in IUnknown *pDevice,
                                                   __inout NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_ReleaseDirectModeDisplay(__in NvU32 vendorId,
                                                   __inout NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_DirectModeCreateSurface(__inout NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                                  __in NV_DIRECT_MODE_INFO *pModeInfo,
                                                  __out NV_DIRECT_MODE_SURFACE_HANDLE *phSurface,
                                                  __out HANDLE *phSharedHandle);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_DirectModeDestroySurface(__inout NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                                   __in NV_DIRECT_MODE_SURFACE_HANDLE hSurface);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_DirectModeRenderWait(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                               __in IUnknown *pRenderDevice, __in bool bEnable);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef enum _NVAPI_DIRECTMODE_PRESENT_FLAG {
  NV_DIRECTMODE_PRESENT_FLAG_NONE = 0,
  NV_DIRECTMODE_PRESENT_FLAG_VSYNC,
  NV_DIRECTMODE_PRESENT_FLAG_QUEUED_VSYNC,
} NVAPI_DIRECTMODE_PRESENT_FLAG;
NVAPI_INTERFACE NvAPI_D3D_DirectModePresent(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                            __in NV_DIRECT_MODE_SURFACE_HANDLE hSurface,
                                            __in NVAPI_DIRECTMODE_PRESENT_FLAG flag, __in IUnknown *pRenderDevice);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
#if defined(__d3d12_h__)
#define ICommandQueue ID3D12CommandQueue
#define IGraphicsCommandList ID3D12GraphicsCommandList
#else
#define ICommandQueue void
#define IGraphicsCommandList void
#endif
NVAPI_INTERFACE NvAPI_D3D_DirectModePresent12(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                              __in NV_DIRECT_MODE_SURFACE_HANDLE hSurface,
                                              __in NVAPI_DIRECTMODE_PRESENT_FLAG flag,
                                              __in ICommandQueue *pCommandQueue,
                                              __in IGraphicsCommandList *pCommandList);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_DirectModeGetDeviceAndSurface(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                                        __in NV_DIRECT_MODE_SURFACE_HANDLE hSurface,
                                                        __inout IUnknown **ppDXGIDevice,
                                                        __inout IUnknown **ppDxSurface);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_DIRECT_MODE_PRESENT_STATS_V1 {
  NvU32 version;
  NV_DISPLAY_REFRESH_RATE refresh;
  NvU32 frameIndex;
  NvU64 timeOfLastVSync;
} NV_DIRECT_MODE_PRESENT_STATS_V1;
typedef struct _NV_DIRECT_MODE_PRESENT_STATS_V2 {
  NvU32 version;
  NV_DISPLAY_REFRESH_RATE refresh;
  NvU32 frameIndex;
  NvU64 timeOfLastVSync;
  NvU64 gpuTimeOfLastVSync;
} NV_DIRECT_MODE_PRESENT_STATS_V2;
#define NV_DIRECT_MODE_PRESENT_STATS_VER1 MAKE_NVAPI_VERSION(NV_DIRECT_MODE_PRESENT_STATS_V1, 1)
#define NV_DIRECT_MODE_PRESENT_STATS_VER2 MAKE_NVAPI_VERSION(NV_DIRECT_MODE_PRESENT_STATS_V1, 2)
#define NV_DIRECT_MODE_PRESENT_STATS_VER NV_DIRECT_MODE_PRESENT_STATS_VER2
typedef NV_DIRECT_MODE_PRESENT_STATS_V2 NV_DIRECT_MODE_PRESENT_STATS;
NVAPI_INTERFACE NvAPI_D3D_GetDirectModePresentStats(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                                    __inout NV_DIRECT_MODE_PRESENT_STATS *pStatsInfo);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_DirectModeSetDisplayMode(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                                   __in NV_DIRECT_MODE_INFO *pModeInfo);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef enum _NV_DIRECTMODE_GETMODES_FLAG {
  NV_DIRECTMODE_GETMODES_FLAG_SUPPORTED = 0,
  NV_DIRECTMODE_GETMODES_FLAG_CURRENT
} NV_DIRECTMODE_GETMODES_FLAG;
NVAPI_INTERFACE NvAPI_D3D_DirectModeGetDisplayModes(__in NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
                                                    __inout NvU32 *modeCount,
                                                    __inout_opt NV_DIRECT_MODE_INFO *pModeInfo,
                                                    __in NV_DIRECTMODE_GETMODES_FLAG flag);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_DirectModeImplicitSLIControl(__in IUnknown *pDev, __in bool disable);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef enum _NV_VR_POWER_MODE { NV_VR_POWER_MODE_DEFAULT = 0, NV_VR_POWER_MODE_MAX_PERFORMANCE } NV_VR_POWER_MODE;
NVAPI_INTERFACE NvAPI_D3D_VRSetPowerMode(__in NV_VR_POWER_MODE mode);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef enum _NV_VR_PERF_LEVEL_CONTROL {
  NV_VR_PERF_LEVEL_CONTROL_SET = 0,
  NV_VR_PERF_LEVEL_CONTROL_GET = 1
} NV_VR_PERF_LEVEL_CONTROL;
typedef enum _NV_VR_PERF_LEVEL {
  NV_VR_PERF_LEVEL_POWER_DEFAULT = 0xFFFFFFFF,
  NV_VR_PERF_LEVEL_POWER_SAVINGS = 0,
  NV_VR_PERF_LEVEL_SUSTAINED_LOW = 25,
  NV_VR_PERF_LEVEL_SUSTAINED_HIGH = 50,
  NV_VR_PERF_LEVEL_BOOST = 75,
  NV_VR_PERF_LEVEL_MAX = 100,
} NV_VR_PERF_LEVEL;
typedef struct _NV_VR_PERF_LEVEL_CONTROL_STRUCT_V1 {
  NvU32 version;
  NV_VR_PERF_LEVEL_CONTROL op;
  NvU32 uNewLevel;
  NvU32 uCurrentLevel;
} NV_VR_PERF_LEVEL_CONTROL_STRUCT_V1;
#define NV_VR_PERF_LEVEL_CONTROL_STRUCT NV_VR_PERF_LEVEL_CONTROL_STRUCT_V1
#define NV_VR_PERF_LEVEL_CONTROL_STRUCT_VER1 MAKE_NVAPI_VERSION(NV_VR_PERF_LEVEL_CONTROL_STRUCT_V1, 1)
#define NV_VR_PERF_LEVEL_CONTROL_STRUCT_VER NV_VR_PERF_LEVEL_CONTROL_STRUCT_VER1
NVAPI_INTERFACE NvAPI_D3D_VRPerfLevelControl(__inout NV_VR_PERF_LEVEL_CONTROL_STRUCT *pPerfLevelControlData);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_DIRECT_MODE_HDCP_STATUS_PACKET_V1 {
  NvU32 version;
  NV_HDCP_CN cN;
  NV_U40 cKsv;
  NV_HDCP_STATUS hdcpStatus;
  NV_HDCP_CS cS;
  NV_U56 kP;
  NV_U40 aN;
  NV_U40 dKsv;
  NV_U40 bKsv;
} NV_DIRECT_MODE_HDCP_STATUS_PACKET_V1;
typedef NV_DIRECT_MODE_HDCP_STATUS_PACKET_V1 NV_DIRECT_MODE_HDCP_STATUS_PACKET;
#define NV_DIRECT_MODE_HDCP_STATUS_PACKET_VER MAKE_NVAPI_VERSION(NV_DIRECT_MODE_HDCP_STATUS_PACKET, 1)
NVAPI_INTERFACE NvAPI_D3D_DirectModeGetHDCPStatus(
    __in NV_DIRECT_MODE_DISPLAY_HANDLE *phDisplay,
    __inout NV_DIRECT_MODE_HDCP_STATUS_PACKET *pDirectModeHDCPStatusPacket);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_QUERY_PERIODIC_FRAME_NOTIFICATION_SUPPORT_PARAMS_V1 {
  NvU32 version;
  NvU32 displayId;
  NvU32 bSupported;
} NV_QUERY_PERIODIC_FRAME_NOTIFICATION_SUPPORT_PARAMS_V1;
typedef NV_QUERY_PERIODIC_FRAME_NOTIFICATION_SUPPORT_PARAMS_V1 NV_QUERY_PERIODIC_FRAME_NOTIFICATION_SUPPORT_PARAMS;
#define NV_QUERY_PERIODIC_FRAME_NOTIFICATION_SUPPORT_PARAMS_VER1                                                       \
  MAKE_NVAPI_VERSION(NV_QUERY_PERIODIC_FRAME_NOTIFICATION_SUPPORT_PARAMS_V1, 1)
#define NV_QUERY_PERIODIC_FRAME_NOTIFICATION_SUPPORT_PARAMS_VER NV_QUERY_PERIODIC_FRAME_NOTIFICATION_SUPPORT_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_QueryPeriodicFrameNotificationSupport(
    __inout NV_QUERY_PERIODIC_FRAME_NOTIFICATION_SUPPORT_PARAMS *pQueryPeriodicFrameNotificationSupportParams);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef enum _PERIODIC_FRAME_NOTIFICATION_TYPE {
  PERIODIC_FRAME_NOTIFICATION_TYPE_EVENT_WAIT = 0,
} PERIODIC_FRAME_NOTIFICATION_TYPE;
typedef struct _NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1 {
  NvU32 version;
  NvU32 displayId;
  NvU64 time;
  NvU32 notificationID;
  HANDLE hNotificationEvent;
  HANDLE hNotification;
} NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1;
typedef struct _NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V2 {
  NvU32 version;
  NvU32 displayId;
  NvU64 time;
  NvU32 notificationID;
  HANDLE hNotificationEvent;
  HANDLE hNotification;
  PERIODIC_FRAME_NOTIFICATION_TYPE waitType;
  IUnknown *pRenderDevice;
} NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V2;
typedef NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V2 NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS;
#define NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER1                                                              \
  MAKE_NVAPI_VERSION(NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1, 1)
#define NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER2                                                              \
  MAKE_NVAPI_VERSION(NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V2, 2)
#define NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER2
NVAPI_INTERFACE NvAPI_D3D_CreatePeriodicFrameNotification(
    __inout NV_CREATE_PERIODIC_FRAME_NOTIFICATION_PARAMS *pCreateNotification);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1 {
  NvU32 version;
  HANDLE hNotification;
  NvU64 time;
} NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1;
#define NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_FLAGS_DEFAULT 0x00000000
typedef struct _NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V2 {
  NvU32 version;
  HANDLE hNotification;
  NvU64 time;
  NvU32 flags;
} NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V2;
typedef NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V2 NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS;
#define NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER1                                                              \
  MAKE_NVAPI_VERSION(NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1, 1)
#define NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER2                                                              \
  MAKE_NVAPI_VERSION(NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_V2, 2)
#define NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER2
NVAPI_INTERFACE NvAPI_D3D_UpdatePeriodicFrameNotification(
    __in NV_UPDATE_PERIODIC_FRAME_NOTIFICATION_PARAMS *pUpdateNotification);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_DESTROY_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1 {
  NvU32 version;
  HANDLE hNotification;
} NV_DESTROY_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1;
typedef NV_DESTROY_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1 NV_DESTROY_PERIODIC_FRAME_NOTIFICATION_PARAMS;
#define NV_DESTROY_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER1                                                             \
  MAKE_NVAPI_VERSION(NV_DESTROY_PERIODIC_FRAME_NOTIFICATION_PARAMS_V1, 1)
#define NV_DESTROY_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER NV_DESTROY_PERIODIC_FRAME_NOTIFICATION_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_DestroyPeriodicFrameNotification(
    __in NV_DESTROY_PERIODIC_FRAME_NOTIFICATION_PARAMS *pDestroyNotification);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_PERIODIC_FRAME_NOTIFICATION_STATS_V1 {
  NvU32 version;
  NvU64 notificationCount;
  NvU64 timeOfLastNotification;
  NvU64 gpuTimeOfLastNotification;
} NV_PERIODIC_FRAME_NOTIFICATION_STATS_V1;
#define NV_PERIODIC_FRAME_NOTIFICATION_STATS_VER1 MAKE_NVAPI_VERSION(NV_PERIODIC_FRAME_NOTIFICATION_STATS_V1, 1)
#define NV_PERIODIC_FRAME_NOTIFICATION_STATS_VER NV_PERIODIC_FRAME_NOTIFICATION_STATS_VER1
typedef NV_PERIODIC_FRAME_NOTIFICATION_STATS_V1 NV_PERIODIC_FRAME_NOTIFICATION_STATS;
typedef struct _NV_GET_PERIODIC_FRAME_NOTIFICATION_STATS_PARAMS_V1 {
  NvU32 version;
  HANDLE hNotification;
} NV_GET_PERIODIC_FRAME_NOTIFICATION_STATS_PARAMS_V1;
typedef NV_GET_PERIODIC_FRAME_NOTIFICATION_STATS_PARAMS_V1 NV_GET_PERIODIC_FRAME_NOTIFICATION_STATS_PARAMS;
#define NV_GET_PERIODIC_FRAME_NOTIFICATION_STATS_PARAMS_VER1                                                           \
  MAKE_NVAPI_VERSION(NV_GET_PERIODIC_FRAME_NOTIFICATION_STATS_PARAMS_V1, 1)
#define NV_GET_PERIODIC_FRAME_NOTIFICATION_STATS_PARAMS_VER NV_GET_PERIODIC_FRAME_NOTIFICATION_STATS_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_GetPeriodicFrameNotificationStats(
    __in NV_GET_PERIODIC_FRAME_NOTIFICATION_STATS_PARAMS *pGetStatsParams,
    __inout NV_PERIODIC_FRAME_NOTIFICATION_STATS *pStatsInfo);
#endif
typedef struct _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1 {
  NvU32 version;
  NvU32 bSinglePassStereoSupported;
} NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1;
typedef struct _NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 {
  NvU32 version;
  NvU32 bSinglePassStereoSupported : 1;
  NvU32 bSinglePassStereoXYZWSupported : 1;
  NvU32 reserved : 30;
} NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2;
typedef NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2 NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS;
#define NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_VER1                                                                \
  MAKE_NVAPI_VERSION(NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1, 1)
#define NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_VER2                                                                \
  MAKE_NVAPI_VERSION(NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V2, 2)
#define NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_VER NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_VER2
#ifndef NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_VER
typedef NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1 NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS;
#define NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_VER1                                                                \
  MAKE_NVAPI_VERSION(NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_V1, 1)
#define NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_VER NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS_VER1
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_QuerySinglePassStereoSupport(
    __in IUnknown *pDevice, __inout NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS *pQuerySinglePassStereoSupportedParams);
#endif
#if defined(__cplusplus) && defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_SetSinglePassStereoMode(__in IUnknown *pDevOrContext, __in NvU32 numViews,
                                                  __in NvU32 renderTargetIndexOffset,
                                                  __in NvU8 independentViewportMaskEnable);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D12_QuerySinglePassStereoSupport(
    __in ID3D12Device *pDevice,
    __inout NV_QUERY_SINGLE_PASS_STEREO_SUPPORT_PARAMS *pQuerySinglePassStereoSupportedParams);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D12_SetSinglePassStereoMode(__in ID3D12GraphicsCommandList *pCommandList, __in NvU32 numViews,
                                                    __in NvU32 renderTargetIndexOffset,
                                                    __in NvU8 independentViewportMaskEnable);
#endif
typedef struct _NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 {
  NvU32 version;
  NvU32 bMultiViewSupported : 1;
  NvU32 bSinglePassStereoSupported : 1;
  NvU32 bSinglePassStereoXYZWSupported : 1;
  NvU32 reserved : 29;
} NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1;
typedef NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1 NV_QUERY_MULTIVIEW_SUPPORT_PARAMS;
#define NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_V1, 1)
#define NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_VER NV_QUERY_MULTIVIEW_SUPPORT_PARAMS_VER1
#define NV_MULTIVIEW_MAX_SUPPORTED_VIEWS 4
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_QueryMultiViewSupport(
    __in IUnknown *pDevice, __inout NV_QUERY_MULTIVIEW_SUPPORT_PARAMS *pQueryMultiViewSupportedParams);
#endif
typedef struct _NV_MULTIVIEW_PARAMS_V1 {
  NvU32 version;
  NvU32 numViews;
  NvU32 renderTargetIndexOffset[NV_MULTIVIEW_MAX_SUPPORTED_VIEWS];
  NvU8 independentViewportMaskEnable;
} NV_MULTIVIEW_PARAMS_V1;
typedef NV_MULTIVIEW_PARAMS_V1 NV_MULTIVIEW_PARAMS;
#define NV_MULTIVIEW_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_MULTIVIEW_PARAMS_V1, 1)
#define NV_MULTIVIEW_PARAMS_VER NV_MULTIVIEW_PARAMS_VER1
#if defined(__cplusplus) && defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_SetMultiViewMode(__in IUnknown *pDevOrContext, __in NV_MULTIVIEW_PARAMS *pMultiViewParams);
#endif
typedef struct _NV_QUERY_NVIEW_SUPPORT_PARAMS_V1 {
  NvU32 version;
  NvU32 bNViewSupported : 1;
  NvU32 reserved : 31;
} NV_QUERY_NVIEW_SUPPORT_PARAMS_V1;
typedef struct _NV_QUERY_NVIEW_SUPPORT_PARAMS_V2 {
  NvU32 version;
  NvU32 bNViewSupported : 1;
  NvU32 bSinglePassStereoSupported : 1;
  NvU32 bSinglePassStereoXYZWSupported : 1;
  NvU32 reserved : 29;
} NV_QUERY_NVIEW_SUPPORT_PARAMS_V2;
typedef NV_QUERY_NVIEW_SUPPORT_PARAMS_V2 NV_QUERY_NVIEW_SUPPORT_PARAMS;
#define NV_QUERY_NVIEW_SUPPORT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_QUERY_NVIEW_SUPPORT_PARAMS_V1, 1)
#define NV_QUERY_NVIEW_SUPPORT_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_QUERY_NVIEW_SUPPORT_PARAMS_V2, 2)
#define NV_QUERY_NVIEW_SUPPORT_PARAMS_VER NV_QUERY_NVIEW_SUPPORT_PARAMS_VER2
#define NV_MULTIVIEW_MAX_SUPPORTED_VIEWS 4
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_QueryNViewSupport(__in IUnknown *pDevice,
                                            __inout NV_QUERY_NVIEW_SUPPORT_PARAMS *pQueryNViewSupportedParams);
#endif
typedef struct _NV_NVIEW_PARAMS_V1 {
  NvU32 version;
  NvU32 numViews;
  NvU32 renderTargetIndexOffset[NV_MULTIVIEW_MAX_SUPPORTED_VIEWS];
  NvU8 independentViewportMaskEnable;
} NV_NVIEW_PARAMS_V1;
typedef NV_NVIEW_PARAMS_V1 NV_NVIEW_PARAMS;
#define NV_NVIEW_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_NVIEW_PARAMS_V1, 1)
#define NV_NVIEW_PARAMS_VER NV_NVIEW_PARAMS_VER1
#if defined(__cplusplus) && defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_SetNViewMode(__in IUnknown *pDevOrContext, __in NV_NVIEW_PARAMS *pNViewParams);
#endif
typedef struct _NV_QUERY_MODIFIED_W_SUPPORT_PARAMS {
  NvU32 version;
  NvU32 bModifiedWSupported;
} NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_V1;
typedef NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_V1 NV_QUERY_MODIFIED_W_SUPPORT_PARAMS;
#define NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_V1, 1)
#define NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_VER NV_QUERY_MODIFIED_W_SUPPORT_PARAMS_VER1
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_QueryModifiedWSupport(
    __in IUnknown *pDev, __inout NV_QUERY_MODIFIED_W_SUPPORT_PARAMS *pQueryModifiedWSupportedParams);
#endif
#define NV_MODIFIED_W_MAX_VIEWPORTS 16
typedef struct _NV_MODIFIED_W_COEFFICIENTS {
  float fA;
  float fB;
  float fAReserved;
  float fBReserved;
  float fReserved[2];
} NV_MODIFIED_W_COEFFICIENTS;
typedef struct _NV_MODIFIED_W_PARAMS {
  NvU32 version;
  NvU32 numEntries;
  NV_MODIFIED_W_COEFFICIENTS modifiedWCoefficients[NV_MODIFIED_W_MAX_VIEWPORTS];
  NvU32 id;
  NvU32 reserved[NV_MODIFIED_W_MAX_VIEWPORTS];
} NV_MODIFIED_W_PARAMS_V1;
typedef NV_MODIFIED_W_PARAMS_V1 NV_MODIFIED_W_PARAMS;
#define NV_MODIFIED_W_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_MODIFIED_W_PARAMS_V1, 1)
#define NV_MODIFIED_W_PARAMS_VER NV_MODIFIED_W_PARAMS_VER1
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_SetModifiedWMode(__in IUnknown *pDevOrContext, __in NV_MODIFIED_W_PARAMS *psModifiedWParams);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D12_QueryModifiedWSupport(
    __in ID3D12Device *pDevice, __inout NV_QUERY_MODIFIED_W_SUPPORT_PARAMS *pQueryModifiedWSupportedParams);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D12_SetModifiedWMode(__in ID3D12GraphicsCommandList *pCommandList,
                                             __in NV_MODIFIED_W_PARAMS *pModifiedWParams);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
DECLARE_INTERFACE(ID3DLateLatchObject_V1) {
  STDMETHOD_(UINT, Release)(THIS) PURE;
  STDMETHOD_(NvAPI_Status, Latch)(THIS_ __in IUnknown *pContext = NULL) PURE;
  STDMETHOD_(ID3D11Buffer *, GetD3D11Buffer)(THIS_ __in UINT index = 0) PURE;
  STDMETHOD_(UINT, GetBufferCount)(THIS) PURE;
  STDMETHOD_(NvAPI_Status, UpdateData)(THIS_ __in void **ppData) PURE;
  STDMETHOD_(NvAPI_Status, UpdateData)(THIS_ __in void *pData, __in size_t offset, __in size_t size,
                                       __in UINT index = 0) PURE;
};
typedef ID3DLateLatchObject_V1 ID3DLateLatchObject;
#define ID3DLateLatchObject_VER1 MAKE_NVAPI_VERSION(ID3DLateLatchObject_V1, 1)
#define ID3DLateLatchObject_VER ID3DLateLatchObject_VER1
typedef struct _NV_D3D_LATELATCH_OBJECT_DESC_V1 {
  NvU32 version;
  NvU32 numBuffers;
  D3D11_BUFFER_DESC **ppBufferDesc;
  ID3DLateLatchObject **ppD3DLateLatchObject;
} NV_D3D_LATELATCH_OBJECT_DESC_V1;
typedef NV_D3D_LATELATCH_OBJECT_DESC_V1 NV_D3D_LATELATCH_OBJECT_DESC;
#define NV_D3D_LATELATCH_OBJECT_DESC_VER1 MAKE_NVAPI_VERSION(NV_D3D_LATELATCH_OBJECT_DESC_V1, 1)
#define NV_D3D_LATELATCH_OBJECT_DESC_VER NV_D3D_LATELATCH_OBJECT_DESC_VER1
NVAPI_INTERFACE NvAPI_D3D_CreateLateLatchObject(__in IUnknown *pDevice,
                                                __inout NV_D3D_LATELATCH_OBJECT_DESC *pLateLatchObjectDesc);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_QUERY_LATELATCH_SUPPORT_PARAMS {
  NvU32 version;
  NvU32 bLateLatchSupported;
} NV_QUERY_LATELATCH_SUPPORT_PARAMS_V1;
typedef NV_QUERY_LATELATCH_SUPPORT_PARAMS_V1 NV_QUERY_LATELATCH_SUPPORT_PARAMS;
#define NV_QUERY_LATELATCH_SUPPORT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_QUERY_LATELATCH_SUPPORT_PARAMS_V1, 1)
#define NV_QUERY_LATELATCH_SUPPORT_PARAMS_VER NV_QUERY_LATELATCH_SUPPORT_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_QueryLateLatchSupport(
    __in IUnknown *pDevice, __inout NV_QUERY_LATELATCH_SUPPORT_PARAMS *pQueryLateLatchSupportParams);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_D3D1X_RESOURCE_INVALIDATE_PARAMS_V1 {
  NvU32 version;
  IUnknown *pResource;
  NvU64 Flags;
} NV_D3D1X_RESOURCE_INVALIDATE_PARAMS_V1;
typedef NV_D3D1X_RESOURCE_INVALIDATE_PARAMS_V1 NV_D3D1X_RESOURCE_INVALIDATE_PARAMS;
#define NV_D3D1X_RESOURCE_INVALIDATE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_D3D1X_RESOURCE_INVALIDATE_PARAMS_V1, 1)
#define NV_D3D1X_RESOURCE_INVALIDATE_PARAMS_VER NV_D3D1X_RESOURCE_INVALIDATE_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D1X_ResourceInvalidate(__in IUnknown *pDevOrContext,
                                               __in NV_D3D1X_RESOURCE_INVALIDATE_PARAMS *pResourceInvalidateParams);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_D3D1X_ATOMIC_COPYBUFFER_PARAMS_V1 {
  NvU32 version;
  IUnknown *pDstResource;
  NvU32 dstOffset;
  IUnknown *pSrcResource;
  NvU32 srcOffset;
  NvU32 srcBytes;
  BOOL bAtomic;
} NV_D3D1X_ATOMIC_COPYBUFFER_PARAMS_V1;
typedef NV_D3D1X_ATOMIC_COPYBUFFER_PARAMS_V1 NV_D3D1X_ATOMIC_COPYBUFFER_PARAMS;
#define NV_D3D1X_ATOMIC_COPYBUFFER_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_D3D1X_ATOMIC_COPYBUFFER_PARAMS_V1, 1)
#define NV_D3D1X_ATOMIC_COPYBUFFER_PARAMS_VER NV_D3D1X_ATOMIC_COPYBUFFER_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D1X_AtomicCopyBuffer(__in IUnknown *pDevOrContext,
                                             __in NV_D3D1X_ATOMIC_COPYBUFFER_PARAMS *pAtomicCopyBufferParams);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_RegisterDevice(__in IUnknown *pDev);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D11_MultiDrawInstancedIndirect(__in ID3D11DeviceContext *pDevContext11, __in NvU32 drawCount,
                                                       __in ID3D11Buffer *pBuffer, __in NvU32 alignedByteOffsetForArgs,
                                                       __in NvU32 alignedByteStrideForArgs);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d11_1_h__))
NVAPI_INTERFACE NvAPI_D3D11_MultiDrawIndexedInstancedIndirect(__in ID3D11DeviceContext *pDevContext11,
                                                              __in NvU32 drawCount, __in ID3D11Buffer *pBuffer,
                                                              __in NvU32 alignedByteOffsetForArgs,
                                                              __in NvU32 alignedByteStrideForArgs);
#endif
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef enum _IMPLICIT_SLI_CONTROL {
  DISABLE_IMPLICIT_SLI = 0,
  ENABLE_IMPLICIT_SLI = 1,
} IMPLICIT_SLI_CONTROL;
NVAPI_INTERFACE NvAPI_D3D_ImplicitSLIControl(__in IMPLICIT_SLI_CONTROL implicitSLIControl);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 370. Instead, use NvAPI_D3D1x_QueryLowLatencySupport.")
    NVAPI_INTERFACE NvAPI_D3D1x_GetLowLatencySupport(__in LUID pAdapterId, __out BOOL *pIsLowLatencySupported);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D1x_QueryLowLatencySupport(__in LUID pAdapterId, __out BOOL *pIsLowLatencySupported);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef struct _NV_SET_SYSMEM_SURFACE_CREATION_PARAMS {
  NvU32 version;
  void *pSystemMemory;
} NV_SET_SYSMEM_SURFACE_CREATION_PARAMS_V1;
typedef NV_SET_SYSMEM_SURFACE_CREATION_PARAMS_V1 NV_SET_SYSMEM_SURFACE_CREATION_PARAMS;
#define NV_SET_SYSMEM_SURFACE_CREATION_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_SET_SYSMEM_SURFACE_CREATION_PARAMS_V1, 1)
#define NV_SET_SYSMEM_SURFACE_CREATION_PARAMS_VER NV_SET_SYSMEM_SURFACE_CREATION_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D1x_SetSystemMemorySurfaceCreation(IUnknown *pDev,
                                                           NV_SET_SYSMEM_SURFACE_CREATION_PARAMS *pParams);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef struct _NV_SET_ALIAS_SURFACE_CREATION_PARAMS {
  NvU32 version;
} NV_SET_ALIAS_SURFACE_CREATION_PARAMS_V1;
typedef NV_SET_ALIAS_SURFACE_CREATION_PARAMS_V1 NV_SET_ALIAS_SURFACE_CREATION_PARAMS;
#define NV_SET_ALIAS_SURFACE_CREATION_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_SET_ALIAS_SURFACE_CREATION_PARAMS_V1, 1)
#define NV_SET_ALIAS_SURFACE_CREATION_PARAMS_VER NV_SET_ALIAS_SURFACE_CREATION_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D1x_SetAliasSurfaceCreation(IUnknown *pDev, NV_SET_ALIAS_SURFACE_CREATION_PARAMS *pParams);
#endif
#if defined(__cplusplus) && (defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
typedef struct _NV_GET_ALIAS_SURFACE_HANDLE_PARAMS {
  NvU32 version;
  NvU64 hAlias;
} NV_GET_ALIAS_SURFACE_HANDLE_PARAMS_V1;
typedef NV_GET_ALIAS_SURFACE_HANDLE_PARAMS_V1 NV_GET_ALIAS_SURFACE_HANDLE_PARAMS;
#define NV_GET_ALIAS_SURFACE_HANDLE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_GET_ALIAS_SURFACE_HANDLE_PARAMS_V1, 1)
#define NV_GET_ALIAS_SURFACE_HANDLE_PARAMS_VER NV_GET_ALIAS_SURFACE_HANDLE_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D1x_GetAliasSurfaceHandle(IUnknown *pDev, NVDX_ObjectHandle hResource,
                                                  NV_GET_ALIAS_SURFACE_HANDLE_PARAMS *pParams);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_GetNeedsAppFPBlendClamping(__in IUnknown *pDev, __out bool *pAppClampNeeded);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_GetNeedsAppFPBlendClamping(__in ID3D12Device *pDevice, __out bool *pAppClampNeeded);
#endif
#if defined(__cplusplus) && (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) ||                    \
                             defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_IsDeviceSandbaggedByDefault(IUnknown *pDevice, bool *pSandbaggingEnabled);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_Aftermath_SetMarker(__in IUnknown *pDx11Context, __in void *pMarkerData,
                                                __in NvU32 markerSize);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_Aftermath_GetContextData(__in IUnknown *pDx11Context, __out void **pOutMarkerData,
                                                     __out NvU32 *pOutMarkerSize, __out NvU32 *pOutContextStatus);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_Aftermath_GetDeviceStatus(__in IUnknown *pDx11Context, __out NvU32 *pOutDeviceStatus);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_Aftermath_SetMarker(__in IUnknown *pDx12Context, __in void *pMarkerData,
                                                __in NvU32 markerSize);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_Aftermath_GetContextData(__in IUnknown *pDx12Context, __out void **pOutMarkerData,
                                                     __out NvU32 *pOutMarkerSize, __out NvU32 *pOutContextStatus);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_Aftermath_GetDeviceStatus(__in IUnknown *pUnknown, __out NvU32 *pOutDeviceStatus);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
#define NVAPI_D3D11_OGL_USE_D3D_FOR_MIRRORING 0x00000000
#define NVAPI_D3D11_OGL_USE_OGL_FOR_MIRRORING 0x00000001
NVAPI_INTERFACE NvAPI_D3D11_RegisterDeviceFromOGL(__in ID3D11Device *pDevice11, __in NvU32 uFlags);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_UseDriverHeapPriorities(__in ID3D12Device *pDevice);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
typedef struct _NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS {
  __in NvU32 version;
  __in ID3D12Device *pDevice;
  __in ID3D12Resource *pSwapChainBuffer;
  __in NvU32 companionBufferCount;
  __inout ID3D12Resource **ppCompanionResources;
} NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS_V1;
typedef NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS_V1 NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS;
#define NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS_VER1 MAKE_NVAPI_VERSION(NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS_V1, 1)
#define NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS_VER NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS_VER1
NVAPI_INTERFACE NvAPI_D3D12_Mosaic_GetCompanionAllocations(__inout NV_D3D12_MOSAIC_GETCOMPANIONALLOCATIONS *params);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
typedef struct _NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS {
  __in NvU32 version;
  __in ID3D12Device *pDevice;
  __in ID3D12Resource *pSwapChainBuffer;
  __inout NvU32 *pPartitionCount;
  __inout RECT *pViewport;
  __inout NvU32 *pNodeMask;
} NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS_V1;
typedef NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS_V1 NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS;
#define NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS_VER1                                                               \
  MAKE_NVAPI_VERSION(NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS_V1, 1)
#define NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS_VER NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS_VER1
NVAPI_INTERFACE NvAPI_D3D12_Mosaic_GetViewportAndGpuPartitions(
    __inout NV_D3D12_MOSAIC_GETVIEWPORTANDGPUPARTITIONS *params);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_RegisterContext(__in IUnknown *pDx11Context, __out void **ppOutDrvContext);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_RegisterContext(__in IUnknown *pDx12Context, __out void **ppOutDrvContext);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
typedef struct _NV_D3D1x_GRAPHICS_CAPS_V1 {
  NvU32 bExclusiveScissorRectsSupported : 1;
  NvU32 bVariablePixelRateShadingSupported : 1;
  NvU32 reservedBits : 30;
  NvU32 reserved[7];
} NV_D3D1x_GRAPHICS_CAPS_V1;
#define NV_D3D1x_GRAPHICS_CAPS_VER1 MAKE_NVAPI_VERSION(NV_D3D1x_GRAPHICS_CAPS_V1, 1)
typedef struct _NV_D3D1x_GRAPHICS_CAPS_V2 {
  NvU32 bExclusiveScissorRectsSupported : 1;
  NvU32 bVariablePixelRateShadingSupported : 1;
  NvU32 bFastUAVClearSupported : 1;
  NvU32 reservedBits : 29;
  NvU16 majorSMVersion;
  NvU16 minorSMVersion;
  NvU32 reserved[14];
} NV_D3D1x_GRAPHICS_CAPS_V2;
typedef NV_D3D1x_GRAPHICS_CAPS_V2 NV_D3D1x_GRAPHICS_CAPS;
#define NV_D3D1x_GRAPHICS_CAPS_VER2 MAKE_NVAPI_VERSION(NV_D3D1x_GRAPHICS_CAPS_V2, 2)
#define NV_D3D1x_GRAPHICS_CAPS_VER NV_D3D1x_GRAPHICS_CAPS_VER2
NVAPI_INTERFACE NvAPI_D3D1x_GetGraphicsCapabilities(__in IUnknown *pDevice, __in NvU32 structVersion,
                                                    __inout NV_D3D1x_GRAPHICS_CAPS *pGraphicsCaps);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
typedef struct _NV_D3D12_GRAPHICS_CAPS_V1 {
  NvU32 bExclusiveScissorRectsSupported : 1;
  NvU32 bVariablePixelRateShadingSupported : 1;
  NvU32 bFastUAVClearSupported : 1;
  NvU32 reservedBits : 29;
  NvU16 majorSMVersion;
  NvU16 minorSMVersion;
  NvU32 reserved[6];
} NV_D3D12_GRAPHICS_CAPS_V1;
typedef NV_D3D12_GRAPHICS_CAPS_V1 NV_D3D12_GRAPHICS_CAPS;
#define NV_D3D12_GRAPHICS_CAPS_VER1 MAKE_NVAPI_VERSION(NV_D3D12_GRAPHICS_CAPS_V1, 1)
#define NV_D3D12_GRAPHICS_CAPS_VER NV_D3D12_GRAPHICS_CAPS_VER1
NVAPI_INTERFACE NvAPI_D3D12_GetGraphicsCapabilities(__in IUnknown *pDevice, __in NvU32 structVersion,
                                                    __inout NV_D3D12_GRAPHICS_CAPS *pGraphicsCaps);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__))
#define NV_MAX_NUM_EXCLUSIVE_SCISSOR_RECTS 16
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
typedef struct _NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC_V1 {
  bool enableExclusiveScissorRect;
  D3D11_RECT scissorRect;
} NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC_V1;
typedef struct _NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_V1 {
  NvU32 version;
  NvU32 numRects;
  NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC_V1 *pRects;
} NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_V1;
typedef NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_V1 NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC;
typedef NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC_V1 NV_D3D11_EXCLUSIVE_SCISSOR_RECT_DESC;
#define NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_VER1 MAKE_NVAPI_VERSION(NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_V1, 1)
#define NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_VER NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC_VER1
NVAPI_INTERFACE NvAPI_D3D11_RSSetExclusiveScissorRects(
    __in IUnknown *pContext, __in NV_D3D11_EXCLUSIVE_SCISSOR_RECTS_DESC *pExclusiveScissorRectsDesc);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__))
#define NV_MAX_PIXEL_SHADING_RATES 16
#define NV_MAX_NUM_VIEWPORTS 16
#define NV_VARIABLE_PIXEL_SHADING_TILE_WIDTH 16
#define NV_VARIABLE_PIXEL_SHADING_TILE_HEIGHT 16
typedef enum {
  NV_PIXEL_X0_CULL_RASTER_PIXELS,
  NV_PIXEL_X16_PER_RASTER_PIXEL,
  NV_PIXEL_X8_PER_RASTER_PIXEL,
  NV_PIXEL_X4_PER_RASTER_PIXEL,
  NV_PIXEL_X2_PER_RASTER_PIXEL,
  NV_PIXEL_X1_PER_RASTER_PIXEL,
  NV_PIXEL_X1_PER_2X1_RASTER_PIXELS,
  NV_PIXEL_X1_PER_1X2_RASTER_PIXELS,
  NV_PIXEL_X1_PER_2X2_RASTER_PIXELS,
  NV_PIXEL_X1_PER_4X2_RASTER_PIXELS,
  NV_PIXEL_X1_PER_2X4_RASTER_PIXELS,
  NV_PIXEL_X1_PER_4X4_RASTER_PIXELS
} NV_PIXEL_SHADING_RATE;
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
typedef struct _NV_D3D11_VIEWPORT_SHADING_RATE_DESC_V1 {
  bool enableVariablePixelShadingRate;
  NV_PIXEL_SHADING_RATE shadingRateTable[NV_MAX_PIXEL_SHADING_RATES];
} NV_D3D11_VIEWPORT_SHADING_RATE_DESC_V1;
typedef struct _NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_V1 {
  NvU32 version;
  NvU32 numViewports;
  NV_D3D11_VIEWPORT_SHADING_RATE_DESC_V1 *pViewports;
} NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_V1;
typedef NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_V1 NV_D3D11_VIEWPORTS_SHADING_RATE_DESC;
typedef NV_D3D11_VIEWPORT_SHADING_RATE_DESC_V1 NV_D3D11_VIEWPORT_SHADING_RATE_DESC;
#define NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_VER1 MAKE_NVAPI_VERSION(NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_V1, 1)
#define NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_VER NV_D3D11_VIEWPORTS_SHADING_RATE_DESC_VER1
NVAPI_INTERFACE NvAPI_D3D11_RSSetViewportsPixelShadingRates(
    __in IUnknown *pContext, __in NV_D3D11_VIEWPORTS_SHADING_RATE_DESC *pShadingRateDesc);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__))
typedef enum _NV_SRRV_DIMENSION {
  NV_SRRV_DIMENSION_TEXTURE2D = 4,
  NV_SRRV_DIMENSION_TEXTURE2DARRAY = 5,
} NV_SRRV_DIMENSION;
typedef struct _NV_TEX2D_SRRV {
  UINT MipSlice;
} NV_TEX2D_SRRV;
typedef struct _NV_TEX2D_ARRAY_SRRV {
  UINT MipSlice;
  UINT FirstArraySlice;
  UINT ArraySize;
} NV_TEX2D_ARRAY_SRRV;
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
typedef struct _NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1 {
  NvU32 version;
  DXGI_FORMAT Format;
  NV_SRRV_DIMENSION ViewDimension;
  union {
    NV_TEX2D_SRRV Texture2D;
    NV_TEX2D_ARRAY_SRRV Texture2DArray;
  };
} NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1;
typedef NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1 NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC;
#define NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_VER1 MAKE_NVAPI_VERSION(NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_V1, 1)
#define NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_VER NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC_VER1
DECLARE_INTERFACE_(__declspec(uuid("E14BE7F6-8FF5-4F5E-B63A-AD016EB8FBE5")) ID3D11NvShadingRateResourceView_V1,
                   ID3D11View) {
  BEGIN_INTERFACE
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  STDMETHOD_(void, GetResource)(THIS_ _Outptr_ ID3D11Resource * *ppResource) PURE;
  STDMETHOD(GetDesc)(THIS_ NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC * pDesc) PURE;
  END_INTERFACE
};
typedef ID3D11NvShadingRateResourceView_V1 ID3D11NvShadingRateResourceView;
#define ID3D11NvShadingRateResourceView_VER1 MAKE_NVAPI_VERSION(ID3D11NvShadingRateResourceView_V1, 1)
#define ID3D11NvShadingRateResourceView_VER ID3D11NvShadingRateResourceView_VER1
NVAPI_INTERFACE NvAPI_D3D11_CreateShadingRateResourceView(
    __in ID3D11Device *pDevice, __in ID3D11Resource *pShadingRateResource,
    __in NV_D3D11_SHADING_RATE_RESOURCE_VIEW_DESC *pShadingRateResourceViewDesc,
    __out ID3D11NvShadingRateResourceView **ppShadingRateResourceView);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D11_RSSetShadingRateResourceView(
    __in IUnknown *pContext, __in ID3D11NvShadingRateResourceView *pShadingRateResourceView);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__))
typedef struct _NV_PIXEL_SRSO_1x2 {
  struct NV_PIXEL_SRSO_1x2_X1 {
    NvU8 Y[2];
  } X1;
  struct NV_PIXEL_SRSO_1x2_X2 {
    NvU8 YS[2][2];
  } X2;
  struct NV_PIXEL_SRSO_1x2_X4 {
    NvU8 YS[2][4];
  } X4;
  struct NV_PIXEL_SRSO_1x2_X8 {
    NvU8 YS[2][8];
  } X8;
} NV_PIXEL_SRSO_1x2;
typedef struct _NV_PIXEL_SRSO_2x1 {
  struct NV_PIXEL_SRSO_2x1_X1 {
    NvU8 X[2];
  } X1;
  struct NV_PIXEL_SRSO_2x1_X2 {
    NvU8 XS[2][2];
  } X2;
  struct NV_PIXEL_SRSO_2x1_X4 {
    NvU8 XS[2][4];
  } X4;
} NV_PIXEL_SRSO_2x1;
typedef struct _NV_PIXEL_SRSO_2x2 {
  struct NV_PIXEL_SRSO_2x2_X1 {
    NvU8 YX[2][2];
  } X1;
  struct NV_PIXEL_SRSO_2x2_X2 {
    NvU8 YXS[2][2][2];
  } X2;
  struct NV_PIXEL_SRSO_2x2_X4 {
    NvU8 YXS[2][2][4];
  } X4;
} NV_PIXEL_SRSO_2x2;
typedef struct _NV_PIXEL_SRSO_2x4 {
  struct NV_PIXEL_SRSO_2x4_X1 {
    NvU8 YX[4][2];
  } X1;
  struct NV_PIXEL_SRSO_2x4_X2 {
    NvU8 YXS[4][2][2];
  } X2;
} NV_PIXEL_SRSO_2x4;
typedef struct _NV_PIXEL_SRSO_4x2 {
  struct NV_PIXEL_SRSO_4x2_X1 {
    NvU8 YX[2][4];
  } X1;
} NV_PIXEL_SRSO_4x2;
typedef struct _NV_PIXEL_SRSO_4x4 {
  struct NV_PIXEL_SRSO_4x4_X1 {
    NvU8 YX[4][4];
  } X1;
} NV_PIXEL_SRSO_4x4;
typedef struct _NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_V1 {
  NvU32 version;
  NV_PIXEL_SRSO_1x2 Pixel_1x2;
  NV_PIXEL_SRSO_2x1 Pixel_2x1;
  NV_PIXEL_SRSO_2x2 Pixel_2x2;
  NV_PIXEL_SRSO_2x4 Pixel_2x4;
  NV_PIXEL_SRSO_4x2 Pixel_4x2;
  NV_PIXEL_SRSO_4x4 Pixel_4x4;
} NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_V1;
typedef NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_V1 NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE;
#define NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_VER1 MAKE_NVAPI_VERSION(NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_V1, 1)
#define NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_VER NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE_VER1
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D11_RSGetPixelShadingRateSampleOrder(
    __in IUnknown *pContext, __out NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE *pSampleOrderTable);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D11_RSSetPixelShadingRateSampleOrder(
    __in IUnknown *pContext, __in NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE *pSampleOrderTable);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
typedef struct _NV_D3D12_EXCLUSIVE_SCISSOR_RECT_DESC_V1 {
  bool enableExclusiveScissorRect;
  D3D12_RECT scissorRect;
} NV_D3D12_EXCLUSIVE_SCISSOR_RECT_DESC_V1;
typedef struct _NV_D3D12_EXCLUSIVE_SCISSOR_RECTS_DESC_V1 {
  NvU32 version;
  NvU32 numRects;
  NV_D3D12_EXCLUSIVE_SCISSOR_RECT_DESC_V1 *pRects;
} NV_D3D12_EXCLUSIVE_SCISSOR_RECTS_DESC_V1;
typedef NV_D3D12_EXCLUSIVE_SCISSOR_RECTS_DESC_V1 NV_D3D12_EXCLUSIVE_SCISSOR_RECTS_DESC;
typedef NV_D3D12_EXCLUSIVE_SCISSOR_RECT_DESC_V1 NV_D3D12_EXCLUSIVE_SCISSOR_RECT_DESC;
#define NV_D3D12_EXCLUSIVE_SCISSOR_RECTS_DESC_VER1 MAKE_NVAPI_VERSION(NV_D3D12_EXCLUSIVE_SCISSOR_RECTS_DESC_V1, 1)
#define NV_D3D12_EXCLUSIVE_SCISSOR_RECTS_DESC_VER NV_D3D12_EXCLUSIVE_SCISSOR_RECTS_DESC_VER1
NVAPI_INTERFACE NvAPI_D3D12_RSSetExclusiveScissorRects(
    __in IUnknown *pContext, __in NV_D3D12_EXCLUSIVE_SCISSOR_RECTS_DESC *pExclusiveScissorRectsDesc);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
typedef struct _NV_D3D12_VIEWPORT_SHADING_RATE_DESC_V1 {
  bool enableVariablePixelShadingRate;
  NV_PIXEL_SHADING_RATE shadingRateTable[NV_MAX_PIXEL_SHADING_RATES];
} NV_D3D12_VIEWPORT_SHADING_RATE_DESC_V1;
typedef struct _NV_D3D12_VIEWPORTS_SHADING_RATE_DESC_V1 {
  NvU32 version;
  NvU32 numViewports;
  NV_D3D12_VIEWPORT_SHADING_RATE_DESC_V1 *pViewports;
} NV_D3D12_VIEWPORTS_SHADING_RATE_DESC_V1;
typedef NV_D3D12_VIEWPORTS_SHADING_RATE_DESC_V1 NV_D3D12_VIEWPORTS_SHADING_RATE_DESC;
typedef NV_D3D12_VIEWPORT_SHADING_RATE_DESC_V1 NV_D3D12_VIEWPORT_SHADING_RATE_DESC;
#define NV_D3D12_VIEWPORTS_SHADING_RATE_DESC_VER1 MAKE_NVAPI_VERSION(NV_D3D12_VIEWPORTS_SHADING_RATE_DESC_V1, 1)
#define NV_D3D12_VIEWPORTS_SHADING_RATE_DESC_VER NV_D3D12_VIEWPORTS_SHADING_RATE_DESC_VER1
NVAPI_INTERFACE NvAPI_D3D12_RSSetViewportsPixelShadingRates(
    __in IUnknown *pContext, __in NV_D3D12_VIEWPORTS_SHADING_RATE_DESC *pShadingRateDesc);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
typedef struct _NV_D3D12_SHADING_RATE_RESOURCE_VIEW_DESC_V1 {
  NvU32 version;
  DXGI_FORMAT Format;
  NV_SRRV_DIMENSION ViewDimension;
  union {
    NV_TEX2D_SRRV Texture2D;
    NV_TEX2D_ARRAY_SRRV Texture2DArray;
  };
} NV_D3D12_SHADING_RATE_RESOURCE_VIEW_DESC_V1;
typedef NV_D3D12_SHADING_RATE_RESOURCE_VIEW_DESC_V1 NV_D3D12_SHADING_RATE_RESOURCE_VIEW_DESC;
#define NV_D3D12_SHADING_RATE_RESOURCE_VIEW_DESC_VER1 MAKE_NVAPI_VERSION(NV_D3D12_SHADING_RATE_RESOURCE_VIEW_DESC_V1, 1)
#define NV_D3D12_SHADING_RATE_RESOURCE_VIEW_DESC_VER NV_D3D12_SHADING_RATE_RESOURCE_VIEW_DESC_VER1
NVAPI_INTERFACE NvAPI_D3D12_CreateShadingRateResourceView(
    __in ID3D12Device *pDevice, __in ID3D12Resource *pShadingRateResource,
    __in NV_D3D12_SHADING_RATE_RESOURCE_VIEW_DESC *pShadingRateResourceViewDesc,
    __in D3D12_CPU_DESCRIPTOR_HANDLE sDescriptorForSRRV);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D12_RSSetShadingRateResourceView(__in IUnknown *pContext,
                                                         __in D3D12_CPU_DESCRIPTOR_HANDLE sDescriptorForSRRV);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D12_RSGetPixelShadingRateSampleOrder(
    __in ID3D12Device *pContext, __out NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE *pSampleOrderTable);
#endif
#if defined(__cplusplus) && (defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D12_RSSetPixelShadingRateSampleOrder(
    __in IUnknown *pContext, __in NV_PIXEL_SHADING_RATE_SAMPLE_ORDER_TABLE *pSampleOrderTable);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
typedef struct _NV_VRS_HELPER_LATCH_GAZE_PARAMS_V1 {
  NvU32 version;
  NvU32 flags;
} NV_VRS_HELPER_LATCH_GAZE_PARAMS_V1;
typedef NV_VRS_HELPER_LATCH_GAZE_PARAMS_V1 NV_VRS_HELPER_LATCH_GAZE_PARAMS;
#define NV_VRS_HELPER_LATCH_GAZE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_VRS_HELPER_LATCH_GAZE_PARAMS_V1, 1)
#define NV_VRS_HELPER_LATCH_GAZE_PARAMS_VER NV_VRS_HELPER_LATCH_GAZE_PARAMS_VER1
typedef enum _NV_VRS_CONTENT_TYPE {
  NV_VRS_CONTENT_TYPE_INVALID = 0x0,
  NV_VRS_CONTENT_TYPE_FOVEATED_RENDERING = 0x1,
  NV_VRS_CONTENT_TYPE_MAX = NV_VRS_CONTENT_TYPE_FOVEATED_RENDERING
} NV_VRS_CONTENT_TYPE;
typedef enum _NV_FOVEATED_RENDERING_SHADING_RATE_PRESET {
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_INVALID = 0,
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_HIGHEST_PERFORMANCE = 1,
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_HIGH_PERFORMANCE = 2,
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_BALANCED = 3,
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_HIGH_QUALITY = 4,
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_HIGHEST_QUALITY = 5,
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_CUSTOM = 6,
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_MAX = NV_FOVEATED_RENDERING_SHADING_RATE_PRESET_CUSTOM
} NV_FOVEATED_RENDERING_SHADING_RATE_PRESET;
typedef struct _NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1 {
  NvU32 version;
  NV_PIXEL_SHADING_RATE InnerMostRegionShadingRate;
  NV_PIXEL_SHADING_RATE MiddleRegionShadingRate;
  NV_PIXEL_SHADING_RATE PeripheralRegionShadingRate;
} NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1;
typedef NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1 NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC;
#define NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_VER1                                                     \
  MAKE_NVAPI_VERSION(NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1, 1)
#define NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_VER                                                      \
  NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_VER1
typedef enum _NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET {
  NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_INVALID = 0,
  NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_WIDE = 1,
  NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_BALANCED = 2,
  NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_NARROW = 3,
  NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_CUSTOM = 4,
  NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_MAX = NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET_CUSTOM
} NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET;
typedef struct _NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1 {
  NvU32 version;
  float fInnermostRadii[2];
  float fMiddleRadii[2];
  float fPeripheralRadii[2];
} NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1;
typedef NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1
    NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC;
#define NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_VER1                                                \
  MAKE_NVAPI_VERSION(NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1, 1)
#define NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_VER                                                 \
  NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_VER1
typedef struct _NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V2 {
  NvU32 version;
  float fInnermostRadii[2];
  float fMiddleRadii[2];
  float fPeripheralRadii[2];
  float fAnisotropicThreshold;
} NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V2;
#define NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_VER2                                                \
  MAKE_NVAPI_VERSION(NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V2, 2)
typedef enum _NV_FOVEATED_RENDERING_DESC_FLAGS {
  NV_FOVEATED_RENDERING_USE_PERSPECTIVE = 0x01,
  NV_FOVEATED_RENDERING_USE_ANISOTROPIC = 0x02
} NV_FOVEATED_RENDERING_DESC_FLAGS;
typedef struct _NV_FOVEATED_RENDERING_DESC_V1 {
  NvU32 version;
  NvU32 flags;
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET ShadingRatePreset;
  NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1 ShadingRateCustomPresetDesc;
  NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET FoveationPatternPreset;
  NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V1 FoveationPatternCustomPresetDesc;
  NvU32 GazeDataDeviceId;
} NV_FOVEATED_RENDERING_DESC_V1;
typedef NV_FOVEATED_RENDERING_DESC_V1 NV_FOVEATED_RENDERING_DESC;
#define NV_FOVEATED_RENDERING_DESC_VER1 MAKE_NVAPI_VERSION(NV_FOVEATED_RENDERING_DESC_V1, 1)
#define NV_FOVEATED_RENDERING_DESC_VER NV_FOVEATED_RENDERING_DESC_VER1
typedef struct _NV_FOVEATED_RENDERING_DESC_V2 {
  NvU32 version;
  NvU32 flags;
  NV_FOVEATED_RENDERING_SHADING_RATE_PRESET ShadingRatePreset;
  NV_FOVEATED_RENDERING_CUSTOM_SHADING_RATE_PRESET_DESC_V1 ShadingRateCustomPresetDesc;
  NV_FOVEATED_RENDERING_FOVEATION_PATTERN_PRESET FoveationPatternPreset;
  NV_FOVEATED_RENDERING_CUSTOM_FOVEATION_PATTERN_PRESET_DESC_V2 FoveationPatternCustomPresetDesc;
  NvU32 GazeDataDeviceId;
} NV_FOVEATED_RENDERING_DESC_V2;
#define NV_FOVEATED_RENDERING_DESC_VER2 MAKE_NVAPI_VERSION(NV_FOVEATED_RENDERING_DESC_V2, 2)
typedef enum _NV_VRS_RENDER_MODE {
  NV_VRS_RENDER_MODE_INVALID = 0,
  NV_VRS_RENDER_MODE_MONO = 1,
  NV_VRS_RENDER_MODE_LEFT_EYE = 2,
  NV_VRS_RENDER_MODE_RIGHT_EYE = 3,
  NV_VRS_RENDER_MODE_STEREO = 4,
  NV_VRS_RENDER_MODE_MAX = NV_VRS_RENDER_MODE_STEREO
} NV_VRS_RENDER_MODE;
#define MAX_NUMBER_OF_GAZE_DATA_PROVIDERS 8
typedef struct _NV_VRS_HELPER_ENABLE_PARAMS_V1 {
  NvU32 version;
  NvU32 flags;
  NV_VRS_RENDER_MODE RenderMode;
  NV_VRS_CONTENT_TYPE ContentType;
  NV_FOVEATED_RENDERING_DESC_V1 sFoveatedRenderingDesc;
} NV_VRS_HELPER_ENABLE_PARAMS_V1;
typedef NV_VRS_HELPER_ENABLE_PARAMS_V1 NV_VRS_HELPER_ENABLE_PARAMS;
#define NV_VRS_HELPER_ENABLE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_VRS_HELPER_ENABLE_PARAMS_V1, 1)
#define NV_VRS_HELPER_ENABLE_PARAMS_VER NV_VRS_HELPER_ENABLE_PARAMS_VER1
typedef struct _NV_VRS_HELPER_ENABLE_PARAMS_V2 {
  NvU32 version;
  NvU32 flags;
  NV_VRS_RENDER_MODE RenderMode;
  NV_VRS_CONTENT_TYPE ContentType;
  NV_FOVEATED_RENDERING_DESC_V2 sFoveatedRenderingDesc;
} NV_VRS_HELPER_ENABLE_PARAMS_V2;
#define NV_VRS_HELPER_ENABLE_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_VRS_HELPER_ENABLE_PARAMS_V2, 2)
typedef struct _NV_VRS_HELPER_DISABLE_PARAMS_V1 {
  NvU32 version;
  NvU32 reserved;
} NV_VRS_HELPER_DISABLE_PARAMS_V1;
typedef NV_VRS_HELPER_DISABLE_PARAMS_V1 NV_VRS_HELPER_DISABLE_PARAMS;
#define NV_VRS_HELPER_DISABLE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_VRS_HELPER_DISABLE_PARAMS_V1, 1)
#define NV_VRS_HELPER_DISABLE_PARAMS_VER NV_VRS_HELPER_DISABLE_PARAMS_VER1
typedef struct _NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_V1 {
  NvU32 version;
  IUnknown **ppShadingRateResource;
  NV_PIXEL_SHADING_RATE shadingRateTable[NV_MAX_PIXEL_SHADING_RATES];
} NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_V1;
typedef NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_V1 NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS;
#define NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_VER1                                                            \
  MAKE_NVAPI_VERSION(NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_V1, 1)
#define NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_VER NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS_VER1
typedef struct _NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_V1 {
  NvU32 version;
  NvU32 reserved;
} NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_V1;
typedef NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_V1 NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS;
#define NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_VER1                                                             \
  MAKE_NVAPI_VERSION(NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_V1, 1)
#define NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_VER NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS_VER1
DECLARE_INTERFACE(ID3DNvVRSHelper_V1) {
  BEGIN_INTERFACE
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  STDMETHOD_(NvAPI_Status, LatchGaze)(THIS_ IUnknown * pContext, NV_VRS_HELPER_LATCH_GAZE_PARAMS * pLatchGazeParams)
      PURE;
  STDMETHOD_(NvAPI_Status, Enable)(THIS_ IUnknown * pContext, NV_VRS_HELPER_ENABLE_PARAMS * pEnableParams) PURE;
  STDMETHOD_(NvAPI_Status, Disable)(THIS_ IUnknown * pContext, NV_VRS_HELPER_DISABLE_PARAMS * pDisableParams) PURE;
  STDMETHOD_(NvAPI_Status, GetShadingRateResource)(
      THIS_ IUnknown * pContext, NV_VRS_HELPER_GET_SHADING_RATE_RESOURCE_PARAMS * pGetShadingRateResourceParams) PURE;
  STDMETHOD_(NvAPI_Status, PurgeInternalShadingRateResources)(
      THIS_ IUnknown * pContext, NV_VRS_HELPER_PURGE_INTERNAL_RESOURCES_PARAMS * pPurgeParams) PURE;
  END_INTERFACE
};
typedef ID3DNvVRSHelper_V1 ID3DNvVRSHelper;
#define ID3DNvVRSHelper_VER1 MAKE_NVAPI_VERSION(ID3DNvVRSHelper_V1, 1)
#define ID3DNvVRSHelper_VER ID3DNvVRSHelper_VER1
typedef struct _NV_VRS_HELPER_INIT_PARAMS_V1 {
  NvU32 version;
  NvU32 flags;
  ID3DNvVRSHelper_V1 **ppVRSHelper;
} NV_VRS_HELPER_INIT_PARAMS_V1;
typedef NV_VRS_HELPER_INIT_PARAMS_V1 NV_VRS_HELPER_INIT_PARAMS;
#define NV_VRS_HELPER_INIT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_VRS_HELPER_INIT_PARAMS_V1, 1)
#define NV_VRS_HELPER_INIT_PARAMS_VER NV_VRS_HELPER_INIT_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_InitializeVRSHelper(__in IUnknown *pDevice,
                                              __inout NV_VRS_HELPER_INIT_PARAMS *pInitializeVRSHelperParams);
typedef enum _NV_GAZE_DATA_VALIDITY_FLAGS {
  NV_GAZE_ORIGIN_VALID = 0x1,
  NV_GAZE_DIRECTION_VALID = 0x2,
  NV_GAZE_LOCATION_VALID = 0x4,
  NV_GAZE_VELOCITY_VALID = 0x8,
  NV_GAZE_PUPIL_DIAMETER_VALID = 0x10,
  NV_GAZE_EYE_OPENNESS_VALID = 0x20,
  NV_GAZE_EYE_SACCADE_DATA_VALID = 0x40
} NV_GAZE_DATA_VALIDITY_FLAGS;
typedef struct _NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE {
  NvU32 version;
  NvU32 GazeDataValidityFlags;
  float fGazeOrigin_mm[3];
  float fGazeDirection[3];
  float fGazeNormalizedLocation[2];
  float fGazeVelocity[2];
  float fPupilDiameter_mm;
  float fEyeOpenness;
  BOOL bInSaccade;
} NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1;
typedef NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1 NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE;
#define NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_VER1 MAKE_NVAPI_VERSION(NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1, 1)
#define NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_VER NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_VER1
typedef struct _NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS {
  NvU32 version;
  NvU32 flags;
  NvU64 Timestamp;
  union {
    NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1 sMonoData;
    struct {
      NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1 sLeftEye;
      NV_FOVEATED_RENDERING_GAZE_DATA_PER_EYE_V1 sRightEye;
    } sStereoData;
  };
} NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS_V1;
typedef NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS_V1 NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS;
#define NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS_VER1                                                             \
  MAKE_NVAPI_VERSION(NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS_V1, 1)
#define NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS_VER NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS_VER1
#define NV_GAZE_PROVIDER_KEY_LENGTH 16
typedef struct _NV_INITIALIZE_GAZE_PROVIDER_PARAMS {
  NvU32 version;
  NvU8 sessionID[NV_GAZE_PROVIDER_KEY_LENGTH];
} NV_INITIALIZE_GAZE_PROVIDER_PARAMS_V1;
#define NV_INITIALIZE_GAZE_PROVIDER_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_INITIALIZE_GAZE_PROVIDER_PARAMS_V1, 1)
typedef NV_INITIALIZE_GAZE_PROVIDER_PARAMS_V1 NV_INITIALIZE_GAZE_PROVIDER_PARAMS;
#define NV_INITIALIZE_GAZE_PROVIDER_PARAMS_VER NV_INITIALIZE_GAZE_PROVIDER_PARAMS_VER1
typedef struct _NV_REGISTER_GAZE_PROVIDER_PARAMS {
  NvU32 version;
  NvU32 flags;
  NvU8 providerID[NV_GAZE_PROVIDER_KEY_LENGTH];
  NvU32 vendorID;
  NvU32 productID;
} NV_REGISTER_GAZE_PROVIDER_PARAMS_V1;
#define NV_REGISTER_GAZE_PROVIDER_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_REGISTER_GAZE_PROVIDER_PARAMS_V1, 1)
typedef NV_REGISTER_GAZE_PROVIDER_PARAMS_V1 NV_REGISTER_GAZE_PROVIDER_PARAMS;
#define NV_REGISTER_GAZE_PROVIDER_PARAMS_VER NV_REGISTER_GAZE_PROVIDER_PARAMS_VER1
typedef struct _NV_GAZE_CONSUMPTION_INFO_PARAMS {
  NvU32 version;
  NvU32 reservedFlags;
  NvU32 consumerCount;
  NvU64 prevFrameIndex;
  NvU64 prevFrameGazeTimestamp;
  NvU64 prevFrameGazeConsumedTimestamp;
} NV_GAZE_CONSUMPTION_INFO_PARAMS_V1;
#define NV_GAZE_CONSUMPTION_INFO_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_GAZE_CONSUMPTION_INFO_PARAMS_V1, 1)
typedef NV_GAZE_CONSUMPTION_INFO_PARAMS_V1 NV_GAZE_CONSUMPTION_INFO_PARAMS;
#define NV_GAZE_CONSUMPTION_INFO_PARAMS_VER NV_GAZE_CONSUMPTION_INFO_PARAMS_VER1
DECLARE_INTERFACE(ID3DNvGazeHandler_V2) {
  BEGIN_INTERFACE
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  STDMETHOD_(NvAPI_Status, UpdateGazeData)(THIS_ IUnknown * pContext,
                                           NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS * pUpdateGazeDataParams) PURE;
  STDMETHOD_(NvAPI_Status, InitializeGazeProvider)(THIS_ IUnknown * pContext,
                                                   NV_INITIALIZE_GAZE_PROVIDER_PARAMS * pInitializationParams) PURE;
  STDMETHOD_(NvAPI_Status, RegisterGazeProvider)(THIS_ IUnknown * pContext,
                                                 NV_REGISTER_GAZE_PROVIDER_PARAMS * pRegisterGazeProviderparams) PURE;
  STDMETHOD_(NvAPI_Status, GetGazeConsumptionInfo)(THIS_ IUnknown * pContext,
                                                   NV_GAZE_CONSUMPTION_INFO_PARAMS * pConsumptionInfoParams) PURE;
  STDMETHOD_(NvAPI_Status, GetWaitableObjectForConsumerAvailability)(THIS_ IUnknown * pContext, HANDLE * hEvent) PURE;
  STDMETHOD_(NvAPI_Status, DeRegisterGazeProvider)(THIS_ IUnknown * pContext) PURE;
  END_INTERFACE
};
typedef ID3DNvGazeHandler_V2 ID3DNvGazeHandler;
#define ID3DNvGazeHandler_VER2 MAKE_NVAPI_VERSION(ID3DNvGazeHandler_V2, 2)
#define ID3DNvGazeHandler_VER ID3DNvGazeHandler_VER2
DECLARE_INTERFACE(ID3DNvGazeHandler_V1) {
  BEGIN_INTERFACE
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  STDMETHOD_(NvAPI_Status, UpdateGazeData)(THIS_ IUnknown * pContext,
                                           NV_FOVEATED_RENDERING_UPDATE_GAZE_DATA_PARAMS * pUpdateGazeDataParams) PURE;
  END_INTERFACE
};
#define ID3DNvGazeHandler_VER1 MAKE_NVAPI_VERSION(ID3DNvGazeHandler_V1, 1)
#ifndef ID3DNvGazeHandler_VER
typedef ID3DNvGazeHandler_V1 ID3DNvGazeHandler;
#define ID3DNvGazeHandler_VER ID3DNvGazeHandler_VER1
#endif
typedef enum _NV_GAZE_DATA_TYPE {
  NV_GAZE_DATA_INVALID = 0,
  NV_GAZE_DATA_MONO = 1,
  NV_GAZE_DATA_STEREO = 2,
  NV_GAZE_DATA_MAX = NV_GAZE_DATA_STEREO
} NV_GAZE_DATA_TYPE;
typedef struct _NV_GAZE_HANDLER_INIT_PARAMS_V2 {
  NvU32 version;
  NvU32 GazeDataDeviceId;
  NV_GAZE_DATA_TYPE GazeDataType;
  NvU32 flags;
  float fHorizontalFOV;
  float fVericalFOV;
  ID3DNvGazeHandler_V2 **ppNvGazeHandler;
} NV_GAZE_HANDLER_INIT_PARAMS_V2;
typedef NV_GAZE_HANDLER_INIT_PARAMS_V2 NV_GAZE_HANDLER_INIT_PARAMS;
#define NV_GAZE_HANDLER_INIT_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_GAZE_HANDLER_INIT_PARAMS_V2, 2)
#define NV_GAZE_HANDLER_INIT_PARAMS_VER NV_GAZE_HANDLER_INIT_PARAMS_VER2
typedef struct _NV_GAZE_HANDLER_INIT_PARAMS_V1 {
  NvU32 version;
  NvU32 GazeDataDeviceId;
  NV_GAZE_DATA_TYPE GazeDataType;
  NvU32 flags;
  float fHorizontalFOV;
  float fVericalFOV;
  ID3DNvGazeHandler_V1 **ppNvGazeHandler;
} NV_GAZE_HANDLER_INIT_PARAMS_V1;
#define NV_GAZE_HANDLER_INIT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_GAZE_HANDLER_INIT_PARAMS_V1, 1)
#ifndef NV_GAZE_HANDLER_INIT_PARAMS_VER
typedef NV_GAZE_HANDLER_INIT_PARAMS_V1 NV_GAZE_HANDLER_INIT_PARAMS;
#define NV_GAZE_HANDLER_INIT_PARAMS_VER NV_GAZE_HANDLER_INIT_PARAMS_VER1
#endif
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_InitializeNvGazeHandler(__in IUnknown *pDevice,
                                                  __inout NV_GAZE_HANDLER_INIT_PARAMS *pInitializeNvGazeHandlerParams);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_Aftermath_Initialize(__in IUnknown *pDx11Context, __in NvU32 flags);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_Aftermath_Initialize(__in IUnknown *pDx12Context, __in NvU32 flags);
#endif
#if defined(__cplusplus) && (defined(__d3d11_h__) || defined(__d3d12_h__))
struct NV_AFTERMATH_RESOURCE_DESCRIPTOR {
  const void *pAppRes;
  NvU64 size;
  NvU32 width;
  NvU32 height;
  NvU32 depth;
  NvU16 mipLevels;
  DXGI_FORMAT format;
  bool bIsBufferHeap : 1;
  bool bIsStaticTextureHeap : 1;
  bool bIsRtvDsvTextureHeap : 1;
  bool bPlacedResource : 1;
  bool bWasDestroyed : 1;
};
struct NV_AFTERMATH_PAGE_FAULT_INFORMATION {
  NvU64 faultingGpuVA;
  NV_AFTERMATH_RESOURCE_DESCRIPTOR resourceDesc;
  bool bHasPageFaultOccured : 1;
};
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_Aftermath_GetPageFaultInformation(
    __in IUnknown *pDx11Context, __out NV_AFTERMATH_PAGE_FAULT_INFORMATION *pOutPageFaultInformation);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_Aftermath_GetPageFaultInformation(
    __in IUnknown *pDx12Context, __out NV_AFTERMATH_PAGE_FAULT_INFORMATION *pOutPageFaultInformation);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef enum NV_SMP_ASSIST_TYPE {
  NV_SMP_ASSIST_NONE = 0,
  NV_SMP_ASSIST_MRS = 1,
  NV_SMP_ASSIST_LMS = 2,
  NV_SMP_ASSIST_NUM_TYPES
} NV_SMP_ASSIST_TYPE;
typedef enum NV_SMP_ASSIST_LEVEL {
  NV_SMP_ASSIST_LEVEL_FULL = 0,
  NV_SMP_ASSIST_LEVEL_PARTIAL = 1,
  NV_SMP_ASSIST_LEVEL_MINIMAL = 2,
  NV_SMP_ASSIST_NUM_LEVELS
} NV_SMP_ASSIST_LEVEL;
typedef enum NV_MRS_CONFIG {
  NV_MRS_CONFIG_BALANCED = 0,
  NV_MRS_CONFIG_AGGRESSIVE = 1,
  NV_MRS_CONFIG_OCULUSRIFT_CV1_CONSERVATIVE = 2,
  NV_MRS_CONFIG_OCULUSRIFT_CV1_BALANCED = 3,
  NV_MRS_CONFIG_OCULUSRIFT_CV1_AGGRESSIVE = 4,
  NV_MRS_CONFIG_HTC_VIVE_CONSERVATIVE = 5,
  NV_MRS_CONFIG_HTC_VIVE_BALANCED = 6,
  NV_MRS_CONFIG_HTC_VIVE_AGGRESSIVE = 7,
  NV_MRS_NUM_CONFIGS
} NV_MRS_CONFIG;
typedef enum NV_LMS_CONFIG {
  NV_LMS_CONFIG_OCULUSRIFT_CV1_CONSERVATIVE = 0,
  NV_LMS_CONFIG_OCULUSRIFT_CV1_BALANCED = 1,
  NV_LMS_CONFIG_OCULUSRIFT_CV1_AGGRESSIVE = 2,
  NV_LMS_CONFIG_HTC_VIVE_CONSERVATIVE = 3,
  NV_LMS_CONFIG_HTC_VIVE_BALANCED = 4,
  NV_LMS_CONFIG_HTC_VIVE_AGGRESSIVE = 5,
  NV_LMS_NUM_CONFIGS
} NV_LMS_CONFIG;
#define NV_SMP_ASSIST_FLAGS_DEFAULT 0x00000000
#define NV_SMP_ASSIST_MAX_VIEWPORTS 16
typedef struct _NV_MRS_CUSTOM_CONFIG_V1 {
  float centerWidth;
  float centerHeight;
  float centerX;
  float centerY;
  float densityScaleX[3];
  float densityScaleY[3];
} NV_MRS_CUSTOM_CONFIG_V1;
typedef NV_MRS_CUSTOM_CONFIG_V1 NV_MRS_CUSTOM_CONFIG;
typedef struct _NV_MRS_INSTANCED_STEREO_CONFIG_V1 {
  float centerWidth[2];
  float centerHeight;
  float centerX[2];
  float centerY;
  float densityScaleX[5];
  float densityScaleY[3];
} NV_MRS_INSTANCED_STEREO_CONFIG_V1;
typedef NV_MRS_INSTANCED_STEREO_CONFIG_V1 NV_MRS_INSTANCED_STEREO_CONFIG;
typedef struct _NV_LMS_CUSTOM_CONFIG_V1 {
  float warpLeft;
  float warpRight;
  float warpUp;
  float warpDown;
  float relativeSizeLeft;
  float relativeSizeRight;
  float relativeSizeUp;
  float relativeSizeDown;
} NV_LMS_CUSTOM_CONFIG_V1;
typedef NV_LMS_CUSTOM_CONFIG_V1 NV_LMS_CUSTOM_CONFIG;
typedef struct _NV_LMS_INSTANCED_STEREO_CONFIG_V1 {
  NV_LMS_CUSTOM_CONFIG_V1 sLeftConfig;
  NV_LMS_CUSTOM_CONFIG_V1 sRightConfig;
} NV_LMS_INSTANCED_STEREO_CONFIG_V1;
typedef NV_LMS_INSTANCED_STEREO_CONFIG_V1 NV_LMS_INSTANCED_STEREO_CONFIG;
typedef enum _NV_SMP_ASSIST_EYE_INDEX {
  NV_SMP_ASSIST_EYE_INDEX_MONO = 0,
  NV_SMP_ASSIST_EYE_INDEX_LEFT_EYE = 1,
  NV_SMP_ASSIST_EYE_INDEX_RIGHT_EYE = 2,
  NV_SMP_ASSIST_EYE_INDEX_INSTANCED_STEREO = 3,
  NV_SMP_ASSIST_RENDER_SINGLE_PASS_STEREO = 4,
  NV_SMP_ASSIST_RENDER_VR_SLI = 5,
  NV_SMP_ASSIST_RENDER_SINGLE_PASS_STEREO_RTA = 6,
  NV_SMP_ASSIST_NUM_EYE_INDICES
} NV_SMP_ASSIST_EYE_INDEX;
#define NV_SMP_ASSIST_MINIMAL_LEVEL_NUM_EYE_INDICES 4
typedef struct _NV_CUSTOM_RECTS_V1 {
  NvU32 numViewports[NV_SMP_ASSIST_MINIMAL_LEVEL_NUM_EYE_INDICES];
  D3D11_VIEWPORT *pViewports[NV_SMP_ASSIST_MINIMAL_LEVEL_NUM_EYE_INDICES];
  D3D11_RECT *pScissors[NV_SMP_ASSIST_MINIMAL_LEVEL_NUM_EYE_INDICES];
} NV_CUSTOM_RECTS_V1;
typedef NV_CUSTOM_RECTS_V1 NV_CUSTOM_RECTS;
typedef struct _NV_SMP_ASSIST_ENABLE_PARAMS_V1 {
  NvU32 version;
  NV_SMP_ASSIST_EYE_INDEX eEyeIndex;
} NV_SMP_ASSIST_ENABLE_PARAMS_V1;
typedef NV_SMP_ASSIST_ENABLE_PARAMS_V1 NV_SMP_ASSIST_ENABLE_PARAMS;
#define NV_SMP_ASSIST_ENABLE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_ENABLE_PARAMS_V1, 1)
#define NV_SMP_ASSIST_ENABLE_PARAMS_VER NV_SMP_ASSIST_ENABLE_PARAMS_VER1
typedef struct _NV_SMP_ASSIST_DISABLE_PARAMS_V1 {
  NvU32 version;
  NvU32 Reserved;
} NV_SMP_ASSIST_DISABLE_PARAMS_V1;
typedef NV_SMP_ASSIST_DISABLE_PARAMS_V1 NV_SMP_ASSIST_DISABLE_PARAMS;
#define NV_SMP_ASSIST_DISABLE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_DISABLE_PARAMS_V1, 1)
#define NV_SMP_ASSIST_DISABLE_PARAMS_VER NV_SMP_ASSIST_DISABLE_PARAMS_VER1
typedef struct _NV_SMP_ASSIST_FASTGSCBDATA_V1 {
  float NDCSplitsX[2];
  float NDCSplitsY[2];
} NV_SMP_ASSIST_FASTGSCBDATA_V1;
typedef NV_SMP_ASSIST_FASTGSCBDATA_V1 NV_SMP_ASSIST_FASTGSCBDATA;
typedef struct _NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO_V1 {
  float NDCSplitsX[4];
  float NDCSplitsY[2];
} NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO_V1;
typedef NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO_V1 NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO;
typedef struct _NV_SMP_ASSIST_REMAPCBDATA_V1 {
  float ClipToWindowSplitsX[2];
  float ClipToWindowSplitsY[2];
  float ClipToWindowX[3][2];
  float ClipToWindowY[3][2];
  float ClipToWindowZ[2];
  float WindowToClipSplitsX[2];
  float WindowToClipSplitsY[2];
  float WindowToClipX[3][2];
  float WindowToClipY[3][2];
  float WindowToClipZ[2];
  float BoundingRectOriginX;
  float BoundingRectOriginY;
  float BoundingRectSizeWidth;
  float BoundingRectSizeHeight;
  float BoundingRectSizeInvWidth;
  float BoundingRectSizeInvHeight;
  float Padding[2];
} NV_SMP_ASSIST_REMAPCBDATA_V1;
typedef NV_SMP_ASSIST_REMAPCBDATA_V1 NV_SMP_ASSIST_REMAPCBDATA;
typedef struct _NV_SMP_ASSIST_GET_CONSTANTS_V3 {
  NvU32 version;
  NV_SMP_ASSIST_EYE_INDEX eEyeIndex;
  NvU32 numViewports;
  D3D11_VIEWPORT *pViewports;
  D3D11_RECT *pScissors;
  NV_SMP_ASSIST_TYPE eSMPAssistType;
  NV_SMP_ASSIST_LEVEL eSMPAssistLevel;
  union {
    NV_MRS_CUSTOM_CONFIG_V1 sMRSConfig;
    NV_LMS_CUSTOM_CONFIG_V1 sLMSConfig;
  };
  float projectionSizeWidth;
  float projectionSizeHeight;
  NV_SMP_ASSIST_FASTGSCBDATA_V1 *pFastGSCBData;
  NV_SMP_ASSIST_REMAPCBDATA_V1 *pRemapCBData;
  D3D11_VIEWPORT boundingViewport;
  D3D11_RECT boundingScissor;
  union {
    NV_MRS_INSTANCED_STEREO_CONFIG_V1 sMRS_ISConfig;
    NV_LMS_INSTANCED_STEREO_CONFIG_V1 sLMS_ISConfig;
  };
  NV_SMP_ASSIST_FASTGSCBDATA_MRS_INSTANCED_STEREO_V1 *pFastGSCBDataMRS_IS;
} NV_SMP_ASSIST_GET_CONSTANTS_V3;
#define NV_SMP_ASSIST_GET_CONSTANTS_VER3 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_GET_CONSTANTS_V3, 3)
typedef NV_SMP_ASSIST_GET_CONSTANTS_V3 NV_SMP_ASSIST_GET_CONSTANTS;
#define NV_SMP_ASSIST_GET_CONSTANTS_VER NV_SMP_ASSIST_GET_CONSTANTS_VER3
typedef struct _NV_SMP_ASSIST_GET_CONSTANTS_V2 {
  NvU32 version;
  NV_SMP_ASSIST_EYE_INDEX eEyeIndex;
  NvU32 numViewports;
  D3D11_VIEWPORT *pViewports;
  D3D11_RECT *pScissors;
  NV_SMP_ASSIST_TYPE eSMPAssistType;
  NV_SMP_ASSIST_LEVEL eSMPAssistLevel;
  union {
    NV_MRS_CUSTOM_CONFIG_V1 sMRSConfig;
    NV_LMS_CUSTOM_CONFIG_V1 sLMSConfig;
  };
  float projectionSizeWidth;
  float projectionSizeHeight;
  NV_SMP_ASSIST_FASTGSCBDATA_V1 *pFastGSCBData;
  NV_SMP_ASSIST_REMAPCBDATA_V1 *pRemapCBData;
  D3D11_VIEWPORT boundingViewport;
  D3D11_RECT boundingScissor;
} NV_SMP_ASSIST_GET_CONSTANTS_V2;
#define NV_SMP_ASSIST_GET_CONSTANTS_VER2 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_GET_CONSTANTS_V2, 2)
#ifndef NV_SMP_ASSIST_GET_CONSTANTS_VER
typedef NV_SMP_ASSIST_GET_CONSTANTS_V2 NV_SMP_ASSIST_GET_CONSTANTS;
#define NV_SMP_ASSIST_GET_CONSTANTS_VER NV_SMP_ASSIST_GET_CONSTANTS_VER2
#endif
typedef struct _NV_SMP_ASSIST_GET_CONSTANTS_V1 {
  NvU32 version;
  NV_SMP_ASSIST_EYE_INDEX eEyeIndex;
  NvU32 numViewports;
  D3D11_VIEWPORT *pViewports;
  D3D11_RECT *pScissors;
  NV_SMP_ASSIST_TYPE eSMPAssistType;
  NV_SMP_ASSIST_LEVEL eSMPAssistLevel;
  union {
    NV_MRS_CUSTOM_CONFIG_V1 sMRSConfig;
    NV_LMS_CUSTOM_CONFIG_V1 sLMSConfig;
  };
  float projectionSizeWidth;
  float projectionSizeHeight;
  NV_SMP_ASSIST_FASTGSCBDATA_V1 *pFastGSCBData;
  NV_SMP_ASSIST_REMAPCBDATA_V1 *pRemapCBData;
} NV_SMP_ASSIST_GET_CONSTANTS_V1;
#define NV_SMP_ASSIST_GET_CONSTANTS_VER1 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_GET_CONSTANTS_V1, 1)
#ifndef NV_SMP_ASSIST_GET_CONSTANTS_VER
typedef NV_SMP_ASSIST_GET_CONSTANTS_V1 NV_SMP_ASSIST_GET_CONSTANTS;
#define NV_SMP_ASSIST_GET_CONSTANTS_VER NV_SMP_ASSIST_GET_CONSTANTS_VER1
#endif
typedef struct _NV_SMP_ASSIST_SETUP_PARAMS_V1 {
  NvU32 version;
  union {
    NV_MRS_CONFIG eMRSConfig;
    NV_LMS_CONFIG eLMSConfig;
    NV_MRS_CUSTOM_CONFIG_V1 sMRSCustomConfig;
    NV_LMS_CUSTOM_CONFIG_V1 sLMSCustomConfig;
    NV_CUSTOM_RECTS_V1 sCustomRects;
  };
  float resolutionScale;
  D3D11_VIEWPORT boundingBox;
  float vpOffsets[2];
} NV_SMP_ASSIST_SETUP_PARAMS_V1;
typedef NV_SMP_ASSIST_SETUP_PARAMS_V1 NV_SMP_ASSIST_SETUP_PARAMS;
#define NV_SMP_ASSIST_SETUP_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_SETUP_PARAMS_V1, 1)
#define NV_SMP_ASSIST_SETUP_PARAMS_VER NV_SMP_ASSIST_SETUP_PARAMS_VER1
typedef struct _NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_V1 {
  NvU32 version;
  NV_SMP_ASSIST_TYPE eSMPAssistType;
  float leftCoeffs[4];
  float leftConst;
  float rightCoeffs[4];
  float rightConst;
} NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_V1;
typedef NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_V1 NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS;
#define NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_VER1                                                          \
  MAKE_NVAPI_VERSION(NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_V1, 1)
#define NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_VER NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS_VER1
DECLARE_INTERFACE(ID3D11NvSMPAssist_V1) {
  STDMETHOD_(NvAPI_Status, Disable)(THIS_ __in ID3D11DeviceContext * pDevContext,
                                    __in const NV_SMP_ASSIST_DISABLE_PARAMS *psSMPAssistDisableParams) PURE;
  STDMETHOD_(NvAPI_Status, Enable)(THIS_ __in ID3D11DeviceContext * pDevContext,
                                   __in const NV_SMP_ASSIST_ENABLE_PARAMS *psSMPAssistEnableParams) PURE;
  STDMETHOD_(NvAPI_Status, GetConstants)(THIS_ __inout NV_SMP_ASSIST_GET_CONSTANTS * psSMPAssistGetConstants) PURE;
};
typedef ID3D11NvSMPAssist_V1 ID3D11NvSMPAssist;
#define ID3D11NVSMPASSIST_VER1 MAKE_NVAPI_VERSION(ID3D11NvSMPAssist_V1, 1)
#define ID3D11NVSMPASSIST_VER ID3D11NVSMPASSIST_VER1
typedef struct _NV_SMP_ASSIST_INIT_PARAMS_V2 {
  NvU32 version;
  NV_SMP_ASSIST_TYPE eSMPAssistType;
  NV_SMP_ASSIST_LEVEL eSMPAssistLevel;
  NvU32 flags;
  union {
    NV_MRS_CONFIG eMRSConfig;
    NV_LMS_CONFIG eLMSConfig;
    NV_MRS_CUSTOM_CONFIG_V1 sMRSCustomConfig;
    NV_LMS_CUSTOM_CONFIG_V1 sLMSCustomConfig;
    NV_CUSTOM_RECTS_V1 sCustomRects;
  };
  float resolutionScale;
  D3D11_VIEWPORT boundingBox;
  ID3D11NvSMPAssist **ppD3D11NvSMPAssist;
  NvU32 VRSLILeftEyeGpuMask;
  NvU32 VRSLIRightEyeGpuMask;
} NV_SMP_ASSIST_INIT_PARAMS_V2;
typedef NV_SMP_ASSIST_INIT_PARAMS_V2 NV_SMP_ASSIST_INIT_PARAMS;
#define NV_SMP_ASSIST_INIT_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_INIT_PARAMS_V2, 2)
#define NV_SMP_ASSIST_INIT_PARAMS_VER NV_SMP_ASSIST_INIT_PARAMS_VER2
typedef struct _NV_SMP_ASSIST_INIT_PARAMS_V1 {
  NvU32 version;
  NV_SMP_ASSIST_TYPE eSMPAssistType;
  NV_SMP_ASSIST_LEVEL eSMPAssistLevel;
  NvU32 flags;
  union {
    NV_MRS_CONFIG eMRSConfig;
    NV_LMS_CONFIG eLMSConfig;
    NV_MRS_CUSTOM_CONFIG_V1 sMRSCustomConfig;
    NV_LMS_CUSTOM_CONFIG_V1 sLMSCustomConfig;
    NV_CUSTOM_RECTS_V1 sCustomRects;
  };
  float resolutionScale;
  D3D11_VIEWPORT boundingBox;
  ID3D11NvSMPAssist **ppD3D11NvSMPAssist;
} NV_SMP_ASSIST_INIT_PARAMS_V1;
#define NV_SMP_ASSIST_INIT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_INIT_PARAMS_V1, 1)
#ifndef NV_SMP_ASSIST_INIT_PARAMS_VER
typedef NV_SMP_ASSIST_INIT_PARAMS_V1 NV_SMP_ASSIST_INIT_PARAMS;
#define NV_SMP_ASSIST_INIT_PARAMS_VER NV_SMP_ASSIST_INIT_PARAMS_VER1
#endif
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 396. Instead, use NvAPI_D3D_InitializeSMPAssist.")
    NVAPI_INTERFACE NvAPI_D3D11_InitializeSMPAssist(__in ID3D11Device *pDevice,
                                                    __inout NV_SMP_ASSIST_INIT_PARAMS *pSMPAssistInitParams);
DECLARE_INTERFACE(ID3DNvSMPAssist_V1) {
  STDMETHOD_(NvAPI_Status, Disable)(THIS_ __in IUnknown * pDevContext,
                                    __in const NV_SMP_ASSIST_DISABLE_PARAMS *psSMPAssistDisableParams) PURE;
  STDMETHOD_(NvAPI_Status, Enable)(THIS_ __in IUnknown * pDevContext,
                                   __in const NV_SMP_ASSIST_ENABLE_PARAMS *psSMPAssistEnableParams) PURE;
  STDMETHOD_(NvAPI_Status, GetConstants)(THIS_ __inout NV_SMP_ASSIST_GET_CONSTANTS * psSMPAssistGetConstants) PURE;
  STDMETHOD_(NvAPI_Status, SetupProjections)(THIS_ __in IUnknown * pDevice,
                                             __in const NV_SMP_ASSIST_SETUP_PARAMS *psSMPAssistSetupParams) PURE;
  STDMETHOD_(NvAPI_Status, UpdateInstancedStereoData)(
      THIS_ __in IUnknown * pDevice,
      __in const NV_SMP_ASSIST_UPDATE_INSTANCEDSTEREO_DATA_PARAMS *psSMPAssistInstancedStereoParams) PURE;
};
typedef ID3DNvSMPAssist_V1 ID3DNvSMPAssist;
#define ID3DNVSMPASSIST_VER1 MAKE_NVAPI_VERSION(ID3DNvSMPAssist_V1, 1)
#define ID3DNVSMPASSIST_VER ID3DNVSMPASSIST_VER1
typedef struct _NV_SMP_ASSIST_INITIALIZE_PARAMS_V2 {
  NvU32 version;
  NV_SMP_ASSIST_TYPE eSMPAssistType;
  NV_SMP_ASSIST_LEVEL eSMPAssistLevel;
  NvU32 flags;
  ID3DNvSMPAssist **ppD3DNvSMPAssist;
  NvU32 VRSLILeftEyeGpuMask;
  NvU32 VRSLIRightEyeGpuMask;
} NV_SMP_ASSIST_INITIALIZE_PARAMS_V2;
#define NV_SMP_ASSIST_INITIALIZE_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_INITIALIZE_PARAMS_V2, 2)
typedef NV_SMP_ASSIST_INITIALIZE_PARAMS_V2 NV_SMP_ASSIST_INITIALIZE_PARAMS;
#define NV_SMP_ASSIST_INITIALIZE_PARAMS_VER NV_SMP_ASSIST_INITIALIZE_PARAMS_VER2
typedef struct _NV_SMP_ASSIST_INITIALIZE_PARAMS_V1 {
  NvU32 version;
  NV_SMP_ASSIST_TYPE eSMPAssistType;
  NV_SMP_ASSIST_LEVEL eSMPAssistLevel;
  NvU32 flags;
  ID3DNvSMPAssist **ppD3DNvSMPAssist;
} NV_SMP_ASSIST_INITIALIZE_PARAMS_V1;
#define NV_SMP_ASSIST_INITIALIZE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_SMP_ASSIST_INITIALIZE_PARAMS_V1, 1)
#ifndef NV_SMP_ASSIST_INITIALIZE_PARAMS_VER
typedef NV_SMP_ASSIST_INITIALIZE_PARAMS_V1 NV_SMP_ASSIST_INITIALIZE_PARAMS;
#define NV_SMP_ASSIST_INITIALIZE_PARAMS_VER NV_SMP_ASSIST_INITIALIZE_PARAMS_VER1
#endif
NVAPI_INTERFACE NvAPI_D3D_InitializeSMPAssist(__in IUnknown *pDevice,
                                              __inout NV_SMP_ASSIST_INITIALIZE_PARAMS *pSMPAssistInitParams);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
typedef struct _NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_V1 {
  NvU32 version;
  NV_SMP_ASSIST_TYPE eSMPAssistType;
  NV_SMP_ASSIST_LEVEL eSMPAssistLevel;
  NvBool bSMPAssistSupported;
} NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_V1;
typedef NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_V1 NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS;
#define NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_V1, 1)
#define NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_VER NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS_VER1
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 396. Instead, use NvAPI_D3D_QuerySMPAssistSupport.")
    NVAPI_INTERFACE
    NvAPI_D3D11_QuerySMPAssistSupport(__in ID3D11Device *pDev,
                                      __inout NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS *pQuerySMPAssistSupportParams);
NVAPI_INTERFACE NvAPI_D3D_QuerySMPAssistSupport(
    __in IUnknown *pDev, __inout NV_QUERY_SMP_ASSIST_SUPPORT_PARAMS *pQuerySMPAssistSupportParams);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CheckResourceVirtualAddress(__in IUnknown *pDx12Context, __in NVDX_ObjectHandle hResource,
                                                        __out NvU64 *pOutGpuVa);
#endif
typedef struct _NV_FRAME_PRESENT_NOTIFY_PARAMS_V1 {
  NvU32 version;
  NvBool bStop;
} NV_FRAME_PRESENT_NOTIFY_PARAMS_V1;
typedef struct _NV_FRAME_PRESENT_NOTIFY_PARAMS_V2 {
  NvU32 version;
  NvBool bStop;
  NvBool bIsAnsel;
  NvU8 rsvd[64];
} NV_FRAME_PRESENT_NOTIFY_PARAMS_V2;
typedef NV_FRAME_PRESENT_NOTIFY_PARAMS_V2 NV_FRAME_PRESENT_NOTIFY_PARAMS;
#define NV_FRAME_PRESENT_NOTIFY_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_FRAME_PRESENT_NOTIFY_PARAMS_V1, 1)
#define NV_FRAME_PRESENT_NOTIFY_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_FRAME_PRESENT_NOTIFY_PARAMS_V2, 2)
#define NV_FRAME_PRESENT_NOTIFY_PARAMS_VER NV_FRAME_PRESENT_NOTIFY_PARAMS_VER2
#if defined(__cplusplus) &&                                                                                            \
    (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D_FramePresentNotify(__in IUnknown *pDev,
                                             __in NV_FRAME_PRESENT_NOTIFY_PARAMS *pFramePresentNotifyParams);
#endif
typedef struct _NV_WKS_READ_SCANOUT_PARAMS_V1 {
  NvU32 version;
  NvU32 targetId;
  NvPhysicalGpuHandle hPhysicalGpu;
  NV_RECT rect;
  struct {
    NvU64 queueIndex : 4;
    NvU64 mpoIndex : 3;
    NvU64 rightStereoEye : 1;
    NvU64 leftAndRightStereoEye : 1;
    NvU64 osRenderBuffer : 1;
    NvU64 scanoutBuffer : 1;
    NvU64 warping : 1;
    NvU64 perPixelIntensity : 1;
    NvU64 intensityRGTexture : 1;
    NvU64 intensityBATexture : 1;
    NvU64 grayscaleDome : 1;
    NvU64 grayscaleEizo : 1;
    NvU64 yuv420 : 1;
    NvU64 yuv422 : 1;
    NvU64 yuv444 : 1;
    NvU64 hdr : 1;
    NvU64 smoothScaling : 1;
    NvU64 eshift : 1;
    NvU64 virtualSplit : 1;
    NvU64 streamSource : 1;
    NvU64 reserved : 39;
  } flags;
  NV_FORMAT format;
  void **ppData;
} NV_WKS_READ_SCANOUT_PARAMS_V1;
typedef NV_WKS_READ_SCANOUT_PARAMS_V1 NV_WKS_READ_SCANOUT_PARAMS;
#define NV_WKS_READ_SCANOUT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_WKS_READ_SCANOUT_PARAMS_V1, 1)
#define NV_WKS_READ_SCANOUT_PARAMS_VER NV_WKS_READ_SCANOUT_PARAMS_VER1
#if defined(__cplusplus) && (defined(__d3d11_h__))
NVAPI_INTERFACE NvAPI_D3D11_WksReadScanout(__in ID3D11Device *pDev,
                                           __inout NV_WKS_READ_SCANOUT_PARAMS *pWksReadScanoutParams);
#endif
typedef struct _NV_GET_SLEEP_STATUS_PARAMS {
  NvU32 version;
  NvBool bLowLatencyMode;
  NvU8 rsvd[128];
} NV_GET_SLEEP_STATUS_PARAMS_V1;
typedef NV_GET_SLEEP_STATUS_PARAMS_V1 NV_GET_SLEEP_STATUS_PARAMS;
#define NV_GET_SLEEP_STATUS_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_GET_SLEEP_STATUS_PARAMS_V1, 1)
#define NV_GET_SLEEP_STATUS_PARAMS_VER NV_GET_SLEEP_STATUS_PARAMS_VER1
#if defined(__cplusplus) && (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) ||                    \
                             defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_GetSleepStatus(__in IUnknown *pDev, __in NV_GET_SLEEP_STATUS_PARAMS *pGetSleepStatusParams);
#endif
typedef struct _NV_SET_SLEEP_MODE_PARAMS {
  NvU32 version;
  NvBool bLowLatencyMode;
  NvBool bLowLatencyBoost;
  NvU32 minimumIntervalUs;
  NvBool bUseMarkersToOptimize;
  NvU8 rsvd[31];
} NV_SET_SLEEP_MODE_PARAMS_V1;
typedef NV_SET_SLEEP_MODE_PARAMS_V1 NV_SET_SLEEP_MODE_PARAMS;
#define NV_SET_SLEEP_MODE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_SET_SLEEP_MODE_PARAMS_V1, 1)
#define NV_SET_SLEEP_MODE_PARAMS_VER NV_SET_SLEEP_MODE_PARAMS_VER1
#if defined(__cplusplus) && (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) ||                    \
                             defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_SetSleepMode(__in IUnknown *pDev, __in NV_SET_SLEEP_MODE_PARAMS *pSetSleepModeParams);
#endif
#if defined(__cplusplus) && (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) ||                    \
                             defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_Sleep(__in IUnknown *pDev);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D_SetServerThreadPriority(__in IUnknown *pDev, __in NvU32 priority);
#endif
typedef struct _NV_LATENCY_RESULT_PARAMS {
  NvU32 version;
  struct FrameReport {
    NvU64 frameID;
    NvU64 inputSampleTime;
    NvU64 simStartTime;
    NvU64 simEndTime;
    NvU64 renderSubmitStartTime;
    NvU64 renderSubmitEndTime;
    NvU64 presentStartTime;
    NvU64 presentEndTime;
    NvU64 driverStartTime;
    NvU64 driverEndTime;
    NvU64 osRenderQueueStartTime;
    NvU64 osRenderQueueEndTime;
    NvU64 gpuRenderStartTime;
    NvU64 gpuRenderEndTime;
    NvU32 gpuActiveRenderTimeUs;
    NvU32 gpuFrameTimeUs;
    NvU8 rsvd[120];
  } frameReport[64];
  NvU8 rsvd[32];
} NV_LATENCY_RESULT_PARAMS_V1;
typedef NV_LATENCY_RESULT_PARAMS_V1 NV_LATENCY_RESULT_PARAMS;
#define NV_LATENCY_RESULT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_LATENCY_RESULT_PARAMS_V1, 1)
#define NV_LATENCY_RESULT_PARAMS_VER NV_LATENCY_RESULT_PARAMS_VER1
#if defined(__cplusplus) && (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) ||                    \
                             defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_GetLatency(__in IUnknown *pDev, __out NV_LATENCY_RESULT_PARAMS *pGetLatencyParams);
#endif
typedef enum {
  SIMULATION_START = 0,
  SIMULATION_END = 1,
  RENDERSUBMIT_START = 2,
  RENDERSUBMIT_END = 3,
  PRESENT_START = 4,
  PRESENT_END = 5,
  INPUT_SAMPLE = 6,
  TRIGGER_FLASH = 7,
  PC_LATENCY_PING = 8,
} NV_LATENCY_MARKER_TYPE;
typedef struct _NV_LATENCY_MARKER_PARAMS {
  NvU32 version;
  NvU64 frameID;
  NV_LATENCY_MARKER_TYPE markerType;
  NvU8 rsvd[64];
} NV_LATENCY_MARKER_PARAMS_V1;
typedef NV_LATENCY_MARKER_PARAMS_V1 NV_LATENCY_MARKER_PARAMS;
#define NV_LATENCY_MARKER_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_LATENCY_MARKER_PARAMS_V1, 1)
#define NV_LATENCY_MARKER_PARAMS_VER NV_LATENCY_MARKER_PARAMS_VER1
#if defined(__cplusplus) && (defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d10_1_h__) ||                    \
                             defined(__d3d11_h__) || defined(__d3d12_h__))
NVAPI_INTERFACE NvAPI_D3D_SetLatencyMarker(__in IUnknown *pDev, __in NV_LATENCY_MARKER_PARAMS *pSetLatencyMarkerParams);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
DECLARE_INTERFACE_(__declspec(uuid("5A88DBEE-E67F-4CD8-9D7D-00124B7D1677")) ID3D12NvStreamFile_V1, IUnknown) {
  BEGIN_INTERFACE
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  STDMETHOD_(bool, UsingFilesystemBypass)(THIS) PURE;
  END_INTERFACE
};
typedef ID3D12NvStreamFile_V1 ID3D12NvStreamFile;
#define ID3D12NvStreamFile_VER1 MAKE_NVAPI_VERSION(IID3D12NvStreamFile_V1, 1)
#define ID3D12NvStreamFile_VER ID3D12NvStreamFile_VER1
DECLARE_INTERFACE_(__declspec(uuid("1E0D5D26-5D08-432C-BF68-8E51B15A4204")) ID3D12NvStreamSource_V1, IUnknown) {
  BEGIN_INTERFACE
  enum Type { TYPE_FILE, TYPE_FILE_COMPRESSED, TYPE_RESOURCE };
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  STDMETHOD_(Type, GetType)() PURE;
  END_INTERFACE
};
typedef ID3D12NvStreamSource_V1 ID3D12NvStreamSource;
#define ID3D12NvStreamSource_VER1 MAKE_NVAPI_VERSION(IID3D12NvStreamSource_V1, 1)
#define ID3D12NvStreamSource_VER ID3D12NvStreamSource_VER1
DECLARE_INTERFACE_(__declspec(uuid("F97496A7-C87A-410C-B751-38EC3602C263")) ID3D12NvStreamDest_V1, IUnknown) {
  BEGIN_INTERFACE
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  END_INTERFACE
};
typedef ID3D12NvStreamDest_V1 ID3D12NvStreamDest;
#define ID3D12NvStreamDest_VER1 MAKE_NVAPI_VERSION(IID3D12NvStreamDest_V1, 1)
#define ID3D12NvStreamDest_VER ID3D12NvStreamDest_VER1
enum NVAPI_STREAM_QUEUE_PRIORITY {
  NVAPI_STREAM_PRIORITY_LOW,
  NVAPI_STREAM_PRIORITY_NORMAL,
  NVAPI_STREAM_PRIORITY_HIGH,
  NVAPI_STREAM_PRIORITY_REALTIME,
  NVAPI_STREAM_PRIORITY_COUNT
};
typedef struct _NVAPI_STREAM_QUEUE_DESC {
  NvU32 maxRequests;
  NVAPI_STREAM_QUEUE_PRIORITY priority;
} NVAPI_STREAM_QUEUE_DESC_V1;
typedef NVAPI_STREAM_QUEUE_DESC_V1 NVAPI_STREAM_QUEUE_DESC;
#define NVAPI_STREAM_QUEUE_DESC_VER1 MAKE_NVAPI_VERSION(NVAPI_STREAM_QUEUE_DESC_V1, 1)
#define NVAPI_STREAM_QUEUE_DESC_VER NVAPI_STREAM_QUEUE_DESC_VER1
typedef struct _NVAPI_SOURCE_SUBRESOURCE_FOOTPRINT {
  NvU64 offset;
  UINT width;
  UINT height;
  UINT depth;
  UINT rowPitch;
} NVAPI_SOURCE_SUBRESOURCE_FOOTPRINT_V1;
typedef NVAPI_SOURCE_SUBRESOURCE_FOOTPRINT_V1 NVAPI_SOURCE_SUBRESOURCE_FOOTPRINT;
#define NVAPI_SOURCE_SUBRESOURCE_FOOTPRINT_VER1 MAKE_NVAPI_VERSION(NVAPI_SOURCE_SUBRESOURCE_FOOTPRINT_V1, 1)
#define NVAPI_SOURCE_SUBRESOURCE_FOOTPRINT_VER NVAPI_SOURCE_SUBRESOURCE_FOOTPRINT_VER1
enum NVAPI_STREAM_SUBRESOURCE_DATALAYOUT { LAYOUT_ROW_MAJOR, LAYOUT_TILE_SHAPE };
typedef struct _NVAPI_SOURCE_SUBRESOURCE_DATA {
  NvU64 offset;
  NvU64 rowPitch;
  NVAPI_STREAM_SUBRESOURCE_DATALAYOUT dataLayout;
} NVAPI_SOURCE_SUBRESOURCE_DATA_V1;
typedef NVAPI_SOURCE_SUBRESOURCE_DATA_V1 NVAPI_SOURCE_SUBRESOURCE_DATA;
#define NVAPI_SOURCE_SUBRESOURCE_DATA_VER1 MAKE_NVAPI_VERSION(NVAPI_SOURCE_SUBRESOURCE_DATA_V1, 1)
#define NVAPI_SOURCE_SUBRESOURCE_DATA_VER NVAPI_SOURCE_SUBRESOURCE_DATA_VER1
DECLARE_INTERFACE_(__declspec(uuid("6C607D01-EEC4-4A83-B6BD-688DD9CCEFFD")) ID3D12NvStreamQueue_V1, IUnknown) {
  BEGIN_INTERFACE
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
  STDMETHOD_(ULONG, AddRef)(THIS) PURE;
  STDMETHOD_(ULONG, Release)(THIS) PURE;
  __nvapi_deprecated_function("Deprecated since r470, use other overloaded versions instead")
      STDMETHOD_(NvAPI_Status, EnqueueRead)(ID3D12NvStreamDest * pDest, ID3D12NvStreamSource * pSource, NvU64 srcOffset,
                                            NvU64 srcSize, NvU32 FirstSubresource, NvU32 NumSubresources,
                                            const NVAPI_SOURCE_SUBRESOURCE_FOOTPRINT *pLayouts, void **pRequestID) PURE;
  STDMETHOD_(NvAPI_Status, EnqueueRead)(ID3D12NvStreamDest * pDest, ID3D12NvStreamSource * pSource, NvU64 srcOffset,
                                        NvU64 srcSize, NvU32 FirstSubresource, NvU32 NumSubresources,
                                        const NVAPI_SOURCE_SUBRESOURCE_DATA *pSubResData, void **pRequestID) PURE;
  __nvapi_deprecated_function("Deprecated since r470, use other overloaded versions instead")
      STDMETHOD_(NvAPI_Status, EnqueueRead)(ID3D12NvStreamDest * pDest, NvU64 dstOffset, ID3D12NvStreamSource * pSource,
                                            NvU64 srcOffset, NvU64 srcSize, void **pRequestID) PURE;
  STDMETHOD_(NvAPI_Status, EnqueueRead)(ID3D12NvStreamDest * pDest, NvU64 dstOffset, ID3D12NvStreamSource * pSource,
                                        NvU64 srcOffset, NvU64 srcSize, NvU64 rowPitch, void **pRequestID) PURE;
  STDMETHOD_(NvAPI_Status, EnqueueSignal)(IUnknown * pFence, NvU64 fenceValue, void **pRequestID) PURE;
  STDMETHOD_(NvAPI_Status, RemoveRequest)(void *requestID) PURE;
  STDMETHOD_(NvAPI_Status, Submit)() PURE;
  STDMETHOD_(NvAPI_Status, UpdateTileMappings)(ID3D12Resource * pDest, UINT NumResourceRegions,
                                               const D3D12_TILED_RESOURCE_COORDINATE *pResourceRegionStartCoordinates,
                                               const D3D12_TILE_REGION_SIZE *pResourceRegionSizes, ID3D12Heap *pHeap,
                                               UINT NumRanges, const D3D12_TILE_RANGE_FLAGS *pRangeFlags,
                                               const UINT *pHeapRangeStartOffsets, const UINT *pRangeTileCounts,
                                               D3D12_TILE_MAPPING_FLAGS Flags) PURE;
  END_INTERFACE
};
typedef ID3D12NvStreamQueue_V1 ID3D12NvStreamQueue;
#define ID3D12NvStreamQueue_VER1 MAKE_NVAPI_VERSION(IID3D12NvStreamQueue_V1, 1)
#define ID3D12NvStreamQueue_VER ID3D12NvStreamQueue_VER1
typedef struct _NVAPI_STREAM_SOURCE_DESC {
  enum Type { TYPE_FILE, TYPE_FILE_COMPRESSED, TYPE_RESOURCE };
  Type type;
  union {
    ID3D12NvStreamFile *pFile;
    ID3D12Resource *pResource;
  };
} NVAPI_STREAM_SOURCE_DESC_V1;
typedef NVAPI_STREAM_SOURCE_DESC_V1 NVAPI_STREAM_SOURCE_DESC;
#define NVAPI_STREAM_SOURCE_DESC_VER1 MAKE_NVAPI_VERSION(NVAPI_STREAM_SOURCE_DESC_V1, 1)
#define NVAPI_STREAM_SOURCE_DESC_VER NVAPI_STREAM_SOURCE_DESC_VER1
typedef class _ID3D12NvStreamProcessor_V1 {
public:
  STDMETHOD_(NvAPI_Status, CreateFile)(const char *fileName, ID3D12NvStreamFile **pFile) PURE;
  STDMETHOD_(NvAPI_Status, CreateSource)(const NVAPI_STREAM_SOURCE_DESC *pDesc, ID3D12NvStreamSource **pSource) PURE;
  STDMETHOD_(NvAPI_Status, CreateDest)(ID3D12Resource *pResource, ID3D12NvStreamDest **pDest) PURE;
  STDMETHOD_(NvAPI_Status, CreateQueue)(const NVAPI_STREAM_QUEUE_DESC *pDesc, ID3D12NvStreamQueue **pStreamQueue) PURE;
} ID3D12NvStreamProcessor_V1;
typedef ID3D12NvStreamProcessor_V1 ID3D12NvStreamProcessor;
#define ID3D12NvStreamProcessor_VER1 MAKE_NVAPI_VERSION(IID3D12NvStreamProcessor_V1, 1)
#define ID3D12NvStreamProcessor_VER ID3D12NvStreamProcessor_VER1
typedef struct _NVAPI_CREATE_STREAM_PROCESSOR_PARAMS {
  ID3D12NvStreamProcessor **ppNvapiStreamProcessor;
  IUnknown *pDev;
  NvU64 StagingBufferSize;
  bool SupportCompression;
  NvU64 WorkerThreadAffinityMask;
  NvS32 WorkerThreadPriority;
} NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_V1;
#define NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_VER1 MAKE_NVAPI_VERSION(NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_V1, 1)
typedef struct {
  NvU32 version;
  ID3D12NvStreamProcessor **ppNvapiStreamProcessor;
  IUnknown *pDev;
  NvU64 StagingBufferSize;
  bool SupportCompression;
  NvU64 WorkerThreadAffinityMask;
  NvS32 WorkerThreadPriority;
  NvU32 NodeMask;
} NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_V2;
#define NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_VER2 MAKE_NVAPI_VERSION(NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_V2, 2)
typedef enum {
  SUPPORT_COMPRESSION = 1,
  USE_FILESYSTEM_BYPASS = 2,
} NVAPI_CREATE_STREAM_PROCESSOR_FLAGS;
typedef struct {
  NvU32 version;
  ID3D12NvStreamProcessor **ppNvapiStreamProcessor;
  IUnknown *pDev;
  NvU64 StagingBufferSize;
  NvU64 WorkerThreadAffinityMask;
  NvS32 WorkerThreadPriority;
  NvU32 NodeMask;
  NvU32 Flags;
} NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_V3;
#define NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_VER3 MAKE_NVAPI_VERSION(NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_V3, 3)
typedef NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_V3 NVAPI_CREATE_STREAM_PROCESSOR_PARAMS;
#define NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_VER NVAPI_CREATE_STREAM_PROCESSOR_PARAMS_VER3
NVAPI_INTERFACE NvAPI_D3D_CreateStreamProcessor(NVAPI_CREATE_STREAM_PROCESSOR_PARAMS *pCreateParams);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef struct _NVAPI_DESTROY_STREAM_PROCESSOR_PARAMS {
  ID3D12NvStreamProcessor *pNvapiStreamProcessor;
} NVAPI_DESTROY_STREAM_PROCESSOR_PARAMS_V1;
typedef NVAPI_DESTROY_STREAM_PROCESSOR_PARAMS_V1 NVAPI_DESTROY_STREAM_PROCESSOR_PARAMS;
#define NVAPI_DESTROY_STREAM_PROCESSOR_PARAMS_VER1 MAKE_NVAPI_VERSION(NVAPI_DESTROY_STREAM_PROCESSOR_PARAMS_V1, 1)
#define NVAPI_DESTROY_STREAM_PROCESSOR_PARAMS_VER NVAPI_DESTROY_STREAM_PROCESSOR_PARAMS_VER1
NVAPI_INTERFACE NvAPI_D3D_DestroyStreamProcessor(NVAPI_DESTROY_STREAM_PROCESSOR_PARAMS *pDestroyParams);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_CreateCubinComputeShader(__in ID3D12Device *pDevice, __in const void *pCubin,
                                                     __in NvU32 size, __in NvU32 blockX, __in NvU32 blockY,
                                                     __in NvU32 blockZ, __out NVDX_ObjectHandle *phShader);
NVAPI_INTERFACE NvAPI_D3D12_CreateCubinComputeShaderEx(__in ID3D12Device *pDevice, __in const void *pCubin,
                                                       __in NvU32 size, __in NvU32 blockX, __in NvU32 blockY,
                                                       __in NvU32 blockZ, __in NvU32 dynSharedMemBytes,
                                                       __in const char *pShaderName, __out NVDX_ObjectHandle *phShader);
NVAPI_INTERFACE NvAPI_D3D12_CreateCubinComputeShaderWithName(__in ID3D12Device *pDevice, __in const void *pCubin,
                                                             __in NvU32 size, __in NvU32 blockX, __in NvU32 blockY,
                                                             __in NvU32 blockZ, __in const char *pShaderName,
                                                             __out NVDX_ObjectHandle *phShader);
NVAPI_INTERFACE NvAPI_D3D12_LaunchCubinShader(__in ID3D12GraphicsCommandList *pCommandList,
                                              __in NVDX_ObjectHandle hShader, __in NvU32 gridX, __in NvU32 gridY,
                                              __in NvU32 gridZ, __in const void *pParams, __in NvU32 paramSize);
NVAPI_INTERFACE NvAPI_D3D12_DestroyCubinComputeShader(__in ID3D12Device *pDevice, __in NVDX_ObjectHandle hShader);
NVAPI_INTERFACE NvAPI_D3D12_GetCudaTextureObject(__in ID3D12Device *pDevice, __in D3D12_CPU_DESCRIPTOR_HANDLE texDesc,
                                                 __in D3D12_CPU_DESCRIPTOR_HANDLE smpDesc, __out NvU32 *pTextureHandle);
NVAPI_INTERFACE NvAPI_D3D12_GetCudaSurfaceObject(__in ID3D12Device *pDevice, __in D3D12_CPU_DESCRIPTOR_HANDLE uavDesc,
                                                 __out NvU32 *pSurfaceHandle);
NVAPI_INTERFACE NvAPI_D3D12_IsFatbinPTXSupported(__in ID3D12Device *pDevice, __out bool *pSupported);
#endif
#if defined(__cplusplus) && defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D11_CreateCubinComputeShader(__in ID3D11Device *pDevice, __in const void *pCubin,
                                                     __in NvU32 size, __in NvU32 blockX, __in NvU32 blockY,
                                                     __in NvU32 blockZ, __out NVDX_ObjectHandle *phShader);
NVAPI_INTERFACE NvAPI_D3D11_CreateCubinComputeShaderEx(__in ID3D11Device *pDevice, __in const void *pCubin,
                                                       __in NvU32 size, __in NvU32 blockX, __in NvU32 blockY,
                                                       __in NvU32 blockZ, __in NvU32 dynSharedMemBytes,
                                                       __in const char *pShaderName, __out NVDX_ObjectHandle *phShader);
NVAPI_INTERFACE NvAPI_D3D11_CreateCubinComputeShaderWithName(__in ID3D11Device *pDevice, __in const void *pCubin,
                                                             __in NvU32 size, __in NvU32 blockX, __in NvU32 blockY,
                                                             __in NvU32 blockZ, __in const char *pShaderName,
                                                             __out NVDX_ObjectHandle *phShader);
NVAPI_INTERFACE NvAPI_D3D11_LaunchCubinShader(__in ID3D11DeviceContext *pDeviceContext, __in NVDX_ObjectHandle hShader,
                                              __in NvU32 gridX, __in NvU32 gridY, __in NvU32 gridZ,
                                              __in const void *pParams, __in NvU32 paramSize,
                                              __in const NVDX_ObjectHandle *pReadResources, __in NvU32 numReadResources,
                                              __in const NVDX_ObjectHandle *pWriteResources,
                                              __in NvU32 numWriteResources);
NVAPI_INTERFACE NvAPI_D3D11_DestroyCubinComputeShader(__in ID3D11Device *pDevice, __in NVDX_ObjectHandle hShader);
NVAPI_INTERFACE NvAPI_D3D11_IsFatbinPTXSupported(__in ID3D11Device *pDevice, __out bool *pSupported);
NVAPI_INTERFACE NvAPI_D3D11_CreateUnorderedAccessView(__in ID3D11Device *pDevice, __in ID3D11Resource *pResource,
                                                      __in const D3D11_UNORDERED_ACCESS_VIEW_DESC *pDesc,
                                                      __out ID3D11UnorderedAccessView **ppUAV,
                                                      __out NvU32 *pDriverHandle);
NVAPI_INTERFACE NvAPI_D3D11_CreateShaderResourceView(__in ID3D11Device *pDevice, __in ID3D11Resource *pResource,
                                                     __in const D3D11_SHADER_RESOURCE_VIEW_DESC *pDesc,
                                                     __out ID3D11ShaderResourceView **ppSRV,
                                                     __out NvU32 *pDriverHandle);
NVAPI_INTERFACE NvAPI_D3D11_CreateSamplerState(__in ID3D11Device *pDevice, __in const D3D11_SAMPLER_DESC *pSamplerDesc,
                                               __out ID3D11SamplerState **ppSamplerState, __out NvU32 *pDriverHandle);
NVAPI_INTERFACE NvAPI_D3D11_GetCudaTextureObject(__in ID3D11Device *pDevice, __in NvU32 srvDriverHandle,
                                                 __in NvU32 samplerDriverHandle, __out NvU32 *pCudaTextureHandle);
NVAPI_INTERFACE NvAPI_D3D11_GetResourceGPUVirtualAddress(__in ID3D11Device *pDevice,
                                                         __in const NVDX_ObjectHandle hResource, __out NvU64 *pGpuVA);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef NvBool(__stdcall *NVAPI_D3D12_DEVTOOLS_PUSH_PATCHABLE_METHODS_INITIALIZE_CALLBACK)(void *pInitializeUserData,
                                                                                           NvU32 *pMethodWords,
                                                                                           size_t numMethodWords);
typedef void(__stdcall *NVAPI_D3D12_DEVTOOLS_PUSH_PATCHABLE_METHODS_SUBMIT_CALLBACK)(void *pSubmitUserData,
                                                                                     struct DTA_DriverContext *drvCtx,
                                                                                     NvU32 *pMethodWords,
                                                                                     size_t numMethodWords);
typedef struct _NVAPI_D3D12_DEVTOOLS_PUSH_PATCHABLE_METHODS_PARAMS {
  size_t structSizeIn;
  size_t structSizeOut;
  ID3D12GraphicsCommandList *pCommandList;
  NvU32 numMethodWords;
  void *pInitializeUserData;
  NVAPI_D3D12_DEVTOOLS_PUSH_PATCHABLE_METHODS_INITIALIZE_CALLBACK pfnInitializeCallback;
  const void *pSubmitUserData;
  NvU32 submitUserDataSize;
  NVAPI_D3D12_DEVTOOLS_PUSH_PATCHABLE_METHODS_SUBMIT_CALLBACK pfnSubmitCallback;
} NVAPI_D3D12_DEVTOOLS_PUSH_PATCHABLE_METHODS_PARAMS;
NVAPI_INTERFACE NvAPI_D3D12_DevtoolsPushPatchableMethods(
    __inout NVAPI_D3D12_DEVTOOLS_PUSH_PATCHABLE_METHODS_PARAMS *params);
#define NVAPI_D3D12_DEVTOOLS_PUSH_PATCHABLE_METHODS_STRUCT_SIZE                                                        \
  NVAPI_STRUCT_SIZE(NVAPI_D3D12_DEVTOOLS_PUSH_PATCHABLE_METHODS_PARAMS, pfnSubmitCallback)
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef struct NvAPI_D3D12_Devtools_Context NvAPI_D3D12_Devtools_Context;
NVAPI_INTERFACE NvAPI_D3D12_Devtools_CreateContext(__in ID3D12Device *pDevice,
                                                   __inout NvAPI_D3D12_Devtools_Context **ppDevtoolsContext);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_D3D12_Devtools_DestroyContext(__in NvAPI_D3D12_Devtools_Context *pDevtoolsContext);
#endif
#if defined(__cplusplus) && defined(__d3d12_h__)
typedef enum _NVAPI_DEVTOOLS_SHADER_INSTANCE_TYPE {
  NVAPI_DEVTOOLS_SHADER_INSTANCE_TYPE_DTA_SHADER_INSTANCE = 0,
  NVAPI_DEVTOOLS_SHADER_INSTANCE_TYPE_CUFUNCTION = 1,
} NVAPI_DEVTOOLS_SHADER_INSTANCE_TYPE;
typedef struct _NVAPI_D3D12_DEVTOOLS_UPLOAD_SHADER_PARAMS {
  size_t structSizeIn;
  size_t structSizeOut;
  struct NvAPI_D3D12_Devtools_Context *pDevtoolsContext;
  ID3D12GraphicsCommandList *pCommandList;
  NVAPI_DEVTOOLS_SHADER_INSTANCE_TYPE devtoolsShaderInstanceType;
  void *pDevtoolsShaderInstance;
  NvU64 shaderOffset;
  ID3D12Resource *pSrcResource;
  NvU64 srcOffset;
  NvU64 sizeInBytes;
} NVAPI_D3D12_DEVTOOLS_UPLOAD_SHADER_PARAMS;
NVAPI_INTERFACE NvAPI_D3D12_Devtools_UploadShader(__inout NVAPI_D3D12_DEVTOOLS_UPLOAD_SHADER_PARAMS *params);
#define NVAPI_D3D12_DEVTOOLS_SHADER_UPLOAD_PARAMS_STRUCT_SIZE                                                          \
  NVAPI_STRUCT_SIZE(NVAPI_D3D12_DEVTOOLS_UPLOAD_SHADER_PARAMS, sizeInBytes)
#endif
typedef NvU32 NVVIOOWNERID;
#define NVVIOOWNERID_NONE 0
typedef enum _NVVIOOWNERTYPE {
  NVVIOOWNERTYPE_NONE,
  NVVIOOWNERTYPE_APPLICATION,
  NVVIOOWNERTYPE_DESKTOP,
} NVVIOOWNERTYPE;
#define NVVIO_O_READ 0x00000000
#define NVVIO_O_WRITE_EXCLUSIVE 0x00010001
#define NVVIO_VALID_ACCESSRIGHTS (NVVIO_O_READ | NVVIO_O_WRITE_EXCLUSIVE)
#define NVVIO_OWNERID_INITIALIZED 0x80000000
#define NVVIO_OWNERID_EXCLUSIVE 0x40000000
#define NVVIO_OWNERID_TYPEMASK 0x0FFFFFFF
typedef enum _NVVIOSIGNALFORMAT {
  NVVIOSIGNALFORMAT_NONE,
  NVVIOSIGNALFORMAT_487I_59_94_SMPTE259_NTSC,
  NVVIOSIGNALFORMAT_576I_50_00_SMPTE259_PAL,
  NVVIOSIGNALFORMAT_1035I_60_00_SMPTE260,
  NVVIOSIGNALFORMAT_1035I_59_94_SMPTE260,
  NVVIOSIGNALFORMAT_1080I_50_00_SMPTE295,
  NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274,
  NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274,
  NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274,
  NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274,
  NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274,
  NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274,
  NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274,
  NVVIOSIGNALFORMAT_1080P_23_976_SMPTE274,
  NVVIOSIGNALFORMAT_720P_60_00_SMPTE296,
  NVVIOSIGNALFORMAT_720P_59_94_SMPTE296,
  NVVIOSIGNALFORMAT_720P_50_00_SMPTE296,
  NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274,
  NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274,
  NVVIOSIGNALFORMAT_720P_30_00_SMPTE296,
  NVVIOSIGNALFORMAT_720P_29_97_SMPTE296,
  NVVIOSIGNALFORMAT_720P_25_00_SMPTE296,
  NVVIOSIGNALFORMAT_720P_24_00_SMPTE296,
  NVVIOSIGNALFORMAT_720P_23_98_SMPTE296,
  NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372,
  NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372,
  NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372,
  NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372,
  NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372,
  NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372,
  NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372,
  NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372,
  NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372,
  NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372,
  NVVIOSIGNALFORMAT_1080PSF_25_00_SMPTE274,
  NVVIOSIGNALFORMAT_1080PSF_29_97_SMPTE274,
  NVVIOSIGNALFORMAT_1080PSF_30_00_SMPTE274,
  NVVIOSIGNALFORMAT_1080PSF_24_00_SMPTE274,
  NVVIOSIGNALFORMAT_1080PSF_23_98_SMPTE274,
  NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_A,
  NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_A,
  NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_A,
  NVVIOSIGNALFORMAT_1080P_60_00_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080I_60_00_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048I_60_00_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080P_50_00_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080I_50_00_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048I_50_00_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080P_30_00_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048P_30_00_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080P_25_00_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048P_25_00_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080P_24_00_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048P_24_00_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080I_48_00_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048I_48_00_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080P_59_94_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080I_59_94_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048I_59_94_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080P_29_97_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048P_29_97_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080P_23_98_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048P_23_98_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_1080I_47_96_SMPTE274_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_2048I_47_96_SMPTE372_3G_LEVEL_B,
  NVVIOSIGNALFORMAT_END
} NVVIOSIGNALFORMAT;
typedef enum _NVVIOVIDEOSTANDARD {
  NVVIOVIDEOSTANDARD_SMPTE259,
  NVVIOVIDEOSTANDARD_SMPTE260,
  NVVIOVIDEOSTANDARD_SMPTE274,
  NVVIOVIDEOSTANDARD_SMPTE295,
  NVVIOVIDEOSTANDARD_SMPTE296,
  NVVIOVIDEOSTANDARD_SMPTE372,
} NVVIOVIDEOSTANDARD;
typedef enum _NVVIOVIDEOTYPE {
  NVVIOVIDEOTYPE_SD,
  NVVIOVIDEOTYPE_HD,
} NVVIOVIDEOTYPE;
typedef enum _NVVIOINTERLACEMODE {
  NVVIOINTERLACEMODE_PROGRESSIVE,
  NVVIOINTERLACEMODE_INTERLACE,
  NVVIOINTERLACEMODE_PSF,
} NVVIOINTERLACEMODE;
typedef enum _NVVIODATAFORMAT {
  NVVIODATAFORMAT_UNKNOWN = -1,
  NVVIODATAFORMAT_R8G8B8_TO_YCRCB444,
  NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4444,
  NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4444,
  NVVIODATAFORMAT_R8G8B8_TO_YCRCB422,
  NVVIODATAFORMAT_R8G8B8A8_TO_YCRCBA4224,
  NVVIODATAFORMAT_R8G8B8Z10_TO_YCRCBZ4224,
  NVVIODATAFORMAT_X8X8X8_444_PASSTHRU,
  NVVIODATAFORMAT_X8X8X8A8_4444_PASSTHRU,
  NVVIODATAFORMAT_X8X8X8Z10_4444_PASSTHRU,
  NVVIODATAFORMAT_X10X10X10_444_PASSTHRU,
  NVVIODATAFORMAT_X10X8X8_444_PASSTHRU,
  NVVIODATAFORMAT_X10X8X8A10_4444_PASSTHRU,
  NVVIODATAFORMAT_X10X8X8Z10_4444_PASSTHRU,
  NVVIODATAFORMAT_DUAL_R8G8B8_TO_DUAL_YCRCB422,
  NVVIODATAFORMAT_DUAL_X8X8X8_TO_DUAL_422_PASSTHRU,
  NVVIODATAFORMAT_R10G10B10_TO_YCRCB422,
  NVVIODATAFORMAT_R10G10B10_TO_YCRCB444,
  NVVIODATAFORMAT_X12X12X12_444_PASSTHRU,
  NVVIODATAFORMAT_X12X12X12_422_PASSTHRU,
  NVVIODATAFORMAT_Y10CR10CB10_TO_YCRCB422,
  NVVIODATAFORMAT_Y8CR8CB8_TO_YCRCB422,
  NVVIODATAFORMAT_Y10CR8CB8A10_TO_YCRCBA4224,
  NVVIODATAFORMAT_R10G10B10_TO_RGB444,
  NVVIODATAFORMAT_R12G12B12_TO_YCRCB444,
  NVVIODATAFORMAT_R12G12B12_TO_YCRCB422,
} NVVIODATAFORMAT;
typedef enum _NVVIOOUTPUTAREA {
  NVVIOOUTPUTAREA_FULLSIZE,
  NVVIOOUTPUTAREA_SAFEACTION,
  NVVIOOUTPUTAREA_SAFETITLE,
} NVVIOOUTPUTAREA;
typedef enum _NVVIOSYNCSOURCE {
  NVVIOSYNCSOURCE_SDISYNC,
  NVVIOSYNCSOURCE_COMPSYNC,
} NVVIOSYNCSOURCE;
typedef enum _NVVIOCOMPSYNCTYPE {
  NVVIOCOMPSYNCTYPE_AUTO,
  NVVIOCOMPSYNCTYPE_BILEVEL,
  NVVIOCOMPSYNCTYPE_TRILEVEL,
} NVVIOCOMPSYNCTYPE;
typedef enum _NVVIOINPUTOUTPUTSTATUS {
  NVINPUTOUTPUTSTATUS_OFF,
  NVINPUTOUTPUTSTATUS_ERROR,
  NVINPUTOUTPUTSTATUS_SDI_SD,
  NVINPUTOUTPUTSTATUS_SDI_HD,
} NVVIOINPUTOUTPUTSTATUS;
typedef enum _NVVIOSYNCSTATUS {
  NVVIOSYNCSTATUS_OFF,
  NVVIOSYNCSTATUS_ERROR,
  NVVIOSYNCSTATUS_SYNCLOSS,
  NVVIOSYNCSTATUS_COMPOSITE,
  NVVIOSYNCSTATUS_SDI_SD,
  NVVIOSYNCSTATUS_SDI_HD,
} NVVIOSYNCSTATUS;
typedef enum _NVVIOCAPTURESTATUS {
  NVVIOSTATUS_STOPPED,
  NVVIOSTATUS_RUNNING,
  NVVIOSTATUS_ERROR,
} NVVIOCAPTURESTATUS;
typedef enum _NVVIOSTATUSTYPE {
  NVVIOSTATUSTYPE_IN,
  NVVIOSTATUSTYPE_OUT,
} NVVIOSTATUSTYPE;
#define NVAPI_MAX_VIO_DEVICES 8
#define NVAPI_MAX_VIO_JACKS 4
#define NVAPI_MAX_VIO_CHANNELS_PER_JACK 2
#define NVAPI_MAX_VIO_STREAMS 4
#define NVAPI_MIN_VIO_STREAMS 1
#define NVAPI_MAX_VIO_LINKS_PER_STREAM 2
#define NVAPI_MAX_FRAMELOCK_MAPPING_MODES 20
#define NVAPI_GVI_MIN_RAW_CAPTURE_IMAGES 1
#define NVAPI_GVI_MAX_RAW_CAPTURE_IMAGES 32
#define NVAPI_GVI_DEFAULT_RAW_CAPTURE_IMAGES 5
typedef enum _NVVIOCONFIGTYPE {
  NVVIOCONFIGTYPE_IN,
  NVVIOCONFIGTYPE_OUT,
} NVVIOCONFIGTYPE;
typedef enum _NVVIOCOLORSPACE {
  NVVIOCOLORSPACE_UNKNOWN,
  NVVIOCOLORSPACE_YCBCR,
  NVVIOCOLORSPACE_YCBCRA,
  NVVIOCOLORSPACE_YCBCRD,
  NVVIOCOLORSPACE_GBR,
  NVVIOCOLORSPACE_GBRA,
  NVVIOCOLORSPACE_GBRD,
} NVVIOCOLORSPACE;
typedef enum _NVVIOCOMPONENTSAMPLING {
  NVVIOCOMPONENTSAMPLING_UNKNOWN,
  NVVIOCOMPONENTSAMPLING_4444,
  NVVIOCOMPONENTSAMPLING_4224,
  NVVIOCOMPONENTSAMPLING_444,
  NVVIOCOMPONENTSAMPLING_422
} NVVIOCOMPONENTSAMPLING;
typedef enum _NVVIOBITSPERCOMPONENT {
  NVVIOBITSPERCOMPONENT_UNKNOWN,
  NVVIOBITSPERCOMPONENT_8,
  NVVIOBITSPERCOMPONENT_10,
  NVVIOBITSPERCOMPONENT_12,
} NVVIOBITSPERCOMPONENT;
typedef enum _NVVIOLINKID {
  NVVIOLINKID_UNKNOWN,
  NVVIOLINKID_A,
  NVVIOLINKID_B,
  NVVIOLINKID_C,
  NVVIOLINKID_D
} NVVIOLINKID;
typedef enum _NVVIOANCPARITYCOMPUTATION {
  NVVIOANCPARITYCOMPUTATION_AUTO,
  NVVIOANCPARITYCOMPUTATION_ON,
  NVVIOANCPARITYCOMPUTATION_OFF
} NVVIOANCPARITYCOMPUTATION;
#define NVVIOCAPS_VIDOUT_SDI 0x00000001
#define NVVIOCAPS_SYNC_INTERNAL 0x00000100
#define NVVIOCAPS_SYNC_GENLOCK 0x00000200
#define NVVIOCAPS_SYNCSRC_SDI 0x00001000
#define NVVIOCAPS_SYNCSRC_COMP 0x00002000
#define NVVIOCAPS_OUTPUTMODE_DESKTOP 0x00010000
#define NVVIOCAPS_OUTPUTMODE_OPENGL 0x00020000
#define NVVIOCAPS_VIDIN_SDI 0x00100000
#define NVVIOCAPS_PACKED_ANC_SUPPORTED 0x00200000
#define NVVIOCAPS_AUDIO_BLANKING_SUPPORTED 0x00400000
#define NVVIOCLASS_SDI 0x00000001
typedef struct _NVVIOCAPS {
  NvU32 version;
  NvAPI_String adapterName;
  NvU32 adapterClass;
  NvU32 adapterCaps;
  NvU32 dipSwitch;
  NvU32 dipSwitchReserved;
  NvU32 boardID;
  struct {
    NvU32 majorVersion;
    NvU32 minorVersion;
  } driver;
  struct {
    NvU32 majorVersion;
    NvU32 minorVersion;
  } firmWare;
  NVVIOOWNERID ownerId;
  NVVIOOWNERTYPE ownerType;
} NVVIOCAPS;
#define NVVIOCAPS_VER1 MAKE_NVAPI_VERSION(NVVIOCAPS, 1)
#define NVVIOCAPS_VER2 MAKE_NVAPI_VERSION(NVVIOCAPS, 2)
#define NVVIOCAPS_VER NVVIOCAPS_VER2
typedef struct _NVVIOCHANNELSTATUS {
  NvU32 smpte352;
  NVVIOSIGNALFORMAT signalFormat;
  NVVIOBITSPERCOMPONENT bitsPerComponent;
  NVVIOCOMPONENTSAMPLING samplingFormat;
  NVVIOCOLORSPACE colorSpace;
  NVVIOLINKID linkID;
} NVVIOCHANNELSTATUS;
typedef struct _NVVIOINPUTSTATUS {
  NVVIOCHANNELSTATUS vidIn[NVAPI_MAX_VIO_JACKS][NVAPI_MAX_VIO_CHANNELS_PER_JACK];
  NVVIOCAPTURESTATUS captureStatus;
} NVVIOINPUTSTATUS;
typedef struct _NVVIOOUTPUTSTATUS {
  NVVIOINPUTOUTPUTSTATUS vid1Out;
  NVVIOINPUTOUTPUTSTATUS vid2Out;
  NVVIOSYNCSTATUS sdiSyncIn;
  NVVIOSYNCSTATUS compSyncIn;
  NvU32 syncEnable;
  NVVIOSYNCSOURCE syncSource;
  NVVIOSIGNALFORMAT syncFormat;
  NvU32 frameLockEnable;
  NvU32 outputVideoLocked;
  NvU32 dataIntegrityCheckErrorCount;
  NvU32 dataIntegrityCheckEnabled;
  NvU32 dataIntegrityCheckFailed;
  NvU32 uSyncSourceLocked;
  NvU32 uPowerOn;
} NVVIOOUTPUTSTATUS;
typedef struct _NVVIOSTATUS {
  NvU32 version;
  NVVIOSTATUSTYPE nvvioStatusType;
  union {
    NVVIOINPUTSTATUS inStatus;
    NVVIOOUTPUTSTATUS outStatus;
  } vioStatus;
} NVVIOSTATUS;
#define NVVIOSTATUS_VER MAKE_NVAPI_VERSION(NVVIOSTATUS, 1)
typedef struct _NVVIOOUTPUTREGION {
  NvU32 x;
  NvU32 y;
  NvU32 width;
  NvU32 height;
} NVVIOOUTPUTREGION;
typedef struct _NVVIOGAMMARAMP8 {
  NvU16 uRed[256];
  NvU16 uGreen[256];
  NvU16 uBlue[256];
} NVVIOGAMMARAMP8;
typedef struct _NVVIOGAMMARAMP10 {
  NvU16 uRed[1024];
  NvU16 uGreen[1024];
  NvU16 uBlue[1024];
} NVVIOGAMMARAMP10;
typedef struct _NVVIOSYNCDELAY {
  NvU32 version;
  NvU32 horizontalDelay;
  NvU32 verticalDelay;
} NVVIOSYNCDELAY;
#define NVVIOSYNCDELAY_VER MAKE_NVAPI_VERSION(NVVIOSYNCDELAY, 1)
typedef struct _NVVIOVIDEOMODE {
  NvU32 horizontalPixels;
  NvU32 verticalLines;
  float fFrameRate;
  NVVIOINTERLACEMODE interlaceMode;
  NVVIOVIDEOSTANDARD videoStandard;
  NVVIOVIDEOTYPE videoType;
} NVVIOVIDEOMODE;
typedef struct _NVVIOSIGNALFORMATDETAIL {
  NVVIOSIGNALFORMAT signalFormat;
  NVVIOVIDEOMODE videoMode;
} NVVIOSIGNALFORMATDETAIL;
#define NVVIOBUFFERFORMAT_R8G8B8 0x00000001
#define NVVIOBUFFERFORMAT_R8G8B8Z24 0x00000002
#define NVVIOBUFFERFORMAT_R8G8B8A8 0x00000004
#define NVVIOBUFFERFORMAT_R8G8B8A8Z24 0x00000008
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FP 0x00000010
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FPZ24 0x00000020
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FP 0x00000040
#define NVVIOBUFFERFORMAT_R16FPG16FPB16FPA16FPZ24 0x00000080
typedef struct _NVVIODATAFORMATDETAIL {
  NVVIODATAFORMAT dataFormat;
  NvU32 vioCaps;
} NVVIODATAFORMATDETAIL;
typedef struct _NVVIOCOLORCONVERSION {
  NvU32 version;
  float colorMatrix[3][3];
  float colorOffset[3];
  float colorScale[3];
  NvU32 compositeSafe;
} NVVIOCOLORCONVERSION;
#define NVVIOCOLORCONVERSION_VER MAKE_NVAPI_VERSION(NVVIOCOLORCONVERSION, 1)
typedef struct _NVVIOGAMMACORRECTION {
  NvU32 version;
  NvU32 vioGammaCorrectionType;
  union {
    NVVIOGAMMARAMP8 gammaRamp8;
    NVVIOGAMMARAMP10 gammaRamp10;
  } gammaRamp;
  float fGammaValueR;
  float fGammaValueG;
  float fGammaValueB;
} NVVIOGAMMACORRECTION;
#define NVVIOGAMMACORRECTION_VER MAKE_NVAPI_VERSION(NVVIOGAMMACORRECTION, 1)
#define MAX_NUM_COMPOSITE_RANGE 2
typedef struct _NVVIOCOMPOSITERANGE {
  NvU32 uRange;
  NvU32 uEnabled;
  NvU32 uMin;
  NvU32 uMax;
} NVVIOCOMPOSITERANGE;
#define NVVIOCONFIG_SIGNALFORMAT 0x00000001
#define NVVIOCONFIG_DATAFORMAT 0x00000002
#define NVVIOCONFIG_OUTPUTREGION 0x00000004
#define NVVIOCONFIG_OUTPUTAREA 0x00000008
#define NVVIOCONFIG_COLORCONVERSION 0x00000010
#define NVVIOCONFIG_GAMMACORRECTION 0x00000020
#define NVVIOCONFIG_SYNCSOURCEENABLE 0x00000040
#define NVVIOCONFIG_SYNCDELAY 0x00000080
#define NVVIOCONFIG_COMPOSITESYNCTYPE 0x00000100
#define NVVIOCONFIG_FRAMELOCKENABLE 0x00000200
#define NVVIOCONFIG_422FILTER 0x00000400
#define NVVIOCONFIG_COMPOSITETERMINATE 0x00000800
#define NVVIOCONFIG_DATAINTEGRITYCHECK 0x00001000
#define NVVIOCONFIG_CSCOVERRIDE 0x00002000
#define NVVIOCONFIG_FLIPQUEUELENGTH 0x00004000
#define NVVIOCONFIG_ANCTIMECODEGENERATION 0x00008000
#define NVVIOCONFIG_COMPOSITE 0x00010000
#define NVVIOCONFIG_ALPHAKEYCOMPOSITE 0x00020000
#define NVVIOCONFIG_COMPOSITE_Y 0x00040000
#define NVVIOCONFIG_COMPOSITE_CR 0x00080000
#define NVVIOCONFIG_COMPOSITE_CB 0x00100000
#define NVVIOCONFIG_FULL_COLOR_RANGE 0x00200000
#define NVVIOCONFIG_RGB_DATA 0x00400000
#define NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE 0x00800000
#define NVVIOCONFIG_STREAMS 0x01000000
#define NVVIOCONFIG_ANC_PARITY_COMPUTATION 0x02000000
#define NVVIOCONFIG_ANC_AUDIO_REPEAT 0x04000000
#define NVVIOCONFIG_ALLFIELDS                                                                                          \
  (NVVIOCONFIG_SIGNALFORMAT | NVVIOCONFIG_DATAFORMAT | NVVIOCONFIG_OUTPUTREGION | NVVIOCONFIG_OUTPUTAREA |             \
   NVVIOCONFIG_COLORCONVERSION | NVVIOCONFIG_GAMMACORRECTION | NVVIOCONFIG_SYNCSOURCEENABLE | NVVIOCONFIG_SYNCDELAY |  \
   NVVIOCONFIG_COMPOSITESYNCTYPE | NVVIOCONFIG_FRAMELOCKENABLE | NVVIOCONFIG_422FILTER |                               \
   NVVIOCONFIG_COMPOSITETERMINATE | NVVIOCONFIG_DATAINTEGRITYCHECK | NVVIOCONFIG_CSCOVERRIDE |                         \
   NVVIOCONFIG_FLIPQUEUELENGTH | NVVIOCONFIG_ANCTIMECODEGENERATION | NVVIOCONFIG_COMPOSITE |                           \
   NVVIOCONFIG_ALPHAKEYCOMPOSITE | NVVIOCONFIG_COMPOSITE_Y | NVVIOCONFIG_COMPOSITE_CR | NVVIOCONFIG_COMPOSITE_CB |     \
   NVVIOCONFIG_FULL_COLOR_RANGE | NVVIOCONFIG_RGB_DATA | NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE | NVVIOCONFIG_STREAMS |  \
   NVVIOCONFIG_ANC_PARITY_COMPUTATION | NVVIOCONFIG_ANC_AUDIO_REPEAT)
#define NVVIOCONFIG_VALIDFIELDS                                                                                        \
  (NVVIOCONFIG_SIGNALFORMAT | NVVIOCONFIG_DATAFORMAT | NVVIOCONFIG_OUTPUTREGION | NVVIOCONFIG_OUTPUTAREA |             \
   NVVIOCONFIG_COLORCONVERSION | NVVIOCONFIG_GAMMACORRECTION | NVVIOCONFIG_SYNCSOURCEENABLE | NVVIOCONFIG_SYNCDELAY |  \
   NVVIOCONFIG_COMPOSITESYNCTYPE | NVVIOCONFIG_FRAMELOCKENABLE | NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE |                \
   NVVIOCONFIG_422FILTER | NVVIOCONFIG_COMPOSITETERMINATE | NVVIOCONFIG_DATAINTEGRITYCHECK | NVVIOCONFIG_CSCOVERRIDE | \
   NVVIOCONFIG_FLIPQUEUELENGTH | NVVIOCONFIG_ANCTIMECODEGENERATION | NVVIOCONFIG_COMPOSITE |                           \
   NVVIOCONFIG_ALPHAKEYCOMPOSITE | NVVIOCONFIG_COMPOSITE_Y | NVVIOCONFIG_COMPOSITE_CR | NVVIOCONFIG_COMPOSITE_CB |     \
   NVVIOCONFIG_FULL_COLOR_RANGE | NVVIOCONFIG_RGB_DATA | NVVIOCONFIG_RESERVED_SDIOUTPUTENABLE | NVVIOCONFIG_STREAMS |  \
   NVVIOCONFIG_ANC_PARITY_COMPUTATION | NVVIOCONFIG_ANC_AUDIO_REPEAT)
#define NVVIOCONFIG_DRIVERFIELDS                                                                                       \
  (NVVIOCONFIG_OUTPUTREGION | NVVIOCONFIG_OUTPUTAREA | NVVIOCONFIG_COLORCONVERSION | NVVIOCONFIG_FLIPQUEUELENGTH)
#define NVVIOCONFIG_GAMMAFIELDS (NVVIOCONFIG_GAMMACORRECTION)
#define NVVIOCONFIG_RMCTRLFIELDS                                                                                       \
  (NVVIOCONFIG_SIGNALFORMAT | NVVIOCONFIG_DATAFORMAT | NVVIOCONFIG_SYNCSOURCEENABLE | NVVIOCONFIG_COMPOSITESYNCTYPE |  \
   NVVIOCONFIG_FRAMELOCKENABLE | NVVIOCONFIG_422FILTER | NVVIOCONFIG_COMPOSITETERMINATE |                              \
   NVVIOCONFIG_DATAINTEGRITYCHECK | NVVIOCONFIG_COMPOSITE | NVVIOCONFIG_ALPHAKEYCOMPOSITE | NVVIOCONFIG_COMPOSITE_Y |  \
   NVVIOCONFIG_COMPOSITE_CR | NVVIOCONFIG_COMPOSITE_CB)
#define NVVIOCONFIG_RMSKEWFIELDS (NVVIOCONFIG_SYNCDELAY)
#define NVVIOCONFIG_ALLOWSDIRUNNING_FIELDS                                                                             \
  (NVVIOCONFIG_DATAINTEGRITYCHECK | NVVIOCONFIG_SYNCDELAY | NVVIOCONFIG_CSCOVERRIDE |                                  \
   NVVIOCONFIG_ANCTIMECODEGENERATION | NVVIOCONFIG_COMPOSITE | NVVIOCONFIG_ALPHAKEYCOMPOSITE |                         \
   NVVIOCONFIG_COMPOSITE_Y | NVVIOCONFIG_COMPOSITE_CR | NVVIOCONFIG_COMPOSITE_CB | NVVIOCONFIG_ANC_PARITY_COMPUTATION)
#define NVVIOCONFIG_RMMODESET_FIELDS                                                                                   \
  (NVVIOCONFIG_SIGNALFORMAT | NVVIOCONFIG_DATAFORMAT | NVVIOCONFIG_SYNCSOURCEENABLE | NVVIOCONFIG_FRAMELOCKENABLE |    \
   NVVIOCONFIG_COMPOSITESYNCTYPE | NVVIOCONFIG_ANC_AUDIO_REPEAT)
typedef struct _NVVIOOUTPUTCONFIG_V1 {
  NVVIOSIGNALFORMAT signalFormat;
  NVVIODATAFORMAT dataFormat;
  NVVIOOUTPUTREGION outputRegion;
  NVVIOOUTPUTAREA outputArea;
  NVVIOCOLORCONVERSION colorConversion;
  NVVIOGAMMACORRECTION gammaCorrection;
  NvU32 syncEnable;
  NVVIOSYNCSOURCE syncSource;
  NVVIOSYNCDELAY syncDelay;
  NVVIOCOMPSYNCTYPE compositeSyncType;
  NvU32 frameLockEnable;
  NvU32 psfSignalFormat;
  NvU32 enable422Filter;
  NvU32 compositeTerminate;
  NvU32 enableDataIntegrityCheck;
  NvU32 cscOverride;
  NvU32 flipQueueLength;
  NvU32 enableANCTimeCodeGeneration;
  NvU32 enableComposite;
  NvU32 enableAlphaKeyComposite;
  NVVIOCOMPOSITERANGE compRange;
  NvU8 reservedData[256];
  NvU32 enableFullColorRange;
  NvU32 enableRGBData;
} NVVIOOUTPUTCONFIG_V1;
typedef struct _NVVIOOUTPUTCONFIG_V2 {
  NVVIOSIGNALFORMAT signalFormat;
  NVVIODATAFORMAT dataFormat;
  NVVIOOUTPUTREGION outputRegion;
  NVVIOOUTPUTAREA outputArea;
  NVVIOCOLORCONVERSION colorConversion;
  NVVIOGAMMACORRECTION gammaCorrection;
  NvU32 syncEnable;
  NVVIOSYNCSOURCE syncSource;
  NVVIOSYNCDELAY syncDelay;
  NVVIOCOMPSYNCTYPE compositeSyncType;
  NvU32 frameLockEnable;
  NvU32 psfSignalFormat;
  NvU32 enable422Filter;
  NvU32 compositeTerminate;
  NvU32 enableDataIntegrityCheck;
  NvU32 cscOverride;
  NvU32 flipQueueLength;
  NvU32 enableANCTimeCodeGeneration;
  NvU32 enableComposite;
  NvU32 enableAlphaKeyComposite;
  NVVIOCOMPOSITERANGE compRange;
  NvU8 reservedData[256];
  NvU32 enableFullColorRange;
  NvU32 enableRGBData;
  NVVIOANCPARITYCOMPUTATION ancParityComputation;
} NVVIOOUTPUTCONFIG_V2;
typedef struct _NVVIOOUTPUTCONFIG_V3 {
  NVVIOSIGNALFORMAT signalFormat;
  NVVIODATAFORMAT dataFormat;
  NVVIOOUTPUTREGION outputRegion;
  NVVIOOUTPUTAREA outputArea;
  NVVIOCOLORCONVERSION colorConversion;
  NVVIOGAMMACORRECTION gammaCorrection;
  NvU32 syncEnable;
  NVVIOSYNCSOURCE syncSource;
  NVVIOSYNCDELAY syncDelay;
  NVVIOCOMPSYNCTYPE compositeSyncType;
  NvU32 frameLockEnable;
  NvU32 psfSignalFormat;
  NvU32 enable422Filter;
  NvU32 compositeTerminate;
  NvU32 enableDataIntegrityCheck;
  NvU32 cscOverride;
  NvU32 flipQueueLength;
  NvU32 enableANCTimeCodeGeneration;
  NvU32 enableComposite;
  NvU32 enableAlphaKeyComposite;
  NVVIOCOMPOSITERANGE compRange;
  NvU8 reservedData[256];
  NvU32 enableFullColorRange;
  NvU32 enableRGBData;
  NVVIOANCPARITYCOMPUTATION ancParityComputation;
  NvU32 enableAudioBlanking;
} NVVIOOUTPUTCONFIG_V3;
typedef struct _NVVIOSTREAM {
  NvU32 bitsPerComponent;
  NVVIOCOMPONENTSAMPLING sampling;
  NvU32 expansionEnable;
  NvU32 numLinks;
  struct {
    NvU32 jack;
    NvU32 channel;
  } links[NVAPI_MAX_VIO_LINKS_PER_STREAM];
} NVVIOSTREAM;
typedef struct _NVVIOINPUTCONFIG {
  NvU32 numRawCaptureImages;
  NVVIOSIGNALFORMAT signalFormat;
  NvU32 numStreams;
  NVVIOSTREAM streams[NVAPI_MAX_VIO_STREAMS];
  NvU32 bTestMode;
} NVVIOINPUTCONFIG;
typedef struct _NVVIOCONFIG_V1 {
  NvU32 version;
  NvU32 fields;
  NVVIOCONFIGTYPE nvvioConfigType;
  union {
    NVVIOINPUTCONFIG inConfig;
    NVVIOOUTPUTCONFIG_V1 outConfig;
  } vioConfig;
} NVVIOCONFIG_V1;
typedef struct _NVVIOCONFIG_V2 {
  NvU32 version;
  NvU32 fields;
  NVVIOCONFIGTYPE nvvioConfigType;
  union {
    NVVIOINPUTCONFIG inConfig;
    NVVIOOUTPUTCONFIG_V2 outConfig;
  } vioConfig;
} NVVIOCONFIG_V2;
typedef struct _NVVIOCONFIG_V3 {
  NvU32 version;
  NvU32 fields;
  NVVIOCONFIGTYPE nvvioConfigType;
  union {
    NVVIOINPUTCONFIG inConfig;
    NVVIOOUTPUTCONFIG_V3 outConfig;
  } vioConfig;
} NVVIOCONFIG_V3;
typedef NVVIOOUTPUTCONFIG_V3 NVVIOOUTPUTCONFIG;
typedef NVVIOCONFIG_V3 NVVIOCONFIG;
#define NVVIOCONFIG_VER1 MAKE_NVAPI_VERSION(NVVIOCONFIG_V1, 1)
#define NVVIOCONFIG_VER2 MAKE_NVAPI_VERSION(NVVIOCONFIG_V2, 2)
#define NVVIOCONFIG_VER3 MAKE_NVAPI_VERSION(NVVIOCONFIG_V3, 3)
#define NVVIOCONFIG_VER NVVIOCONFIG_VER3
typedef struct {
  NvPhysicalGpuHandle hPhysicalGpu;
  NvVioHandle hVioHandle;
  NvU32 vioId;
  NvU32 outputId;
} NVVIOTOPOLOGYTARGET;
typedef struct _NV_VIO_TOPOLOGY {
  NvU32 version;
  NvU32 vioTotalDeviceCount;
  NVVIOTOPOLOGYTARGET vioTarget[NVAPI_MAX_VIO_DEVICES];
} NV_VIO_TOPOLOGY, NVVIOTOPOLOGY;
#define NV_VIO_TOPOLOGY_VER MAKE_NVAPI_VERSION(NV_VIO_TOPOLOGY, 1)
#define NVVIOTOPOLOGY_VER MAKE_NVAPI_VERSION(NVVIOTOPOLOGY, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_GetCapabilities(NvVioHandle hVioHandle, NVVIOCAPS *pAdapterCaps);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_Open(NvVioHandle hVioHandle, NvU32 vioClass, NVVIOOWNERTYPE ownerType);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_Close(NvVioHandle hVioHandle, NvU32 bRelease);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_Status(NvVioHandle hVioHandle, NVVIOSTATUS *pStatus);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_SyncFormatDetect(NvVioHandle hVioHandle, NvU32 *pWait);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_GetConfig(NvVioHandle hVioHandle, NVVIOCONFIG *pConfig);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_SetConfig(NvVioHandle hVioHandle, const NVVIOCONFIG *pConfig);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.") NVAPI_INTERFACE
    NvAPI_VIO_SetCSC(NvVioHandle hVioHandle, NVVIOCOLORCONVERSION *pCSC);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.") NVAPI_INTERFACE
    NvAPI_VIO_GetCSC(NvVioHandle hVioHandle, NVVIOCOLORCONVERSION *pCSC);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.") NVAPI_INTERFACE
    NvAPI_VIO_SetGamma(NvVioHandle hVioHandle, NVVIOGAMMACORRECTION *pGamma);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.") NVAPI_INTERFACE
    NvAPI_VIO_GetGamma(NvVioHandle hVioHandle, NVVIOGAMMACORRECTION *pGamma);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_SetConfig.") NVAPI_INTERFACE
    NvAPI_VIO_SetSyncDelay(NvVioHandle hVioHandle, const NVVIOSYNCDELAY *pSyncDelay);
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 290. Instead, use NvAPI_VIO_GetConfig.") NVAPI_INTERFACE
    NvAPI_VIO_GetSyncDelay(NvVioHandle hVioHandle, NVVIOSYNCDELAY *pSyncDelay);
typedef enum _NVVIOPCILINKRATE {
  NVVIOPCILINKRATE_UNKNOWN = 0,
  NVVIOPCILINKRATE_GEN1 = 1,
  NVVIOPCILINKRATE_GEN2 = 2,
  NVVIOPCILINKRATE_GEN3 = 3,
} NVVIOPCILINKRATE;
typedef enum _NVVIOPCILINKWIDTH {
  NVVIOPCILINKWIDTH_UNKNOWN = 0,
  NVVIOPCILINKWIDTH_x1 = 1,
  NVVIOPCILINKWIDTH_x2 = 2,
  NVVIOPCILINKWIDTH_x4 = 4,
  NVVIOPCILINKWIDTH_x8 = 8,
  NVVIOPCILINKWIDTH_x16 = 16,
} NVVIOPCILINKWIDTH;
typedef struct _NVVIOPCIINFO {
  NvU32 version;
  NvU32 pciDeviceId;
  NvU32 pciSubSystemId;
  NvU32 pciRevisionId;
  NvU32 pciDomain;
  NvU32 pciBus;
  NvU32 pciSlot;
  NVVIOPCILINKWIDTH pciLinkWidth;
  NVVIOPCILINKRATE pciLinkRate;
} NVVIOPCIINFO_V1;
typedef NVVIOPCIINFO_V1 NVVIOPCIINFO;
#define NVVIOPCIINFO_VER1 MAKE_NVAPI_VERSION(NVVIOPCIINFO_V1, 1)
#define NVVIOPCIINFO_VER NVVIOPCIINFO_VER1
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_GetPCIInfo(__in NvVioHandle hVioHandle, __inout NVVIOPCIINFO *pVioPCIInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_IsRunning(NvVioHandle hVioHandle);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_Start(NvVioHandle hVioHandle);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_Stop(NvVioHandle hVioHandle);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_IsFrameLockModeCompatible(NvVioHandle hVioHandle, NvU32 srcEnumIndex, NvU32 destEnumIndex,
                                        NvU32 *pbCompatible);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_EnumDevices(NvVioHandle hVioHandle[NVAPI_MAX_VIO_DEVICES], NvU32 *vioDeviceCount);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_QueryTopology(NV_VIO_TOPOLOGY *pNvVIOTopology);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_EnumSignalFormats(NvVioHandle hVioHandle, NvU32 enumIndex, NVVIOSIGNALFORMATDETAIL *pSignalFormatDetail);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_VIO_EnumDataFormats(NvVioHandle hVioHandle, NvU32 enumIndex, NVVIODATAFORMATDETAIL *pDataFormatDetail);
typedef enum _NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS {
  NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_SUCCESS,
  NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_NA,
  NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_INVALID_ARG,
  NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_ERROR,
  NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS_POWER_OFF,
} NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS;
typedef enum _NVAPI_CAMERA_TEST_DEVICE_ID {
  NVAPI_CAMERA_TEST_DEVICE_CAMERA1_ID,
  NVAPI_CAMERA_TEST_DEVICE_SENSOR1_ID,
  NVAPI_CAMERA_TEST_DEVICE_FOCUSSER1_ID,
  NVAPI_CAMERA_TEST_DEVICE_FLASH1_ID,
  NVAPI_CAMERA_TEST_DEVICE_CAMERA2_ID,
  NVAPI_CAMERA_TEST_DEVICE_SENSOR2_ID,
  NVAPI_CAMERA_TEST_DEVICE_FOCUSSER2_ID,
  NVAPI_CAMERA_TEST_DEVICE_FLASH2_ID,
  NVAPI_CAMERA_TEST_DEVICE_CAMERA3_ID,
  NVAPI_CAMERA_TEST_DEVICE_SENSOR3_ID,
  NVAPI_CAMERA_TEST_DEVICE_FOCUSSER3_ID,
  NVAPI_CAMERA_TEST_DEVICE_FLASH3_ID,
} NVAPI_CAMERA_TEST_DEVICE_ID;
typedef enum _NVAPI_CAMERA_TEST_FUNCTION_ID {
  NVAPI_CAMERA_TEST_FUNCTION_ID_POWERON,
  NVAPI_CAMERA_TEST_FUNCTION_ID_POWEROFF,
  NVAPI_CAMERA_TEST_FUNCTION_ID_GET_TOPOLOGY,
  NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST,
  NVAPI_CAMERA_TEST_FUNCTION_ID_REGWRITE,
  NVAPI_CAMERA_TEST_FUNCTION_ID_CAPTURE
} NVAPI_CAMERA_TEST_FUNCTION_ID;
typedef enum _NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM {
  NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM_CAM1,
  NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM_CAM2,
  NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM_CAM3,
} NVAPI_CAMERA_TEST_FUNCTION_ID_POWER_PARAM;
typedef enum _NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM {
  NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM_SENSOR,
  NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM_FOCUSSER,
  NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM_FLASH,
} NVAPI_CAMERA_TEST_FUNCTION_ID_SYSTEMTEST_PARAM;
typedef struct _NVAPI_CAMERA_TEST_PARAMS_V1 {
  NvU32 version;
  NVAPI_VIDEO_CAMERA_TEST_RETURN_STATUS dwStatus;
  NVAPI_CAMERA_TEST_FUNCTION_ID functionId;
  NvU32 dwParam;
  NvAPI_String szParam;
  NvU32 adwReserved[5];
} NVAPI_CAMERA_TEST_PARAMS_V1;
#define NVAPI_CAMERA_TEST_PARAMS_VER_V1 MAKE_NVAPI_VERSION(NVAPI_CAMERA_TEST_PARAMS_V1, 1)
typedef NVAPI_CAMERA_TEST_PARAMS_V1 NVAPI_CAMERA_TEST_PARAMS;
#define NVAPI_CAMERA_TEST_PARAMS_VER NVAPI_CAMERA_TEST_PARAMS_VER_V1
NVAPI_INTERFACE NvAPI_CameraTest(__in NvDisplayHandle hNvDisplay, __inout NVAPI_CAMERA_TEST_PARAMS *pCameraTestParams);
#define NV_STEREO_DIAG_INFO_VER MAKE_NVAPI_VERSION(NV_STEREO_DIAG_INFO, 2)
#define NV_STEREO_MAX_HEADS 4
typedef enum _NV_STEREO_DIAG_INFO_QUERY_ID {
  NV_STEREO_DIAG_INFO_QUERY_ID_COMMON,
  NV_STEREO_DIAG_INFO_QUERY_ID_LAST,
} NV_STEREO_DIAG_INFO_QUERY_ID;
typedef enum _NV_STEREO_HIGH_VBI_OVERRIDE {
  NV_STEREO_HIGH_VBI_OVERRIDE_DONE = 0x10000,
  NV_STEREO_HIGH_VBI_OVERRIDE_NOT_DONE = 0x20000,
  NV_STEREO_HIGH_VBI_OVERRIDE_NO_MONITOR = 0x40000,
  NV_STEREO_HIGH_VBI_OVERRIDE_PENDING_ON_RESUME = 0x80000
} NV_STEREO_HIGH_VBI_OVERRIDE;
typedef struct _NV_STEREO_STATUS_INFO {
  NvU8 isStereoEnabled;
  NvU8 isStereoActive;
  NvU32 numStereoClients;
  NvS32 stereoDeviceCount;
  NvU32 pendingStereoConfig[NV_STEREO_MAX_HEADS];
  NvU32 persistentStereoConfig[NV_STEREO_MAX_HEADS];
  NvU32 stereoConfig[NV_STEREO_MAX_HEADS];
  NvU32 stereoVBIOverride[NV_STEREO_MAX_HEADS];
  NvU32 stereoLastModeSetVBIOverride[NV_STEREO_MAX_HEADS];
  NvU32 stereoDesktopCount[NV_STEREO_MAX_HEADS];
  NvU32 monitor3DEnableStatus[NV_STEREO_MAX_HEADS];
  NvU32 stereoVBIOverrideTargetId[NV_STEREO_MAX_HEADS];
  NvU32 reserved[5];
} NV_STEREO_STATUS_INFO;
typedef struct _NV_STEREO_EMITTER_INFO {
  NvU8 isInit;
  NvU8 isConnected;
  NvU8 isActivated;
  NvU32 activatedHead;
  NvU32 activeHeadRR;
  NvU32 activeCount;
  NvU8 isActiveStatusUSBDrv;
  NvU32 reserved[5];
} NV_STEREO_EMITTER_INFO;
typedef struct _NV_STEREO_AERO_INFO {
  NvU32 appCount;
  NvU32 appPid;
  NvU32 orgRR;
  NvU32 reserved[5];
} NV_STEREO_AERO_INFO;
typedef struct _NV_STEREO_DIAG_COMMON_INFO {
  NvU32 reserved1;
  NV_STEREO_STATUS_INFO status;
  NV_STEREO_EMITTER_INFO emitter;
  NV_STEREO_AERO_INFO aero;
  NvU32 reserved2[20];
} NV_STEREO_DIAG_COMMON_INFO;
typedef struct _NV_STEREO_DIAG_INFO {
  NvU32 version;
  NvU32 queryId;
  NvU32 result;
  NvU32 reserved1;
  union {
    NV_STEREO_DIAG_COMMON_INFO commonInfo;
  };
} NV_STEREO_DIAG_INFO;
NVAPI_INTERFACE NvAPI_Stereo_GetInfo(__in NvDisplayHandle hNvDisplay, __inout NV_STEREO_DIAG_INFO *pStereoInfo);
#define NV_STEREO_DIAG_APP_INFO_VER MAKE_NVAPI_VERSION(NV_STEREO_DIAG_APP_INFO, 2)
#define NV_STEREO_INFO_MAX_APPS 32
#define NV_STEREO_INFO_DX9_APP 1
#define NV_STEREO_INFO_DX10_APP 2
#define NV_STEREO_APP_INFO_SIZE 1024
typedef enum _NV_STEREO_MODE {
  NV_STEREO_MODE_DEFAULT = 0,
  NV_STEREO_MODE_EXPLICIT = 1,
  NV_STEREO_MODE_QUADBUFFER = 2,
  NV_STEREO_MODE_LAST,
} NV_STEREO_MODE;
typedef enum _NV_STEREO_BROWSER_TYPE {
  NV_STEREO_BROWSER_NONE = 0x000,
  NV_STEREO_BROWSER_IE_BASE = 0x100,
  NV_STEREO_BROWSER_IE9_PLUS = 0x101,
  NV_STEREO_BROWSER_FF_BASE = 0x200,
  NV_STEREO_BROWSER_FF_3_6_4_PLUS = 0x201,
  NV_STEREO_BROWSER_FF_4_PLUS = 0x202,
  NV_STEREO_BROWSER_CHROME_BASE = 0x300,
  NV_STEREO_BROWSER_LAST
} NV_STEREO_BROWSER_TYPE;
typedef enum _NV_STEREO_SOURCE_LAYOUT {
  NV_STEREO_SOURCE_LAYOUT_LEFT_RIGHT = 0,
  NV_STEREO_SOURCE_LAYOUT_RIGHT_LEFT = 1,
  NV_STEREO_SOURCE_LAYOUT_TOP_BOTTOM = 2,
  NV_STEREO_SOURCE_LAYOUT_BOTTOM_TOP = 3,
  NV_STEREO_SOURCE_LAYOUT_MONO_MODE = 4,
  NV_STEREO_SOURCE_LAYOUT_LAST
} NV_STEREO_SOURCE_LAYOUT;
typedef enum _NV_STEREO_STATE {
  NV_STEREO_STATE_NOT_READY = -1,
  NV_STEREO_STATE_OFF = 0,
  NV_STEREO_STATE_ON = 1,
  NV_STEREO_STATE_FORCED_OFF = 2,
  NV_STEREO_STATE_OFF_IN_REGISTRY = 3,
} NV_STEREO_STATE;
typedef enum _NV_STEREO_DX_VERSION {
  NV_STEREO_DX_VERSION_DX10_0 = 2,
  NV_STEREO_DX_VERSION_DX10_1 = 3,
  NV_STEREO_DX_VERSION_DX11_0 = 4,
  NV_STEREO_DX_VERSION_DX11_1 = 5,
} NV_STEREO_DX_VERSION;
typedef enum _NV_STEREO_CFG {
  NV_STEREO_CFG_STEREOACTIVATED = 0x80000000,
  NV_STEREO_CFG_CONNECTIONTYPE = 0x000007FF,
  NV_STEREO_CFG_DEFAULT_VIEWER = 0x00000001,
  NV_STEREO_CFG_ELSADDC = 0x00000001,
  NV_STEREO_CFG_INTERLACED = 0x00000002,
  NV_STEREO_CFG_COLORINTERLEAVED = 0x00000003,
  NV_STEREO_CFG_MULTIHEAD = 0x00000004,
  NV_STEREO_CFG_INTERLEAVED = 0x00000008,
  NV_STEREO_CFG_LINECODE = 0x00000010,
  NV_STEREO_CFG_ANAGLYPH = 0x00000020,
  NV_STEREO_CFG_NVIDIA_ONBOARD_GPIO5_DAC0 = 0x00000040,
  NV_STEREO_CFG_NVIDIA_ONBOARD_GPIO5_DAC1 = 0x00000080,
  NV_STEREO_CFG_PRAMDAC_STEREO = 0x00000100,
  NV_STEREO_CFG_SHARP_GPIO4 = 0x00000200,
} NV_STEREO_CFG;
typedef struct _NV_STEREO_APP_INFO_DX9 {
  NvU8 exeName[128];
  NvU32 stereoMode;
  NvU32 reserved1;
  NvU32 stereoHWType;
  NvU32 reservedbits7 : 8;
  NvU32 isStereoActivated : 1;
  NvU32 isStereoBlocked : 1;
  NvU32 isAnaglyphOnly : 1;
  NvU32 isHDMIStereo : 1;
  NvU32 isHDMIAllowed : 1;
  NvU32 isHDMISupported : 1;
  NvU32 isHDMIProtected : 1;
  NvU32 isHDMIWindowed : 1;
  NvU32 isSLIBroadcast : 1;
  NvU32 isClonedMode : 1;
  NvU32 isGameProfiled : 1;
  NvU32 reservedbits1 : 5;
  NvU32 reservedbits2 : 8;
  NvU32 reserved2;
  NvU32 isFullLicense : 1;
  NvU32 isTestLicense : 1;
  NvU32 isPanelReleased : 1;
  NvU32 isDisplayIdentified : 1;
  NvU32 isDisplayReleased : 1;
  NvU32 isNB : 1;
  NvU32 isQuadro : 1;
  NvU32 isSandBox : 1;
  NvU32 reservedbits6 : 8;
  NvU32 isDisableHighVBIOverride : 1;
  NvU32 isDisableAuthentication : 1;
  NvU32 isNBInternalPanel : 1;
  NvU32 isBrowserStereoApp : 1;
  NvU32 isBrowserPhotoApp : 1;
  NvU32 isInDWM : 1;
  NvU32 isBulkLicense : 1;
  NvU32 isUserLicense : 1;
  NvU32 reservedbits4 : 8;
  NvU32 reserved3;
  NvU32 isFullscreen : 1;
  NvU32 isAeroWindowModeEnabled : 1;
  NvU32 isGDIWindowModeEnabled : 1;
  NvU32 isAeroWindowModeActivated : 1;
  NvU32 isGDIWindowModeActivated : 1;
  NvU32 reservedBits4 : 3;
  NvU32 reservedbits5 : 24;
  NvU32 reserved4;
  NvU32 browserType;
  NvU32 primaryWidth;
  NvU32 primaryHeight;
  NvU32 primaryRR;
  NvU32 primaryFormat;
  NvU32 numStereoSwapChain;
  NvU32 currentVideoWidth;
  NvU32 currentVideoHeight;
  NvU32 reserved5;
  NvU32 uFPS;
  NvU32 refreshRateOverride;
  NvU32 monitorHead;
  NvU32 originalRefreshRate;
  NvU32 stereoDesktopCount;
  NvU32 persistentStereoDesktop;
  NvU32 delayedStereoDesktop;
  NvU32 reserved6;
  NvU32 displayWidth;
  NvU32 displayHeight;
  NvU32 targetDisplayCount;
  NvU32 reserved7[20];
} NV_STEREO_APP_INFO_DX9;
typedef struct _NV_STEREO_APP_INFO_DX10 {
  NvU32 reservedbits9 : 8;
  NvU32 isNvStereoEnabled : 1;
  NvU32 isDxStereoEnabled : 1;
  NvU32 isAnaglyphOnly : 1;
  NvU32 isStereoActivated : 1;
  NvU32 isSLIDisabled : 1;
  NvU32 isStereoEnabledInRegistry : 1;
  NvU32 isAeroWindowedModeEnabled : 1;
  NvU32 isAeroWindowedModeActive : 1;
  NvU32 isStereoDesktopCreationDelayed : 1;
  NvU32 isAeroEnabled : 1;
  NvU32 isBrowserStereoApp : 1;
  NvU32 isFirefoxHTML5 : 1;
  NvU32 isIE9HTML5 : 1;
  NvU32 isGameProfiled : 1;
  NvU32 reservedBits1 : 2;
  NvU32 reservedbits2 : 8;
  NvU32 reserved1;
  NvU32 html5FFWidth;
  NvU32 html5FFHeight;
  NvU32 browserType;
  NvU32 fireFoxLayout;
  NvU32 reserved2;
  NvU32 primaryFormat;
  NvU32 primaryWidth;
  NvU32 primaryHeight;
  NvU32 primaryRR;
  NvU32 origAeroRefreshRate;
  NvU32 numStereoSwapChain;
  NvU32 reserved3;
  NvU32 stereoHWType;
  NvU32 reservedbits10 : 8;
  NvU32 isDLPStereo : 1;
  NvU32 isAnaglypthStereo : 1;
  NvU32 isAutoStereo : 1;
  NvU32 isHDMIStereo : 1;
  NvU32 isHDMIAllowed : 1;
  NvU32 isHDMISupported : 1;
  NvU32 isHDMIProtected : 1;
  NvU32 isHDMIWindowed : 1;
  NvU32 isHDMINotificationDone : 1;
  NvU32 isHDMIWARsApplied : 1;
  NvU32 isHDMI3DEnabled : 1;
  NvU32 isFullLicense : 1;
  NvU32 isTestLicense : 1;
  NvU32 isNB : 1;
  NvU32 isQuadro : 1;
  NvU32 isPanelReleased : 1;
  NvU32 isBulkLicense : 1;
  NvU32 isUserLicense : 1;
  NvU32 reservedbits3 : 6;
  NvU32 reserved4;
  NvU32 state;
  NvU32 appRealName[128];
  NvU32 stereoMode;
  NvU32 stereoVSConst;
  NvU32 numStereoVS;
  NvU32 reserved5;
  NvU32 reservedbits4 : 8;
  NvU32 isClonedMode : 1;
  NvU32 isStereoBroadcastSLI : 1;
  NvU32 doNotStartInStereoOnInit : 1;
  NvU32 isStereoTextureEnabled : 1;
  NvU32 isStereoSmallTexturesEnabled : 1;
  NvU32 isStereoSmallTexturesEnabledOnlyForRGB10A2 : 1;
  NvU32 isEnableVerticalOrientedTextures : 1;
  NvU32 isStereoSquareTexturesEnabled : 1;
  NvU32 isDisableSmallSquareStereoTextures : 1;
  NvU32 isDisableBBSeparationIfStereoTexureInUse : 1;
  NvU32 isDisableBBSeparationCompletely : 1;
  NvU32 isStereoPlaneRTEnabled : 1;
  NvU32 isDisableStereoGSShader : 1;
  NvU32 isDisableSeparationWithoutZB : 1;
  NvU32 isDisableTexSeparationIfStereoTexureInUse : 1;
  NvU32 isStereoSmallTexturesDisabledForRGBA8 : 1;
  NvU32 isEnableVSStereoShadersWithoutConst : 1;
  NvU32 isEnableDSStereoShadersWithoutConst : 1;
  NvU32 isEnableGSStereoShadersWithoutConst : 1;
  NvU32 isWasLastDrawCallStereoized : 1;
  NvU32 isDisplayIdentified : 1;
  NvU32 isDisplayReleased : 1;
  NvU32 isSandBox : 1;
  NvU32 reservedbits6 : 1;
  NvU32 reservedbits7 : 8;
  NvU32 reservedbits11 : 8;
  NvU32 isDisableHighVBIOverride : 1;
  NvU32 isDisableAuthentication : 1;
  NvU32 isNotInFullScreen : 1;
  NvU32 isNBInternalPanel : 1;
  NvU32 allowWindowedOnGDIStereo : 1;
  NvU32 activeWindowedOnGDIStereo : 1;
  NvU32 isPersistentMode : 1;
  NvU32 isForcedPersistence : 1;
  NvU32 reservedbits8 : 8;
  NvU32 reservedbits12 : 32;
  NvU32 reserved6[3];
  NvU32 stereoConfig;
  NvU32 refreshRateOverride;
  NvU32 defaultRefreshRate;
  NvU32 surfaceCreateMode;
  NvU32 failToSetHighVBIDueToLackOfMonitor;
  NvU32 totalDisplaysInSys;
  NvU32 origRefreshRate;
  NvU32 reserved7[20];
} NV_STEREO_APP_INFO_DX10;
typedef struct _NV_STEREO_APP_INFO {
  NvU32 dxVersion;
  NvU32 processId;
  NvU32 reserved[2];
  union {
    NvU8 appData[NV_STEREO_APP_INFO_SIZE];
    NV_STEREO_APP_INFO_DX9 dx9;
    NV_STEREO_APP_INFO_DX10 dx10;
  };
} NV_STEREO_APP_INFO;
typedef struct _NV_STEREO_DIAG_APP_INFO {
  NvU32 version;
  NvU32 reserved1;
  NvU32 appCount;
  NvU32 appDataSize;
  NV_STEREO_APP_INFO info[NV_STEREO_INFO_MAX_APPS];
  NvU32 reserved2[10];
} NV_STEREO_DIAG_APP_INFO;
NVAPI_INTERFACE NvAPI_Stereo_GetAppInfo(__in NvDisplayHandle hNvDisplay, __inout NV_STEREO_DIAG_APP_INFO *pStereoInfo);
typedef enum _NV_StereoRegistryProfileType {
  NVAPI_STEREO_DEFAULT_REGISTRY_PROFILE,
  NVAPI_STEREO_DX9_REGISTRY_PROFILE,
  NVAPI_STEREO_DX10_REGISTRY_PROFILE
} NV_STEREO_REGISTRY_PROFILE_TYPE;
NVAPI_INTERFACE NvAPI_Stereo_CreateConfigurationProfileRegistryKey(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType);
NVAPI_INTERFACE NvAPI_Stereo_DeleteConfigurationProfileRegistryKey(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType);
typedef enum _NV_StereoRegistryID {
  NVAPI_CONVERGENCE_ID,
  NVAPI_FRUSTUM_ADJUST_MODE_ID,
} NV_STEREO_REGISTRY_ID;
NVAPI_INTERFACE NvAPI_Stereo_SetConfigurationProfileValue(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType,
                                                          NV_STEREO_REGISTRY_ID valueRegistryID, void *pValue);
NVAPI_INTERFACE NvAPI_Stereo_DeleteConfigurationProfileValue(NV_STEREO_REGISTRY_PROFILE_TYPE registryProfileType,
                                                             NV_STEREO_REGISTRY_ID valueRegistryID);
NVAPI_INTERFACE NvAPI_Stereo_Enable(void);
NVAPI_INTERFACE NvAPI_Stereo_Disable(void);
NVAPI_INTERFACE NvAPI_Stereo_IsEnabled(NvU8 *pIsStereoEnabled);
typedef enum _NVAPI_STEREO_WINDOWED_MODE {
  WINDOWED_MODE_STEREO_OFF = 0,
  WINDOWED_MODE_STEREO_AUTOMATIC = 1,
  WINDOWED_MODE_STEREO_PERSISTENT = 2,
} NVAPI_STEREO_WINDOWED_MODE;
NVAPI_INTERFACE NvAPI_Stereo_SetWindowedMode(NVAPI_STEREO_WINDOWED_MODE mode, NvU32 flags);
NVAPI_INTERFACE NvAPI_Stereo_GetWindowedMode(NVAPI_STEREO_WINDOWED_MODE *pMode);
typedef struct _NVAPI_STEREO_CAPS {
  NvU32 version;
  NvU32 supportsWindowedModeOff : 1;
  NvU32 supportsWindowedModeAutomatic : 1;
  NvU32 supportsWindowedModePersistent : 1;
  NvU32 reserved : 29;
  NvU32 reserved2[3];
} NVAPI_STEREO_CAPS_V1;
#define NVAPI_STEREO_CAPS_VER1 MAKE_NVAPI_VERSION(NVAPI_STEREO_CAPS, 1)
#define NVAPI_STEREO_CAPS_VER NVAPI_STEREO_CAPS_VER1
typedef NVAPI_STEREO_CAPS_V1 NVAPI_STEREO_CAPS;
NVAPI_INTERFACE NvAPI_Stereo_GetStereoSupport(__in NvMonitorHandle hMonitor, __out NVAPI_STEREO_CAPS *pCaps);
NVAPI_INTERFACE NvAPI_Stereo_GetStereoCaps(NVAPI_STEREO_CAPS *pCaps);
NVAPI_INTERFACE NvAPI_Stereo_GetStereoCapsInternal(NVAPI_STEREO_CAPS *pCaps);
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__) || defined(__d3d12_h__)
NVAPI_INTERFACE NvAPI_Stereo_CreateHandleFromIUnknown(IUnknown *pDevice, StereoHandle *pStereoHandle);
#endif
NVAPI_INTERFACE NvAPI_Stereo_DestroyHandle(StereoHandle stereoHandle);
NVAPI_INTERFACE NvAPI_Stereo_Activate(StereoHandle stereoHandle);
NVAPI_INTERFACE NvAPI_Stereo_Deactivate(StereoHandle stereoHandle);
NVAPI_INTERFACE NvAPI_Stereo_IsActivated(StereoHandle stereoHandle, NvU8 *pIsStereoOn);
NVAPI_INTERFACE NvAPI_Stereo_GetSeparation(StereoHandle stereoHandle, float *pSeparationPercentage);
NVAPI_INTERFACE NvAPI_Stereo_SetSeparation(StereoHandle stereoHandle, float newSeparationPercentage);
NVAPI_INTERFACE NvAPI_Stereo_DecreaseSeparation(StereoHandle stereoHandle);
NVAPI_INTERFACE NvAPI_Stereo_IncreaseSeparation(StereoHandle stereoHandle);
NVAPI_INTERFACE NvAPI_Stereo_GetConvergence(StereoHandle stereoHandle, float *pConvergence);
NVAPI_INTERFACE NvAPI_Stereo_SetConvergence(StereoHandle stereoHandle, float newConvergence);
NVAPI_INTERFACE NvAPI_Stereo_DecreaseConvergence(StereoHandle stereoHandle);
NVAPI_INTERFACE NvAPI_Stereo_IncreaseConvergence(StereoHandle stereoHandle);
typedef enum _NV_FrustumAdjustMode {
  NVAPI_NO_FRUSTUM_ADJUST,
  NVAPI_FRUSTUM_STRETCH,
  NVAPI_FRUSTUM_CLEAR_EDGES
} NV_FRUSTUM_ADJUST_MODE;
NVAPI_INTERFACE NvAPI_Stereo_GetFrustumAdjustMode(StereoHandle stereoHandle,
                                                  NV_FRUSTUM_ADJUST_MODE *pFrustumAdjustMode);
NVAPI_INTERFACE NvAPI_Stereo_SetFrustumAdjustMode(StereoHandle stereoHandle,
                                                  NV_FRUSTUM_ADJUST_MODE newFrustumAdjustModeValue);
NVAPI_INTERFACE NvAPI_Stereo_CaptureJpegImage(StereoHandle stereoHandle, NvU32 quality);
typedef enum _NVAPI_STEREO_INIT_ACTIVATION_FLAGS {
  NVAPI_STEREO_INIT_ACTIVATION_IMMEDIATE = 0X00,
  NVAPI_STEREO_INIT_ACTIVATION_DELAYED = 0x01,
} NVAPI_STEREO_INIT_ACTIVATION_FLAGS;
NVAPI_INTERFACE NvAPI_Stereo_InitActivation(__in StereoHandle hStereoHandle,
                                            __in NVAPI_STEREO_INIT_ACTIVATION_FLAGS flags);
NVAPI_INTERFACE NvAPI_Stereo_Trigger_Activation(__in StereoHandle hStereoHandle);
NVAPI_INTERFACE NvAPI_Stereo_CapturePngImage(StereoHandle stereoHandle);
NVAPI_INTERFACE NvAPI_Stereo_ReverseStereoBlitControl(StereoHandle hStereoHandle, NvU8 TurnOn);
NVAPI_INTERFACE NvAPI_Stereo_SetNotificationMessage(StereoHandle hStereoHandle, NvU64 hWnd, NvU64 messageID);
typedef enum _NV_StereoActiveEye {
  NVAPI_STEREO_EYE_RIGHT = 1,
  NVAPI_STEREO_EYE_LEFT = 2,
  NVAPI_STEREO_EYE_MONO = 3,
} NV_STEREO_ACTIVE_EYE;
NVAPI_INTERFACE NvAPI_Stereo_SetActiveEye(StereoHandle hStereoHandle, NV_STEREO_ACTIVE_EYE StereoEye);
typedef enum _NV_StereoDriverMode {
  NVAPI_STEREO_DRIVER_MODE_AUTOMATIC = 0,
  NVAPI_STEREO_DRIVER_MODE_DIRECT = 2,
} NV_STEREO_DRIVER_MODE;
NVAPI_INTERFACE NvAPI_Stereo_SetDriverMode(NV_STEREO_DRIVER_MODE mode);
NVAPI_INTERFACE NvAPI_Stereo_GetEyeSeparation(StereoHandle hStereoHandle, float *pSeparation);
NVAPI_INTERFACE NvAPI_Stereo_IsWindowedModeSupported(NvU8 *bSupported);
typedef enum _STEREO_SRC_LAYOUT {
  STEREO_SRC_LAYOUT_LEFT_RIGHT = 0,
  STEREO_SRC_LAYOUT_RIGHT_LEFT = 1,
  STEREO_SRC_LAYOUT_TOP_BOTTOM = 2,
  STEREO_SRC_LAYOUT_BOTTOM_TOP = 3,
  STEREO_SRC_LAYOUT_MONO_MODE = 4,
  STEREO_SRC_LAYOUT_LAST = 5
} STEREO_SRC_LAYOUT;
typedef struct _NVAPI_STEREO_VIDEO_CONTROL {
  NvU32 dwVersion;
  STEREO_SRC_LAYOUT eStereoSrcLayout;
  NvU32 dwClientIdentifier;
  NvU32 dwStereoEnable;
} NVAPI_STEREO_VIDEO_CONTROL_V1;
typedef NVAPI_STEREO_VIDEO_CONTROL_V1 NVAPI_STEREO_VIDEO_CONTROL;
#define NVAPI_STEREO_VIDEO_CONTROL_VER1 MAKE_NVAPI_VERSION(NVAPI_STEREO_VIDEO_CONTROL_V1, 1)
#define NVAPI_STEREO_VIDEO_CONTROL_VER NVAPI_STEREO_VIDEO_CONTROL_VER1
NVAPI_INTERFACE NvAPI_Stereo_SetVideoControl(StereoHandle hStereoHandle,
                                             NVAPI_STEREO_VIDEO_CONTROL *pStereoVideoControl);
typedef struct _NVAPI_STEREO_VIDEO_METADATA {
  NvU32 dwVersion;
  NvU32 dwVideoWidth;
  NvU32 dwVideoHeight;
  NvU64 hSrcLuma;
  NvU64 hDst;
} NVAPI_STEREO_VIDEO_METADATA_V1;
typedef NVAPI_STEREO_VIDEO_METADATA_V1 NVAPI_STEREO_VIDEO_METADATA;
#define NVAPI_STEREO_VIDEO_METADATA_VER1 MAKE_NVAPI_VERSION(NVAPI_STEREO_VIDEO_METADATA_V1, 1)
#define NVAPI_STEREO_VIDEO_METADATA_VER NVAPI_STEREO_VIDEO_METADATA_VER1
NVAPI_INTERFACE NvAPI_Stereo_SetVideoMetadata(StereoHandle hStereoHandle,
                                              NVAPI_STEREO_VIDEO_METADATA *pStereoVideoMetadata);
typedef enum _NVAPI_STEREO_HANDSHAKE_COMMANDS {
  NVAPI_STEREO_HANDSHAKE_CMD_CHALLENGE = 0x01,
  NVAPI_STEREO_HANDSHAKE_CMD_RESPONSE = 0x02,
} NVAPI_STEREO_HANDSHAKE_COMMANDS;
#define NVAPI_STEREO_HANDSHAKE_CHALLENGE_SIZE 16
#define NVAPI_STEREO_HANDSHAKE_RESPONSE_SIZE 20
typedef struct _NVAPI_STEREO_HANDSHAKE_CHALLENGE_PARAMS {
  NvU8 challenge[NVAPI_STEREO_HANDSHAKE_CHALLENGE_SIZE];
} NVAPI_STEREO_HANDSHAKE_CHALLENGE_PARAMS;
typedef struct _NVAPI_STEREO_HANDSHAKE_RESPONSE_PARAMS {
  NvGUID vendorGUID;
  NvU8 response[NVAPI_STEREO_HANDSHAKE_RESPONSE_SIZE];
  NvU32 flags;
} NVAPI_STEREO_HANDSHAKE_RESPONSE_PARAMS;
typedef struct _NVAPI_STEREO_HANDSHAKE_PARAMS {
  NvU32 version;
  NvU32 dwCommand;
  union {
    NVAPI_STEREO_HANDSHAKE_CHALLENGE_PARAMS ChallengeParams;
    NVAPI_STEREO_HANDSHAKE_RESPONSE_PARAMS ResponseParams;
  };
} NVAPI_STEREO_HANDSHAKE_PARAMS_V1;
typedef NVAPI_STEREO_HANDSHAKE_PARAMS_V1 NVAPI_STEREO_HANDSHAKE_PARAMS;
#define NVAPI_STEREO_HANDSHAKE_PARAMS_VER1 MAKE_NVAPI_VERSION(NVAPI_STEREO_HANDSHAKE_PARAMS_V1, 1)
#define NVAPI_STEREO_HANDSHAKE_PARAMS_VER NVAPI_STEREO_HANDSHAKE_PARAMS_VER1
NVAPI_INTERFACE NvAPI_Stereo_AppHandShake(StereoHandle hStereoHandle,
                                          NVAPI_STEREO_HANDSHAKE_PARAMS *pStereoHandshakeParams);
NVAPI_INTERFACE NvAPI_Stereo_HandShake_Trigger_Activation(StereoHandle hStereoHandle);
NVAPI_INTERFACE NvAPI_Stereo_HandShake_Message_Control(StereoHandle hStereoHandle, NvU8 TurnOn);
typedef enum _NVAPI_STEREO_SURFACECREATEMODE {
  NVAPI_STEREO_SURFACECREATEMODE_AUTO,
  NVAPI_STEREO_SURFACECREATEMODE_FORCESTEREO,
  NVAPI_STEREO_SURFACECREATEMODE_FORCEMONO
} NVAPI_STEREO_SURFACECREATEMODE;
NVAPI_INTERFACE NvAPI_Stereo_SetSurfaceCreationMode(__in StereoHandle hStereoHandle,
                                                    __in NVAPI_STEREO_SURFACECREATEMODE creationMode);
NVAPI_INTERFACE NvAPI_Stereo_GetSurfaceCreationMode(__in StereoHandle hStereoHandle,
                                                    __in NVAPI_STEREO_SURFACECREATEMODE *pCreationMode);
NVAPI_INTERFACE NvAPI_Stereo_Debug_WasLastDrawStereoized(__in StereoHandle hStereoHandle, __out NvU8 *pWasStereoized);
NVAPI_INTERFACE NvAPI_Stereo_ForceToScreenDepth(__in StereoHandle hStereoHandle, __in NvU8 bForceToScreenDepth);
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_SetVertexShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                      __in float *pConstantDataMono, __in float *pConstantDataLeft,
                                                      __in float *pConstantDataRight, __in UINT Vector4fCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_SetVertexShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                      __in BOOL *pConstantDataMono, __in BOOL *pConstantDataLeft,
                                                      __in BOOL *pConstantDataRight, __in UINT BoolCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_SetVertexShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                      __in int *pConstantDataMono, __in int *pConstantDataLeft,
                                                      __in int *pConstantDataRight, __in UINT Vector4iCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_GetVertexShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                      __inout float *pConstantDataMono,
                                                      __inout float *pConstantDataLeft,
                                                      __inout float *pConstantDataRight, __in UINT Vector4fCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_GetVertexShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                      __inout BOOL *pConstantDataMono, __inout BOOL *pConstantDataLeft,
                                                      __inout BOOL *pConstantDataRight, __in UINT BoolCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_GetVertexShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                      __inout int *pConstantDataMono, __inout int *pConstantDataLeft,
                                                      __inout int *pConstantDataRight, __in UINT Vector4iCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_SetPixelShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                     __in float *pConstantDataMono, __in float *pConstantDataLeft,
                                                     __in float *pConstantDataRight, __in UINT Vector4fCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_SetPixelShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                     __in BOOL *pConstantDataMono, __in BOOL *pConstantDataLeft,
                                                     __in BOOL *pConstantDataRight, __in UINT BoolCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_SetPixelShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                     __in int *pConstantDataMono, __in int *pConstantDataLeft,
                                                     __in int *pConstantDataRight, __in UINT Vector4iCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_GetPixelShaderConstantF(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                     __inout float *pConstantDataMono, __inout float *pConstantDataLeft,
                                                     __inout float *pConstantDataRight, __in UINT Vector4fCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_GetPixelShaderConstantB(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                     __inout BOOL *pConstantDataMono, __inout BOOL *pConstantDataLeft,
                                                     __inout BOOL *pConstantDataRight, __in UINT BoolCount);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_GetPixelShaderConstantI(__in StereoHandle hStereoHandle, __in UINT StartRegister,
                                                     __inout int *pConstantDataMono, __inout int *pConstantDataLeft,
                                                     __inout int *pConstantDataRight, __in UINT Vector4iCount);
#endif
NVAPI_INTERFACE NvAPI_Stereo_SetDefaultProfile(__in const char *szProfileName);
NVAPI_INTERFACE NvAPI_Stereo_GetDefaultProfile(__in NvU32 cbSizeIn,
                                               __out_bcount_part_opt(cbSizeIn, *pcbSizeOut) char *szProfileName,
                                               __out NvU32 *pcbSizeOut);
typedef enum _STEREO_MODE_ENUM_CONTROL {
  STEREO_MODE_ENUM_DISABLE = 0,
  STEREO_MODE_ENUM_ENBALE = 1,
  STEREO_MODE_ENUM_STATUS = 2,
} STEREO_MODE_ENUM_CONTROL;
typedef struct _NVAPI_STEREO_MODE_ENUM_CONTROL {
  NvU32 version;
  STEREO_MODE_ENUM_CONTROL command;
  NvU32 data;
} NVAPI_STEREO_MODE_ENUM_CONTROL;
#define NVAPI_STEREO_MODE_ENUM_CONTROL_VER MAKE_NVAPI_VERSION(NVAPI_STEREO_MODE_ENUM_CONTROL, 1)
NVAPI_INTERFACE NvAPI_Stereo_ModeEnumControl(__inout NVAPI_STEREO_MODE_ENUM_CONTROL *pStereoModeEnumControl);
NVAPI_INTERFACE NvAPI_Stereo_IsAccessoryDisplayEnabled(__out NvU32 *IsAccessoryDisplayEnabled);
typedef enum _STEREO_DONGLE_CONTROL_COMMAND {
  STEREO_DONGLE_COMMAND_POLL = 1,
  STEREO_DONGLE_COMMAND_SUPPORTED = 2,
  STEREO_DONGLE_COMMAND_SET_TIMING = 3,
  STEREO_DONGLE_COMMAND_ACTIVATE = 4,
  STEREO_DONGLE_COMMAND_DEACTIVATE = 5,
  STEREO_DONGLE_COMMAND_AEGIS_SURROUND = 6,
  STEREO_DONGLE_COMMAND_GET_ACTIVE_COUNT = 7,
  STEREO_DONGLE_COMMAND_SUPPORTED_DEVINDEPENDENT = 8,
} STEREO_DONGLE_CONTROL_COMMAND;
typedef struct _NVAPI_STEREO_DONGLE_CONTROL {
  NvU32 version;
  STEREO_DONGLE_CONTROL_COMMAND command;
  NvU32 data;
  NvU32 result;
} NVAPI_STEREO_DONGLE_CONTROL_V1;
typedef NVAPI_STEREO_DONGLE_CONTROL_V1 NVAPI_STEREO_DONGLE_CONTROL;
#define NVAPI_STEREO_DONGLE_CONTROL_VER1 MAKE_NVAPI_VERSION(NVAPI_STEREO_DONGLE_CONTROL_V1, 1)
#define NVAPI_STEREO_DONGLE_CONTROL_VER NVAPI_STEREO_DONGLE_CONTROL_VER1
NVAPI_INTERFACE NvAPI_Stereo_DongleControl(__in NvDisplayHandle hNvDisplay,
                                           __inout NVAPI_STEREO_DONGLE_CONTROL *pStereoDongleControl);
typedef struct _NVAPI_STEREO_DIAG_KMD {
  NvU32 version;
  NvU32 ulDongleActiveCount;
  NvU32 ulStereoConfig[NV_MAX_HEADS];
} NVAPI_STEREO_DIAG_KMD;
#define NVAPI_STEREO_DIAG_KMD_VER MAKE_NVAPI_VERSION(NVAPI_STEREO_DIAG_KMD, 1)
typedef struct _NVAPI_STEREO_DIAG {
  NvU32 version;
  union {
    struct _NV_STEREO_API_DIAG_UMD *pUMDData;
    NvU64 pad0;
  };
  union {
    NVAPI_STEREO_DIAG_KMD *pKMDData;
    NvU64 pad1;
  };
} NVAPI_STEREO_DIAG;
#define NVAPI_STEREO_DIAG_VER MAKE_NVAPI_VERSION(NVAPI_STEREO_DIAG, 1)
NVAPI_INTERFACE NvAPI_Stereo_GetStereoDiag(__in StereoHandle hStereoHandle, __in NVAPI_STEREO_DIAG *pDiag);
NVAPI_INTERFACE NvAPI_Stereo_Is3DCursorSupported(__in StereoHandle stereoHandle, __out NvU8 *bSupported);
NVAPI_INTERFACE NvAPI_Stereo_GetCursorSeparation(__in StereoHandle stereoHandle, __out float *pSeparationPercentage);
NVAPI_INTERFACE NvAPI_Stereo_SetCursorSeparation(__in StereoHandle stereoHandle, __in float newSeparationPercentage);
#define NVAPI_STEREO_QUADBUFFERED_API_VERSION 0x2
typedef enum _NV_StereoSwapChainMode {
  NVAPI_STEREO_SWAPCHAIN_DEFAULT = 0,
  NVAPI_STEREO_SWAPCHAIN_STEREO = 1,
  NVAPI_STEREO_SWAPCHAIN_MONO = 2,
} NV_STEREO_SWAPCHAIN_MODE;
#if defined(__d3d10_h__) || defined(__d3d10_1_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_D3D1x_CreateSwapChain(StereoHandle hStereoHandle, DXGI_SWAP_CHAIN_DESC *pDesc,
                                            IDXGISwapChain **ppSwapChain, NV_STEREO_SWAPCHAIN_MODE mode);
#endif
#if defined(_D3D9_H_)
NVAPI_INTERFACE NvAPI_D3D9_CreateSwapChain(StereoHandle hStereoHandle, D3DPRESENT_PARAMETERS *pPresentationParameters,
                                           IDirect3DSwapChain9 **ppSwapChain, NV_STEREO_SWAPCHAIN_MODE mode);
#endif
#if defined(_D3D9_H_) || defined(__d3d10_h__) || defined(__d3d11_h__)
NVAPI_INTERFACE NvAPI_Stereo_SetProfileName(__in StereoHandle hStereoHandle, __in NvAPI_String szProfileName,
                                            __in IUnknown *pDevice, __in unsigned int uiFlags);
#endif
NVAPI_INTERFACE NvAPI_Stereo_IsDisplayAegisDTType(__in NvU32 ulPanelId, __out NvU8 *bAegisDTDetected);
#define STEREO_DONGLE_DEVICE_STATUS 0x00000009
NVAPI_INTERFACE NvAPI_Stereo_Dongle_Status(__in NvU32 displayId, __in NvU8 statusParam, __out NvU32 *pResult);
#ifndef NV_VIDEO_POSTPROCESSING_DEFINE
#define NV_VIDEO_POSTPROCESSING_DEFINE
typedef struct {
  NvU32 value;
  NvU32 min;
  NvU32 max;
} NV_VIDEO_POSTPROCESSING_RANGE_VALUE;
typedef enum {
  NV_VIDEO_POSTPROCESSING_CAPS_FEATURE_SUPPORTED = 0x00,
  NV_VIDEO_POSTPROCESSING_CAPS_FEATURE_NOT_SUPPORTED = 0x01,
} NV_VIDEO_POSTPROCESSING_CAPS;
typedef enum {
  NV_VIDEO_CODEC_TYPE_NONE = 0,
  NV_VIDEO_CODEC_TYPE_H264 = 4,
  NV_VIDEO_CODEC_TYPE_HEVC = 5,
} NV_VIDEO_CODEC_TYPE;
typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE {
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE_DISABLE = 0x00,
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE_ENABLE = 0x01,
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE;
typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG {
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_BOB = 0x01,
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_WEAVE = 0x02,
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_SIMPLE_ADAPTIVE = 0x03,
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_GRADIENT_SIMPLE = 0x04,
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_GRADIENT_FULL = 0x05,
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG_ADVANCED = 0x06,
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG;
typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE {
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_DEFAULT = 0x01,
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_SIMPLE = 0x02,
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE_DIR_SPATIAL_ADVANCED = 0x03,
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE;
typedef enum _NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC {
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC;
typedef struct {
  NV_VIDEO_POSTPROCESSING_CAPS caps;
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_FEATURE feature;
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ALG alg;
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_ENHANCE enhance;
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_MISC misc;
} NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO;
typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_FEATURE {
  NV_VIDEO_POSTPROCESSING_SCALING_FEATURE_DISABLE = 0x00,
  NV_VIDEO_POSTPROCESSING_SCALING_FEATURE_ENABLE = 0x01,
} NV_VIDEO_POSTPROCESSING_SCALING_FEATURE;
typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_ALG {
  NV_VIDEO_POSTPROCESSING_SCALING_ALG_DEFAULT = 0x01,
  NV_VIDEO_POSTPROCESSING_SCALING_ALG_4x4FILTER = 0x02,
} NV_VIDEO_POSTPROCESSING_SCALING_ALG;
typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE {
  NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE;
typedef enum _NV_VIDEO_POSTPROCESSING_SCALING_MISC {
  NV_VIDEO_POSTPROCESSING_SCALING_MISC_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_SCALING_MISC;
typedef struct {
  NV_VIDEO_POSTPROCESSING_CAPS caps;
  NV_VIDEO_POSTPROCESSING_SCALING_FEATURE feature;
  NV_VIDEO_POSTPROCESSING_SCALING_ALG alg;
  NV_VIDEO_POSTPROCESSING_SCALING_ENHANCE enhance;
  NV_VIDEO_POSTPROCESSING_SCALING_MISC misc;
} NV_VIDEO_POSTPROCESSING_SCALING_INFO;
typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE {
  NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE_DISABLE = 0x00,
  NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE_ENABLE = 0x01,
} NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE;
typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_ALG {
  NV_VIDEO_POSTPROCESSING_CADENCE_ALG_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_CADENCE_ALG;
typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE {
  NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE_NONE = 0x00,
  NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE_VOF = 0x01,
} NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE;
typedef enum _NV_VIDEO_POSTPROCESSING_CADENCE_MISC {
  NV_VIDEO_POSTPROCESSING_CADENCE_MISC_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_CADENCE_MISC;
typedef struct {
  NV_VIDEO_POSTPROCESSING_CAPS caps;
  NV_VIDEO_POSTPROCESSING_CADENCE_FEATURE feature;
  NV_VIDEO_POSTPROCESSING_CADENCE_ALG alg;
  NV_VIDEO_POSTPROCESSING_CADENCE_ENHANCE enhance;
  NV_VIDEO_POSTPROCESSING_CADENCE_MISC misc;
} NV_VIDEO_POSTPROCESSING_CADENCE_INFO;
typedef enum _NV_VIDEO_POSTPROCESSING_EE_FEATURE {
  NV_VIDEO_POSTPROCESSING_EE_FEATURE_DISABLE = 0x00,
  NV_VIDEO_POSTPROCESSING_EE_FEATURE_ENABLE = 0x01,
} NV_VIDEO_POSTPROCESSING_EE_FEATURE;
typedef enum _NV_VIDEO_POSTPROCESSING_EE_ALG {
  NV_VIDEO_POSTPROCESSING_EE_ALG_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_EE_ALG;
typedef enum _NV_VIDEO_POSTPROCESSING_EE_ENHANCE {
  NV_VIDEO_POSTPROCESSING_EE_ENHANCE_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_EE_ENHANCE;
typedef enum _NV_VIDEO_POSTPROCESSING_EE_MISC {
  NV_VIDEO_POSTPROCESSING_EE_MISC_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_EE_MISC;
typedef struct {
  NV_VIDEO_POSTPROCESSING_CAPS caps;
  NV_VIDEO_POSTPROCESSING_EE_FEATURE feature;
  NV_VIDEO_POSTPROCESSING_EE_ALG alg;
  NV_VIDEO_POSTPROCESSING_EE_ENHANCE enhance;
  NV_VIDEO_POSTPROCESSING_EE_MISC misc;
  NV_VIDEO_POSTPROCESSING_RANGE_VALUE rangeValue;
} NV_VIDEO_POSTPROCESSING_EE_INFO;
typedef enum _NV_VIDEO_POSTPROCESSING_NR_FEATURE {
  NV_VIDEO_POSTPROCESSING_NR_FEATURE_DISABLE = 0x00,
  NV_VIDEO_POSTPROCESSING_NR_FEATURE_ENABLE = 0x01,
} NV_VIDEO_POSTPROCESSING_NR_FEATURE;
typedef enum _NV_VIDEO_POSTPROCESSING_NR_ALG {
  NV_VIDEO_POSTPROCESSING_NR_ALG_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_NR_ALG;
typedef enum _NV_VIDEO_POSTPROCESSING_NR_ENHANCE {
  NV_VIDEO_POSTPROCESSING_NR_ENHANCE_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_NR_ENHANCE;
typedef enum _NV_VIDEO_POSTPROCESSING_NR_MISC {
  NV_VIDEO_POSTPROCESSING_NR_MISC_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_NR_MISC;
typedef struct {
  NV_VIDEO_POSTPROCESSING_CAPS caps;
  NV_VIDEO_POSTPROCESSING_NR_FEATURE feature;
  NV_VIDEO_POSTPROCESSING_NR_ALG alg;
  NV_VIDEO_POSTPROCESSING_NR_ENHANCE enhance;
  NV_VIDEO_POSTPROCESSING_NR_MISC misc;
  NV_VIDEO_POSTPROCESSING_RANGE_VALUE rangeValue;
} NV_VIDEO_POSTPROCESSING_NR_INFO;
typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE {
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE_DISABLE = 0x00,
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE_ENABLE = 0x01,
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE;
typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG {
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG;
typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE {
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE;
typedef enum _NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC {
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC_NONE = 0x00,
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC;
typedef struct {
  NV_VIDEO_POSTPROCESSING_CAPS caps;
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_FEATURE feature;
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_ALG alg;
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_ENHANCE enhance;
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_MISC misc;
} NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO;
typedef struct {
  NvU32 version;
  NV_VIDEO_POSTPROCESSING_DEINTERLACE_INFO deinterlaceInfo;
  NV_VIDEO_POSTPROCESSING_SCALING_INFO scalingInfo;
  NV_VIDEO_POSTPROCESSING_CADENCE_INFO cadenceInfo;
  NV_VIDEO_POSTPROCESSING_NR_INFO nrInfo;
  NV_VIDEO_POSTPROCESSING_EE_INFO eeInfo;
  NV_VIDEO_POSTPROCESSING_OVERDRIVE_INFO overDriveInfo;
} NV_VIDEO_POSTPROCESSING_CTRL_INFO;
#define NV_VIDEO_POSTPROCESSING_CTRL_NVAPI_VER MAKE_NVAPI_VERSION(NV_VIDEO_POSTPROCESSING_CTRL_INFO, 1)
typedef struct {
  NvU32 value;
  NvU32 min;
  NvU32 max;
} NV_VIDEO_COLORCONTROL_RANGE_VALUE;
typedef enum {
  NV_VIDEO_COLORCONTROL_CAPS_FEATURE_SUPPORTED = 0x00,
  NV_VIDEO_COLORCONTROL_CAPS_FEATURE_NOT_SUPPORTED = 0x01,
} NV_VIDEO_COLORCONTROL_CAPS;
typedef enum _NV_VIDEO_COLORCONTROL_FEATURE {
  NV_VIDEO_COLORCONTROL_FEATURE_DISABLE = 0x00,
  NV_VIDEO_COLORCONTROL_FEATURE_ENABLE = 0x01,
} NV_VIDEO_COLORCONTROL_FEATURE;
typedef enum _NV_VIDEO_COLORTEMP_FEATURE {
  NV_VIDEO_COLORTEMP_FEATURE_DISABLE = 0x00,
  NV_VIDEO_COLORTEMP_FEATURE_ENABLE = 0x01,
} NV_VIDEO_COLORTEMP_FEATURE;
typedef enum _NV_VIDEO_GAMMA_FEATURE {
  NV_VIDEO_GAMMA_FEATURE_DISABLE = 0x00,
  NV_VIDEO_GAMMA_FEATURE_ENABLE_Y = 0x01,
  NV_VIDEO_GAMMA_FEATURE_ENABLE_RGB = 0x02,
} NV_VIDEO_GAMMA_FEATURE;
typedef enum _NV_VIDEO_COLOR_CONTROL_SETTING {
  NV_VIDEO_COLORCONTROL_SETTING_OVERRIDE_APP_CTRLS = 0x00,
  NV_VIDEO_COLORCONTROL_SETTING_USE_APP_CTRLS = 0x01,
} NV_VIDEO_COLORCONTROL_SETTING;
typedef struct {
  NvU32 version;
  NV_VIDEO_COLORCONTROL_SETTING colorControlSettings;
  NV_VIDEO_COLORCONTROL_CAPS colorCaps;
  NV_VIDEO_COLORCONTROL_FEATURE colorFeature;
  NV_VIDEO_COLORCONTROL_RANGE_VALUE brightnessRangeValue;
  NV_VIDEO_COLORCONTROL_RANGE_VALUE contrastRangeValue;
  NV_VIDEO_COLORCONTROL_RANGE_VALUE hueRangeValue;
  NV_VIDEO_COLORCONTROL_RANGE_VALUE saturationRangeValue;
  NV_VIDEO_COLORCONTROL_CAPS colorTempCaps;
  NV_VIDEO_COLORTEMP_FEATURE colorTempFeature;
  NV_VIDEO_COLORCONTROL_RANGE_VALUE colorTempRangeValue;
  NV_VIDEO_COLORCONTROL_CAPS gammaCaps;
  NV_VIDEO_GAMMA_FEATURE gammaFeature;
  NV_VIDEO_COLORCONTROL_RANGE_VALUE yGammaRangeValue;
  NV_VIDEO_COLORCONTROL_RANGE_VALUE rgbGammaRRangeValue;
  NV_VIDEO_COLORCONTROL_RANGE_VALUE rgbGammaGRangeValue;
  NV_VIDEO_COLORCONTROL_RANGE_VALUE rgbGammaBRangeValue;
} NV_VIDEO_COLORCONTROL_INFO;
#define NV_VIDEO_COLORCONTROL_NVAPI_VER MAKE_NVAPI_VERSION(NV_VIDEO_COLORCONTROL_INFO, 1)
#endif
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_Video_PostProcessing_GetDefault(NvDisplayHandle hNvDisplay,
                                          NV_VIDEO_POSTPROCESSING_CTRL_INFO *pVideoPPCtrlInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_Video_PostProcessing_Get(NvDisplayHandle hNvDisplay, NV_VIDEO_POSTPROCESSING_CTRL_INFO *pVideoPPCtrlInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 450.") NVAPI_INTERFACE
    NvAPI_Video_PostProcessing_Set(NvDisplayHandle hNvDisplay, NV_VIDEO_POSTPROCESSING_CTRL_INFO *pVideoPPCtrlInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_Video_ColorControl_GetDefault(NvDisplayHandle hNvDisplay, NV_VIDEO_COLORCONTROL_INFO *pVideoColorCtrlInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_Video_ColorControl_Get(NvDisplayHandle hNvDisplay, NV_VIDEO_COLORCONTROL_INFO *pVideoColorCtrlInfo);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 455.") NVAPI_INTERFACE
    NvAPI_Video_ColorControl_Set(NvDisplayHandle hNvDisplay, NV_VIDEO_COLORCONTROL_INFO *pVideoColorCtrlInfo);
#define NV_EVO_VIDEO_LUT_VER MAKE_NVAPI_VERSION(NV_EVO_VIDEO_LUT, 1)
typedef struct {
  NvU16 Red;
  NvU16 Green;
  NvU16 Blue;
  NvU16 Unused;
} NVAPI_EVO_VIDEO_CLUTDATA;
#define EVO_LUT_ENTRIES 257
typedef NVAPI_EVO_VIDEO_CLUTDATA NVAPI_EVO_VIDEO_LUT[EVO_LUT_ENTRIES];
typedef struct {
  NvU32 version;
  NVAPI_EVO_VIDEO_LUT lut;
} NV_EVO_VIDEO_LUT;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 515.") NVAPI_INTERFACE
    NvAPI_Video_EvoOverlayLUT_Get(NvDisplayHandle hNvDisplay, NV_EVO_VIDEO_LUT *pLut);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 515.") NVAPI_INTERFACE
    NvAPI_Video_EvoOverlayLUT_Set(NvDisplayHandle hNvDisplay, NV_EVO_VIDEO_LUT *pLut);
#if defined(_D3D9_H_) && defined(__cplusplus)
typedef enum _NVAPI_VIDEO_BRINGUP_ACTION {
  NVAPI_VIDEO_BRINGUP_ACTION_RUN_TEST = 0x01,
  NVAPI_VIDEO_BRINGUP_ACTION_CHECK_RESULT = 0x02,
  NVAPI_VIDEO_BRINGUP_ACTION_INIT_TRACE_PLAYER = 0x03,
  NVAPI_VIDEO_BRINGUP_ACTION_SETUP_BUFFERS = 0x04,
  NVAPI_VIDEO_BRINGUP_ACTION_SETUP_EXECUTE = 0x05,
  NVAPI_VIDEO_BRINGUP_ACTION_DESTROY_TRACE = 0x06,
} NVAPI_VIDEO_BRINGUP_ACTION;
typedef enum _NVAPI_VIDEO_BRINGUP_TEST {
  NVAPI_VIDEO_BRINGUP_TEST_TCIPHER_BASIC = 0x01,
  NVAPI_VIDEO_BRINGUP_TEST_COMPUTE_MULTI = 0x02,
  NVAPI_VIDEO_BRINGUP_TEST_SEC_BASIC = 0x03,
  NVAPI_VIDEO_BRINGUP_TEST_SEC_EXECUTE = 0x04,
  NVAPI_VIDEO_BRINGUP_TEST_CE_EXECUTE = 0x05,
} NVAPI_VIDEO_BRINGUP_TEST;
typedef struct _NVAPI_VIDEO_BRINGUP_PARAMS {
  NvU32 version;
  NVAPI_VIDEO_BRINGUP_ACTION action;
  NVAPI_VIDEO_BRINGUP_TEST test;
  NvU32 params[4];
  void *pOutput;
  NvU32 dwOutputSize;
} NVAPI_VIDEO_BRINGUP_PARAMS;
#define NVAPI_VIDEO_BRINGUP_PARAMS_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_BRINGUP_PARAMS, 1)
NVAPI_INTERFACE NvAPI_Video_Bringup(IDirect3DDevice9 *pDev, NVAPI_VIDEO_BRINGUP_PARAMS *pVideoBringupParams);
#endif
typedef struct {
  NvU32 version;
  NvU32 ucID;
  NvU32 ucVersion;
  char szMicrocodeDescription[40];
  NvU32 ucCRC;
  NvU32 unCompressedSize;
  NvU32 flags;
  NvU32 microcodeFormat;
  NvU32 compSize;
  union {
    NvU8 *pImg;
    NvU64 pImgpad;
  };
} NV_MICROCODE_INFO;
#define NV_MICROCODE_INFO_VER MAKE_NVAPI_VERSION(NV_MICROCODE_INFO, 1)
typedef struct _NV_MICROCODE_REPOS_INDEX {
  NvU32 version;
  NV_MICROCODE_INFO info;
  NvU32 offset;
  NvU32 loadedDataSize;
  NvS32 indexStatus;
  union {
    struct _NV_MICROCODE_REPOS_INDEX *pNext;
    NvU64 pImgpad;
  };
} NV_MICROCODE_REPOS_INDEX;
#define NV_MICROCODE_REPOS_INDEX_VER MAKE_NVAPI_VERSION(NV_MICROCODE_REPOS_INDEX, 1)
NVAPI_INTERFACE NvAPI_LoadMicrocode(NvDisplayHandle hNvDisplay, NV_MICROCODE_INFO *pMicrocodeInfo);
NVAPI_INTERFACE NvAPI_GetLoadedMicrocodePrograms(NvDisplayHandle hNvDisplay,
                                                 NV_MICROCODE_REPOS_INDEX **pMicrocodeReposIndex);
NVAPI_INTERFACE NvAPI_GetVideoPerformanceData(char *pData, NvU32 dataSize);
NVAPI_INTERFACE NvAPI_SetVideoPerformanceDataCollectionEnabled(NvU32 bEnabled);
NVAPI_INTERFACE NvAPI_GetVideoPerformanceDataCollectionEnabled(NvU32 *pbEnabled);
typedef enum _NV_VIDEO_PMMC_ACTION {
  NV_VIDEO_PMMC_DELETE = 0,
  NV_VIDEO_PMMC_START,
  NV_VIDEO_PMMC_STOP,
} NV_VIDEO_PMMC_ACTION;
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_Video_PmmC_SetMode(NV_VIDEO_PMMC_ACTION modeAction);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_Video_PmmC_GetReport(NvU32 bytesAllocd, NvU32 *pBytesNeeded, char *pReport);
typedef struct {
  NvU32 version;
  NvU32 dwControl;
  NvU32 dwTrig0Sel;
  NvU32 dwTrig1Sel;
  NvU32 dwEventSel;
  NvU32 dwSampleSel;
  NvU32 dwSampleOp;
  NvU32 engine[12];
  NvU32 sigtype[12];
} NV_VIDEO_PMMC_DOMAIN_CONTROL;
#define NV_VIDEO_PMMC_DOMAIN_CONTROL_VER MAKE_NVAPI_VERSION(NV_VIDEO_PMMC_DOMAIN_CONTROL, 1)
typedef struct {
  NvU32 version;
  NvU32 bEnable;
  NvU32 dwMaxCaptureRecords;
  NvU32 dwMaxReportRecords;
  NV_VIDEO_PMMC_DOMAIN_CONTROL controlSetup;
} NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP;
#define NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP_VER MAKE_NVAPI_VERSION(NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_Video_Pmmc_SetDomainConfig(NvU32 domain, NV_VIDEO_PMMC_DOMAIN_CONTROL_SETUP *setupData);
typedef enum _NVAPI_VIDEO_STATE_DEVICE_KIND {
  NVAPI_VIDEO_DEVICE_KIND_NONE = -1,
  NVAPI_VIDEO_DEVICE_GLOBAL_DEFAULT,
  NVAPI_VIDEO_DEVICE_MASK,
  NVAPI_VIDEO_DEVICE_EDID,
  NVAPI_VIDEO_DEVICE_CONNECTOR_TYPE,
  NVAPI_VIDEO_DEVICE_KIND_LAST
} NVAPI_VIDEO_STATE_DEVICE_KIND;
#define VIDEO_DEVICE_DESCRIPTION_LENGTH 40
#define VIDEO_DEVICE_REG_PREFIX_LENGTH 32
typedef struct _NVAPI_VIDEO_GET_DEVICE_INFO {
  NvU32 version;
  NvU32 deviceIndex;
  NvU32 deviceType;
  NvU32 deviceID;
  NvU8 deviceDescription[VIDEO_DEVICE_DESCRIPTION_LENGTH];
  NvU8 deviceRegistryPrefix[VIDEO_DEVICE_REG_PREFIX_LENGTH];
  NvU32 bDefaultGammaCompIdx;
  NvU8 reserved[4];
} NVAPI_VIDEO_GET_DEVICE_INFO;
#define NVAPI_VIDEO_GET_DEVICE_INFO_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_GET_DEVICE_INFO, 1)
NVAPI_INTERFACE NvAPI_GetVideoDeviceCount(NvDisplayHandle hNvDisplay, NvU32 *pParms);
NVAPI_INTERFACE NvAPI_GetVideoDeviceInfo(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_GET_DEVICE_INFO *pParms);
typedef enum _NVAPI_ACTIVE_VIDEO_DEVICE {
  NVAPI_ACTIVE_VIDEO_DEVICE_USER_CHOICE = 0,
  NVAPI_ACTIVE_VIDEO_DEVICE_PER_DISPLAY,
  NVAPI_ACTIVE_VIDEO_DEVICE_LAST
} NVAPI_ACTIVE_VIDEO_DEVICE;
typedef struct _NVAPI_ACTIVE_VIDEO_DEVICE_INFO {
  NvU32 version;
  NvU32 activeDevice;
  NvU32 deviceIndex;
  NvU32 reserved[5];
} NVAPI_ACTIVE_VIDEO_DEVICE_INFO;
#define NVAPI_ACTIVE_VIDEO_DEVICE_INFO_VER MAKE_NVAPI_VERSION(NVAPI_ACTIVE_VIDEO_DEVICE_INFO, 1)
NVAPI_INTERFACE NvAPI_GetActiveVideoDevice(NvDisplayHandle hNvDisplay,
                                           NVAPI_ACTIVE_VIDEO_DEVICE_INFO *pActiveVideoDevice);
NVAPI_INTERFACE NvAPI_SetActiveVideoDevice(NvDisplayHandle hNvDisplay,
                                           NVAPI_ACTIVE_VIDEO_DEVICE_INFO *pActiveVideoDevice);
typedef struct _NVAPI_GET_VIDEO_STATE_COMPONENT_EX {
  NvU32 version;
  NvU32 componentID;
  NvU32 deviceIndex;
  NvU32 bIsSupported : 1;
  NvU32 bIsHigherPriorityThanApp : 1;
  NvU32 bOverrideAppDefault : 1;
  NvU32 reserved1 : 29;
  NvU32 isEnabled;
  NvU32 defaultEnabledState;
  NvU32 minValue;
  NvU32 maxValue;
  NvU32 totalSteps;
  NvU32 defaultValue;
  NvU32 unityValue;
  NvU32 currentValueActive;
  NvU64 defaultAlgo;
  NvU64 currentAlgoActive;
  NvU32 appValueInUse : 1;
  NvU32 appAlgoInUse : 1;
  NvU32 reserved2 : 30;
  NvU32 appValue;
  NvU64 appAlgo;
  NvU64 lastAlgoSet;
  NvU32 lastValueSet;
  NvU32 reserved3;
  NvU64 reserved4[4];
} NVAPI_GET_VIDEO_STATE_COMPONENT_EX;
#define NVAPI_GET_VIDEO_STATE_COMPONENT_EX_VER MAKE_NVAPI_VERSION(NVAPI_GET_VIDEO_STATE_COMPONENT_EX, 1)
typedef struct _NVAPI_SET_VIDEO_STATE_COMPONENT_EX {
  NvU32 version;
  NvU32 componentID;
  NvU32 deviceIndex;
  NvU32 bIsTopPriority : 1;
  NvU32 reserved1 : 31;
  NvU32 enable;
  NvU32 setToValue;
  NvU64 setToAlgo;
  NvU32 retStatus;
  NvU32 reserved2;
  NvU64 reserved3[3];
} NVAPI_SET_VIDEO_STATE_COMPONENT_EX;
#define NVAPI_SET_VIDEO_STATE_COMPONENT_EX_VER MAKE_NVAPI_VERSION(NVAPI_SET_VIDEO_STATE_COMPONENT_EX, 1)
NVAPI_INTERFACE NvAPI_GetVideoStateEx(NvDisplayHandle hNvDisplay, NVAPI_GET_VIDEO_STATE_COMPONENT_EX *pParms);
NVAPI_INTERFACE NvAPI_SetVideoStateEx(NvDisplayHandle hNvDisplay, NVAPI_SET_VIDEO_STATE_COMPONENT_EX *pParms);
typedef enum _NVAPI_VIDEO_FORMAT_LAYOUT {
  NVAPI_VIDEO_FMT_NONE = 0,
  NVAPI_VIDEO_FMT_INTERLACED,
  NVAPI_VIDEO_FMT_PROGRESSIVE,
  NVAPI_VIDEO_FMT_FIELD,
  NVAPI_VIDEO_FMT_LAST
} NVAPI_VIDEO_FORMAT_LAYOUT;
#define APP_NAME_LENGTH 64
typedef struct _NVAPI_VIDEO_GET_STREAM_INFO {
  NvU32 version;
  NvU32 streamIndex;
  NvU32 deviceIndex;
  NvU32 processID;
  NvU8 processName[APP_NAME_LENGTH];
  NvU32 streamSrcWidth;
  NvU32 streamSrcHeight;
  NvU32 streamSrcFormat;
  NvU32 streamFormatLayout;
  NvU32 streamSrcColorSpace;
  NvU32 streamDstWidth;
  NvU32 streamDstHeight;
  NvU32 streamDstFormat;
  NvU32 streamDstColorSpace;
  NvU32 streamDstColorRange;
  double streamFreq;
  double streamFreqDetected;
  double streamFreqPlayback;
  NvU32 curPState;
  NvU32 curPstateTuningAction;
  NvU64 lastUpdateTime;
  NvU64 reserved;
} NVAPI_VIDEO_GET_STREAM_INFO;
#define NVAPI_VIDEO_GET_STREAM_INFO_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_GET_STREAM_INFO, 1)
NVAPI_INTERFACE NvAPI_GetVideoStreamCount(NvDisplayHandle hNvDisplay, NvU32 *pParms);
NVAPI_INTERFACE NvAPI_GetVideoStreamInfo(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_GET_STREAM_INFO *pParms);
NVAPI_INTERFACE NvAPI_GPU_SetVidPnInfo(NvPhysicalGpuHandle hPhysicalGpu);
#ifndef NV_VIDEO_COMPONENTS_DEFINE
#define NV_VIDEO_COMPONENTS_DEFINE
typedef enum _NVAPI_VIDEO_STATE_COMPONENT_ID {
  NVAPI_VIDEO_STATE_COMPONENT_ID_NONE = -1,
  NVAPI_VIDEO_STATE_COMPONENT_BRIGHTNESS,
  NVAPI_VIDEO_STATE_COMPONENT_CONTRAST,
  NVAPI_VIDEO_STATE_COMPONENT_HUE,
  NVAPI_VIDEO_STATE_COMPONENT_SATURATION,
  NVAPI_VIDEO_STATE_COMPONENT_COLORTEMP,
  NVAPI_VIDEO_STATE_COMPONENT_Y_GAMMA,
  NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_R,
  NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_G,
  NVAPI_VIDEO_STATE_COMPONENT_RGB_GAMMA_B,
  NVAPI_VIDEO_STATE_COMPONENT_COLOR_SPACE,
  NVAPI_VIDEO_STATE_COMPONENT_COLOR_RANGE,
  NVAPI_VIDEO_STATE_COMPONENT_PLAYBACK_PROFILE,
  NVAPI_VIDEO_STATE_COMPONENT_DEINTERLACE,
  NVAPI_VIDEO_STATE_COMPONENT_SCALING,
  NVAPI_VIDEO_STATE_COMPONENT_CADENCE,
  NVAPI_VIDEO_STATE_COMPONENT_NOISE_REDUCE,
  NVAPI_VIDEO_STATE_COMPONENT_EDGE_ENHANCE,
  NVAPI_VIDEO_STATE_COMPONENT_OVERDRIVE,
  NVAPI_VIDEO_STATE_COMPONENT_SPLITSCREEN,
  NVAPI_VIDEO_STATE_COMPONENT_DEBLOCKING,
  NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST,
  NVAPI_VIDEO_STATE_COMPONENT_GREEN_STRETCH,
  NVAPI_VIDEO_STATE_COMPONENT_BLUE_STRETCH,
  NVAPI_VIDEO_STATE_COMPONENT_SKIN_TONE_CORRECTION,
  NVAPI_VIDEO_STATE_COMPONENT_GAMUT_REMAPPING,
  NVAPI_VIDEO_STATE_COMPONENT_2DTO3D,
  NVAPI_VIDEO_STATE_COMPONENT_3D_ANALYSIS,
  NVAPI_VIDEO_STATE_COMPONENT_FRC,
  NVAPI_VIDEO_STATE_COMPONENT_BEN,
  NVAPI_VIDEO_STATE_COMPONENT_ID_LAST,
} NVAPI_VIDEO_STATE_COMPONENT_ID;
#define NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONSTRAST NVAPI_VIDEO_STATE_COMPONENT_DYNAMIC_CONTRAST
#define VIDEO_COMP_ALGO_CUSTOM_BASE 64
typedef enum _NVAPI_VIDEO_COMPONENT_ALGORITHM {
  VIDEO_COMP_ALGO_COLOR_SPACE_601 = 0,
  VIDEO_COMP_ALGO_COLOR_SPACE_709 = 1,
  VIDEO_COMP_ALGO_COLOR_SPACE_CUSTOM_04 = VIDEO_COMP_ALGO_CUSTOM_BASE + 4,
  VIDEO_COMP_ALGO_COLOR_RANGE_STD = 0,
  VIDEO_COMP_ALGO_COLOR_RANGE_EXT = 1,
  VIDEO_COMP_ALGO_PLAYBACK_PROFILE_NONE = 0,
  VIDEO_COMP_ALGO_PLAYBACK_PROFILE_ADOBE_FLASH_9 = 1,
  VIDEO_COMP_ALGO_DEINTERLACE_BOB = 0,
  VIDEO_COMP_ALGO_DEINTERLACE_WEAVE = 1,
  VIDEO_COMP_ALGO_DEINTERLACE_SIMPLE_ADAPTIVE = 2,
  VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_SIMPLE = 3,
  VIDEO_COMP_ALGO_DEINTERLACE_GRADIENT_FULL = 4,
  VIDEO_COMP_ALGO_DEINTERLACE_ADAPTIVE_FOUR_FIELD = 5,
  VIDEO_COMP_ALGO_DEINTERLACE_DIR_SPATIAL = 6,
  VIDEO_COMP_ALGO_DEINTERLACE_ADVANCED = 7,
  VIDEO_COMP_ALGO_DEINTERLACE_GPU_CAPABLE = 8,
  VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_DEINTERLACE_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_SCALING_ALG_SIMPLE = 0,
  VIDEO_COMP_ALGO_SCALING_ALG_4x4FILTER = 1,
  VIDEO_COMP_ALGO_SCALING_ALG_8x8FILTER = 2,
  VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_SCALING_ALG_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_CADENCE_NONE = 0,
  VIDEO_COMP_ALGO_CADENCE_SIMPLE = 1,
  VIDEO_COMP_ALGO_CADENCE_VOF = 2,
  VIDEO_COMP_ALGO_CADENCE_COMPUTE = 3,
  VIDEO_COMP_ALGO_CADENCE_GPU_CAPABLE = 4,
  VIDEO_COMP_ALGO_NOISE_REDUCE_PUREVIDEO = 0,
  VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_NOISE_REDUCE_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_EDGE_ENHANCE_PUREVIDEO = 0,
  VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_EDGE_ENHANCE_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_GAMUT_REMAPPING_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_OVERDRIVE_SIMPLE = 0,
  VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_NORMAL = 0,
  VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_REPEATED = 1,
  VIDEO_COMP_ALGO_SPLITSCREEN_TYPE_ON_MIRROR = 2,
  VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_NONE = 0,
  VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_LOW = 1,
  VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_MEDIUM = 2,
  VIDEO_COMP_ALGO_DYNAMIC_CONTRAST_PRESET_HIGH = 3,
  VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_NONE = 0,
  VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_LOW = 1,
  VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_MEDIUM = 2,
  VIDEO_COMP_ALGO_GREEN_STRETCH_PRESET_HIGH = 3,
  VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_NONE = 0,
  VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_LOW = 1,
  VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_MEDIUM = 2,
  VIDEO_COMP_ALGO_BLUE_STRETCH_PRESET_HIGH = 3,
  VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_NONE = 0,
  VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_SQUEEZE = 1,
  VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_RED = 2,
  VIDEO_COMP_ALGO_SKIN_TONE_CORRECTION_PRESET_YELLOW = 3,
  VIDEO_COMP_ALGO_2DTO3D_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_2DTO3D_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_3D_ANALYSIS_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_3D_ANALYSIS_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_FRC_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_FRC_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
  VIDEO_COMP_ALGO_BEN_CUSTOM_00 = VIDEO_COMP_ALGO_CUSTOM_BASE + 0,
  VIDEO_COMP_ALGO_BEN_CUSTOM_01 = VIDEO_COMP_ALGO_CUSTOM_BASE + 1,
} NVAPI_VIDEO_COMPONENT_ALGORITHM;
typedef enum _NVAPI_VIDEO_COMPONENT_ENABLE {
  VIDEO_COMP_ENA_480i = 0x00000001,
  VIDEO_COMP_ENA_480p = 0x00000002,
  VIDEO_COMP_ENA_576i = 0x00000004,
  VIDEO_COMP_ENA_576p = 0x00000008,
  VIDEO_COMP_ENA_720p = 0x00000010,
  VIDEO_COMP_ENA_1080i = 0x00000020,
  VIDEO_COMP_ENA_1080p = 0x00000040,
} NVAPI_VIDEO_COMPONENT_ENABLE;
typedef struct _NVAPI_GET_VIDEO_STATE_COMPONENT {
  NvU32 version;
  NvU32 componentID;
  NvU32 bIsSupported : 1;
  NvU32 bIsOverridenByUser : 1;
  NvU32 reserved1 : 30;
  NvU32 isEnabled;
  NvU32 minValue;
  NvU32 maxValue;
  NvU32 totalSteps;
  NvU32 defaultValue;
  NvU32 unityValue;
  NvU32 currentValueActive;
  NvU64 defaultAlgo;
  NvU64 currentAlgoActive;
  union {
    NvU64 qwReserved[9];
    struct {
      NvU32 dwAppKey;
      NvU32 bTopPriority : 1;
      NvU32 bHasCustomAlgo : 1;
      NvU32 bReserved : 30;
      struct {
        NvU64 pData;
        NvU32 dwSize;
      } customAlgo;
    } appInfo;
  };
} NVAPI_GET_VIDEO_STATE_COMPONENT;
#define NVAPI_GET_VIDEO_STATE_COMPONENT_VER MAKE_NVAPI_VERSION(NVAPI_GET_VIDEO_STATE_COMPONENT, 1)
typedef enum _NVAPI_VIDEO_COMP_RETURN_STATUS {
  VIDEO_COMP_STATUS_SUCCESS = 0x00000000,
  VIDEO_COMP_STATUS_UNSUCCESSFUL = 0x00000001,
  VIDEO_COMP_STATUS_COMPONENT_NOT_SUPPORTED = 0x00000002,
  VIDEO_COMP_STATUS_VALUE_OUT_OF_RANGE = 0x00000004,
  VIDEO_COMP_STATUS_ALGO_NOT_RECOGNIZED = 0x00000008,
  VIDEO_COMP_STATUS_OVERRIDDEN_BY_USER = 0x00000010,
  VIDEO_COMP_STATUS_Y_GAMMA_ENABLED = 0x00000020,
  VIDEO_COMP_STATUS_RGB_GAMMA_ENABLED = 0x00000040,
} NVAPI_VIDEO_COMP_RETURN_STATUS;
#define NVAPI_VIDEO_STATE_MAX_CUSTOM_ALGO_SIZE 128
typedef struct _NVAPI_SET_VIDEO_STATE_COMPONENT {
  NvU32 version;
  NvU32 componentID;
  NvU32 enable;
  NvU32 setToValue;
  NvU64 setToAlgo;
  NvU32 retStatus;
  NvU32 reserved;
  union {
    NvU64 qwReserved[4];
    struct {
      NvU32 dwAppKey;
      NvU32 bTopPriority : 1;
      NvU32 bHasCustomAlgo : 1;
      NvU32 bReserved : 30;
      struct {
        NvU64 pData;
        NvU32 dwSize;
      } customAlgo;
    } appInfo;
  };
} NVAPI_SET_VIDEO_STATE_COMPONENT;
#define NVAPI_SET_VIDEO_STATE_COMPONENT_VER MAKE_NVAPI_VERSION(NVAPI_SET_VIDEO_STATE_COMPONENT, 1)
#endif
NVAPI_INTERFACE NvAPI_GetVideoState(NvDisplayHandle hNvDisplay, NVAPI_GET_VIDEO_STATE_COMPONENT *pGetVidStateComp);
NVAPI_INTERFACE NvAPI_SetVideoState(NvDisplayHandle hNvDisplay, NVAPI_SET_VIDEO_STATE_COMPONENT *pSetVidStateComp);
typedef struct _NVAPI_FRAME_RATE_NOTIFY_INFO {
  NvU32 version;
  NvU64 hWnd;
  NvU32 bEnable : 1;
  NvU32 bReserved : 31;
} NVAPI_FRAME_RATE_NOTIFY_INFO;
#define NVAPI_FRAME_RATE_NOTIFY_INFO_VER MAKE_NVAPI_VERSION(NVAPI_FRAME_RATE_NOTIFY_INFO, 1)
NVAPI_INTERFACE NvAPI_SetFrameRateNotify(NvDisplayHandle hNvDisplay, NVAPI_FRAME_RATE_NOTIFY_INFO *pFRNotifyInfo);
#ifndef NV_STEREO_VIDEO_FORMAT_DEFINE
#define NV_STEREO_VIDEO_FORMAT_DEFINE
typedef enum _NV_STEREO_VIDEO_FORMAT {
  NV_STEREO_VIDEO_FORMAT_NOT_STEREO = 0,
  NV_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_LR = 1,
  NV_STEREO_VIDEO_FORMAT_SIDE_BY_SIDE_RL = 2,
  NV_STEREO_VIDEO_FORMAT_TOP_BOTTOM_LR = 3,
  NV_STEREO_VIDEO_FORMAT_TOP_BOTTOM_RL = 4,
  NV_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_LR = 5,
  NV_STEREO_VIDEO_FORMAT_ROW_INTERLEAVE_RL = 6,
  NV_STEREO_VIDEO_FORMAT_TWO_FRAMES_LR = 7,
  NV_STEREO_VIDEO_FORMAT_MONO_PLUS_OFFSET = 8,
  NV_STEREO_VIDEO_FORMAT_LAST = 9,
} NV_STEREO_VIDEO_FORMAT;
#endif
typedef struct _NV_VIDEO_STEREO_INFO {
  NvU32 dwVersion;
  NV_STEREO_VIDEO_FORMAT eFormat;
  NvS32 sViewOffset;
  NvU32 bStereoEnable : 1;
} NV_VIDEO_STEREO_INFO;
#define NV_VIDEO_STEREO_INFO_VER MAKE_NVAPI_VERSION(NV_VIDEO_STEREO_INFO, 1)
NVAPI_INTERFACE NvAPI_VideoSetStereoInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_STEREO_INFO *pStereoInfo);
NVAPI_INTERFACE NvAPI_VideoGetStereoInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_STEREO_INFO *pStereoInfo);
typedef enum _NVAPI_VIDEO_CTRL_REQUEST {
  NVAPI_VCTL_REQ_NONE = 0x00000000,
  NVAPI_VCTL_REQ_DI_BOB = 0x00000001,
  NVAPI_VCTL_REQ_DI_MEDIAN = 0x00000002,
  NVAPI_VCTL_REQ_DI_WEAVE = 0x00000004,
  NVAPI_VCTL_REQ_DI_ADAPTIVE = 0x00000008,
  NVAPI_VCTL_REQ_DI_EDGE_FULL = 0x00000010,
  NVAPI_VCTL_REQ_DI_EDGE_SIMPLE = 0x00000020,
  NVAPI_VCTL_REQ_GAMMA_DISABLE = 0x00000040,
  NVAPI_VCTL_REQ_709EXT_ENABLE = 0x00000080,
  NVAPI_VCTL_REQ_709EXT_DISABLE = 0x00000100,
  NVAPI_VCTL_REQ_601EXT_DISABLE = 0x00000200,
  NVAPI_VCTL_REQ_OVERDRIVE_DISABLE = 0x00000400,
  NVAPI_VCTL_REQ_COLORTEMP_DISABLE = 0x00000800,
  NVAPI_VCTL_REQ_INV32_DISABLE = 0x00001000,
  NVAPI_VCTL_REQ_VP_DISABLE = 0x00002000,
  NVAPI_VCTL_REQ_DI_GRADIENT_FULL = 0x00004000,
  NVAPI_VCTL_REQ_DI_GRADIENT_SIMPLE = 0x00008000,
  NVAPI_VCTL_REQ_INV22_DISABLE = 0x00010000,
  NVAPI_VCTL_REQ_DI_SIMPLE_ADAPTIVE = 0x00020000,
  NVAPI_VCTL_REQ_NO_PROCESSING = 0x00040000,
  NVAPI_VCTL_REQ_DI_ONLY = 0x00080000,
  NVAPI_VCTL_REQ_NR_ONLY = 0x00100000,
  NVAPI_VCTL_REQ_EE_ONLY = 0x00200000,
  NVAPI_VCTL_REQ_CADENCE_ONLY = 0x00400000,
  NVAPI_VCTL_REQ_XFER_XTRA_SAME = 0x00800000,
  NVAPI_VCTL_REQ_XFER_XTRA_NV12 = 0x01000000,
  NVAPI_VCTL_REQ_XFER_XTRA_YUY2 = 0x02000000,
  NVAPI_VCTL_REQ_XFER_XTRA_SCALE = 0x04000000,
  NVAPI_VCTL_REQ_DI_ADVANCED = 0x08000000,
  NVAPI_VCTL_REQ_DI_DIR_SPATIAL = 0x10000000,
  NVAPI_VCTL_REQ_DI_CADENCE = 0x20000000,
  NVAPI_VCTL_REQ_DI_VOF = 0x40000000,
  NVAPI_VCTL_REQ_XFER_XTRA_ARGB = 0x80000000,
} NVAPI_VIDEO_CTRL_REQUEST;
typedef enum _NVAPI_VIDEO_CTRL_REQUEST2 {
  NVAPI_VCTL2_REQ_10BITOVERLAY_ENABLE = 0x00000001,
  NVAPI_VCTL2_REQ_VP2_SCALING_ENABLE = 0x00000002,
  NVAPI_VCTL2_REQ_VP2_SCALING_DISABLE = 0x00000004,
  NVAPI_VCTL2_REQ_CAPTURE_UNIQUE_FRAME = 0x00000008,
} NVAPI_VIDEO_CTRL_REQUEST2;
typedef enum _NVAPI_VIDEO_CTRL_CAPS_FLAG {
  NVAPI_VIDEO_CTRL_CAPS_NONE = 0x00000000,
  NVAPI_VIDEO_CTRL_CAPS_MEDIAN_DI = 0x00000001,
  NVAPI_VIDEO_CTRL_CAPS_SPAD_DI = 0x00000002,
  NVAPI_VIDEO_CTRL_CAPS_ADV_DI = 0x00000004,
  NVAPI_VIDEO_CTRL_CAPS_GAMMA = 0x00000008,
  NVAPI_VIDEO_CTRL_CAPS_709EXT = 0x00000010,
  NVAPI_VIDEO_CTRL_CAPS_OVERDRIVE = 0x00000020,
  NVAPI_VIDEO_CTRL_CAPS_COLORTEMP = 0x00000040,
  NVAPI_VIDEO_CTRL_CAPS_INVAPI32 = 0x00000080,
  NVAPI_VIDEO_CTRL_CAPS_VP = 0x00000100,
  NVAPI_VIDEO_CTRL_CAPS_INVAPI22 = 0x00000200,
  NVAPI_VIDEO_CTRL_CAPS_XFER_XTRA = 0x00000400,
  NVAPI_VIDEO_CTRL_CAPS_NVAPI24 = 0x00000800,
} NVAPI_VIDEO_CTRL_CAPS_FLAG;
typedef enum _NVAPI_VIDEO_CTRL_ID {
  NVAPI_VIDEO_CTRL_ID_NONE = -1,
  NVAPI_VIDEO_CTRL_ID_REQ1,
  NVAPI_VIDEO_CTRL_ID_REQ2,
  NVAPI_VIDEO_CTRL_ID_CAPTURE,
  NVAPI_VIDEO_CTRL_ID_PERF,
  NVAPI_VIDEO_CTRL_ID_LAST,
} NVAPI_VIDEO_CTRL_ID;
typedef enum _NVAPI_VIDEO_CTRL_FLAG {
  NVAPI_VIDEO_CTRL_FLAG_SET = 1,
  NVAPI_VIDEO_CTRL_FLAG_GET,
  NVAPI_VIDEO_CTRL_FLAG_RESET,
} NVAPI_VIDEO_CTRL_FLAG;
typedef enum _NVAPI_VIDEO_CAPTURE_FLAG {
  NVAPI_VIDEO_CAPTURE_STOP = 0x00000001,
  NVAPI_VIDEO_CAPTURE_SOURCE_ALSO = 0x00000002,
  NVAPI_VIDEO_CAPTURE_ALLFRAMES = 0x00000004,
  NVAPI_VIDEO_CAPTURE_NEWBUFFER = 0x00000008,
} NVAPI_VIDEO_CAPTURE_FLAG;
typedef enum _NVAPI_VIDEO_CAPTURE_POINT {
  NVAPI_VIDEO_CAPTURE_POINT_NONE = 0,
  NVAPI_VIDEO_CAPTURE_POINT_OVERLAY_FLIP = 1,
  NVAPI_VIDEO_CAPTURE_POINT_VIDEO_BLIT = 2,
  NVAPI_VIDEO_CAPTURE_POINT_DELETED_RENDER_MPEG = 3,
  NVAPI_VIDEO_CAPTURE_POINT_DELETED_RENDER_WMV9 = 4,
  NVAPI_VIDEO_CAPTURE_POINT_PROCAMP_OUTPUT = 5,
  NVAPI_VIDEO_CAPTURE_POINT_DI_OUTPUT = 6,
  NVAPI_VIDEO_CAPTURE_POINT_DELETED_SUBPIC_OUTPUT = 7,
  NVAPI_VIDEO_CAPTURE_POINT_CSC_OUTPUT = 8,
  NVAPI_VIDEO_CAPTURE_POINT_DELETED_INV32_OUTPUT = 9,
  NVAPI_VIDEO_CAPTURE_POINT_UNLOCK = 10,
  NVAPI_VIDEO_CAPTURE_POINT_DELETED_00 = 11,
  NVAPI_VIDEO_CAPTURE_POINT_MOCOMP_END_FRAME = 12,
  NVAPI_VIDEO_CAPTURE_POINT_DELETED_MOCOMP_H264 = 13,
  NVAPI_VIDEO_CAPTURE_POINT_MIRROR = 14,
  NVAPI_VIDEO_CAPTURE_POINT_BLIT32_DST = 15,
  NVAPI_VIDEO_CAPTURE_POINT_FE_SP_BLEND = 16,
  NVAPI_VIDEO_CAPTURE_POINT_BE_SP_BLEND = 17,
  NVAPI_VIDEO_CAPTURE_POINT_VP_OUTPUT = 18,
  NVAPI_VIDEO_CAPTURE_POINT_DELETED_MOCOMP_VC1 = 19,
  NVAPI_VIDEO_CAPTURE_POINT_YUV_OUT = 20,
  NVAPI_VIDEO_CAPTURE_POINT_NR_OUTPUT = 21,
  NVAPI_VIDEO_CAPTURE_POINT_ADI_OUTPUT = 22,
  NVAPI_VIDEO_CAPTURE_POINT_MSDEC_OUTPUT = 23,
} NVAPI_VIDEO_CAPTURE_POINT;
typedef struct _NVAPI_VIDEO_CTRL_V1 {
  NvU32 version;
  NvU32 ctrlID;
  NvU32 ctrlFlag;
  NvU32 retStatus;
  union {
    NvU32 parm[8];
    NvU32 diagCtrlReq1;
    NvU32 diagCtrlReq2;
  } u;
  NvU64 reserved3[10];
} NVAPI_VIDEO_CTRL_V1;
typedef struct _NVAPI_VIDEO_CTRL_V2 {
  NvU32 version;
  NvU32 ctrlID;
  NvU32 ctrlFlag;
  NvU32 retStatus;
  NvU32 bResetDiagCtrlInfo : 1;
  NvU32 bReserved : 31;
  union {
    NvU32 parm[8];
    struct {
      NvU32 diagCtrlReq1;
      NvU32 diagCtrlReq2;
    } diagCtrlRequest;
    struct {
      NvU32 captureBufferAdd;
      NvU32 captureFlags;
      NvU32 captureBufferSize;
      NvU32 capturePoint;
      NvU32 captureFrameIndex;
      NvU32 captureFrameRange : 16;
      NvU32 reserved2 : 16;
    } captureInfo;
    struct {
      NvU32 startFrameIdx;
      NvU32 endFrameIdx;
      NvU32 bEnablePerf : 1;
      NvU32 reserved2 : 31;
    } perftestInfo;
  } u;
  struct {
    NvU32 dwVideoControlDiagInfoBits;
    NvU32 dwVideoControlDiagInfo2Bits;
    NvU32 dwVideoControlDiagCapsBits;
  } diagVideoControlInfo;
  struct {
    NvU32 dwTargetWidth;
    NvU32 dwTargetHeight;
  } diagVideoControlParm;
  NvU64 reserved3[7];
} NVAPI_VIDEO_CTRL_V2;
typedef NVAPI_VIDEO_CTRL_V2 NVAPI_VIDEO_CTRL;
#define NVAPI_VIDEO_CTRL_VER1 MAKE_NVAPI_VERSION(NVAPI_VIDEO_CTRL_V1, 1)
#define NVAPI_VIDEO_CTRL_VER2 MAKE_NVAPI_VERSION(NVAPI_VIDEO_CTRL_V2, 2)
#define NVAPI_VIDEO_CTRL_VER NVAPI_VIDEO_CTRL_VER2
typedef enum _NVAPI_VIDEO_CTRL_RETURN_STATUS {
  NVAPI_VIDEO_CTRL_STATUS_SUCCESS = 0x00000000,
  NVAPI_VIDEO_CTRL_STATUS_UNSUCCESSFUL = 0x00000001,
  NVAPI_VIDEO_CTRL_STATUS_CTRL_NOT_SUPPORTED = 0x00000002,
  NVAPI_VIDEO_CTRL_STATUS_CTRL_FLAG_INVALID = 0x00000003,
  NVAPI_VIDEO_CTRL_STATUS_CTRL_FIELD_NOT_SUPPORTED = 0x00000004,
  NVAPI_VIDEO_CTRL_STATUS_CAPTURE_PENDING = 0x00000005,
} NVAPI_VIDEO_CTRL_RETURN_STATUS;
NVAPI_INTERFACE NvAPI_VideoCtrl(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_CTRL *pVideoCtrl);
#define NVAPI_MAX_CONTROL_POINT_DATA_SIZE_IN_BYTES 0x100
#define NVAPI_MAX_CONTROL_POINTS_PER_PACKET 20
typedef enum _NVAPI_VIDEO_CONTROL_RETURN_STATUS {
  NVAPI_VIDEO_CONTROL_STATUS_SUCCESS = 0,
  NVAPI_VIDEO_CONTROL_STATUS_UNSUCCESSFUL,
  NVAPI_VIDEO_CONTROL_STATUS_COMPONENT_NOT_SUPPORTED,
  NVAPI_VIDEO_CONTROL_STATUS_VALUE_OUT_OF_RANGE,
  NVAPI_VIDEO_CONTROL_STATUS_DATA_TYPE_MISMATCH,
  NVAPI_VIDEO_CONTROL_STATUS_FLAG_INVALID,
  NVAPI_VIDEO_CONTROL_STATUS_UNREGISTERED,
  NVAPI_VIDEO_CONTROL_STATUS_INVALID_ARGUMENT,
  NVAPI_VIDEO_CONTROL_STATUS_INVALID_ID,
  NVAPI_VIDEO_CONTROL_STATUS_INVALID_DATA_SIZE,
  NVAPI_VIDEO_CONTROL_STATUS_DISABLED,
} NVAPI_VIDEO_CONTROL_RETURN_STATUS;
typedef enum _NVAPI_VIDEO_CONTROL_POINT_ID {
  NVAPI_CPID_FIRST = -1,
  NVAPI_CPID_NoiseReductionStrength,
  NVAPI_CPID_EdgeEnhancementStrength,
  NVAPI_CPID_BrightnessValue,
  NVAPI_CPID_ContrastValue,
  NVAPI_CPID_HueValue,
  NVAPI_CPID_SaturationValue,
  NVAPI_CPID_GammaValueR,
  NVAPI_CPID_GammaValueG,
  NVAPI_CPID_GammaValueB,
  NVAPI_CPID_DeInterlacingAlgo,
  NVAPI_CPID_CadenceDetectionAlgo,
  NVAPI_CPID_SubPictureBlendingMode,
  NVAPI_CPID_ColorSpace,
  NVAPI_CPID_ColorRange,
  NVAPI_CPID_DynamicContrastEnhancement,
  NVAPI_CPID_Scaling,
  NVAPI_CPID_GamutRemap,
  NVAPI_CPID_SkinToneCorrection,
  NVAPI_CPID_DurationTrackingActive,
  NVAPI_CPID_LAST,
} NVAPI_VIDEO_CONTROL_POINT_ID;
typedef enum _NVAPI_VIDEO_CONTROL_POINT_DATATYPE {
  NVAPI_CPDT_UNKNOWN = 0,
  NVAPI_CPDT_Integer,
  NVAPI_CPDT_Float,
  NVAPI_CPDT_String,
  NVAPI_CPDT_Binary,
  NVAPI_CPDT_LAST,
} NVAPI_VIDEO_CONTROL_POINT_DATATYPE;
typedef enum _NVAPI_CONTROL_POINT_GRANULARITY {
  NVAPI_CPG_UNKNOWN = 0,
  NVAPI_CPG_InitTime,
  NVAPI_CPG_PerFrame,
} NVAPI_CONTROL_POINT_GRANULARITY;
typedef enum _NVAPI_VIDEO_CONTROL_GET_FLAG {
  NVAPI_CP_FLAG_GET_UNKNOWN = 0,
  NVAPI_CP_FLAG_GET_COUNT,
  NVAPI_CP_FLAG_GET_DETAILS,
} NVAPI_VIDEO_CONTROL_GET_FLAG;
typedef enum _NVAPI_VIDEO_CONTROL_COMPONENT_ALGORITHM {
  NV_VCTRL_ColorSpaceBase = 0x1000,
  NV_VCTRL_ColorSpace601 = (NV_VCTRL_ColorSpaceBase) + 0x01,
  NV_VCTRL_ColorSpace709 = (NV_VCTRL_ColorSpaceBase) + 0x02,
  NV_VCTRL_ColorSpaceLast = (NV_VCTRL_ColorSpaceBase) + 0x03,
  NV_VCTRL_ColorRangeBase = 0x1100,
  NV_VCTRL_ColorRangeStd = (NV_VCTRL_ColorRangeBase) + 0x01,
  NV_VCTRL_ColorRangeExt = (NV_VCTRL_ColorRangeBase) + 0x02,
  NV_VCTRL_ColorRangeLast = (NV_VCTRL_ColorRangeBase) + 0x03,
  NV_VCTRL_DIBase = 0x2000,
  NV_VCTRL_DIBob = (NV_VCTRL_DIBase) + 0x01,
  NV_VCTRL_DIMedian = (NV_VCTRL_DIBase) + 0x02,
  NV_VCTRL_DI3x3 = (NV_VCTRL_DIBase) + 0x03,
  NV_VCTRL_DIAdaptiveFourField = (NV_VCTRL_DIBase) + 0x04,
  NV_VCTRL_DIDirectionalSpatial = (NV_VCTRL_DIBase) + 0x05,
  NV_VCTRL_DIOnePass = (NV_VCTRL_DIBase) + 0x06,
  NV_VCTRL_DISony = (NV_VCTRL_DIBase) + 0x07,
  NV_VCTRL_DILast = (NV_VCTRL_DIBase) + 0x08,
  NV_VCTRL_CadenceBase = 0x3000,
  NV_VCTRL_CadenceBasic = (NV_VCTRL_CadenceBase) + 0x01,
  NV_VCTRL_CadenceVideoOnFilm = (NV_VCTRL_CadenceBase) + 0x02,
  NV_VCTRL_CadenceAdv = (NV_VCTRL_CadenceBase) + 0x03,
  NV_VCTRL_CadenceLast = (NV_VCTRL_CadenceBase) + 0x04,
  NV_VCTRL_DCCEBase = 0x4000,
  NV_VCTRL_DCCELow = (NV_VCTRL_DCCEBase) + 0x01,
  NV_VCTRL_DCCEMedium = (NV_VCTRL_DCCEBase) + 0x02,
  NV_VCTRL_DCCEHigh = (NV_VCTRL_DCCEBase) + 0x03,
  NV_VCTRL_DCCELast = (NV_VCTRL_DCCEBase) + 0x04,
  NV_VCTRL_ScalingBase = 0x5000,
  NV_VCTRL_ScalingSimple = (NV_VCTRL_ScalingBase) + 0x01,
  NV_VCTRL_Scaling4x4Filter = (NV_VCTRL_ScalingBase) + 0x02,
  NV_VCTRL_ScalingSony = (NV_VCTRL_ScalingBase) + 0x03,
  NV_VCTRL_ScalingLast = (NV_VCTRL_ScalingBase) + 0x04,
  NV_VCTRL_GamutRemapBase = 0x6000,
  NV_VCTRL_GamutRemapSony = (NV_VCTRL_GamutRemapBase) + 0x01,
  NV_VCTRL_GamutRemapLast = (NV_VCTRL_GamutRemapBase) + 0x02,
  NV_VCTRL_SkinToneCorrectionBase = 0x7000,
  NV_VCTRL_SkinToneCorrectionSqueeze = (NV_VCTRL_SkinToneCorrectionBase) + 0x01,
  NV_VCTRL_SkinToneCorrectionRed = (NV_VCTRL_SkinToneCorrectionBase) + 0x02,
  NV_VCTRL_SkinToneCorrectionYellow = (NV_VCTRL_SkinToneCorrectionBase) + 0x03,
  NV_VCTRL_SkinToneCorrectionLast = (NV_VCTRL_SkinToneCorrectionBase) + 0x04,
} NVAPI_VIDEO_CONTROL_COMPONENT_ALGORITHM;
typedef struct _NVAPI_VIDEO_CONTROL_POINT_DESC {
  NVAPI_VIDEO_CONTROL_POINT_ID eID;
  NVAPI_VIDEO_CONTROL_POINT_DATATYPE eType;
  NVAPI_CONTROL_POINT_GRANULARITY eGranularity;
  NvU32 dwDataSize;
  NvU32 adwReserved[4];
} NVAPI_VIDEO_CONTROL_POINT_DESC;
typedef struct _NVAPI_VID_CTRL_POINT_DESC_STRINGS {
  NVAPI_VIDEO_CONTROL_POINT_ID eID;
  NvAPI_ShortString szControlPoint;
  NvAPI_ShortString szDataType;
  NvAPI_ShortString szGranularity;
  NvAPI_ShortString szReserved1;
} NVAPI_VID_CTRL_POINT_DESC_STRINGS;
typedef struct _NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET {
  NvU32 version;
  NvU32 dwReturnStatus;
  NVAPI_VIDEO_CONTROL_GET_FLAG eGetID;
  NVAPI_VIDEO_CONTROL_POINT_DESC astCtrlPointDesc[NVAPI_MAX_CONTROL_POINTS_PER_PACKET];
  NvU32 dwCPCount;
  NvU32 dwStartCPCount;
  NvU64 aqwReserved[3];
} NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET;
#define NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET, 1)
typedef enum _NVAPI_VID_CTRL_COMMAND {
  NVAPI_VideoCtrlPoint_Set = 1,
  NVAPI_VideoCtrlPoint_Reset = 2,
  NVAPI_VideoCtrlPoint_ResetAll = 3,
} NVAPI_VID_CTRL_COMMAND;
typedef struct _NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET {
  NvU32 version;
  NvU32 dwReturnStatus;
  NVAPI_VID_CTRL_COMMAND eCommand;
  NVAPI_VIDEO_CONTROL_POINT_ID eID;
  NVAPI_VIDEO_CONTROL_POINT_DATATYPE eType;
  union {
    void *pData;
    NvU64 qwDataPad;
  };
  NvU32 dwDataSize;
  NvU32 adwReserved[4];
} NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET;
#define NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET, 1)
typedef struct _NVAPI_VIDEO_CONTROL_POINT_DATA {
  NVAPI_VID_CTRL_COMMAND eCommand;
  NVAPI_VIDEO_CONTROL_POINT_ID eID;
  NvU32 dwReturnStatus;
  NVAPI_VIDEO_CONTROL_POINT_DATATYPE eType;
  NvU32 dwStartOffset;
  NvU8 abyData[NVAPI_MAX_CONTROL_POINT_DATA_SIZE_IN_BYTES];
  NvU32 dwPacketDataSize;
  NvU32 dwDataSize;
} NVAPI_VIDEO_CONTROL_POINT_DATA;
typedef struct _NVAPI_VIDEO_CONTROL_POINT_REGISTER {
  NvU64 qwCPSupportedBitFlags;
} NVAPI_VIDEO_CONTROL_POINT_REGISTER;
typedef enum _NVAPI_VIDEO_CONTROL_ID {
  NVAPI_VID_CTRL_ENUM = 1,
  NVAPI_VID_CTRL_GET,
  NVAPI_VID_CTRL_SET,
  NVAPI_VID_CTRL_REGISTER,
  NVAPI_VID_CTRL_LAST,
} NVAPI_VIDEO_CONTROL_ID;
typedef struct _NVAPI_VIDEO_CONTROL {
  NvU32 dwCtrlID;
  union {
    NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET stVidCtrlPointDesc;
    NVAPI_VIDEO_CONTROL_POINT_DATA stVidCtrlPointData;
    NVAPI_VIDEO_CONTROL_POINT_REGISTER stVidCtrlPointReg;
  };
} NVAPI_VIDEO_CONTROL;
NVAPI_INTERFACE NvAPI_EnumerateVideoControlPoints(NvDisplayHandle hNvDisplay,
                                                  NVAPI_VIDEO_CONTROL_POINT_DESC_PACKET *pControlPointDesc,
                                                  NVAPI_VID_CTRL_POINT_DESC_STRINGS *pCPDescNamesArray);
NVAPI_INTERFACE NvAPI_VideoControl(NvDisplayHandle hNvDisplay,
                                   NVAPI_VIDEO_CONTROL_POINT_DATA_PACKET *pControlPointData);
#define NVAPI_MAX_DATA_PROVIDER_DETAILS 10
#define NVAPI_MAX_CAPTURE_IMAGES 8
#define NVAPI_MAX_CAPTURE_EXTRA_INFO 8
#define NVAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES 476
#define NVAPI_MAX_APPLIED_ALGO_PER_STREAM_RUN 30
#define NVAPI_VIDEO_MAX_STREAMS 12
#define NVAPI_VIDEO_NAME_MAX_LENGTH 260
#define NVAPI_MAX_FUNCTION_CALLS_TO_TRACK 100
typedef enum _NVAPI_VIDEO_DATA_PROVIDER_STATUS {
  NVAPI_DP_STATUS_SUCCESS = 0,
  NVAPI_DP_STATUS_UNSUCCESSFUL,
  NVAPI_DP_STATUS_INVALID_ID,
  NVAPI_DP_STATUS_VALUE_OUT_OF_RANGE,
  NVAPI_DP_STATUS_INVALID_DATA_SIZE,
  NVAPI_DP_STATUS_FLAG_INVALID,
  NVAPI_DP_STATUS_NOT_INTIALIZED,
  NVAPI_DP_STATUS_INVALID_ARGUMENT,
  NVAPI_DP_STATUS_DISABLED,
  NVAPI_DP_STATUS_MAX_CLIENT_REACHED,
  NVAPI_DP_STATUS_CLIENT_NOT_PRESENT,
  NVAPI_DP_STATUS_MAX_DP_PER_CLIENT_REACHED,
} NVAPI_VIDEO_DATA_PROVIDER_STATUS;
typedef enum _NVAPI_VIDEO_DATA_PROVIDER_ID {
  NVAPI_DPID_INVALID = -1,
  NVAPI_DPID_DECODEDFRAMECOUNT,
  NVAPI_DPID_VPPSURFACECOUNT,
  NVAPI_DPID_VP2CYCLES,
  NVAPI_DPID_IMAGEBUFFER,
  NVAPI_DPID_FIXEDBUGS,
  NVAPI_DPID_INVTCWEAVEMODE,
  NVAPI_DPID_IMAGEBUFFER_OVERLAY_INTERNAL,
  NVAPI_DPID_IMAGEBUFFER_OVERLAY_EXTERNAL,
  NVAPI_DPID_IMAGEBUFFER_SHADER_DCCE,
  NVAPI_DPID_IMAGEBUFFER_SHADER_GAMUT_REMAP,
  NVAPI_DPID_IMAGEBUFFER_SHADER_GAMMA,
  NVAPI_DPID_IMAGEBUFFER_SHADER_PROCAMP,
  NVAPI_DPID_IMAGEBUFFER_SHADER_CSC,
  NVAPI_DPID_IMAGEBUFFER_SHADER_EE,
  NVAPI_DPID_IMAGEBUFFER_SHADER_FE,
  NVAPI_DPID_IMAGEBUFFER_SHADER_FMTXFER,
  NVAPI_DPID_IMAGEBUFFER_SHADER_NR,
  NVAPI_DPID_IMAGEBUFFER_SHADER_BLEND,
  NVAPI_DPID_IMAGEBUFFER_SHADER_SCALE,
  NVAPI_DPID_IMAGEBUFFER_4x4_SCALE,
  NVAPI_DPID_IMAGEBUFFER_COMPOSITOR_D3D,
  NVAPI_DPID_IMAGEBUFFER_DECODE,
  NVAPI_DPID_IMAGEBUFFER_SHADER_DI,
  NVAPI_DPID_IMAGEBUFFER_SHADER_ROTATE,
  NVAPI_DPID_DXVA_APPLIED_ALGORITHMS,
  NVAPI_DPID_BLITTER_APPLIED_ALGORITHMS,
  NVAPI_DPID_CALL_DURATION,
  NVAPI_DPID_IMAGEBUFFER_COMPOSITOR_VIC,
  NVAPI_DPID_IMAGEBUFFER_DMA_TRANSFER,
  NVAPI_DPID_IMAGEBUFFER_PRESENT_STEREO_LEFT,
  NVAPI_DPID_IMAGEBUFFER_PRESENT_STEREO_RIGHT,
  NVAPI_DPID_IMAGEBUFFER_UPDATE_OVERLAY_LEFT,
  NVAPI_DPID_IMAGEBUFFER_UPDATE_OVERLAY_RIGHT,
  NVAPI_DPID_IMAGEBUFFER_FLIP_OVERLAY_LEFT,
  NVAPI_DPID_IMAGEBUFFER_FLIP_OVERLAY_RIGHT,
  NVAPI_DPID_IMAGEBUFFER_SHADOWPLAY_OSD,
  NVAPI_DPID_IMAGEBUFFER_VR_DIRECT_PRESENT,
  NVAPI_DPID_IMAGEBUFFER_VR_MULTI_GPU_PRESENT,
  NVAPI_DPID_VR_HIGH_PRIORITY_CONTEXT_CREATE,
  NVAPI_DPID_DIRECTMODE_IMPLICIT_SLI_CONTROL,
  NVAPI_DPID_OVERLAY_KMDFLIP_INFO,
  NVAPI_DPID_LAST,
} NVAPI_VIDEO_DATA_PROVIDER_ID;
typedef enum _NVAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS {
  NVAPI_DP_STATUS_CAPTURE_OFF = 0,
  NVAPI_DP_STATUS_CAPTURE_GENERIC_ERROR,
  NVAPI_DP_STATUS_CAPTURE_PENDING,
  NVAPI_DP_STATUS_CAPTURE_PENDING_SRC,
  NVAPI_DP_STATUS_CAPTURE_COMPLETE,
  NVAPI_DP_STATUS_CAPTURE_BUFFER_TOO_SMALL,
} NVAPI_VIDEO_DATA_PROVIDER_CAPTURE_STATUS;
typedef struct _NVAPI_VIDEO_DATA_PROVIDER_DESC {
  NVAPI_VIDEO_DATA_PROVIDER_ID eID;
  NvU32 dwPeriod;
  NvU32 dwBufferSize;
  NvU32 dwBufferCount;
  NvU32 bIsPullModelDataProvider : 1;
  NvU32 bReserved1 : 31;
  NvU64 aqwReserved2[3];
} NVAPI_VIDEO_DATA_PROVIDER_DESC;
typedef struct _NVAPI_VID_DATA_PROVIDER_DESC_STRINGS {
  NVAPI_VIDEO_DATA_PROVIDER_ID eID;
  NvAPI_ShortString szDataProviderName;
  NvAPI_ShortString szReserved1;
  NvAPI_ShortString szReserved2;
} NVAPI_VID_DATA_PROVIDER_DESC_STRINGS;
typedef enum _NVAPI_VID_DATA_PROVIDER_GET_FLAG {
  NVAPI_DP_GET_COUNT = 0,
  NVAPI_DP_GET_DETAILS,
  NVAPI_DP_GET_REGISTERED_COUNT,
} NVAPI_VID_DATA_PROVIDER_GET_FLAG;
typedef struct _NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR {
  NvU32 version;
  NvU32 dwStatus;
  NVAPI_VID_DATA_PROVIDER_GET_FLAG eGetID;
  NvU32 dwStartDPCount;
  NvU32 dwDPCount;
  NVAPI_VIDEO_DATA_PROVIDER_DESC astDataProviderDetails[NVAPI_MAX_DATA_PROVIDER_DETAILS];
  NvU32 adwReserved[5];
} NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR;
#define NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR, 1)
NVAPI_INTERFACE NvAPI_EnumVideoDataProviders(NvDisplayHandle hNvDisplay,
                                             NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR *pVideoDataProviderDesc,
                                             NVAPI_VID_DATA_PROVIDER_DESC_STRINGS *pDataProvDescNamesArray);
typedef struct _NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO {
  NvU32 version;
  NvU32 dwStatus;
  NVAPI_VIDEO_DATA_PROVIDER_ID eID;
  NvU32 dwClientID;
  NvU32 dwBufferCount;
  NvU32 dwBufferSize;
  NvU64 qwBufferArrayAdd;
  NvU32 dwCapturePoint;
  NvU32 dwNotifyPeriod;
  NvU64 qwEventHandle;
  NvU32 dwFrameStart;
  NvU32 dwFrameEnd;
  NvU32 bEmulationMode : 1;
  NvU32 bReserved : 31;
  NvU32 dwReserved;
  NvU64 aqwReserved[3];
} NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO;
#define NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO_VER                                                                \
  MAKE_NVAPI_VERSION(NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO, 1)
NVAPI_INTERFACE NvAPI_RegisterVideoDataProvider(NvDisplayHandle hNvDisplay,
                                                NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO *pDataProviderReg);
NVAPI_INTERFACE NvAPI_UnregisterVideoDataProvider(NvDisplayHandle hNvDisplay,
                                                  NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO *pDataProviderReg);
typedef struct _NVAPI_PULL_MODEL_DATA_PACKET {
  NvU32 dwStatus;
  NVAPI_VIDEO_DATA_PROVIDER_ID eID;
  NvU32 dwBufferCount;
  NvU32 dwBufferSize;
  NvU32 dwStartOffset;
  NvU8 abyData[NVAPI_MAX_PULL_MODEL_DP_DATA_SIZE_IN_BYTES];
  NvU32 dwClientID;
} NVAPI_PULL_MODEL_DATA_PACKET;
typedef struct _NVAPI_VIDEO_DATA_GET {
  NvU32 version;
  NvU32 dwStatus;
  NVAPI_VIDEO_DATA_PROVIDER_ID eID;
  NvU32 dwClientID;
  NvU32 dwBufferSize;
  NvU32 dwBufferCount;
  union {
    void *pBuffArray;
    NvU64 pPad;
  };
  NvU32 dwReserved[3];
} NVAPI_VIDEO_DATA_GET;
#define NVAPI_VIDEO_DATA_GET_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_DATA_GET, 1)
NVAPI_INTERFACE NvAPI_GetVideoData(NvDisplayHandle hNvDisplay, NVAPI_VIDEO_DATA_GET *pVidDataGet);
typedef struct _NVAPI_IMAGE_BUFFER {
  NvU32 dwDataSize;
  NvU32 dwPixelType;
  NvU32 dwHeight;
  NvU32 dwWidth;
  NvU32 bytesPerPixel : 3;
  NvU32 bReserved1 : 29;
  NvU32 dwPitch;
  NvU32 dwInfo1;
  NvU32 dwInfo2;
  union {
    NvU8 *pImgData;
    NvU64 qwPad;
  };
  NvU64 aqwReserved2[2];
} NVAPI_IMAGE_BUFFER;
typedef struct _NVAPI_ALGO_DETAILS {
  NvU32 dwAlgoID;
  char cAlgoName[NVAPI_VIDEO_NAME_MAX_LENGTH];
  NvU64 qwflags[NVAPI_VIDEO_MAX_STREAMS];
} NVAPI_ALGO_DETAILS;
typedef struct _NVAPI_VIDEO_APPLIED_ALGOS_PER_STREAM {
  NvU32 dwAppliedAlgoCount;
  NVAPI_ALGO_DETAILS astAppliedAlgoList[NVAPI_MAX_APPLIED_ALGO_PER_STREAM_RUN];
} NVAPI_VIDEO_APPLIED_ALGOS_PER_STREAM;
typedef struct _NVAPI_VIDEO_APPLIED_ALGOS_PER_VID_PROC_INSTANCE {
  NvU32 dwVidProcInstanceIndex;
  char cVidProcInstanceName[NVAPI_VIDEO_NAME_MAX_LENGTH];
  NvU32 dwNumStreams;
  NVAPI_VIDEO_APPLIED_ALGOS_PER_STREAM astAppliedAlgosPerStream[NVAPI_VIDEO_MAX_STREAMS];
} NVAPI_VIDEO_APPLIED_ALGOS_PER_VID_PROC_INSTANCE;
typedef struct _NVAPI_VIDEO_APPLIED_ALGOS_BUFFER {
  NvU32 dwCaptureStatus;
  NVAPI_VIDEO_APPLIED_ALGOS_PER_VID_PROC_INSTANCE stAppliedAlgosPerVidProcInstance;
} NVAPI_VIDEO_APPLIED_ALGOS_BUFFER;
typedef enum _NVAPI_FUNCTION_NAME {
  NVAPI_DecodeExecute = 0,
  NVAPI_DecodeBeginFrame,
  NVAPI_DecodeEndFrame,
  NVAPI_VideoProcessBlt,
  NVAPI_ExtensionExecute,
  NVAPI_FlipOverlay,
  NVAPI_FlipOverlayNvApi,
  NVAPI_OverlayTransfer,
  NVAPI_nvRenderDeinterlace,
  NVAPI_PresentVideoShow,
  NVAPI_LAST_FUNCTION,
} NVAPI_FUNCTION_NAME;
typedef struct _NVAPI_VIDEO_FUNCTION_CALL_INFO {
  NVAPI_FUNCTION_NAME eFunctionName;
  NvU32 iCallNumber;
  NvU32 bIsFunctionActive;
  NvU64 iCallDuration[NVAPI_MAX_FUNCTION_CALLS_TO_TRACK];
} NVAPI_VIDEO_FUNCTION_CALL_INFO;
typedef struct _NVAPI_VIDEO_CALL_DURATION_BUFFER {
  NvU32 dwCaptureStatus;
  NVAPI_VIDEO_FUNCTION_CALL_INFO stCallDurationInfo[NVAPI_LAST_FUNCTION];
} NVAPI_VIDEO_CALL_DURATION_BUFFER;
typedef struct _NVAPI_VIDEO_CAPTURE_BUFFER {
  NvU32 dwCaptureStatus;
  NvU32 dwCapturePoint;
  NvU32 dwCaptureFrameIndex;
  NvU32 dwCaptureBufferSize;
  NvU32 dwCurrentFrameIndex;
  NvU32 dwImageCount;
  NVAPI_IMAGE_BUFFER astImage[NVAPI_MAX_CAPTURE_IMAGES];
  NvU32 bCaptureSource : 1;
  NvU32 bCaptureAllFrames : 1;
  NvU32 byDecodedFrameType : 8;
  NvU32 reserved1 : 22;
  NvU32 dwCaptureFrameRange;
  NvU32 dwDecodedFrameCount;
  NvU32 dwUsedBufferSpace;
  NvU32 dwSrcCount;
  NvU32 adwExtraInfo[NVAPI_MAX_CAPTURE_EXTRA_INFO];
  NvU32 dwVersion;
  NvU32 dwReserved2[2];
  NvU32 dwAppliedAlgoCount;
  NVAPI_ALGO_DETAILS astAppliedAlgoList[NVAPI_MAX_APPLIED_ALGO_PER_STREAM_RUN];
} NVAPI_VIDEO_CAPTURE_BUFFER;
#define NVAPI_VIDEO_CAPTURE_BUFFER_VER MAKE_NVAPI_VERSION(NVAPI_VIDEO_CAPTURE_BUFFER, 2)
typedef struct _NVAPI_VIDEO_INVTC_WEAVEMODE_BUFFER {
  NvU32 dwCaptureStatus;
  NvU32 dwWeaveMode;
  NvU32 dwReserved[2];
} NVAPI_VIDEO_INVTC_WEAVEMODE_BUFFER;
typedef struct _NVAPI_VIDEO_OVERLAY_KMDFLIP_INFO_BUFFER {
  NvU32 dwCaptureStatus;
  NvU32 dwFlipBufferIndex;
  NvU32 dwCompletedFlipCount;
  NvU32 dwActiveFlipCount;
} NVAPI_VIDEO_OVERLAY_KMDFLIP_INFO_BUFFER;
#define NVAPI_VIDEO_MAX_CAPTURE_STR_SIZE 100
typedef struct _NVAPI_VIDEO_STR_INFO {
  NvU32 dwStrLen;
  char captureStr[NVAPI_VIDEO_MAX_CAPTURE_STR_SIZE];
} NVAPI_VIDEO_STR_INFO;
typedef struct _NVAPI_VIDEO_STR_BUFFER {
  NvU32 dwCaptureStatus;
  NVAPI_VIDEO_STR_INFO stStrInfo;
} NVAPI_VIDEO_STR_BUFFER;
typedef enum _NVAPI_VIDEO_CAPTURE_POINTS {
  NVAPI_VIDEO_CAPTURE_NONE = 0x00000000,
  NVAPI_VIDEO_CAPTURE_DECODE = 0x00000001,
  NVAPI_VIDEO_CAPTURE_OVERLAY = 0x00000002,
  NVAPI_VIDEO_CAPTURE_BLIT = 0x00000004,
  NVAPI_VIDEO_CAPTURE_VPBLIT = 0x00000008,
  NVAPI_VIDEO_CAPTURE_UNLOCK = 0x00000010,
  NVAPI_VIDEO_CAPTURE_FE = 0x00000020,
  NVAPI_VIDEO_CAPTURE_EE = 0x00000040,
  NVAPI_VIDEO_CAPTURE_NR = 0x00000080,
  NVAPI_VIDEO_CAPTURE_DI = 0x00000100,
  NVAPI_VIDEO_CAPTURE_INVTC = 0x00000200,
  NVAPI_VIDEO_CAPTURE_PROCAMP_CSC = 0x00000400,
  NVAPI_VIDEO_CAPTURE_GAMMA = 0x00000800,
  NVAPI_VIDEO_CAPTURE_GAMUT_REMAP = 0x00001000,
  NVAPI_VIDEO_CAPTURE_DCCE = 0x00002000,
  NVAPI_VIDEO_CAPTURE_BLEND = 0x00004000,
  NVAPI_VIDEO_CAPTURE_SCALE = 0x00008000,
  NVAPI_VIDEO_CAPTURE_COMPOSITOR = 0x00010000,
} NVAPI_VIDEO_CAPTURE_POINTS;
typedef enum _NVAPI_VID_DATA_PROVIDER_CTRL_ID {
  NV_DATA_PROVIDER_ENUM = 1,
  NV_DATA_PROVIDER_REGISTER = 2,
  NV_DATA_PROVIDER_UNREGISTER = 3,
  NV_DATA_PROVIDER_PULL_MODEL_GET = 6,
  NV_DATA_PROVIDER_CTRL_LAST = 7,
} NVAPI_VID_DATA_PROVIDER_CTRL_ID;
typedef struct _NVAPI_VID_DATA_PROVIDER_CTRL {
  NvU32 dwCtrlID;
  union {
    NvU64 qwParams[70];
    NVAPI_VIDEO_DATA_PROVIDER_DESCRIPTOR stDataProviderDesc;
    NVAPI_VIDEO_DATA_PROVIDER_REGISTRATION_INFO stDataProviderReg;
    NVAPI_PULL_MODEL_DATA_PACKET stPullModelData;
  };
} NVAPI_VID_DATA_PROVIDER_CTRL;
#define MAX_VIDEO_SURFACE_COUNT 64
#define NV_MAX_VID_PP_INSTANCE 8
typedef enum _D3D_Version {
  D3D_Version_9 = 9,
  D3D_Version_11 = 11,
} D3D_Version;
typedef struct _NV_VIDEO_DECODE_STREAM_INFO_V1 {
  NvU32 streamIndex;
  NvU32 processID;
  NvU32 streamSrcWidth;
  NvU32 streamSrcHeight;
  NvU32 streamFormat;
} NV_VIDEO_DECODE_STREAM_INFO_V1;
typedef struct _NV_VIDEO_DECODE_STREAM_INFO_V2 {
  NvU32 streamIndex;
  NvU32 processID;
  NvU32 streamSrcWidth;
  NvU32 streamSrcHeight;
  NvU32 streamFormat;
  D3D_Version dxVersion;
} NV_VIDEO_DECODE_STREAM_INFO_V2;
typedef struct _NV_VIDEO_DECODE_STREAM_INFO_V3 {
  NvU32 streamIndex;
  NvU32 processID;
  NvU32 streamSrcWidth;
  NvU32 streamSrcHeight;
  NvU32 streamFormat;
  D3D_Version dxVersion;
  NvU32 isHWDRM : 1;
  NvU32 isSWDRM : 1;
  NvU32 reserved : 30;
} NV_VIDEO_DECODE_STREAM_INFO_V3;
typedef struct _NV_VIDEO_DECODE_STREAM_INFO_V4 {
  NvU32 streamIndex;
  NvU32 processID;
  NvU32 streamSrcWidth;
  NvU32 streamSrcHeight;
  NvU32 streamFormat;
  D3D_Version dxVersion;
  NvU32 isHWDRM : 1;
  NvU32 isSWDRM : 1;
  NvU32 isAOTActive : 1;
  NvU32 isHistogramActive : 1;
  NvU32 isHistogramReported : 1;
  NvU32 reserved : 27;
} NV_VIDEO_DECODE_STREAM_INFO_V4;
typedef NV_VIDEO_DECODE_STREAM_INFO_V4 NV_VIDEO_DECODE_STREAM_INFO;
typedef struct _NV_VIDEO_DXVA_INFO_V1 {
  NvU32 version;
  NvU32 dxvaObjectCount;
  NV_VIDEO_DECODE_STREAM_INFO_V1 streamInfo[NV_MAX_VID_STREAMS];
} NV_VIDEO_DXVA_INFO_V1;
typedef struct _NV_VIDEO_DXVA_INFO_V2 {
  NvU32 version;
  NvU32 dxvaObjectCount;
  NV_VIDEO_DECODE_STREAM_INFO_V2 streamInfo[NV_MAX_VID_STREAMS];
} NV_VIDEO_DXVA_INFO_V2;
typedef struct _NV_VIDEO_DXVA_INFO_V3 {
  NvU32 version;
  NvU32 dxvaObjectCount;
  NV_VIDEO_DECODE_STREAM_INFO_V2 streamInfo[NV_MAX_VID_STREAMS_EX];
} NV_VIDEO_DXVA_INFO_V3;
typedef struct _NV_VIDEO_DXVA_INFO_V4 {
  NvU32 version;
  NvU32 dxvaObjectCount;
  NV_VIDEO_DECODE_STREAM_INFO_V3 streamInfo[NV_MAX_VID_STREAMS_EX];
  NvU32 isVPRSupported : 1;
  NvU32 isPRSupported : 1;
  NvU32 reserved : 30;
} NV_VIDEO_DXVA_INFO_V4;
typedef struct _NV_VIDEO_DXVA_INFO_V5 {
  NvU32 version;
  NvU32 dxvaObjectCount;
  NV_VIDEO_DECODE_STREAM_INFO_V4 streamInfo[NV_MAX_VID_STREAMS_EX];
  NvU32 isVPRSupported : 1;
  NvU32 isPRSupported : 1;
  NvU32 isVideoTimerActive : 1;
  NvU32 isMPOEnabled : 1;
  NvU32 isMPONextInfoValid : 1;
  NvU32 isMPORestricted : 1;
  NvU32 isMPOYuvPlaneActive : 1;
  NvU32 isMPOProcampActive : 1;
  NvU32 YuvPlaneVidPnSrcId : 2;
  NvU32 reserved : 22;
} NV_VIDEO_DXVA_INFO_V5;
typedef NV_VIDEO_DXVA_INFO_V5 NV_VIDEO_DXVA_INFO;
#define NV_VIDEO_DXVA_INFO_VER_1 MAKE_NVAPI_VERSION(NV_VIDEO_DXVA_INFO_V1, 1)
#define NV_VIDEO_DXVA_INFO_VER_2 MAKE_NVAPI_VERSION(NV_VIDEO_DXVA_INFO_V2, 2)
#define NV_VIDEO_DXVA_INFO_VER_3 MAKE_NVAPI_VERSION(NV_VIDEO_DXVA_INFO_V3, 3)
#define NV_VIDEO_DXVA_INFO_VER_4 MAKE_NVAPI_VERSION(NV_VIDEO_DXVA_INFO_V4, 4)
#define NV_VIDEO_DXVA_INFO_VER_5 MAKE_NVAPI_VERSION(NV_VIDEO_DXVA_INFO_V5, 5)
#define NV_VIDEO_DXVA_INFO_VER NV_VIDEO_DXVA_INFO_VER_5
NVAPI_INTERFACE NvAPI_Video_GetDXVAInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_DXVA_INFO *pDxvaInfo);
typedef struct {
  NvU32 version;
  NvU8 overlayInUse;
  NvU32 overlaySurfaceCount;
} NV_VIDEO_OVERLAY_INFO_V1;
typedef enum _NVAPI_VIDEO_OVERLAY_FLAGS {
  NVAPI_OVERLAY_FLAG_UNKNOWN = 0,
  NVAPI_OVERLAY_FLAG_D3DAPI,
  NVAPI_OVERLAY_FLAG_NVAPI,
} NVAPI_VIDEO_OVERLAY_FLAGS;
typedef struct {
  NvU32 version;
  NvU8 overlayInUse;
  NvU32 overlaySurfaceCount;
  NvU8 overlaySurfaceBPP[NV_MAX_HEADS];
  NVAPI_VIDEO_OVERLAY_FLAGS overlayFlags[NV_MAX_HEADS];
  NV_RECT overlaySrcRect[NV_MAX_HEADS];
  NV_RECT overlayDestRect[NV_MAX_HEADS];
} NV_VIDEO_OVERLAY_INFO_V2;
typedef NV_VIDEO_OVERLAY_INFO_V2 NV_VIDEO_OVERLAY_INFO;
#define NV_VIDEO_OVERLAY_INFO_VER_1 MAKE_NVAPI_VERSION(NV_VIDEO_OVERLAY_INFO_V1, 1)
#define NV_VIDEO_OVERLAY_INFO_VER_2 MAKE_NVAPI_VERSION(NV_VIDEO_OVERLAY_INFO_V2, 2)
#define NV_VIDEO_OVERLAY_INFO_VER NV_VIDEO_OVERLAY_INFO_VER_2
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 515.") NVAPI_INTERFACE
    NvAPI_Video_GetOverlayInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_OVERLAY_INFO *pVideoOverlayInfo);
typedef struct _NV_VIDEO_SURFACE_INFO_V1 {
  NvU32 surfaceWidth;
  NvU32 surfaceHeight;
  NvU32 surfaceFormat;
  NvU32 surfaceSize;
} NV_VIDEO_SURFACE_INFO_V1;
typedef struct _NV_VIDEO_SURFACE_INFO_V2 {
  NvU32 surfaceWidth;
  NvU32 surfaceHeight;
  NvU32 surfaceFormat;
  NvU32 surfaceSize;
  NvU32 isVPR : 1;
  NvU32 reserved : 31;
  NvU32 processID;
} NV_VIDEO_SURFACE_INFO_V2;
typedef struct _NV_VIDEO_GET_SURFACE_COUNT_V1 {
  NvU32 version;
  NvU32 surfaceFormat;
  NvU32 videoSurfaceCount;
} NV_VIDEO_GET_SURFACE_COUNT_V1;
typedef struct _NV_VIDEO_GET_SURFACE_COUNT_V2 {
  NvU32 version;
  NvU32 surfaceFormat;
  NvU32 videoSurfaceCount;
  NvU32 processID;
} NV_VIDEO_GET_SURFACE_COUNT_V2;
typedef NV_VIDEO_GET_SURFACE_COUNT_V2 NV_VIDEO_GET_SURFACE_COUNT;
#define NV_VIDEO_GET_SURFACE_COUNT_VER_1 MAKE_NVAPI_VERSION(NV_VIDEO_GET_SURFACE_COUNT_V1, 1)
#define NV_VIDEO_GET_SURFACE_COUNT_VER_2 MAKE_NVAPI_VERSION(NV_VIDEO_GET_SURFACE_COUNT_V2, 2)
#define NV_VIDEO_GET_SURFACE_COUNT_VER NV_VIDEO_GET_SURFACE_COUNT_VER_2
NVAPI_INTERFACE NvAPI_Video_GetVideoSurfaceCount(NvDisplayHandle hNvDisplay,
                                                 NV_VIDEO_GET_SURFACE_COUNT *pVideoSurfaceCount);
typedef struct _NV_VIDEO_GET_SURFACE_INFO_V1 {
  NvU32 version;
  NvU32 surfaceFormat;
  NvU32 startSurfCount;
  NvU32 videoSurfaceCount;
  NV_VIDEO_SURFACE_INFO_V1 surfaceInfo[MAX_VIDEO_SURFACE_COUNT];
} NV_VIDEO_GET_SURFACE_INFO_V1;
typedef struct _NV_VIDEO_GET_SURFACE_INFO_V2 {
  NvU32 version;
  NvU32 surfaceFormat;
  NvU32 startSurfCount;
  NvU32 videoSurfaceCount;
  NV_VIDEO_SURFACE_INFO_V2 surfaceInfo[MAX_VIDEO_SURFACE_COUNT];
  NvU32 processID;
} NV_VIDEO_GET_SURFACE_INFO_V2;
typedef NV_VIDEO_GET_SURFACE_INFO_V2 NV_VIDEO_GET_SURFACE_INFO;
#define NV_VIDEO_GET_SURFACE_INFO_VER_1 MAKE_NVAPI_VERSION(NV_VIDEO_GET_SURFACE_INFO_V1, 1)
#define NV_VIDEO_GET_SURFACE_INFO_VER_2 MAKE_NVAPI_VERSION(NV_VIDEO_GET_SURFACE_INFO_V2, 2)
#define NV_VIDEO_GET_SURFACE_INFO_VER NV_VIDEO_GET_SURFACE_INFO_VER_2
NVAPI_INTERFACE NvAPI_Video_GetVideoSurfaceInfo(NvDisplayHandle hNvDisplay,
                                                NV_VIDEO_GET_SURFACE_INFO *pVideoSurfaceInfo);
typedef struct _NV_VIDEO_STREAM_STATE_V1 {
  NvU32 streamIndex;
  NvU32 surfaceWidth;
  NvU32 surfaceHeight;
  NvU8 gdiDisplayName[32];
  NVAPI_GET_VIDEO_STATE_COMPONENT vidComponent[NVAPI_VIDEO_STATE_COMPONENT_ID_LAST];
  NvU32 bVICInUse;
  NvU32 dwReserved[8];
} NV_VIDEO_STREAM_STATE_V1;
typedef struct _NV_VIDEO_STREAM_STATE_V2 {
  NvU32 streamIndex;
  NvU32 surfaceWidth;
  NvU32 surfaceHeight;
  NvU8 gdiDisplayName[32];
  NVAPI_GET_VIDEO_STATE_COMPONENT vidComponent[NVAPI_VIDEO_STATE_COMPONENT_ID_LAST];
  NvU32 bVICInUse;
  NvU32 dwReserved[8];
  D3D_Version dxVersion;
} NV_VIDEO_STREAM_STATE_V2;
typedef struct _NV_VIDEO_STREAM_STATE_V3 {
  NvU32 streamIndex;
  NvU32 surfaceWidth;
  NvU32 surfaceHeight;
  NvU8 gdiDisplayName[32];
  NVAPI_GET_VIDEO_STATE_COMPONENT vidComponent[NVAPI_VIDEO_STATE_COMPONENT_ID_LAST];
  NvU32 bVICInUse;
  NvU32 dwReserved[8];
  D3D_Version dxVersion;
  NvU64 totalPoolSize;
  NvU64 freePoolSize;
  NvU64 totalVPRSize;
  NvU64 freeVPRSize;
} NV_VIDEO_STREAM_STATE_V3;
typedef struct _NV_VIDEO_STREAM_STATE_V4 {
  NvU32 streamIndex;
  NvU32 surfaceWidth;
  NvU32 surfaceHeight;
  NvU8 gdiDisplayName[32];
  NVAPI_GET_VIDEO_STATE_COMPONENT vidComponent[NVAPI_VIDEO_STATE_COMPONENT_ID_LAST];
  NvU32 bVICInUse;
  NvU32 bMPORestricted;
  NvU32 processID;
  NvU32 lastUpdateTime;
  NvU32 bIsDwmProcess : 1;
  NvU32 bIsHwndNull : 1;
  NvU32 bAutoProcessingDisable : 1;
  NvU32 dwReservedBits : 29;
  NvU32 dwReserved[4];
  D3D_Version dxVersion;
  NvU64 totalPoolSize;
  NvU64 freePoolSize;
  NvU64 totalVPRSize;
  NvU64 freeVPRSize;
  NvU32 srcSurfaceFormat;
  NvU32 srcColorSpaceRange;
  NvU32 srcColorSpacePrimaries;
  NvU32 srcColorGamma;
  NvU32 dstSurfaceFormat;
  NvU32 dstColorSpaceRange;
  NvU32 dstColorSpacePrimaries;
  NvU32 dstColorGamma;
  NvU32 shader;
  float nitMultiplier;
} NV_VIDEO_STREAM_STATE_V4;
typedef NV_VIDEO_STREAM_STATE_V4 NV_VIDEO_STREAM_STATE;
typedef struct {
  NvU32 version;
  NvU32 streamCount;
  NV_VIDEO_STREAM_STATE_V1 streamInfo[NV_MAX_VID_PP_INSTANCE];
} NV_VIDEO_STATE_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 streamCount;
  NV_VIDEO_STREAM_STATE_V2 streamInfo[NV_MAX_VID_PP_INSTANCE];
} NV_VIDEO_STATE_INFO_V2;
typedef struct {
  NvU32 version;
  NvU32 streamCount;
  NV_VIDEO_STREAM_STATE_V3 streamInfo[NV_MAX_VID_PP_INSTANCE];
} NV_VIDEO_STATE_INFO_V3;
typedef struct {
  NvU32 version;
  NvU32 streamCount;
  NV_VIDEO_STREAM_STATE_V4 streamInfo[NV_MAX_VID_PP_INSTANCE];
} NV_VIDEO_STATE_INFO_V4;
typedef NV_VIDEO_STATE_INFO_V4 NV_VIDEO_STATE_INFO;
#define NV_VIDEO_STATE_INFO_VER_1 MAKE_NVAPI_VERSION(NV_VIDEO_STATE_INFO_V1, 1)
#define NV_VIDEO_STATE_INFO_VER_2 MAKE_NVAPI_VERSION(NV_VIDEO_STATE_INFO_V2, 2)
#define NV_VIDEO_STATE_INFO_VER_3 MAKE_NVAPI_VERSION(NV_VIDEO_STATE_INFO_V3, 3)
#define NV_VIDEO_STATE_INFO_VER_4 MAKE_NVAPI_VERSION(NV_VIDEO_STATE_INFO_V4, 4)
#define NV_VIDEO_STATE_INFO_VER NV_VIDEO_STATE_INFO_VER_4
NVAPI_INTERFACE NvAPI_Video_GetVideoStateInfo(NvDisplayHandle hNvDisplay, NV_VIDEO_STATE_INFO *pVideoStateInfo);
typedef enum _NV_VIDEO_QUERY_ID {
  NV_VIDEO_GET_DXVA_INFO,
  NV_VIDEO_GET_OVERLAY_INFO,
  NV_VIDEO_GET_VIDEO_SURFACE_COUNT,
  NV_VIDEO_GET_SURFACE_DETAIL,
  NV_VIDEO_GET_STATE_INFO,
  NV_VIDEO_GET_COMMAND_LAST
} NV_VIDEO_QUERY_ID;
typedef struct _NV_VIDEO_GET_INFO {
  NvU32 version;
  NV_VIDEO_QUERY_ID queryID;
  union {
    NV_VIDEO_DXVA_INFO getDxvaInfo;
    NV_VIDEO_OVERLAY_INFO getOverlayInfo;
    NV_VIDEO_GET_SURFACE_COUNT getVideoSurfaceCount;
    NV_VIDEO_GET_SURFACE_INFO getVideoSurfaceInfo;
    NV_VIDEO_STATE_INFO getVideoStateInfo;
  };
} NV_VIDEO_GET_INFO;
#define NV_VIDEO_GET_INFO_VER MAKE_NVAPI_VERSION(NV_VIDEO_GET_INFO, 1)
typedef struct _NV_VIDEO_LOCATION_MAP {
  NvU32 vidPnSrcId;
  NvU32 head;
  NvU32 displayId;
  NvU8 gdiDisplayName[32];
} NV_VIDEO_LOCATION_MAP;
typedef struct _NV_VIDEO_GET_VID_LOCATION_MAP {
  NvU32 version;
  NV_VIDEO_LOCATION_MAP vidLocMap;
} NV_VIDEO_GET_VID_LOCATION_MAP;
#define NV_VIDEO_GET_VID_LOCATION_MAP_VER MAKE_NVAPI_VERSION(NV_VIDEO_GET_VID_LOCATION_MAP, 1)
NVAPI_INTERFACE NvAPI_GetVidLocMap(NvDisplayHandle hNvDisplay, NV_VIDEO_GET_VID_LOCATION_MAP *pGetVidLocMap);
typedef struct _NV_ENCODE_CODEC_H264 {
  NvU32 profile;
  NvU32 level;
  NvU32 numSlices;
  NvU32 intraRefreshCnt;
  NvU32 transform8x8Mode;
  NvU32 numRefFrames;
  NvU32 sliceMode;
  NvU32 sliceModeData;
  NvU32 bSVCTemporalFlag : 1;
  NvU32 bHierarchicalPFrames : 1;
  NvU32 bHierarchicalBFrames : 1;
  NvU32 bRepeatSPSPPS : 1;
  NvU32 bSeparateColourPlaneFlag : 1;
  NvU32 bVleCabacEnable : 1;
  NvU32 bDeblockingFilterControlPresentFlag : 1;
  NvU32 reserved1 : 25;
  NvU32 reserved2[7];
} NV_ENCODE_CODEC_H264_V1;
typedef NV_ENCODE_CODEC_H264_V1 NV_ENCODE_CODEC_H264;
typedef struct _NV_ENCODE_CODEC_HEVC {
  NvU32 profile;
  NvU32 level;
  NvU32 numSlices;
  NvU32 intraRefreshCnt;
  NvU32 sliceMode;
  NvU32 sliceModeData;
  NvU32 maxNumRefFramesInDPB;
  NvU32 maxTemporalLayersMinus1;
  NvU32 bRepeatSPSPPS : 1;
  NvU32 bVleCabacEnable : 1;
  NvU32 bDeblockingFilterControlPresentFlag : 1;
  NvU32 bTransQuantBypassEnableFlag : 1;
  NvU32 bSeparateColourPlaneFlag : 1;
  NvU32 chromaFormatIDC : 2;
  NvU32 pixelBitDepthMinus8 : 3;
  NvU32 reserved1 : 22;
  NvU32 reserved2[7];
} NV_ENCODE_CODEC_HEVC_V1;
typedef NV_ENCODE_CODEC_HEVC_V1 NV_ENCODE_CODEC_HEVC;
typedef union _NV_ENCODE_CODEC {
  NV_ENCODE_CODEC_H264_V1 h264Config;
  NV_ENCODE_CODEC_HEVC_V1 hevcConfig;
  NvU32 reserved[32];
} NV_ENCODE_CODEC;
typedef struct _NV_ENCODE_INSTANCE_INFO {
  NvU32 processId;
  NvU32 instanceId;
  NvU32 codecType;
  NvU32 idrPeriod;
  NvU32 rateControlMode;
  NvU32 maxqp[3];
  NvU32 minqp[3];
  NvU32 vbvBufferSize;
  NvU32 vbvInitialDelay;
  NvU32 hrdBitRate;
  NvU32 rcAvgBitRate;
  NvU32 frmFldMode;
  NvU32 encodeWidth;
  NvU32 encodeHeight;
  NvU32 darWidth;
  NvU32 darHeight;
  double frameRate;
  NvU32 numBFrames;
  NvU32 gopILength;
  NvU32 msencPreset;
  NV_ENCODE_CODEC encodeCodec;
  union {
    struct _NV_ENCODE_INSTANCE_INFO *pNext;
    NvU64 padding;
  };
  NvU32 bEnableExternalHints : 1;
  NvU32 path : 1;
  NvU32 reserved1 : 30;
  NvU32 reserved2[4];
} NV_ENCODE_INSTANCE_INFO_V1;
typedef NV_ENCODE_INSTANCE_INFO_V1 NV_ENCODE_INSTANCE_INFO;
typedef struct _NV_ENCODE_INSTANCE {
  NvU32 version;
  NvU32 instCount;
  union {
    NV_ENCODE_INSTANCE_INFO_V1 *pEncInfo;
    NvU64 padding;
  };
  NvU32 bGetInstanceInfoFlag : 1;
  NvU32 reserved1 : 31;
  NvU32 reserved2[4];
} NV_ENCODE_INSTANCE_V1;
typedef NV_ENCODE_INSTANCE_V1 NV_ENCODE_INSTANCE;
#define NV_ENCODE_INSTANCE_VER1 MAKE_NVAPI_VERSION(NV_ENCODE_INSTANCE_V1, 1)
#define NV_ENCODE_INSTANCE_VER NV_ENCODE_INSTANCE_VER1
NVAPI_INTERFACE NvAPI_Video_GetEncodeInfo(__inout NV_ENCODE_INSTANCE *pEncodeInfo);
NVAPI_INTERFACE NvAPI_Video_SetEncodeInfo(__in NV_ENCODE_INSTANCE *pEncodeInfo);
NVAPI_INTERFACE NvAPI_Video_ReleaseEncodeInfo(__in NvU32 processId, __in NvU32 instanceId);
#if defined(__cplusplus) && defined(_WINNT_)
NVAPI_INTERFACE NvAPI_Vulkan_InitLowLatencyDevice(__in HANDLE vkDevice, __out HANDLE *signalSemaphoreHandle);
#endif
#if defined(__cplusplus) && defined(_WINNT_)
NVAPI_INTERFACE NvAPI_Vulkan_DestroyLowLatencyDevice(__in HANDLE vkDevice);
#endif
typedef struct _NV_VULKAN_GET_SLEEP_STATUS_PARAMS {
  NvU32 version;
  NvBool bLowLatencyMode;
  NvU8 rsvd[128];
} NV_VULKAN_GET_SLEEP_STATUS_PARAMS_V1;
typedef NV_VULKAN_GET_SLEEP_STATUS_PARAMS_V1 NV_VULKAN_GET_SLEEP_STATUS_PARAMS;
#define NV_VULKAN_GET_SLEEP_STATUS_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_VULKAN_GET_SLEEP_STATUS_PARAMS_V1, 1)
#define NV_VULKAN_GET_SLEEP_STATUS_PARAMS_VER NV_VULKAN_GET_SLEEP_STATUS_PARAMS_VER1
#if defined(__cplusplus) && defined(_WINNT_)
NVAPI_INTERFACE NvAPI_Vulkan_GetSleepStatus(__in HANDLE vkDevice,
                                            __inout NV_VULKAN_GET_SLEEP_STATUS_PARAMS *pGetSleepStatusParams);
#endif
#if defined(__cplusplus) && defined(_WINNT_)
typedef struct _NV_VULKAN_SET_SLEEP_MODE_PARAMS {
  NvU32 version;
  NvBool bLowLatencyMode;
  NvBool bLowLatencyBoost;
  NvU32 minimumIntervalUs;
  NvU8 rsvd[32];
} NV_VULKAN_SET_SLEEP_MODE_PARAMS_V1;
typedef NV_VULKAN_SET_SLEEP_MODE_PARAMS_V1 NV_VULKAN_SET_SLEEP_MODE_PARAMS;
#define NV_VULKAN_SET_SLEEP_MODE_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_VULKAN_SET_SLEEP_MODE_PARAMS_V1, 1)
#define NV_VULKAN_SET_SLEEP_MODE_PARAMS_VER NV_VULKAN_SET_SLEEP_MODE_PARAMS_VER1
#endif
#if defined(__cplusplus) && defined(_WINNT_)
NVAPI_INTERFACE NvAPI_Vulkan_SetSleepMode(__in HANDLE vkDevice,
                                          __in NV_VULKAN_SET_SLEEP_MODE_PARAMS *pSetSleepModeParams);
#endif
#if defined(__cplusplus) && defined(_WINNT_)
NVAPI_INTERFACE NvAPI_Vulkan_Sleep(__in HANDLE vkDevice, __in NvU64 signalValue);
#endif
typedef struct _NV_VULKAN_LATENCY_RESULT_PARAMS {
  NvU32 version;
  struct vkFrameReport {
    NvU64 frameID;
    NvU64 inputSampleTime;
    NvU64 simStartTime;
    NvU64 simEndTime;
    NvU64 renderSubmitStartTime;
    NvU64 renderSubmitEndTime;
    NvU64 presentStartTime;
    NvU64 presentEndTime;
    NvU64 driverStartTime;
    NvU64 driverEndTime;
    NvU64 osRenderQueueStartTime;
    NvU64 osRenderQueueEndTime;
    NvU64 gpuRenderStartTime;
    NvU64 gpuRenderEndTime;
    NvU8 rsvd[128];
  } frameReport[64];
  NvU8 rsvd[32];
} NV_VULKAN_LATENCY_RESULT_PARAMS_V1;
typedef NV_VULKAN_LATENCY_RESULT_PARAMS_V1 NV_VULKAN_LATENCY_RESULT_PARAMS;
#define NV_VULKAN_LATENCY_RESULT_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_VULKAN_LATENCY_RESULT_PARAMS_V1, 1)
#define NV_VULKAN_LATENCY_RESULT_PARAMS_VER NV_VULKAN_LATENCY_RESULT_PARAMS_VER1
#if defined(__cplusplus) && defined(_WINNT_)
NVAPI_INTERFACE NvAPI_Vulkan_GetLatency(__in HANDLE vkDevice,
                                        __inout NV_VULKAN_LATENCY_RESULT_PARAMS *pGetLatencyParams);
#endif
typedef enum {
  VULKAN_SIMULATION_START = 0,
  VULKAN_SIMULATION_END = 1,
  VULKAN_RENDERSUBMIT_START = 2,
  VULKAN_RENDERSUBMIT_END = 3,
  VULKAN_PRESENT_START = 4,
  VULKAN_PRESENT_END = 5,
  VULKAN_INPUT_SAMPLE = 6,
  VULKAN_TRIGGER_FLASH = 7,
} NV_VULKAN_LATENCY_MARKER_TYPE;
typedef struct _NV_VULKAN_LATENCY_MARKER_PARAMS {
  NvU32 version;
  NvU64 frameID;
  NV_VULKAN_LATENCY_MARKER_TYPE markerType;
  NvU8 rsvd[64];
} NV_VULKAN_LATENCY_MARKER_PARAMS_V1;
typedef NV_VULKAN_LATENCY_MARKER_PARAMS_V1 NV_VULKAN_LATENCY_MARKER_PARAMS;
#define NV_VULKAN_LATENCY_MARKER_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_VULKAN_LATENCY_MARKER_PARAMS_V1, 1)
#define NV_VULKAN_LATENCY_MARKER_PARAMS_VER NV_VULKAN_LATENCY_MARKER_PARAMS_VER1
#if defined(__cplusplus) && defined(_WINNT_)
NVAPI_INTERFACE NvAPI_Vulkan_SetLatencyMarker(__in HANDLE vkDevice,
                                              __in NV_VULKAN_LATENCY_MARKER_PARAMS *pSetLatencyMarkerParams);
#endif
NVAPI_INTERFACE NvAPI_Audio_EnumDeviceHandle(NvU32 thisEnum, NvAudioHandle *hDeviceObject);
typedef enum _NV_AUDIO_CHANNEL {
  NV_AUDIO_CHAN_0 = (1 << 0),
  NV_AUDIO_CHAN_1 = (1 << 1),
  NV_AUDIO_CHAN_2 = (1 << 2),
  NV_AUDIO_CHAN_3 = (1 << 3),
  NV_AUDIO_CHAN_4 = (1 << 4),
  NV_AUDIO_CHAN_5 = (1 << 5),
  NV_AUDIO_CHAN_6 = (1 << 6),
  NV_AUDIO_CHAN_7 = (1 << 7),
  NV_AUDIO_CHAN_8 = (1 << 8),
  NV_AUDIO_CHAN_9 = (1 << 9),
  NV_AUDIO_CHAN_10 = (1 << 10)
} NV_AUDIO_CHANNEL;
typedef enum _NV_AUDIO_SIZE {
  NV_AUDIO_SIZE_16BIT = (1 << 0),
  NV_AUDIO_SIZE_20BIT = (1 << 1),
  NV_AUDIO_SIZE_24BIT = (1 << 2),
} NV_AUDIO_SIZE;
typedef enum _NV_AUDIO_RATE {
  NV_AUDIO_RATE_32000 = (1 << 8),
  NV_AUDIO_RATE_44100 = (1 << 9),
  NV_AUDIO_RATE_48000 = (1 << 10),
  NV_AUDIO_RATE_88200 = (1 << 11),
  NV_AUDIO_RATE_96000 = (1 << 12),
  NV_AUDIO_RATE_176400 = (1 << 13),
  NV_AUDIO_RATE_192000 = (1 << 14),
} NV_AUDIO_RATE;
typedef enum _NV_AUDIO_FORMAT {
  NV_AUDIO_FORMAT_LPCM = (1 << 1),
  NV_AUDIO_FORMAT_AC3 = (1 << 2),
  NV_AUDIO_FORMAT_MPEG1 = (1 << 3),
  NV_AUDIO_FORMAT_MP3 = (1 << 4),
  NV_AUDIO_FORMAT_MPEG2 = (1 << 5),
  NV_AUDIO_FORMAT_AAC = (1 << 6),
  NV_AUDIO_FORMAT_DTS = (1 << 7),
  NV_AUDIO_FORMAT_ATRAC = (1 << 8),
  NV_AUDIO_FORMAT_SACD = (1 << 9),
  NV_AUDIO_FORMAT_DDPLUS = (1 << 10),
  NV_AUDIO_FORMAT_DTSHD = (1 << 11),
  NV_AUDIO_FORMAT_MAT = (1 << 12),
  NV_AUDIO_FORMAT_DST = (1 << 13),
  NV_AUDIO_FORMAT_WMAPRO = (1 << 14),
  NV_AUDIO_FORMAT_RESERVED = (1 << 15),
} NV_AUDIO_FORMAT;
typedef struct _NV_AUDIO_PARAMETERS {
  NvU32 version;
  NvU32 venID;
  NvU32 devID;
  NvU32 revID;
  NvU32 paramVersion;
  NvU32 regH0S0;
  NvU32 regH0S1;
  NvU32 regH1S0;
  NvU32 regH1S1;
  NvU32 regLPCM;
  NvU32 currentState : 1;
  NvU32 currentChan;
  NvU32 currentRate;
  NvU32 currentSampleSize;
  NvU32 maxState : 1;
  NvU32 maxRate;
  NvU32 maxSampleSize;
  NvU32 maxFormats;
  NvU32 maxChan;
  NvU32 sinkState : 1;
  NvU32 sinkRate;
  NvU32 sinkSampleSize;
  NvU32 sinkFormats;
  NvU32 sinkChan;
  NvU32 overrideState : 1;
  NvU32 overrideRate;
  NvU32 overrideSampleSize;
  NvU32 overrideFormats;
  NvU32 overrideChan;
} NV_AUDIO_PARAMETERS;
#define NV_AUDIO_PARAMETERS_VER MAKE_NVAPI_VERSION(NV_AUDIO_PARAMETERS, 1)
NVAPI_INTERFACE NvAPI_Audio_GetDeviceParameters(NvAudioHandle NvAudioHandle, NV_AUDIO_PARAMETERS *pNV_AUDIO_PARAMETERS);
NVAPI_INTERFACE NvAPI_Audio_SetDeviceParametersOverride(NvAudioHandle NvAudioHandle,
                                                        NV_AUDIO_PARAMETERS *pNV_AUDIO_PARAMETERS);
#define NV_SECURE_AUDIO_API_REVISION 0x00010001
#define NV_CONTENT_KEY_HEADER_VERSION 0x01
#define NV_CONTENT_KEY_HEADER_KEY_IS_PLAINTEXT NV_BIT(1)
#define NV_CONTENT_KEY_HEADER_OOS_ENABLED NV_BIT(2)
#define NV_CONTENT_KEY_HEADER_KEYLENGTH 16
#define NV_CONTENT_KEY_HEADER_IVLENGTH 16
#define NV_CONTENT_KEY_HEADER_SIZE sizeof(NV_CONTENT_KEY_HEADER)
typedef struct _NV_CONTENT_KEY_HEADER {
  NvU8 version;
  NvU8 contentKeyHeaderLength;
  NvU8 flags;
  NvU8 counterWrapAround;
  NvU8 iv[NV_CONTENT_KEY_HEADER_IVLENGTH];
  NvU8 key[NV_CONTENT_KEY_HEADER_KEYLENGTH];
} NV_CONTENT_KEY_HEADER;
__nvapi_deprecated_function(
    "Do not use this function - it is deprecated in release 313. Instead, use NvAPI_SecureAudio_CheckAPICompatibility.")
    NVAPI_INTERFACE NvAPI_SecureAudio_GetSecureAudioAPIRevision(__out NvU32 *nvSecureAudioAPIRevision);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 495.") NVAPI_INTERFACE
    NvAPI_SecureAudio_CheckAPICompatibility(__in NvAPI_LPCWSTR endpointID, __in NvU32 nvSecureAudioAPIRevision);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 495.") NVAPI_INTERFACE
    NvAPI_SecureAudio_GetCustomFormatGUID(__inout NvGUID *subFormat);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 495.") NVAPI_INTERFACE
    NvAPI_SecureAudio_NegotiateDHExchange(__in NvAPI_LPCWSTR endpointID, __in NvU8 *challengeToken,
                                          __out NvU8 *responseToken);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 495.") NVAPI_INTERFACE
    NvAPI_SecureAudio_ComputeSessionKey(__in NvAPI_LPCWSTR endpointID, __out NvU8 *sessionKey);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 495.") NVAPI_INTERFACE
    NvAPI_SecureAudio_PollOOSDState(__in NvAPI_LPCWSTR endpointID);
typedef enum {
  NV_GPU_AUDIO_DE_LIST_TYPE_DEFAULT = 0,
  NV_GPU_AUDIO_DE_LIST_TYPE_ADAPTER,
  NV_GPU_AUDIO_DE_LIST_TYPE_CONNECTOR,
} NV_AUDIO_PRIORITY_ENUM;
typedef struct {
  NvU32 version;
  NvU32 deviceEntry;
} NV_AUDIO_PRIORITY_ENTRY_V1;
typedef NV_AUDIO_PRIORITY_ENTRY_V1 NV_AUDIO_PRIORITY_ENTRY;
#define NV_AUDIO_PRIORITY_ENTRY_VER1 MAKE_NVAPI_VERSION(NV_AUDIO_PRIORITY_ENTRY_V1, 1)
#define NV_AUDIO_PRIORITY_ENTRY_VER NV_AUDIO_PRIORITY_ENTRY_VER1
NVAPI_INTERFACE NvAPI_GPU_GetAudioDeviceEntryPriorityList(NvU32 rootConnectorId, NV_AUDIO_PRIORITY_ENUM type,
                                                          NV_AUDIO_PRIORITY_ENTRY *pDeviceEntries, NvU32 *pNumEntries);
NVAPI_INTERFACE NvAPI_GPU_SetAudioDeviceEntryPriorityList(NvU32 rootConnectorId, NV_AUDIO_PRIORITY_ENUM type,
                                                          NV_AUDIO_PRIORITY_ENTRY *pDeviceEntries, NvU32 *pNumEntries);
NVAPI_INTERFACE NvAPI_GPU_GetMaxAudioStreamCount(__in NvU32 displayId, __out_opt NvU32 *pGpuAudioStreamsCount,
                                                 __out_opt NvU32 *pConnectorAudioStreamsCount);
#define NVAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR 16
#define NV_GET_AUDIO_STREAMS_STATE_TYPE_DEFAULT NV_BIT(0)
#define NV_GET_AUDIO_STREAMS_STATE_TYPE_PREFERRED NV_BIT(1)
#define NV_GET_AUDIO_STREAMS_STATE_TYPE_ENABLED NV_BIT(2)
#define NV_GET_AUDIO_STREAMS_STATE_TYPE_ACTIVE NV_BIT(3)
#define NV_GET_AUDIO_STREAMS_STATE_TYPE_MUTED NV_BIT(4)
typedef enum _NV_GET_AUDIO_DEVICE_TYPE {
  NV_GET_AUDIO_ONLY_DEVICE = 1,
  NV_GET_AUDIO_AND_VIDEO_DEVICE
} NV_GET_AUDIO_DEVICE_TYPE;
typedef struct {
  NV_GET_AUDIO_DEVICE_TYPE deviceType;
  NvU32 stateTypeFlags;
  NvU32 audioStreamDisplayId;
} NV_AUDIO_STREAMS;
typedef struct {
  NvU32 version;
  NvU32 audioStreamCount;
  NV_AUDIO_STREAMS audioStreams[NVAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR];
} NV_GET_AUDIO_STREAMS_V1;
typedef NV_GET_AUDIO_STREAMS_V1 NV_GET_AUDIO_STREAMS;
#define NV_GET_AUDIO_STREAMS_VER MAKE_NVAPI_VERSION(NV_GET_AUDIO_STREAMS_V1, 1)
NVAPI_INTERFACE NvAPI_GPU_GetAudioStreams(__in NvU32 rootDisplayId, __inout NV_GET_AUDIO_STREAMS *pAudioStreamEntries);
typedef enum _NV_SET_AUDIO_STREAMS_STATE_ENUM {
  NV_SET_AUDIO_STREAMS_STATE_ENABLE = 1,
  NV_SET_AUDIO_STREAMS_STATE_PREFER,
  NV_SET_AUDIO_STREAMS_STATE_DISABLE,
  NV_SET_AUDIO_STREAMS_STATE_MUTE,
  NV_SET_AUDIO_STREAMS_STATE_UNMUTE
} NV_SET_AUDIO_STREAMS_STATE_ENUM;
typedef struct {
  NvU32 version;
  NV_SET_AUDIO_STREAMS_STATE_ENUM type;
  NvU32 rootDisplayId;
  NvU32 audioStreamCount;
  NvU32 audioStreamDisplayIds[NVAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR];
  NvU8 status[NVAPI_MAX_AUDIO_STREAMS_PER_CONNECTOR];
} NV_SET_AUDIO_STREAMS_V1;
typedef NV_SET_AUDIO_STREAMS_V1 NV_SET_AUDIO_STREAMS;
#define NV_SET_AUDIO_STREAMS_VER MAKE_NVAPI_VERSION(NV_SET_AUDIO_STREAMS_V1, 1)
NVAPI_INTERFACE NvAPI_GPU_SetAudioStreams(__inout_ecount(audioStreamEntriesCount)
                                              NV_SET_AUDIO_STREAMS *pAudioStreamEntries,
                                          __in NvU32 audioStreamEntriesCount);
NV_DECLARE_HANDLE(NvDRSSessionHandle);
NV_DECLARE_HANDLE(NvDRSProfileHandle);
#define NVAPI_DRS_GLOBAL_PROFILE ((NvDRSProfileHandle) - 1)
#define NVAPI_SETTING_MAX_VALUES 100
typedef enum _NVDRS_SETTING_TYPE {
  NVDRS_DWORD_TYPE,
  NVDRS_BINARY_TYPE,
  NVDRS_STRING_TYPE,
  NVDRS_WSTRING_TYPE
} NVDRS_SETTING_TYPE;
typedef enum _NVDRS_SETTING_LOCATION {
  NVDRS_CURRENT_PROFILE_LOCATION,
  NVDRS_GLOBAL_PROFILE_LOCATION,
  NVDRS_BASE_PROFILE_LOCATION,
  NVDRS_DEFAULT_PROFILE_LOCATION
} NVDRS_SETTING_LOCATION;
typedef struct _NVDRS_GPU_SUPPORT {
  NvU32 geforce : 1;
  NvU32 quadro : 1;
  NvU32 nvs : 1;
  NvU32 reserved4 : 1;
  NvU32 reserved5 : 1;
  NvU32 reserved6 : 1;
  NvU32 reserved7 : 1;
  NvU32 reserved8 : 1;
  NvU32 reserved9 : 1;
  NvU32 reserved10 : 1;
  NvU32 reserved11 : 1;
  NvU32 reserved12 : 1;
  NvU32 reserved13 : 1;
  NvU32 reserved14 : 1;
  NvU32 reserved15 : 1;
  NvU32 reserved16 : 1;
  NvU32 reserved17 : 1;
  NvU32 reserved18 : 1;
  NvU32 reserved19 : 1;
  NvU32 reserved20 : 1;
  NvU32 reserved21 : 1;
  NvU32 reserved22 : 1;
  NvU32 reserved23 : 1;
  NvU32 reserved24 : 1;
  NvU32 reserved25 : 1;
  NvU32 reserved26 : 1;
  NvU32 reserved27 : 1;
  NvU32 reserved28 : 1;
  NvU32 reserved29 : 1;
  NvU32 reserved30 : 1;
  NvU32 reserved31 : 1;
  NvU32 reserved32 : 1;
} NVDRS_GPU_SUPPORT;
typedef struct _NVDRS_BINARY_SETTING {
  NvU32 valueLength;
  NvU8 valueData[NVAPI_BINARY_DATA_MAX];
} NVDRS_BINARY_SETTING;
typedef struct _NVDRS_SETTING_VALUES {
  NvU32 version;
  NvU32 numSettingValues;
  NVDRS_SETTING_TYPE settingType;
  union {
    NvU32 u32DefaultValue;
    NVDRS_BINARY_SETTING binaryDefaultValue;
    NvAPI_UnicodeString wszDefaultValue;
  };
  union {
    NvU32 u32Value;
    NVDRS_BINARY_SETTING binaryValue;
    NvAPI_UnicodeString wszValue;
  } settingValues[NVAPI_SETTING_MAX_VALUES];
} NVDRS_SETTING_VALUES;
#define NVDRS_SETTING_VALUES_VER MAKE_NVAPI_VERSION(NVDRS_SETTING_VALUES, 1)
typedef struct _NVDRS_SETTING_V1 {
  NvU32 version;
  NvAPI_UnicodeString settingName;
  NvU32 settingId;
  NVDRS_SETTING_TYPE settingType;
  NVDRS_SETTING_LOCATION settingLocation;
  NvU32 isCurrentPredefined;
  NvU32 isPredefinedValid;
  union {
    NvU32 u32PredefinedValue;
    NVDRS_BINARY_SETTING binaryPredefinedValue;
    NvAPI_UnicodeString wszPredefinedValue;
  };
  union {
    NvU32 u32CurrentValue;
    NVDRS_BINARY_SETTING binaryCurrentValue;
    NvAPI_UnicodeString wszCurrentValue;
  };
} NVDRS_SETTING_V1;
#define NVDRS_SETTING_VER1 MAKE_NVAPI_VERSION(NVDRS_SETTING_V1, 1)
typedef NVDRS_SETTING_V1 NVDRS_SETTING;
#define NVDRS_SETTING_VER NVDRS_SETTING_VER1
typedef struct _NVDRS_APPLICATION_V1 {
  NvU32 version;
  NvU32 isPredefined;
  NvAPI_UnicodeString appName;
  NvAPI_UnicodeString userFriendlyName;
  NvAPI_UnicodeString launcher;
} NVDRS_APPLICATION_V1;
typedef struct _NVDRS_APPLICATION_V2 {
  NvU32 version;
  NvU32 isPredefined;
  NvAPI_UnicodeString appName;
  NvAPI_UnicodeString userFriendlyName;
  NvAPI_UnicodeString launcher;
  NvAPI_UnicodeString fileInFolder;
} NVDRS_APPLICATION_V2;
typedef struct _NVDRS_APPLICATION_V3 {
  NvU32 version;
  NvU32 isPredefined;
  NvAPI_UnicodeString appName;
  NvAPI_UnicodeString userFriendlyName;
  NvAPI_UnicodeString launcher;
  NvAPI_UnicodeString fileInFolder;
  NvU32 isMetro : 1;
  NvU32 isCommandLine : 1;
  NvU32 reserved : 30;
} NVDRS_APPLICATION_V3;
typedef struct _NVDRS_APPLICATION_V4 {
  NvU32 version;
  NvU32 isPredefined;
  NvAPI_UnicodeString appName;
  NvAPI_UnicodeString userFriendlyName;
  NvAPI_UnicodeString launcher;
  NvAPI_UnicodeString fileInFolder;
  NvU32 isMetro : 1;
  NvU32 isCommandLine : 1;
  NvU32 reserved : 30;
  NvAPI_UnicodeString commandLine;
} NVDRS_APPLICATION_V4;
#define NVDRS_APPLICATION_VER_V1 MAKE_NVAPI_VERSION(NVDRS_APPLICATION_V1, 1)
#define NVDRS_APPLICATION_VER_V2 MAKE_NVAPI_VERSION(NVDRS_APPLICATION_V2, 2)
#define NVDRS_APPLICATION_VER_V3 MAKE_NVAPI_VERSION(NVDRS_APPLICATION_V3, 3)
#define NVDRS_APPLICATION_VER_V4 MAKE_NVAPI_VERSION(NVDRS_APPLICATION_V4, 4)
typedef NVDRS_APPLICATION_V4 NVDRS_APPLICATION;
#define NVDRS_APPLICATION_VER NVDRS_APPLICATION_VER_V4
typedef struct _NVDRS_PROFILE_V1 {
  NvU32 version;
  NvAPI_UnicodeString profileName;
  NVDRS_GPU_SUPPORT gpuSupport;
  NvU32 isPredefined;
  NvU32 numOfApps;
  NvU32 numOfSettings;
} NVDRS_PROFILE_V1;
typedef NVDRS_PROFILE_V1 NVDRS_PROFILE;
#define NVDRS_PROFILE_VER1 MAKE_NVAPI_VERSION(NVDRS_PROFILE_V1, 1)
#define NVDRS_PROFILE_VER NVDRS_PROFILE_VER1
NVAPI_INTERFACE NvAPI_DRS_CreateSession(NvDRSSessionHandle *phSession);
NVAPI_INTERFACE NvAPI_DRS_DestroySession(NvDRSSessionHandle hSession);
NVAPI_INTERFACE NvAPI_DRS_LoadSettings(NvDRSSessionHandle hSession);
NVAPI_INTERFACE NvAPI_DRS_LoadGoldSettings(NvDRSSessionHandle hSession);
NVAPI_INTERFACE NvAPI_DRS_LoadDefaultSettings(__in NvDRSSessionHandle hSession);
NVAPI_INTERFACE NvAPI_DRS_DecryptSession(__in NvDRSSessionHandle hSession);
NVAPI_INTERFACE NvAPI_DRS_SaveSettings(NvDRSSessionHandle hSession);
NVAPI_INTERFACE NvAPI_DRS_SaveSettingsEx(__in NvDRSSessionHandle hSession, __inout NvU64 *pFileModifiedTime);
NVAPI_INTERFACE NvAPI_DRS_LoadSettingsFromFile(NvDRSSessionHandle hSession, NvAPI_UnicodeString fileName);
NVAPI_INTERFACE NvAPI_DRS_SaveSettingsToFile(NvDRSSessionHandle hSession, NvAPI_UnicodeString fileName);
NVAPI_INTERFACE NvAPI_DRS_SaveSettingsToPrdFile(NvDRSSessionHandle hSession, NvAPI_UnicodeString fileName);
NVAPI_INTERFACE NvAPI_DRS_LoadSettingsFromPrdFile(NvDRSSessionHandle hSession, NvAPI_UnicodeString fileName);
NVAPI_INTERFACE NvAPI_DRS_CreateProfile(NvDRSSessionHandle hSession, NVDRS_PROFILE *pProfileInfo,
                                        NvDRSProfileHandle *phProfile);
NVAPI_INTERFACE NvAPI_DRS_DeleteProfile(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile);
NVAPI_INTERFACE NvAPI_DRS_SetCurrentGlobalProfile(NvDRSSessionHandle hSession,
                                                  NvAPI_UnicodeString wszGlobalProfileName);
NVAPI_INTERFACE NvAPI_DRS_GetCurrentGlobalProfile(NvDRSSessionHandle hSession, NvDRSProfileHandle *phProfile);
NVAPI_INTERFACE NvAPI_DRS_GetProfileInfo(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                         NVDRS_PROFILE *pProfileInfo);
NVAPI_INTERFACE NvAPI_DRS_SetProfileInfo(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                         NVDRS_PROFILE *pProfileInfo);
NVAPI_INTERFACE NvAPI_DRS_FindProfileByName(NvDRSSessionHandle hSession, NvAPI_UnicodeString profileName,
                                            NvDRSProfileHandle *phProfile);
NVAPI_INTERFACE NvAPI_DRS_EnumProfiles(NvDRSSessionHandle hSession, NvU32 index, NvDRSProfileHandle *phProfile);
NVAPI_INTERFACE NvAPI_DRS_GetNumProfiles(NvDRSSessionHandle hSession, NvU32 *numProfiles);
NVAPI_INTERFACE NvAPI_DRS_CreateApplication(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                            NVDRS_APPLICATION *pApplication);
NVAPI_INTERFACE NvAPI_DRS_DeleteApplicationEx(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                              NVDRS_APPLICATION *pApp);
NVAPI_INTERFACE NvAPI_DRS_DeleteApplication(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                            NvAPI_UnicodeString appName);
NVAPI_INTERFACE NvAPI_DRS_GetApplicationInfo(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                             NvAPI_UnicodeString appName, NVDRS_APPLICATION *pApplication);
NVAPI_INTERFACE NvAPI_DRS_EnumApplications(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 startIndex,
                                           NvU32 *appCount, NVDRS_APPLICATION *pApplication);
NVAPI_INTERFACE NvAPI_DRS_FindApplicationByName(__in NvDRSSessionHandle hSession, __in NvAPI_UnicodeString appName,
                                                __out NvDRSProfileHandle *phProfile,
                                                __inout NVDRS_APPLICATION *pApplication);
NVAPI_INTERFACE NvAPI_DRS_SetSetting(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NVDRS_SETTING *pSetting);
NVAPI_INTERFACE NvAPI_DRS_GetSetting(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 settingId,
                                     NVDRS_SETTING *pSetting);
NVAPI_INTERFACE NvAPI_DRS_EnumSettings(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 startIndex,
                                       NvU32 *settingsCount, NVDRS_SETTING *pSetting);
NVAPI_INTERFACE NvAPI_DRS_EnumAvailableSettingIds(NvU32 *pSettingIds, NvU32 *pMaxCount);
NVAPI_INTERFACE NvAPI_DRS_EnumAvailableSettingValues(NvU32 settingId, NvU32 *pMaxNumValues,
                                                     NVDRS_SETTING_VALUES *pSettingValues);
NVAPI_INTERFACE NvAPI_DRS_GetSettingIdFromName(NvAPI_UnicodeString settingName, NvU32 *pSettingId);
NVAPI_INTERFACE NvAPI_DRS_GetSettingNameFromId(NvU32 settingId, NvAPI_UnicodeString *pSettingName);
NVAPI_INTERFACE NvAPI_DRS_DeleteProfileSetting(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                               NvU32 settingId);
NVAPI_INTERFACE NvAPI_DRS_RestoreAllDefaults(NvDRSSessionHandle hSession);
NVAPI_INTERFACE NvAPI_DRS_RestoreDefaultSettings(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile,
                                                 __in_ecount_opt(numSettings) NvU32 *pSettingIds,
                                                 __in NvU32 numSettings, __in NvU8 bIgnore);
NVAPI_INTERFACE NvAPI_DRS_RestoreProfileDefault(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile);
NVAPI_INTERFACE NvAPI_DRS_RestoreProfileDefaultSetting(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                                       NvU32 settingId);
NVAPI_INTERFACE NvAPI_DRS_EnumUISettingValues(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                              NvU32 startIndex, NvU32 *settingsCount, NVDRS_SETTING *pSetting);
NVAPI_INTERFACE NvAPI_DRS_GetDefaultGlobalProfile(NvDRSSessionHandle hSession, NvDRSProfileHandle *phProfile);
NVAPI_INTERFACE NvAPI_DRS_FindApplicationEx(__in NvDRSSessionHandle hSession, __in NvU32 exactMatch,
                                            __inout NVDRS_APPLICATION *pApplication,
                                            __out NvDRSProfileHandle *phProfile);
typedef struct _NVDRS_VERSION_INFORMATION {
  NvU32 version;
  NvAPI_LongString driverTitle;
  NvAPI_UnicodeString systemDrsPath;
  NvU32 changelistNumber;
  NvU32 drslibVersion;
} NVDRS_VERSION_INFORMATION;
#define NVDRS_VERSION_INFORMATION_VER MAKE_NVAPI_VERSION(NVDRS_VERSION_INFORMATION, 1)
NVAPI_INTERFACE NvAPI_DRS_GetSystemDrsVersion(NVDRS_VERSION_INFORMATION *pVersionInformation);
NVAPI_INTERFACE NvAPI_DRS_GetGoldDBDrsVersion(NVDRS_VERSION_INFORMATION *pVersionInformation);
NVAPI_INTERFACE NvAPI_DRS_GetGoldDBDrsVersionEx(NVDRS_VERSION_INFORMATION *pVersionInformation);
typedef enum _NVDRS_VERSION_TARGET { NVDRS_SYSTEM_DB = 0, NVDRS_GOLD_DB, NVDRS_UPDATE_DB } NVDRS_VERSION_TARGET;
NVAPI_INTERFACE NvAPI_DRS_GetDrsVersion(NVDRS_VERSION_TARGET target, NVDRS_VERSION_INFORMATION *pVersionInformation);
NVAPI_INTERFACE NvAPI_DRS_SetBaseProfile(NvDRSSessionHandle hSession, NvAPI_UnicodeString wszBaseProfileName);
NVAPI_INTERFACE NvAPI_DRS_GetBaseProfile(NvDRSSessionHandle hSession, NvDRSProfileHandle *phProfile);
NVAPI_INTERFACE NvAPI_DRS_SetSettingEx(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                       NVDRS_SETTING *pSetting, NvU32 isPredefined, NvU32 isOverride);
NVAPI_INTERFACE NvAPI_DRS_GetSettingEx(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile, NvU32 settingId,
                                       NVDRS_SETTING *pSetting, NvU32 *isOverride);
NVAPI_INTERFACE NvAPI_DRS_CreateApplicationEx(NvDRSSessionHandle hSession, NvDRSProfileHandle hProfile,
                                              NVDRS_APPLICATION *pApplication, NvU32 isPredefined);
NVAPI_INTERFACE NvAPI_DRS_CreateProfileEx(NvDRSSessionHandle hSession, NVDRS_PROFILE *pProfileInfo,
                                          NvDRSProfileHandle *phProfile, NvU32 isPredefined);
typedef enum _NVDRS_FEATURE_ID {
  NVDRS_FEATURE_ID_UNKNOWN = 0,
  NVDRS_FEATURE_ID_MFAA,
} NVDRS_FEATURE_ID;
typedef enum _NVDRS_FEATURE_MFAA_VALUES {
  NVDRS_FEATURE_MFAA_UNKNOWN = 0,
  NVDRS_FEATURE_MFAA_OFF,
  NVDRS_FEATURE_MFAA_ON,
} NVDRS_FEATURE_MFAA_VALUES;
typedef union _NVDRS_VALUE_V1 {
  NvU32 u32Value;
  NVDRS_BINARY_SETTING binaryValue;
  NvAPI_LongString wszValue;
} NVDRS_VALUE_V1, *PNVDRS_VALUE_V1;
typedef enum _NVDRS_SETTING_FLAGS_V1 {
  NVDRS_SETTING_NOT_SUPPORTED = 0x00000001,
  NVDRS_SETTING_DISABLED = 0X00000010,
  NVDRS_SETTING_ENABLED = 0X00000100,
  NVDRS_SETTING_RANGE_VALUES = 0X00001000
} NVDRS_SETTING_FLAGS_V1;
typedef struct _NVDRS_SETTING_DETAILS_V1 {
  NvU32 version;
  NvAPI_LongString settingName;
  NvU32 settingId;
  NVDRS_SETTING_TYPE settingType;
  NVDRS_SETTING_LOCATION settingLocation;
  NvU32 flags;
  NvU32 isCurrentValid;
  NvU32 isPredefinedValid;
  NVDRS_VALUE_V1 predefinedValue;
  NVDRS_VALUE_V1 currentValue;
} NVDRS_SETTING_DETAILS_V1;
#define NVDRS_SETTING_DETAILS_VER1 MAKE_NVAPI_VERSION(NVDRS_SETTING_V1, 1)
typedef NVDRS_SETTING_DETAILS_V1 NVDRS_SETTING_DETAILS;
#define NVDRS_SETTING_DETAILS_VER NVDRS_SETTING_DETAILS_VER1
typedef struct _NVDRS_SETTING_INFO_V1 {
  NvU32 version;
  NVDRS_SETTING_V1 settingDetails;
  NvU32 numSupportedValues;
  union {
    NvU32 u32Value;
    NVDRS_BINARY_SETTING binaryValue;
    NvAPI_UnicodeString wszValue;
  } supportedValues[NVAPI_SETTING_MAX_VALUES];
} NVDRS_SETTING_INFO_V1;
typedef struct _NVDRS_SETTING_INFO_V2 {
  NvU32 version;
  NVDRS_SETTING_DETAILS_V1 settingDetails;
  NvU32 isDefaultValid;
  NvU32 numSupportedValues;
  NvU32 numValues;
  NVDRS_VALUE_V1 defaultValue;
  PNVDRS_VALUE_V1 supportedValues;
} NVDRS_SETTING_INFO_V2;
#define NVDRS_SETTING_INFO_VER1 MAKE_NVAPI_VERSION(NVDRS_SETTING_INFO_V1, 1)
#define NVDRS_SETTING_INFO_VER2 MAKE_NVAPI_VERSION(NVDRS_SETTING_INFO_V2, 1)
typedef NVDRS_SETTING_INFO_V2 NVDRS_SETTING_INFO;
#define NVDRS_SETTING_INFO_VER NVDRS_SETTING_INFO_VER2
NVAPI_INTERFACE NvAPI_DRS_GetSettingInfo(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile,
                                         __in NvU32 settingId, __inout NVDRS_SETTING_INFO *pSettingInfo);
NVAPI_INTERFACE NvAPI_DRS_SetProfileData(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile,
                                         __in NvU32 settingsCount, __in NVDRS_SETTING *pSetting);
typedef enum _NVDRS_SETTING_ENUMERATOR_FLAGS_V1 {
  NVDRS_SETTING_ENUMERATOR_NODETAILS = 0x00000000,
  NVDRS_SETTING_ENUMERATOR_DETAILS = 0x00000001,
  NVDRS_SETTING_ENUMERATOR_OPTIMIZED = 0x00000010
} NVDRS_SETTING_ENUMERATOR_FLAGS_V1;
NVAPI_INTERFACE NvAPI_DRS_EnumSettingInfo(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile,
                                          __in NvU32 startIndex, __in NvU32 enumeratorFlags,
                                          __inout NvU32 *featureCount, __inout NVDRS_SETTING_INFO *pSettingInfo);
NVAPI_INTERFACE NvAPI_DRS_RestoreSettingsInfo(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile,
                                              __in_ecount_opt(numFeatures) NvU32 *settingId, __in NvU32 numFeatures,
                                              __in NvU8 bIgnore);
NVAPI_INTERFACE NvAPI_DRS_GetLastDBChangeTime(__out NvU64 *pLastModifyTime);
NVAPI_INTERFACE NvAPI_DRS_GetSettingForCurrentProcess(__in NvU32 settingId, __inout NVDRS_SETTING *pSettingInfo);
NVAPI_INTERFACE NvAPI_DRS_EnumAvailableSettingValuesEx(__in NvU32 settingId, __out NvU32 *pMaxNumValues,
                                                       __inout NVDRS_SETTING_VALUES *pSettingValues);
NVAPI_INTERFACE NvAPI_DRS_EnumSettingsEx(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile,
                                         __in NvU32 startIndex, __out NvU32 *settingsCount,
                                         __inout NVDRS_SETTING *pSetting);
NVAPI_INTERFACE NvAPI_DRS_EnumAvailableSettingIdsEx(NvU32 *pSettingIds, __out NvU32 *pMaxCount);
NVAPI_INTERFACE NvAPI_DRS_GetSettingIdFromNameEx(__in NvAPI_UnicodeString settingName, __out NvU32 *pSettingId);
NVAPI_INTERFACE NvAPI_DRS_GetSettingNameFromIdEx(__in NvU32 settingId, __out NvAPI_UnicodeString *pSettingName);
NVAPI_INTERFACE NvAPI_DRS_DeleteProfileSettingEx(__in NvDRSSessionHandle hSession, __in NvDRSProfileHandle hProfile,
                                                 __in NvU32 settingId);
NVAPI_INTERFACE NvAPI_DRS_RestoreProfileDefaultSettingEx(__in NvDRSSessionHandle hSession,
                                                         __in NvDRSProfileHandle hProfile, __in NvU32 settingId);
#define DP_MST_MAX_EDID_DATA_SIZE 512
typedef struct {
  NvU32 version;
  NvU32 deviceType;
  NvU32 upstreamPorts;
  NvU32 downstreamPorts;
  NvU32 validPorts;
  NvU8 edidBuffer[DP_MST_MAX_EDID_DATA_SIZE];
  NvU32 edidLen;
  NvU8 GUID[16];
  NvU32 hasRevision12 : 1;
  NvU32 hasAudio : 1;
  NvU32 reserved : 30;
} NV_DPFAKE_DEVICE_INFO_V1;
typedef struct {
  NvU32 version;
  NvU32 deviceType;
  NvU32 upstreamPorts;
  NvU32 downstreamPorts;
  NvU32 validPorts;
  NvU8 edidBuffer[DP_MST_MAX_EDID_DATA_SIZE];
  NvU32 edidLen;
  NvU8 GUID[16];
  NvU32 hasRevision12 : 1;
  NvU32 hasRevision14 : 1;
  NvU32 hasAudio : 1;
  NvU32 reserved : 29;
} NV_DPFAKE_DEVICE_INFO_V2;
#define NV_DPFAKE_DEVICE_INFO_VER1 MAKE_NVAPI_VERSION(NV_DPFAKE_DEVICE_INFO_V1, 1)
#define NV_DPFAKE_DEVICE_INFO_VER2 MAKE_NVAPI_VERSION(NV_DPFAKE_DEVICE_INFO_V2, 2)
#define NV_DPFAKE_DEVICE_INFO_VER NV_DPFAKE_DEVICE_INFO_VER2
typedef NV_DPFAKE_DEVICE_INFO_V2 NV_DPFAKE_DEVICE_INFO;
typedef struct {
  NvU32 version;
  NvU32 lanes;
  NvU64 peakRate;
  NvU64 minRate;
  NvU32 currentUsedPBN;
  NvU32 isEnhancedFraming : 1;
  NvU32 isValid : 1;
  NvU32 isInput : 1;
  NvU32 isPlugged : 1;
  NvU32 isMultiStream : 1;
  NvU32 reserved : 27;
} NV_DPFAKE_DEVICE_CONNECTION_INFO_V1;
#define NV_DPFAKE_DEVICE_CONNECTION_INFO_VER1 MAKE_NVAPI_VERSION(NV_DPFAKE_DEVICE_CONNECTION_INFO_V1, 1)
#define NV_DPFAKE_DEVICE_CONNECTION_INFO_VER NV_DPFAKE_DEVICE_CONNECTION_INFO_VER1
typedef NV_DPFAKE_DEVICE_CONNECTION_INFO_V1 NV_DPFAKE_DEVICE_CONNECTION_INFO;
NVAPI_INTERFACE NvAPI_DPFAKE_CreateModel(__in NvU32 displayId);
NVAPI_INTERFACE NvAPI_DPFAKE_DestroyModel(__in NvU32 displayId, __in NvU32 afterMsecs);
NVAPI_INTERFACE NvAPI_DPFAKE_StopSimulation(__in NvU32 displayId, __in NvU32 afterMsecs);
NVAPI_INTERFACE NvAPI_DPFAKE_StartSimulation(__in NvU32 displayId, __in NvU32 fakeDeviceRootId, __in NvU32 afterMsecs);
NVAPI_INTERFACE NvAPI_DPFAKE_ConnectDevice(__in NvU32 displayId, __in NvU32 fakeDeviceparentId,
                                           __in NvU32 fakeDeviceParentPort, __in NvU32 fakeDeviceChildId,
                                           __in NvU32 fakeDeviceChildPort, __in NvU32 afterMsecs);
NVAPI_INTERFACE NvAPI_DPFAKE_DisconnectDevice(__in NvU32 displayId, __in NvU32 fakeDeviceId, __in NvU32 fakeDevicePort,
                                              __in NvU32 afterMsecs);
NVAPI_INTERFACE NvAPI_DPFAKE_NewFakeDevice(__in NvU32 displayId, __in NV_DPFAKE_DEVICE_INFO *pDpFakeDeviceInfo,
                                           __out NvU32 *pFakeDeviceId);
NVAPI_INTERFACE NvAPI_DPFAKE_ChangeBandwidthOnLink(__in NvU32 displayId, __in NvU32 fakeDeviceId,
                                                   __in NvU32 fakeDevicePort, __in NvU64 newRate, __in NvU32 newLanes,
                                                   __in NvU8 isLinkSupportedChange, __in NvU32 afterMsecs);
NVAPI_INTERFACE NvAPI_DPFAKE_GetFakeDeviceProperties(__in NvU32 displayId, __in NvU32 fakeDeviceId,
                                                     __inout NV_DPFAKE_DEVICE_INFO *pDpFakeDeviceInfo);
NVAPI_INTERFACE NvAPI_DPFAKE_GetDeviceConnectionProperties(__in NvU32 displayId, __in NvU32 fakeDeviceId,
                                                           __in NvU32 fakeDevicePort,
                                                           __inout NV_DPFAKE_DEVICE_CONNECTION_INFO *pDpFakeDeviceInfo);
NVAPI_INTERFACE NvAPI_DPFAKE_CheckSimulationStatus(__in NvU32 displayId, __out NvU32 *fakeModelStatus,
                                                   __out NvU32 *simulationStatus, __out NvU32 *simulationSetupStatus);
NVAPI_INTERFACE NvAPI_DPFAKE_NotifySimulationSetupCompletion(__in NvU32 displayId, __in NvU32 afterMsecs);
NVAPI_INTERFACE NvAPI_DPFAKE_ResetDPAssertBuffer(__in NvU32 displayId);
typedef struct {
  NvU32 version;
  NvU64 breakpointAddr;
} NV_DPFAKE_DP_ASSERT_HIT_RECORD_V1;
#define NV_DPFAKE_DP_ASSERT_HIT_RECORD_VER1 MAKE_NVAPI_VERSION(NV_DPFAKE_DP_ASSERT_HIT_RECORD_V1, 1)
#define NV_DPFAKE_DP_ASSERT_HIT_RECORD_VER NV_DPFAKE_DP_ASSERT_HIT_RECORD_VER1
typedef NV_DPFAKE_DP_ASSERT_HIT_RECORD_V1 NV_DPFAKE_DP_ASSERT_HIT_RECORD;
typedef struct {
  NvU32 version;
  char msg[100];
  NvU64 addr;
} NV_DPFAKE_DP_LOG_CALL_RECORD_V1;
#define NV_DPFAKE_DP_LOG_CALL_RECORD_VER1 MAKE_NVAPI_VERSION(NV_DPFAKE_DP_LOG_CALL_RECORD_V1, 1)
#define NV_DPFAKE_DP_LOG_CALL_RECORD_VER NV_DPFAKE_DP_LOG_CALL_RECORD_VER1
typedef NV_DPFAKE_DP_LOG_CALL_RECORD_V1 NV_DPFAKE_DP_LOG_CALL_RECORD;
#define NV_DPFAKE_DP_LOG_MAX_MESSAGE_LEN 100
#define NV_DPFAKE_DP_LOG_MAX_RECORD_COUNT 15
typedef enum _NV_DPFAKE_DP_LOG_QUERY_TYPE {
  NV_DPFAKE_DP_LOG_QUERY_SIZE = 0,
  NV_DPFAKE_DP_LOG_QUERY_ASSERT = 1,
  NV_DPFAKE_DP_LOG_QUERY_DPLOGS = 2,
} NV_DPFAKE_DP_LOG_QUERY_TYPE;
typedef union _NV_DPFAKE_DP_LOG_RECORD {
  NV_DPFAKE_DP_ASSERT_HIT_RECORD dpAssertHitRecord;
  NV_DPFAKE_DP_LOG_CALL_RECORD dpLogCallRecord;
} NV_DPFAKE_DP_LOG_RECORD;
NVAPI_INTERFACE NvAPI_DPFAKE_QueryDPLogs(__in NvU32 displayId, __in NV_DPFAKE_DP_LOG_QUERY_TYPE logQueryType,
                                         __out NV_DPFAKE_DP_LOG_RECORD *records, __inout NvU32 *numRecords);
typedef struct {
  NvU32 version;
  NvU32 TDRcount;
  NvU32 RCcount;
  NvU32 maxConsecutiveRC;
} NV_TDR_INFO_V1;
typedef NV_TDR_INFO_V1 NV_TDR_INFO;
#define NV_TDR_INFO_VER_1 MAKE_NVAPI_VERSION(NV_TDR_INFO_V1, 1)
#define NV_TDR_INFO_VER NV_TDR_INFO_VER_1
NVAPI_INTERFACE NvAPI_GPU_GetTDRInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_TDR_INFO *tdrInfo);
typedef struct _NV_DISPLAYID_ENTRY_V1 {
  NvU32 version;
  NvU32 displayId;
  NvU32 targetId;
  NvU32 monitorHandlePosition;
  NvU32 deviceId;
  NvU32 ddmonitorHandlePosition;
  NvU32 rmDisplayID;
  NvU32 rmRootDisplayID;
  NV_DP_ADDRESS rmAuxAddress;
  NvU32 ddClusterId;
} NV_DISPLAYID_ENTRY_V1;
typedef struct _NV_DISPLAYID_ENTRY_V2 {
  NvU32 version;
  NvU32 displayId;
  NvU32 targetId;
  NvU32 monitorHandlePosition;
  NvU32 deviceId;
  NvU32 ddmonitorHandlePosition;
  NvU32 rmDisplayID;
  NvU32 rmRootDisplayID;
  NV_DP_ADDRESS rmAuxAddress;
  NvU32 ddClusterId;
  NvU32 auxHashCode;
} NV_DISPLAYID_ENTRY_V2;
typedef NV_DISPLAYID_ENTRY_V2 NV_DISPLAYID_ENTRY;
#define NV_DISPLAYID_ENTRY_VER1 MAKE_NVAPI_VERSION(NV_DISPLAYID_ENTRY_V1, 1)
#define NV_DISPLAYID_ENTRY_VER2 MAKE_NVAPI_VERSION(NV_DISPLAYID_ENTRY_V2, 2)
#define NV_DISPLAYID_ENTRY_VER NV_DISPLAYID_ENTRY_VER2
NVAPI_INTERFACE NvAPI_DIAG_DumpAllDisplayIds(__in NvPhysicalGpuHandle hPhysicalGpu,
                                             __inout_ecount_part_opt(*pDisplayIdCount, *pDisplayIdCount)
                                                 NV_DISPLAYID_ENTRY *pDisplayIds,
                                             __inout NvU32 *pDisplayIdCount);
typedef struct {
  NvU32 version;
  NvU32 sensorIndex;
  NvS32 hotspotOffset;
} NV_DIAG_THERMAL_SENSOR_INFO_V1;
typedef NV_DIAG_THERMAL_SENSOR_INFO_V1 NV_DIAG_THERMAL_SENSOR_INFO;
#define NV_DIAG_THERMAL_SENSOR_INFO_VER_1 MAKE_NVAPI_VERSION(NV_DIAG_THERMAL_SENSOR_INFO_V1, 1)
#define NV_DIAG_THERMAL_SENSOR_INFO_VER NV_DIAG_THERMAL_SENSOR_INFO_VER_1
NVAPI_INTERFACE NvAPI_Diag_GetThermalSensorInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                NV_DIAG_THERMAL_SENSOR_INFO *pThermalSensorInfo);
NVAPI_INTERFACE NvAPI_GPU_MapGpuTimestampToUsermode(NvPhysicalGpuHandle hPhysicalGpu, NvU32 bUnmap,
                                                    NvU64 **ppMappedTimestamp, NvU32 *pStructSizeInBytes);
typedef struct {
  NvU32 version;
  NvU8 revMin;
  NvU8 revMaj;
  NvU8 verMin;
  NvU8 verMaj;
} NV_SWINSTR_REVISION;
#define NV_SWINSTR_REVISION_VER MAKE_NVAPI_VERSION(NV_SWINSTR_REVISION, 1)
NVAPI_INTERFACE NvAPI_SwInstr_GetInterfaceRevision(NV_SWINSTR_REVISION *pNvSwInstrRev);
typedef enum _NV_SWINSTR_SENSOR_SUBSYSTEM {
  NV_SENSOR_SUBSYSTEM_CPU = 0x01,
  NV_SENSOR_SUBSYSTEM_GPU = 0x02,
  NV_SENSOR_SUBSYSTEM_CHIPSET = 0x04,
  NV_SENSOR_SUBSYSTEM_MEMORY = 0x08,
  NV_SENSOR_SUBSYSTEM_DISPLAY = 0x10,
  NV_SENSOR_SUBSYSTEM_NETWORK = 0x20,
  NV_SENSOR_SUBSYSTEM_PS = 0x40,
  NV_SENSOR_SUBSYSTEM_SKIN = 0x80,
  NV_SENSOR_SUBSYSTEM_ALL = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_SUBSYSTEM;
typedef enum _NV_SWINSTR_SENSOR_COMPONENT {
  NV_SENSOR_COMPONENT_CORE = 0x01,
  NV_SENSOR_COMPONENT_MEMORY = 0x02,
  NV_SENSOR_COMPONENT_BUS = 0x04,
  NV_SENSOR_COMPONENT_PS = 0x08,
  NV_SENSOR_COMPONENT_ALL = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_COMPONENT;
typedef enum _NV_SWINSTR_SENSOR_GPU_CORE_PARTITION {
  NV_SENSOR_PARTITION_GPU_FB = 0x01,
  NV_SENSOR_PARTITION_GPU_RENDER = 0x02,
  NV_SENSOR_PARTITION_GPU_HOST = 0x04,
  NV_SENSOR_PARTITION_GPU_DISPLAY = 0x08,
  NV_SENSOR_PARTITION_GPU_VIDEO = 0x10,
  NV_SENSOR_PARTITION_GPU_ALL = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_GPU_CORE_PARTITION;
typedef enum _NV_SWINSTR_SENSOR_GFX_LM_PARTITION {
  NV_SENSOR_PARTITION_GFX_LM_LOGIC = 0x01,
  NV_SENSOR_PARTITION_GFX_LM_DATA = 0x02,
  NV_SENSOR_PARTITION_GFX_LM_TOTAL = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_GFX_LM_PARTITION;
typedef enum _NV_SWINSTR_SENSOR_GFX_BUS_PARTITION {
  NV_SENSOR_PARTITION_GFX_BUS_PCIE = 0x01,
  NV_SENSOR_PARTITION_GFX_BUS_MEMORY = 0x02,
  NV_SENSOR_PARTITION_GFX_BUS_MIO = 0x04,
  NV_SENSOR_PARTITION_GFX_BUS_TOTAL = 0xFFFFFFFF,
} NV_SWINSTR_SENSOR_GFX_BUS_PARTITION;
typedef enum _NV_SWINSTR_MEASUREMENT_TYPE {
  NV_SENSOR_MEASURE_UNKNOWN = 0x00,
  NV_SENSOR_MEASURE_ALTRSVD = 0x01,
  NV_SENSOR_MEASURE_UTIL = 0x02,
  NV_SENSOR_MEASURE_PERF_STATE = 0x04,
  NV_SENSOR_MEASURE_ABS_POWER = 0x08,
  NV_SENSOR_MEASURE_TEMP = 0x10,
  NV_SENSOR_MEASURE_REL_POWER = 0x20,
} NV_SWINSTR_MEASUREMENT_TYPE;
typedef struct {
  NvU32 subSystem;
  NvU32 component;
  NvU32 partition;
  NvU32 instance;
} NV_SWINSTR_SENSOR_LOCATION;
typedef struct {
  NV_SWINSTR_SENSOR_LOCATION sensorLocation;
  NvU32 measurementType;
} NV_SWINSTR_SENSOR_POINT;
#define NV_SWINSTR_MAX_SENSOR_POINTS (0x00000020)
typedef struct {
  NvU32 version;
  NvU32 numPoints;
  NV_SWINSTR_SENSOR_POINT sensorPoints[NV_SWINSTR_MAX_SENSOR_POINTS];
} NV_SWINSTR_SENSOR_POINTS;
#define NV_SWINSTR_SENSOR_POINTS_VER MAKE_NVAPI_VERSION(NV_SWINSTR_SENSOR_POINTS, 1)
NVAPI_INTERFACE NvAPI_SwInstr_GetSensorPoints(NV_SWINSTR_SENSOR_POINTS *pNvSwInstrSensorPoints);
typedef struct {
  NvU32 version;
  struct {
    unsigned bMovingAverage : 1;
    unsigned bMASampleWindow : 1;
    unsigned bMAWindowSamples : 1;
    unsigned powerPosErr : 7;
    unsigned powerNegErr : 7;
    unsigned tempPosErr : 7;
    unsigned tempNegErr : 7;
  } caps;
  NvU32 maxSamples;
  NvU32 minMovingAverageWindow;
  NvU32 maxMovingAverageWindow;
  NvU32 minSampleRate;
  NvU32 maxPerfSampleRate;
  NvU32 maxPowerSampleRate;
  NvU32 maxTempSampleRate;
  NvU32 maxUtilSampleRate;
} NV_SWINSTR_CAPTURE_CAPS;
#define NV_SWINSTR_CAPTURE_CAPS_VER MAKE_NVAPI_VERSION(NV_SWINSTR_CAPTURE_CAPS, 1)
NVAPI_INTERFACE NvAPI_SwInstr_GetCapabilities(NV_SWINSTR_CAPTURE_CAPS *pNvSwInstrCapabilities);
typedef struct {
  NvU32 version;
  NvU32 bufferSize;
  NvU8 bCapturebyTime;
  NvU8 powerMode;
  NvU32 value;
  NvU32 powerSampleRate;
  NvU32 perfSampleRate;
  NvU32 tempSampleRate;
  NvU32 utilSampleRate;
  NvU32 numPoints;
  NV_SWINSTR_SENSOR_POINT sensorPoints[NV_SWINSTR_MAX_SENSOR_POINTS];
} NV_SWINSTR_CAPTURE_SETTINGS;
#define NV_SWINSTR_CAPTURE_SETTINGS_VER MAKE_NVAPI_VERSION(NV_SWINSTR_CAPTURE_SETTINGS, 1)
NVAPI_INTERFACE NvAPI_SwInstr_OpenCaptureSession(NV_SWINSTR_CAPTURE_SETTINGS *pNvSwInstrCapSets);
NVAPI_INTERFACE NvAPI_SwInstr_CloseCaptureSession();
NVAPI_INTERFACE NvAPI_SwInstr_StartCaptureSession();
NVAPI_INTERFACE NvAPI_SwInstr_StopCaptureSession();
typedef struct {
  NvU32 currPerfState;
  NvU32 totalPerfStates;
} NV_SWINSTR_PERF_SAMPLE;
typedef struct {
  NvU16 voltage;
  NvU16 current;
} NV_SWINSTR_VOLTAGE_CURRENT;
typedef struct {
  union {
    NvU32 power;
    NV_SWINSTR_VOLTAGE_CURRENT voltageCurrent;
  } data;
  NvU64 timeStamp;
} NV_SWINSTR_POWER_SAMPLE;
typedef struct {
  NvS32 temp;
  NvU64 timeStamp;
} NV_SWINSTR_TEMP_SAMPLE;
typedef struct {
  NvU32 utilization;
  NvU64 timeStamp;
} NV_SWINSTR_UTIL_SAMPLE;
typedef struct {
  NV_SWINSTR_SENSOR_POINT sensor;
  union {
    NV_SWINSTR_PERF_SAMPLE perfSample;
    NV_SWINSTR_POWER_SAMPLE powerSample;
    NV_SWINSTR_TEMP_SAMPLE tempSample;
    NV_SWINSTR_UTIL_SAMPLE utilSample;
  } sample;
} NV_SWINSTR_SAMPLE;
typedef struct {
  NvU32 version;
  NvU32 numSamples;
  NV_SWINSTR_SAMPLE *pSamples;
} NV_SWINSTR_CAPTURE_BUFFER;
#define NV_SWINSTR_CAPTURE_BUFFER_VER MAKE_NVAPI_VERSION(NV_SWINSTR_CAPTURE_BUFFER, 1)
NVAPI_INTERFACE NvAPI_SwInstr_GetCaptureData(NV_SWINSTR_CAPTURE_BUFFER *pNvSwInstrCaptureData, NvU32 *pSize);
#define NV_SWINSTR_SNAPSHOT_DATA_VER MAKE_NVAPI_VERSION(NV_SWINSTR_SNAPSHOT_DATA, 1)
NVAPI_INTERFACE NvAPI_SwInstr_GetSnapshot(NV_SWINSTR_CAPTURE_SETTINGS *pCaptureSettings,
                                          NV_SWINSTR_CAPTURE_BUFFER *pNvSwInstrSnapshotData, NvU32 *pSize);
typedef enum _NV_SET_HYBIRD_DIAG_FUNCTION_ID {
  NVAPI_SET_HYBRID_DIAG_FUNCTION_ACPI_EVAL_METHOD = 0,
  NVAPI_SET_HYBRID_DIAG_FUNCTION_QUERY_CHILD_RELATIONS,
  NVAPI_SET_HYBRID_DIAG_NUM_SUPPORTED_FUNCTIONS
} NV_SET_HYBRID_DIAG_FUNCTION_ID;
typedef enum _NV_SET_HYBRID_DIAG_MODE_ID {
  NVAPI_SET_HYBRID_DIAG_MODE_USE_IGPU = 0,
  NVAPI_SET_HYBRID_DIAG_MODE_USE_DGPU,
  NVAPI_SET_HYBRID_DIAG_MODE_USE_MVIGPU,
  NVAPI_SET_HYBRID_DIAG_MODE_USE_MVDGPU,
  NVAPI_SET_HYBRID_DIAG_NUM_SUPPORTED_FUNCTION_MODES
} NV_SET_HYBRID_DIAG_MODE_ID;
#define NV_SET_HYBRID_DIAG_BLOCK_SIZE (64 * 1024)
typedef struct {
  NvU32 version;
  NvU32 ulAcpiID;
  NvU32 ulDGPU;
  NV_SET_HYBRID_DIAG_MODE_ID modeID;
  NvU32 bufferSize;
  NvU8 buffer[NV_SET_HYBRID_DIAG_BLOCK_SIZE];
} NV_SET_HYBRID_DIAG_BLOCK;
#define NV_SET_HYBRID_DIAG_BLOCK_VER MAKE_NVAPI_VERSION(NV_SET_HYBRID_DIAG_BLOCK, 1)
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 445.") NVAPI_INTERFACE
    NvAPI_Diag_SetHybridDiag(NvPhysicalGpuHandle hPhysicalGpu, NV_SET_HYBRID_DIAG_FUNCTION_ID diagFunction,
                             NV_SET_HYBRID_DIAG_BLOCK *pDiagBlock);
#define MAX_XCODE_INSTANCE 4
typedef struct _NV_XCODE_ENCODE_INFO {
  NvU32 version;
  NvU32 processId;
  NvAPI_ShortString szFramework;
  NvAPI_ShortString szCodecType;
  NvAPI_ShortString szProfile;
  NvAPI_ShortString szPreset;
  NvU32 level;
  NvAPI_ShortString szFieldMode;
  NvU32 botFldFirst;
  NvS32 width;
  NvS32 height;
  float aspectRatio;
  float frameRate;
  NvU32 bitRateAvg;
  NvU32 bitRatePeak;
  NvAPI_ShortString vbrMode;
  NvU32 gpuOffloadLvl;
  NvU8 bMultiGpu : 1;
  NvU8 reserved : 7;
  NvU32 totalDevMemUsed;
} NV_XCODE_ENCODE_INFO_V1;
typedef NV_XCODE_ENCODE_INFO_V1 NV_XCODE_ENCODE_INFO;
#define NV_XCODE_ENCODE_INFO_VER1 MAKE_NVAPI_VERSION(NV_XCODE_ENCODE_INFO_V1, 1)
#define NV_XCODE_ENCODE_INFO_VER NV_XCODE_ENCODE_INFO_VER1
typedef struct _NV_XCODE_ENC_INSTANCE {
  NvU32 version;
  NvU32 instCount;
  NV_XCODE_ENCODE_INFO encInfo[MAX_XCODE_INSTANCE];
} NV_XCODE_ENC_INSTANCE_V1;
typedef NV_XCODE_ENC_INSTANCE_V1 NV_XCODE_ENC_INSTANCE;
#define NV_XCODE_ENC_INSTANCE_VER1 MAKE_NVAPI_VERSION(NV_XCODE_ENC_INSTANCE_V1, 1)
#define NV_XCODE_ENC_INSTANCE_VER NV_XCODE_ENC_INSTANCE_VER1
typedef struct _NV_XCODE_DECODE_INFO {
  NvU32 version;
  NvU32 processId;
  NvAPI_ShortString szDecoderType;
  NvU8 bMFTInterface : 1;
  NvU8 reserved : 7;
  NvAPI_ShortString szCodecType;
  NvU32 width;
  NvU32 height;
  NvU32 numDecSurf;
  NvAPI_ShortString szDeinterlaceMode;
  NvU32 outputFormat;
  NvU32 targetWidth;
  NvU32 targetHeight;
  NvU32 numOutputSurf;
  NV_RECT display_area;
  NvU32 totalDevMemUsed;
} NV_XCODE_DECODE_INFO_V1;
typedef NV_XCODE_DECODE_INFO_V1 NV_XCODE_DECODE_INFO;
#define NV_XCODE_DECODE_INFO_VER1 MAKE_NVAPI_VERSION(NV_XCODE_DECODE_INFO_V1, 1)
#define NV_XCODE_DECODE_INFO_VER NV_XCODE_DECODE_INFO_VER1
typedef struct _NV_XCODE_DEC_INSTANCE {
  NvU32 version;
  NvU32 instCount;
  NV_XCODE_DECODE_INFO decInfo[MAX_XCODE_INSTANCE];
} NV_XCODE_DEC_INSTANCE_V1;
typedef NV_XCODE_DEC_INSTANCE_V1 NV_XCODE_DEC_INSTANCE;
#define NV_XCODE_DEC_INSTANCE_VER1 MAKE_NVAPI_VERSION(NV_XCODE_DEC_INSTANCE_V1, 1)
#define NV_XCODE_DEC_INSTANCE_VER NV_XCODE_DEC_INSTANCE_VER1
typedef struct _NV_XCODE_NVAPIDMA_INFO {
  NvU8 bUpdateFlag : 1;
  NvU8 reserved : 7;
  NvU32 processId;
  NvU32 surfFormat;
  NV_RECT srcRect;
  NV_RECT destRect;
} NV_XCODE_NVAPIDMA_INFO;
typedef struct _NV_XCODE_NVAPIDMA_INSTANCE {
  NvU32 version;
  NvU32 instCount;
  NV_XCODE_NVAPIDMA_INFO Info[MAX_XCODE_INSTANCE];
} NV_XCODE_NVAPIDMA_INSTANCE_V1;
typedef NV_XCODE_NVAPIDMA_INSTANCE_V1 NV_XCODE_NVAPIDMA_INSTANCE;
#define NV_XCODE_NVAPIDMA_INSTANCE_VER1 MAKE_NVAPI_VERSION(NV_XCODE_NVAPIDMA_INSTANCE_V1, 1)
#define NV_XCODE_NVAPIDMA_INSTANCE_VER NV_XCODE_NVAPIDMA_INSTANCE_VER1
typedef enum _NV_XCODE_QUERY_ID {
  NV_XCODE_QUERY_ENCODE_INFO,
  NV_XCODE_QUERY_DECODE_INFO,
  NV_XCODE_QUERY_NVAPIDMA_INFO,
  NV_XCODE_QUERY_LAST
} NV_XCODE_QUERY_ID;
typedef struct _NV_XCODE_INFO {
  NV_XCODE_QUERY_ID queryID;
  NvU8 bFlag : 1;
  NvU8 reserved : 7;
  union {
    NV_XCODE_ENC_INSTANCE EncodeInfo;
    NV_XCODE_DEC_INSTANCE DecodeInfo;
    NV_XCODE_NVAPIDMA_INSTANCE NvapiDMAInfo;
  };
} NV_XCODE_INFO;
NVAPI_INTERFACE NvAPI_Xcode_SetEncodeInfo(NV_XCODE_ENCODE_INFO *pEncodeInfo);
NVAPI_INTERFACE NvAPI_Xcode_SetDecodeInfo(NV_XCODE_DECODE_INFO *pDecodeInfo);
NVAPI_INTERFACE NvAPI_Xcode_GetEncodeInfo(NV_XCODE_ENC_INSTANCE *pEncodeInfo);
NVAPI_INTERFACE NvAPI_Xcode_GetDecodeInfo(NV_XCODE_DEC_INSTANCE *pDecodeInfo);
NVAPI_INTERFACE NvAPI_Xcode_GetNvapiDMAInfo(NV_XCODE_NVAPIDMA_INSTANCE *pNvapiDMAInfo);
#define NVAPI_FB_ECC_PARTITION_COUNT 6
typedef enum NV_EDC_FLAGS {
  NV_EDC_FLAGS_NONE = 0x00000000,
  NV_EDC_FLAGS_FB_EDC_MAX_DELTAS_FLAGS_RESET = 0x00000001
} NV_EDC_FLAGS;
typedef struct {
  NvU32 version;
  NvU32 maxDeltas[NVAPI_FB_ECC_PARTITION_COUNT];
  NvU32 crcTickValue;
} NV_EDC_INFO_V1;
typedef NV_EDC_INFO_V1 NV_EDC_INFO;
#define NV_EDC_INFO_VER_1 MAKE_NVAPI_VERSION(NV_EDC_INFO_V1, 1)
#define NV_EDC_INFO_VER NV_EDC_INFO_VER_1
NVAPI_INTERFACE NvAPI_DIAG_GetEDCInfo(__in NvPhysicalGpuHandle hPhysicalGpu, __inout NV_EDC_INFO *pEDCInfo,
                                      __in NV_EDC_FLAGS flags);
NVAPI_INTERFACE NvAPI_Diag_Escape(NvPhysicalGpuHandle hPhysicalGpu, NvU32 escapeId, void *pData, NvU32 dataSize);
NVAPI_INTERFACE NvAPI_Diag_NvRmAllocRoot(NvU32 *phClient);
NVAPI_INTERFACE NvAPI_Diag_NvRmAlloc(NvU32 hClient, NvU32 hParent, NvU32 hObject, NvU32 hClass, void *pAllocParams,
                                     NvU32 allocParamSize);
NVAPI_INTERFACE NvAPI_Diag_NvRmControl(NvU32 hClient, NvU32 hObject, NvU32 cmd, void *pParams, NvU32 paramsSize);
NVAPI_INTERFACE NvAPI_Diag_NvRmFree(NvU32 hClient, NvU32 hParent, NvU32 hObject);
NVAPI_INTERFACE NvAPI_ToggleICafeFrameTag();
NVAPI_INTERFACE NvAPI_ToggleICafeStatsDump();
NVAPI_INTERFACE NvAPI_ToggleICafeImageDump();
#define MAX_PEX_COUNTER_TYPES 31
#define NVAPI_PEX_COUNTER_TYPE 0x00000000
#define NVAPI_PEX_COUNTER_RECEIVER_ERRORS 0x00000001
#define NVAPI_PEX_COUNTER_REPLAY_COUNT 0x00000002
#define NVAPI_PEX_COUNTER_REPLAY_ROLLOVER_COUNT 0x00000004
#define NVAPI_PEX_COUNTER_BAD_DLLP_COUNT 0x00000008
#define NVAPI_PEX_COUNTER_BAD_TLP_COUNT 0x00000010
#define NVAPI_PEX_COUNTER_8B10B_ERRORS_COUNT 0x00000020
#define NVAPI_PEX_COUNTER_SYNC_HEADER_ERRORS_COUNT 0x00000040
#define NVAPI_PEX_COUNTER_LCRC_ERRORS_COUNT 0x00000080
#define NVAPI_PEX_COUNTER_FAILED_L0S_EXITS_COUNT 0x00000100
#define NVAPI_PEX_COUNTER_NAKS_SENT_COUNT 0x00000200
#define NVAPI_PEX_COUNTER_NAKS_RCVD_COUNT 0x00000400
#define NVAPI_PEX_COUNTER_LANE_ERRORS 0x00000800
#define NVAPI_PEX_COUNTER_L1_TO_RECOVERY_COUNT 0x00001000
#define NVAPI_PEX_COUNTER_L0_TO_RECOVERY_COUNT 0x00002000
#define NVAPI_PEX_COUNTER_RECOVERY_COUNT 0x00004000
#define NVAPI_PEX_COUNTER_CHIPSET_XMIT_L0S_ENTRY_COUNT 0x00008000
#define NVAPI_PEX_COUNTER_GPU_XMIT_L0S_ENTRY_COUNT 0x00010000
#define NVAPI_PEX_COUNTER_L1_ENTRY_COUNT 0x00020000
#define NVAPI_PEX_COUNTER_L1P_ENTRY_COUNT 0x00040000
#define NVAPI_PEX_COUNTER_DEEP_L1_ENTRY_COUNT 0x00080000
#define NVAPI_PEX_COUNTER_ASLM_COUNT 0x00100000
#define NVAPI_PEX_COUNTER_TOTAL_CORR_ERROR_COUNT 0x00200000
#define NVAPI_PEX_COUNTER_CORR_ERROR_COUNT 0x00400000
#define NVAPI_PEX_COUNTER_NON_FATAL_ERROR_COUNT 0x00800000
#define NVAPI_PEX_COUNTER_FATAL_ERROR_COUNT 0x01000000
#define NVAPI_PEX_COUNTER_UNSUPP_REQ_COUNT 0x02000000
#define NVAPI_PEX_COUNTER_L1_1_ENTRY_COUNT 0x04000000
#define NVAPI_PEX_COUNTER_L1_2_ENTRY_COUNT 0x08000000
#define NVAPI_PEX_COUNTER_L1_2_ABORT_COUNT 0x10000000
#define NVAPI_PEX_COUNTER_L1SS_TO_DEEP_L1_TIMEOUT_COUNT 0x20000000
#define NVAPI_PEX_COUNTER_L1_SHORT_DURATION_COUNT 0x40000000
typedef struct _NV_PEX_COUNTER_INFO_V1 {
  NvU32 version;
  NvU32 pexCounterMask;
  NvU32 pexTotalCorrectableErrors;
  NvU16 pexCorrectableErrors;
  NvU8 pexTotalNonFatalErrors;
  NvU8 pexTotalFatalErrors;
  NvU8 pexTotalUnsupportedReqs;
  NvU16 pexCounters[MAX_PEX_COUNTER_TYPES];
} NV_PEX_COUNTER_INFO_V1;
typedef NV_PEX_COUNTER_INFO_V1 NV_PEX_COUNTER_INFO;
#define NVAPI_PEX_COUNTER_INFO_VER1 NVAPI_PEX_COUNTER_INFO_VER
#define NVAPI_PEX_COUNTER_INFO_VER MAKE_NVAPI_VERSION(NV_PEX_COUNTER_INFO, 1)
NVAPI_INTERFACE NvAPI_Diag_GetPexCounters(__in NvPhysicalGpuHandle hPhysicalGpuHandle,
                                          __inout NV_PEX_COUNTER_INFO *info);
NVAPI_INTERFACE NvAPI_Diag_ResetPexCounters(__in NvPhysicalGpuHandle hPhysicalGpuHandle, __in NvU32 pexCounterMask);
typedef enum _NV_DIAG_GC6_DEBUG_INFO_FLAGS {
  NV_GC6_DEBUG_INFO_VBIOS_FBCLAMP_ENABLED = NV_BIT(0),
  NV_GC6_DEBUG_INFO_VBIOS_IFR_ENABLED = NV_BIT(1),
  NV_GC6_DEBUG_INFO_SBIOS_ENABLED = NV_BIT(2),
  NV_GC6_DEBUG_INFO_ROMLESS_OPTIMUS_RESUME_ENABLED = NV_BIT(3),
  NV_GC6_DEBUG_INFO_ROM_JT_GC6_ENABLED = NV_BIT(4),
  NV_GC6_DEBUG_INFO_PGISLAND_PRESENT = NV_BIT(5),
} NV_DIAG_GC6_DEBUG_INFO_FLAGS;
typedef enum _NV_DIAG_GC6_CAPS_INFO_FLAGS {
  NV_GC6_CAPS_INFO_CORE_SEQUENCE_ENABLED = NV_BIT(0),
  NV_GC6_CAPS_INFO_ROM_SEQUENCE_ENABLED = NV_BIT(1),
} NV_DIAG_GC6_CAPS_INFO_FLAGS;
typedef struct _NV_DIAG_GC6_DEBUG_INFO_V1 {
  NvU32 version;
  NvU32 gc6DebugInfo;
} NV_DIAG_GC6_DEBUG_INFO_V1;
typedef struct _NV_DIAG_GC6_DEBUG_INFO_V2 {
  NvU32 version;
  NvU32 gc6DebugInfo;
  NvU32 gc6CapsInfo;
} NV_DIAG_GC6_DEBUG_INFO_V2;
typedef NV_DIAG_GC6_DEBUG_INFO_V2 NV_DIAG_GC6_DEBUG_INFO;
#define NV_DIAG_GC6_DEBUG_INFO_VER1 MAKE_NVAPI_VERSION(NV_DIAG_GC6_DEBUG_INFO_V1, 1)
#define NV_DIAG_GC6_DEBUG_INFO_VER2 MAKE_NVAPI_VERSION(NV_DIAG_GC6_DEBUG_INFO_V2, 2)
#define NV_DIAG_GC6_DEBUG_INFO_VER NV_DIAG_GC6_DEBUG_INFO_VER2
NVAPI_INTERFACE NvAPI_Diag_GetGC6DebugInfo(__in NvPhysicalGpuHandle hPhysicalGpu,
                                           __inout NV_DIAG_GC6_DEBUG_INFO *pGC6DebugInfo);
typedef enum _NV_NodeType {
  NV_NodeUnknown = 0xffffffff,
  NV_Node2D = 0,
  NV_Node3D = 1,
  NV_NodeOverlay = 2,
  NV_NodeMDEC = 3,
  NV_NodeVP = 4,
  NV_NodeBSP = 5,
  NV_NodeCipher = 6,
  NV_NodeMSPDEC = 7,
  NV_NodeMSPPP = 8,
  NV_NodeMSVLD = 9,
  NV_NodeSEC = 10,
  NV_NodeDmaCopy0 = 11,
  NV_NodeDmaCopy1 = 12,
  NV_NodeDmaCopy2 = 13,
  NV_NodeVIC = 14,
  NV_NodeDmaLzo = 15,
  NV_NodeMSENC = 16,
  NV_NodeMSENC2 = 17,
  NV_NodeMSENC3 = 18,
  NV_Node3DLowLatency = 19,
  NV_NodeSCG1 = 20,
  NV_NodeMPE = 21,
  NV_NodeNVDEC = 22,
  NV_NodeTSEC = 23,
  NV_NodeDmaCopyHigh = 24,
  NV_NodeDmaCopyMedium = 25,
  NV_NodeDmaCopyLow = 26,
  NV_NodeTypeCount = 27
} NV_NodeType;
typedef enum _NV_FAULT_METHOD {
  NV_FAULT_METHOD_RESET_CHANNEL = 0,
  NV_FAULT_METHOD_BUFFER_SKIPPING = 1,
} NV_FAULT_METHOD;
typedef struct _NV_INDUCE_CHANNEL_FAULT_INFO_V1 {
  NvU32 version;
  NvU32 processId;
  NV_NodeType nodeType;
  NvU32 engineOrdinal;
  NV_FAULT_METHOD method;
  union {
    struct {
      NvU32 submitCount;
      NvU32 submitDelayUs;
    } resetChannelParams;
    struct {
      NvU32 bufferInterval;
    } bufferSkippingParams;
  } params;
} NV_INDUCE_CHANNEL_FAULT_INFO_V1;
typedef NV_INDUCE_CHANNEL_FAULT_INFO_V1 NV_INDUCE_CHANNEL_FAULT_INFO;
#define NV_INDUCE_CHANNEL_FAULT_INFO_VER1 MAKE_NVAPI_VERSION(NV_INDUCE_CHANNEL_FAULT_INFO_V1, 1)
#define NV_INDUCE_CHANNEL_FAULT_INFO_VER NV_INDUCE_CHANNEL_FAULT_INFO_VER1
typedef struct _NV_GPU_INDUCE_CHANNEL_FAULT_V1 {
  NvU32 version;
  NV_INDUCE_CHANNEL_FAULT_INFO_V1 induceChannelFaultInfo;
} NV_GPU_INDUCE_CHANNEL_FAULT_V1;
typedef NV_GPU_INDUCE_CHANNEL_FAULT_V1 NV_GPU_INDUCE_CHANNEL_FAULT;
#define NV_GPU_INDUCE_CHANNEL_FAULT_VER1 MAKE_NVAPI_VERSION(NV_GPU_INDUCE_CHANNEL_FAULT_V1, 1)
#define NV_GPU_INDUCE_CHANNEL_FAULT_VER NV_GPU_INDUCE_CHANNEL_FAULT_VER1
NVAPI_INTERFACE NvAPI_Diag_InduceChannelFault(__in NvLogicalGpuHandle hLogicalGpuHandle,
                                              __in NV_GPU_INDUCE_CHANNEL_FAULT *pGpuChannelFaultInfo);
typedef enum _NVAPI_DIRECTMODE_QUERY_ID {
  NV_DIRECTMODE_QUERY_ID_NULL = 0x00,
  NV_DIRECTMODE_QUERY_ID_ETW_MANIFEST = 0x01,
  NV_DIRECTMODE_QUERY_ID_ETW_RESOURCE = 0x02,
} NV_DIRECTMODE_QUERY_ID;
typedef struct _NV_DIRECTMODE_QUERY_ETW {
  NvU32 etwDataSize;
  NvU8 *pEtwData;
} NV_DIRECTMODE_QUERY_ETW;
typedef struct _NV_DIRECTMODE_QUERY {
  NvU32 version;
  NV_DIRECTMODE_QUERY_ID queryId;
  union {
    NV_DIRECTMODE_QUERY_ETW etwInfo;
  };
} NV_DIRECTMODE_QUERY;
#define NV_DIRECTMODE_QUERY_VER MAKE_NVAPI_VERSION(NV_DIRECTMODE_QUERY, 1)
NVAPI_INTERFACE NvAPI_DirectModeQuery(NV_DIRECTMODE_QUERY *pQuery);
typedef struct {
  NvU32 version;
  NvU32 IsWrongThermSetup : 1;
  NvU32 IsEngineeringSample : 1;
  NvU32 reserved : 30;
} NV_MODE_RESTRICT_PARAMS;
#define NV_MODE_RESTRICT_PARAMS_VER MAKE_NVAPI_VERSION(NV_MODE_RESTRICT_PARAMS, 1)
NVAPI_INTERFACE NvAPI_DIAG_ModeRestrictInfo(NvPhysicalGpuHandle hPhysicalGpu, NV_MODE_RESTRICT_PARAMS *pModeRestrict);
typedef struct {
  NvU32 version;
  NvU32 sensorIndex;
  NvU32 rawReading;
  NvS32 slope;
  NvS32 offset;
} NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO_V1;
typedef NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO_V1 NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO;
#define NV_DIAG_INTERNAL_THERMAL_SENSOR_VER_1 MAKE_NVAPI_VERSION(NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO_V1, 1)
#define NV_DIAG_INTERNAL_THERMAL_SENSOR_VER NV_DIAG_INTERNAL_THERMAL_SENSOR_VER_1
NVAPI_INTERFACE NvAPI_Diag_GetInternalThermalSensorInfo(NvPhysicalGpuHandle hPhysicalGpu,
                                                        NV_DIAG_INTERNAL_THERMAL_SENSOR_INFO *pDiagData);
typedef struct {
  NvU32 version;
  NvU32 resetRcData : 1;
  NvU32 reserved : 31;
  NvU32 rcErrorCount;
} NV_RC_ERROR_DATA_V1;
typedef NV_RC_ERROR_DATA_V1 NV_RC_ERROR_DATA;
#define NV_RC_ERROR_DATA_VER1 MAKE_NVAPI_VERSION(NV_RC_ERROR_DATA_V1, 1)
#define NV_RC_ERROR_DATA_VER NV_RC_ERROR_DATA_VER1
NVAPI_INTERFACE NvAPI_DIAG_GetRcErrorData(NvPhysicalGpuHandle hPhysicalGpu, NV_RC_ERROR_DATA *pRcErrorData);
NVAPI_INTERFACE NvAPI_Diag_ResetKMDCoverageData();
typedef enum _NV_GET_DIAGNOSTIC_DATA_COMMAND {
  NV_COMMAND_INVALID = 0,
  NV_COMMAND_GET_FIXED_BUGS_DATA = 1,
} NV_GET_DIAGNOSTIC_DATA_COMMAND;
typedef struct _NV_GET_FIXED_BUGS_DATA_V1 {
  NvU32 fixedBugsCount;
  NvU32 *pFixedBugsData;
  NvU32 reserved[16];
} NV_GET_FIXED_BUGS_DATA_V1;
typedef union {
  NV_GET_FIXED_BUGS_DATA_V1 fixedBugsInfo;
} NV_DIAGNOSTIC_INFO_V1;
typedef struct _NV_GET_DIAGNOSTIC_DATA_V1 {
  NvU32 version;
  NV_GET_DIAGNOSTIC_DATA_COMMAND cmd;
  NV_DIAGNOSTIC_INFO_V1 diagnosticInfo;
  NvU32 reserved[8];
} NV_GET_DIAGNOSTIC_DATA_V1;
#define NV_GET_DIAGNOSTIC_DATA_VER1 MAKE_NVAPI_VERSION(NV_GET_DIAGNOSTIC_DATA_V1, 1)
typedef NV_GET_DIAGNOSTIC_DATA_V1 NV_GET_DIAGNOSTIC_DATA;
#define NV_GET_DIAGNOSTIC_DATA_VER NV_GET_DIAGNOSTIC_DATA_VER1
NVAPI_INTERFACE NvAPI_Diag_GetDiagnosticData(__inout NV_GET_DIAGNOSTIC_DATA *pDiagnosticData);
NVAPI_INTERFACE NvAPI_SYS_IsPhysXApplication(__out NvU32 *isPhysXApplication);
NVAPI_INTERFACE NvAPI_SYS_IsPhysXValidConfig(__out NvU8 *isPhysXValidConfig);
typedef enum _NV_FEATURE_ID {
  NV_FEATURE_ID_SGM_CLOCK_LOCK = 0,
  NV_FEATURE_ID_PAN_SCAN_STATE = 1,
  NV_FEATURE_ID_VRR_STATE = 2,
  NV_FEATURE_ID_CONSISTENT_PERF = 3,
  NV_FEATURE_ID_HYPER_SAMPLING = 4,
  NV_FEATURE_ID_GC6_NOTIFY_STATE_CHANGE = 5,
  NV_FEATURE_ID_DIRECTMODE = 6,
  NV_FEATURE_ID_VIDEO_ONESHOT = 7
} NV_FEATURE_ID;
typedef enum _NV_FEATURE_ID_VALUE {
  NV_FEATURE_ID_OFF = 0,
  NV_FEATURE_ID_ON = 1,
} NV_FEATURE_ID_VALUE;
typedef struct _NV_SYS_FEATURE_DATA_V1 {
  NvU32 version;
  NV_FEATURE_ID featureId;
  NV_FEATURE_ID_VALUE featureIdValue;
  union {
    NvPhysicalGpuHandle hPhysicalGpu;
    NvU32 displayId;
  };
} NV_SYS_FEATURE_DATA_V1;
#define NV_FEATURE_NO_SUPPORT_DISABLED NV_BIT(0)
#define NV_FEATURE_NO_SUPPORT_GPU NV_BIT(1)
#define NV_FEATURE_NO_SUPPORT_DISPLAY NV_BIT(2)
#define NV_FEATURE_NO_SUPPORT_DISPLAY_DRIVER NV_BIT(3)
#define NV_FEATURE_NO_SUPPORT_CURRENT_DISPLAY_SETTINGS NV_BIT(4)
typedef struct _NV_SYS_FEATURE_DATA_V2 {
  NvU32 version;
  NV_FEATURE_ID featureId;
  NV_FEATURE_ID_VALUE featureIdValue;
  union {
    NvPhysicalGpuHandle hPhysicalGpu;
    NvU32 displayId;
  };
  NvU32 problemFlags;
} NV_SYS_FEATURE_DATA_V2;
typedef NV_SYS_FEATURE_DATA_V2 NV_SYS_FEATURE_DATA;
#define NV_SYS_FEATURE_DATA_VER_1 MAKE_NVAPI_VERSION(NV_SYS_FEATURE_DATA_V1, 1)
#define NV_SYS_FEATURE_DATA_VER_2 MAKE_NVAPI_VERSION(NV_SYS_FEATURE_DATA_V2, 2)
#define NV_SYS_FEATURE_DATA_VER NV_SYS_FEATURE_DATA_VER_2
NVAPI_INTERFACE NvAPI_SYS_SetFeatureState(__in NV_SYS_FEATURE_DATA featureData);
NVAPI_INTERFACE NvAPI_SYS_GetFeatureState(__inout NV_SYS_FEATURE_DATA *featureData);
typedef enum _NV_APPROVAL_COOKIE_TYPE {
  NV_APPROVAL_COOKIE_TYPE_UNKNOWN = 0x00,
  NV_APPROVAL_COOKIE_TYPE_SLI = 0x01,
  NV_APPROVAL_COOKIE_TYPE_COPROC = 0x02,
  NV_APPROVAL_COOKIE_TYPE_TEMPLATE = 0x03,
} NV_APPROVAL_COOKIE_TYPE;
#define MAX_APPROVAL_COOKIE 4
typedef struct {
  NvU32 version;
  NvU32 ApprovalCookieCount;
  NV_APPROVAL_COOKIE_TYPE ApprovalCookieType[MAX_APPROVAL_COOKIE];
  NvAPI_String ApprovalCookieString[MAX_APPROVAL_COOKIE];
} NV_APPROVAL_COOKIES;
#define NV_APPROVAL_COOKIES_VER MAKE_NVAPI_VERSION(NV_APPROVAL_COOKIES, 1)
NVAPI_INTERFACE NvAPI_SYS_GetApprovalCookies(NV_APPROVAL_COOKIES *pApprovalCookies);
typedef enum _NV_ACPI_EVENT_TYPE {
  NVAPI_ACPI_EVENT_TYPE_LID_STATE,
  NVAPI_ACPI_EVENT_TYPE_POWER_SOURCE,
  NVAPI_ACPI_EVENT_TYPE_DOCK_STATE,
  NVAPI_ACPI_EVENT_TYPE_TRUST_LID,
  NVAPI_ACPI_EVENT_TYPE_TRUST_DOCK,
} NV_ACPI_EVENT_TYPE;
typedef enum _NV_ACPI_EVENT_DATA {
  NVAPI_ACPI_EVENT_DATA_LID_OPEN,
  NVAPI_ACPI_EVENT_DATA_LID_CLOSED,
  NVAPI_ACPI_EVENT_DATA_POWER_BATTERY,
  NVAPI_ACPI_EVENT_DATA_POWER_AC,
  NVAPI_ACPI_EVENT_DATA_DOCK_UNDOCKED,
  NVAPI_ACPI_EVENT_DATA_DOCK_DOCKED,
  NVAPI_ACPI_EVENT_DATA_TRUST_LID_DCS,
  NVAPI_ACPI_EVENT_DATA_TRUST_LID_NVIF,
  NVAPI_ACPI_EVENT_DATA_TRUST_LID_ACPI,
  NVAPI_ACPI_EVENT_DATA_TRUST_LID_POLL,
  NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_DCS,
  NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_NVIF,
  NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_ACPI,
  NVAPI_ACPI_EVENT_DATA_TRUST_DOCK_POLL,
} NV_ACPI_EVENT_DATA;
typedef enum _NV_ACPI_EVENT_FORCED_DATA {
  NVAPI_ACPI_EVENT_FORCED_DATA_NO,
  NVAPI_ACPI_EVENT_FORCED_DATA_YES
} NV_ACPI_EVENT_FORCED_DATA;
NVAPI_INTERFACE NvAPI_SYS_ACPI_NotifyEvent(NvPhysicalGpuHandle hPhysicalGpu, NV_ACPI_EVENT_TYPE eventType,
                                           NV_ACPI_EVENT_DATA eventData, NV_ACPI_EVENT_FORCED_DATA dataForced);
typedef enum _NV_NVIF_FUNC_ID {
  NVAPI_NVIF_FUNC_LID_STATUS = 0,
  NVAPI_NVIF_FUNC_DOCKING_STATUS,
  NVAPI_NVIF_FUNC_THERMAL_MONITOR,
  NVAPI_NVIF_FUNC_BRIGHTNESS_CONTROL,
  NVAPI_NVIF_FUNC_POWERMIZER_LIMIT,
  NVAPI_NVIF_FUNC_DISPLAY_ATTRIBUTES,
  NVAPI_NVIF_FUNC_HDCP,
  NVAPI_NVIF_FUNC_DISPLAY_GET_VALUE,
  NVAPI_NVIF_FUNC_DISPLAY_SET_VALUE,
  NVAPI_NVIF_FUNC_PLATFORM_CONFIG,
  NVAPI_NVIF_FUNC_NUM,
} NV_NVIF_FUNC_ID;
NVAPI_INTERFACE NvAPI_SYS_NVIF_QuerySupport(NV_NVIF_FUNC_ID func);
typedef struct {
  NvU32 version;
  struct {
    NvU32 displayOutputId;
    NvU32 data;
  } displayData[NVAPI_MAX_DISPLAYS];
  NvU32 validDataSize;
} NVIF_FUNC_DATA_SET;
#define NVIF_FUNC_DATA_SET_VER MAKE_NVAPI_VERSION(NVIF_FUNC_DATA_SET, 1)
typedef enum {
  NVIF_FUNC_REQUEST_SCALING = 0,
  NVIF_FUNC_REQUEST_TVFORMAT = 1,
  NVIF_FUNC_REQUEST_NUM,
} NVIF_FUNC_REQUEST_ID;
NVAPI_INTERFACE NvAPI_SYS_NVIF_GetValues(NV_NVIF_FUNC_ID func, NVIF_FUNC_REQUEST_ID dataReqId,
                                         NVIF_FUNC_DATA_SET *data);
NVAPI_INTERFACE NvAPI_SYS_NVIF_SetValues(NV_NVIF_FUNC_ID func, NVIF_FUNC_REQUEST_ID dataReqId, NVIF_FUNC_DATA_SET data);
#define NVAPI_MEM_DATA_SIZE 128
typedef struct {
  NvU32 version;
  NvU32 dataBlob[NVAPI_MEM_DATA_SIZE];
  NvU32 dataSize;
} NVIF_FUNC_MEM_BW_INFO;
#define NVIF_FUNC_MEM_BW_INFO_VER MAKE_NVAPI_VERSION(NVIF_FUNC_MEM_BW_INFO, 1)
NVAPI_INTERFACE NvAPI_SYS_NVIF_PlatformConfig(NV_NVIF_FUNC_ID func, NVIF_FUNC_MEM_BW_INFO *data);
typedef enum _NV_CPU_TYPE {
  NV_CPU_TYPE_UNKNOWN = 0x00000000,
  NV_CPU_TYPE_P5 = 0x00000001,
  NV_CPU_TYPE_P55 = 0x00000002,
  NV_CPU_TYPE_P6 = 0x00000003,
  NV_CPU_TYPE_P2 = 0x00000004,
  NV_CPU_TYPE_P2XC = 0x00000005,
  NV_CPU_TYPE_CELA = 0x00000006,
  NV_CPU_TYPE_P3 = 0x00000007,
  NV_CPU_TYPE_P3_INTL2 = 0x00000008,
  NV_CPU_TYPE_P4 = 0x00000009,
  NV_CPU_TYPE_CORE2 = 0x00000010,
  NV_CPU_TYPE_CELN_M16H = 0x00000011,
  NV_CPU_TYPE_CORE2_EXTRM = 0x00000012,
  NV_CPU_TYPE_ATOM = 0x00000013,
  NV_CPU_TYPE_IA64 = 0x00000020,
  NV_CPU_TYPE_K5 = 0x00000030,
  NV_CPU_TYPE_K6 = 0x00000031,
  NV_CPU_TYPE_K62 = 0x00000032,
  NV_CPU_TYPE_K63 = 0x00000033,
  NV_CPU_TYPE_K7 = 0x00000034,
  NV_CPU_TYPE_K8 = 0x00000035,
  NV_CPU_TYPE_K10 = 0x00000036,
  NV_CPU_TYPE_K11 = 0x00000037,
  NV_CPU_TYPE_RYZEN = 0x00000038,
  NV_CPU_TYPE_C6 = 0x00000060,
  NV_CPU_TYPE_C62 = 0x00000061,
  NV_CPU_TYPE_GX = 0x00000070,
  NV_CPU_TYPE_M1 = 0x00000071,
  NV_CPU_TYPE_M2 = 0x00000072,
  NV_CPU_TYPE_MGX = 0x00000073,
  NV_CPU_TYPE_TM_CRUSOE = 0x00000080,
  NV_CPU_TYPE_PPC603 = 0x00000090,
  NV_CPU_TYPE_PPC604 = 0x00000091,
  NV_CPU_TYPE_PPC750 = 0x00000092,
} NV_CPU_TYPE;
typedef enum _NV_CPU_CAPABILITIES {
  NV_CPU_CAP_MMX = 0x00000001,
  NV_CPU_CAP_SSE = 0x00000002,
  NV_CPU_CAP_3DNOW = 0x00000004,
  NV_CPU_CAP_SSE2 = 0x00000008,
  NV_CPU_CAP_SFENCE = 0x00000010,
  NV_CPU_CAP_WRITE_COMBINING = 0x00000020,
  NV_CPU_CAP_ALTIVEC = 0x00000040,
  NV_CPU_CAP_PUT_NEEDS_IO = 0x00000080,
  NV_CPU_CAP_NEEDS_WC_WORKAROUND = 0x00000100,
  NV_CPU_CAP_3DNOW_EXT = 0x00000200,
  NV_CPU_CAP_MMX_EXT = 0x00000400,
  NV_CPU_CAP_CMOV = 0x00000800,
  NV_CPU_CAP_CLFLUSH = 0x00001000,
  NV_CPU_CAP_NEEDS_WAR_190854 = 0x00002000,
  NV_CPU_CAP_SSE3 = 0x00004000,
  NV_CPU_CAP_NEEDS_WAR_124888 = 0x00008000,
  NV_CPU_CAP_HT_CAPABLE = 0x00010000,
} NV_CPU_CAPABILITIES;
typedef struct {
  NvU32 version;
  NV_CPU_TYPE type;
  NV_CPU_CAPABILITIES capabilities;
  NvU32 clock;
  NvU32 L1DataCacheSize;
  NvU32 L2DataCacheSize;
  NvU32 dataCacheLineSize;
  NvU32 numLogicalCpus;
  NvU32 numPhysicalCpus;
  NvAPI_ShortString szEmbeddedName;
} NV_CPU_INFO_v1;
typedef struct {
  NvU32 version;
  NV_CPU_TYPE type;
  NV_CPU_CAPABILITIES capabilities;
  NvU32 clock;
  NvU32 L1DataCacheSize;
  NvU32 L2DataCacheSize;
  NvU32 dataCacheLineSize;
  NvU32 numLogicalCpus;
  NvU32 numPhysicalCpus;
  NvU32 numCoresOnDie;
  NvAPI_ShortString szEmbeddedName;
} NV_CPU_INFO_V1;
typedef struct {
  NvU32 version;
  NV_CPU_TYPE type;
  NV_CPU_CAPABILITIES capabilities;
  NvU32 clock;
  NvU32 L1DataCacheSize;
  NvU32 L2DataCacheSize;
  NvU32 dataCacheLineSize;
  NvU32 numLogicalCpus;
  NvU32 numPhysicalCpus;
  NvU32 numCoresOnDie;
  NvAPI_ShortString szEmbeddedName;
  NvU32 family;
  NvU32 model;
  NvU8 stepping;
  NvU8 rsvd[80];
} NV_CPU_INFO_V2;
#define NV_CPU_INFO_VER_1 MAKE_NVAPI_VERSION(NV_CPU_INFO_v1, 1)
#define NV_CPU_INFO_VER_EX MAKE_NVAPI_VERSION(NV_CPU_INFO_V1, 2)
#define NV_CPU_INFO_VER_2 MAKE_NVAPI_VERSION(NV_CPU_INFO_V2, 2)
#define NV_CPU_INFO_VER NV_CPU_INFO_VER_2
#define NV_CPU_INFO NV_CPU_INFO_V2
NVAPI_INTERFACE NvAPI_SYS_GetCpuInfo(NV_CPU_INFO *pInfo);
typedef struct {
  NvU32 version;
  NvU32 vendorId;
  NvU32 deviceId;
  NvAPI_ShortString szVendorName;
  NvAPI_ShortString szChipsetName;
  NvU32 flags;
  NvU32 subSysVendorId;
  NvU32 subSysDeviceId;
  NvAPI_ShortString szSubSysVendorName;
  NvU32 HBvendorId;
  NvU32 HBdeviceId;
  NvU32 HBsubSysVendorId;
  NvU32 HBsubSysDeviceId;
} NV_CHIPSET_INFO_v4;
typedef struct {
  NvU32 version;
  NvU32 vendorId;
  NvU32 deviceId;
  NvAPI_ShortString szVendorName;
  NvAPI_ShortString szChipsetName;
  NvU32 flags;
  NvU32 subSysVendorId;
  NvU32 subSysDeviceId;
  NvAPI_ShortString szSubSysVendorName;
} NV_CHIPSET_INFO_v3;
typedef enum {
  NV_CHIPSET_INFO_HYBRID = 0x00000001,
} NV_CHIPSET_INFO_FLAGS;
typedef struct {
  NvU32 version;
  NvU32 vendorId;
  NvU32 deviceId;
  NvAPI_ShortString szVendorName;
  NvAPI_ShortString szChipsetName;
  NvU32 flags;
} NV_CHIPSET_INFO_v2;
typedef struct {
  NvU32 version;
  NvU32 vendorId;
  NvU32 deviceId;
  NvAPI_ShortString szVendorName;
  NvAPI_ShortString szChipsetName;
} NV_CHIPSET_INFO_v1;
#define NV_CHIPSET_INFO_VER_1 MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v1, 1)
#define NV_CHIPSET_INFO_VER_2 MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v2, 2)
#define NV_CHIPSET_INFO_VER_3 MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v3, 3)
#define NV_CHIPSET_INFO_VER_4 MAKE_NVAPI_VERSION(NV_CHIPSET_INFO_v4, 4)
#define NV_CHIPSET_INFO NV_CHIPSET_INFO_v4
#define NV_CHIPSET_INFO_VER NV_CHIPSET_INFO_VER_4
NVAPI_INTERFACE NvAPI_SYS_GetChipSetInfo(NV_CHIPSET_INFO *pChipSetInfo);
typedef struct {
  NvU32 version;
  NvU32 currentLidState;
  NvU32 currentDockState;
  NvU32 currentLidPolicy;
  NvU32 currentDockPolicy;
  NvU32 forcedLidMechanismPresent;
  NvU32 forcedDockMechanismPresent;
} NV_LID_DOCK_PARAMS;
#define NV_LID_DOCK_PARAMS_VER MAKE_NVAPI_VERSION(NV_LID_DOCK_PARAMS, 1)
NVAPI_INTERFACE NvAPI_SYS_GetLidAndDockInfo(NV_LID_DOCK_PARAMS *pLidAndDock);
typedef struct {
  NvU32 version;
  NvU32 sliBondId;
  NvAPI_ShortString szSliBondName;
} NV_CHIPSET_SLI_BOND_INFO;
#define NV_CHIPSET_SLI_BOND_INFO_VER MAKE_NVAPI_VERSION(NV_CHIPSET_SLI_BOND_INFO, 1)
NVAPI_INTERFACE NvAPI_SYS_GetChipSetSliBondInfo(NV_CHIPSET_SLI_BOND_INFO *pChipSetSliBondInfo);
typedef struct {
  NvU32 version;
  NvU32 hwbcId;
  NvU32 firmwareVersion;
  NvU32 secondaryBus;
  NvU32 subordinateBus;
} NV_HWBC_INFO;
#define NV_HWBC_INFO_VER MAKE_NVAPI_VERSION(NV_HWBC_INFO, 1)
typedef struct {
  NvU32 version;
  NV_HWBC_INFO hwbcInfo[NVAPI_SYSTEM_MAX_HWBCS];
} NV_HWBC_INFO_PARAMS;
#define NV_HWBC_INFO_PARAMS_VER MAKE_NVAPI_VERSION(NV_HWBC_INFO_PARAMS, 1)
NVAPI_INTERFACE NvAPI_SYS_GetHwbcInfo(NV_HWBC_INFO_PARAMS *pHwbcInfoParams);
typedef enum _NV_STEREO_PACKED_FRAME_LAYOUT {
  PACKED_FRAME_LEFT_RIGHT = 0x0,
  PACKED_FRAME_RIGHT_LEFT = 0x1,
  PACKED_FRAME_OVER_UNDER = 0x2,
  PACKED_FRAME_UNDER_OVER = 0x3,
  PACKED_FRAME_LAST
} NV_STEREO_PACKED_FRAME_LAYOUT;
typedef enum _NV_STEREO_METADATA_STATE {
  METADATA_STATE_ENABLE = 0x0,
  METADATA_STATE_DISABLE = 0x1,
  METADATA_STATE_LAST
} NV_STEREO_METADATA_STATE;
typedef enum _NV_STEREO_COMMAND {
  STEREO_COMMAND_ADD_RECORD = 0x0,
  STEREO_COMMAND_REMOVE_RECORD = 0x1,
  STEREO_COMMAND_LAST
} NV_STEREO_COMMAND;
typedef struct _NV_STEREO_FRAME_INFO {
  NvU32 processID;
  NvU32 streamSrcWidth;
  NvU32 streamSrcHeight;
  NV_STEREO_PACKED_FRAME_LAYOUT streamFormat;
  NV_STEREO_COMMAND stereoCmd;
  NV_STEREO_METADATA_STATE stereoState;
  NvU32 IsFromNPAPIPlugin;
  NvU32 dwReserved[7];
} NV_STEREO_FRAME_INFO;
typedef struct _NV_STEREO_METADATA_V1 {
  NvU32 version;
  NV_STEREO_FRAME_INFO frameInfo;
} NV_STEREO_METADATA_V1;
typedef NV_STEREO_METADATA_V1 NV_STEREO_METADATA;
#define NV_STEREO_METADATA_VER1 MAKE_NVAPI_VERSION(NV_STEREO_METADATA_V1, 1)
#define NV_STEREO_METADATA_VER NV_STEREO_METADATA_VER1
NVAPI_INTERFACE NvAPI_SYS_SetStereoMetaData(NV_STEREO_METADATA *pNvStereoMetaData);
NVAPI_INTERFACE NvAPI_SYS_EnableDisplayHotkeyHandling(void);
NVAPI_INTERFACE NvAPI_SYS_DisableDisplayHotkeyHandling(void);
typedef enum {
  NV_SMART_DIMMER_LEVEL_OFF = 0,
  NV_SMART_DIMMER_LEVEL_HIGHEST_QUALITY = 1,
  NV_SMART_DIMMER_LEVEL_HIGHER_QUALITY = 2,
  NV_SMART_DIMMER_LEVEL_BALANCED = 3,
  NV_SMART_DIMMER_LEVEL_HIGHER_BATT_LIFE = 4,
  NV_SMART_DIMMER_LEVEL_HIGHEST_BATT_LIFE = 5,
} NV_SMART_DIMMER_LEVEL;
#define NV_SMART_DIMMER_DISABLED NV_SMART_DIMMER_LEVEL_OFF
#define NV_SMART_DIMMER_AGGR_LEVEL_MIN NV_SMART_DIMMER_LEVEL_HIGHEST_QUALITY
#define NV_SMART_DIMMER_AGGR_LEVEL_MAX NV_SMART_DIMMER_LEVEL_HIGHEST_BATT_LIFE
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_SYS_GetSmartDimmerLevel(NV_SMART_DIMMER_LEVEL *pLevel);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_SYS_SetSmartDimmerLevel(NV_SMART_DIMMER_LEVEL level);
typedef struct {
  NvU32 version;
  NvU8 enable;
  NV_SMART_DIMMER_LEVEL aggressivenessLevel;
  NvU16 flickerThreshold;
  NvU16 flickerTimeLimit;
  NvU16 backlightStep;
  NvU16 backlightTC;
} NV_SMART_DIMMER_CONFIG_V1;
typedef NV_SMART_DIMMER_CONFIG_V1 NV_SMART_DIMMER_CONFIG;
#define NV_SMART_DIMMER_CONFIG_VER1 MAKE_NVAPI_VERSION(NV_SMART_DIMMER_CONFIG_V1, 1)
#define NV_SMART_DIMMER_CONFIG_VER NV_SMART_DIMMER_CONFIG_VER1
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_GPU_GetSmartDimmerConfig(NvPhysicalGpuHandle hPhysicalGpu, NV_SMART_DIMMER_CONFIG *pConfig);
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 440.") NVAPI_INTERFACE
    NvAPI_GPU_SetSmartDimmerConfig(NvPhysicalGpuHandle hPhysicalGpu, NV_SMART_DIMMER_CONFIG config);
NVAPI_INTERFACE NvAPI_SYS_NotifySBiosDisplaySwitch(NvU32 ulDevicesMask);
typedef enum _NV_SYS_POST_PORT_FORMAT {
  NVAPI_POST_PORT_FORMAT_HEX = 0,
  NVAPI_POST_PORT_FORMAT_BCD,
} NVAPI_POST_PORT_FORMAT;
NVAPI_INTERFACE NvAPI_SYS_SetPostOutput(NvU32 address, NVAPI_POST_PORT_FORMAT format, NvU32 data);
NVAPI_INTERFACE NvAPI_SYS_FixInvalidDriverState();
typedef enum _NV_SPB_COMMAND {
  NVAPI_SPB_CMD_GET_INIT = 0x0000,
  NVAPI_SPB_CMD_SET_EXEC,
  NVAPI_SPB_CMD_GET_EXEC,
  NVAPI_SPB_CMD_SET_ACTIONS,
  NVAPI_SPB_CMD_GET_ACTIONS,
  NVAPI_SPB_CMD_SET_LOGIC,
  NVAPI_SPB_CMD_GET_LOGIC,
  NVAPI_SPB_CMD_SET_PREFERENCE,
  NVAPI_SPB_CMD_GET_PREFERENCE,
  NVAPI_SPB_CMD_SET_GPU2CPU_LIMIT,
  NVAPI_SPB_CMD_GET_GPU2CPU_LIMIT,
  NVAPI_SPB_CMD_SET_PMU_SPB_STATE,
  NVAPI_SPB_CMD_GET_PMU_SPB_STATE,
  NVAPI_SPB_SYS_SET_MAX_POWER = 0x0100,
  NVAPI_SPB_SYS_GET_MAX_POWER,
  NVAPI_SPB_SYS_SET_COOLING_BUDGET,
  NVAPI_SPB_SYS_GET_COOLING_BUDGET,
  NVAPI_SPB_SYS_SET_INTEGRAL_PERIOD,
  NVAPI_SPB_SYS_GET_INTEGRAL_PERIOD,
  NVAPI_SPB_SYS_SET_RULESET,
  NVAPI_SPB_SYS_GET_RULESET,
  NVAPI_SPB_SYS_GET_RULE_COUNT,
  NVAPI_SPB_SYS_SET_APP_BOOST,
  NVAPI_SPB_SYS_GET_APP_BOOST,
  NVAPI_SPB_SYS_SET_PWR_SUPPLY_MODE,
  NVAPI_SPB_SYS_GET_PWR_SUPPLY_MODE,
  NVAPI_SPB_SYS_GET_VCT_SUPPORT_INFO,
  NVAPI_SPB_SYS_GET_SUPPORTED_FUNCTIONS,
  NVAPI_SPB_DATA_GET_POWER = 0x0200,
  NVAPI_SPB_DATA_GET_POWER_DELTA,
  NVAPI_SPB_DATA_GET_POWER_FUTURE,
  NVAPI_SPB_DATA_GET_POWER_LTMAVG,
  NVAPI_SPB_DATA_GET_POWER_INTEGRAL,
  NVAPI_SPB_DATA_GET_POWER_BURDEN,
  NVAPI_SPB_DATA_GET_POWER_INTERMEDIATE,
  NVAPI_SPB_DATA_GET_SENSOR_PARAMETERS = 0x0210,
  NVAPI_SPB_DATA_GET_TEMP = 0x0220,
  NVAPI_SPB_DATA_GET_TEMP_DELTA,
  NVAPI_SPB_DATA_GET_TEMP_FUTURE,
  NVAPI_SPB_DATA_GET_PSTATE = 0x0240,
  NVAPI_SPB_DATA_GET_PSTATE_CAP,
  NVAPI_SPB_DATA_GET_PSTATE_MIN,
  NVAPI_SPB_DATA_GET_PSTATE_MAX,
  NVAPI_SPB_DATA_GET_PSTATE_ACTION,
  NVAPI_SPB_DATA_GET_PSTATE_SLFM_PRESENT,
  NVAPI_SPB_CMD_SET_POWER_SIM_STATE = 0x0250,
  NVAPI_SPB_CMD_GET_POWER_SIM_STATE,
  NVAPI_SPB_DATA_SET_POWER_SIM_DATA,
  NVAPI_SPB_DATA_GET_POWER_SIM_DATA,
  NVAPI_SPB_DATA_PING_SBIOS_FOR_EVENT = 0x0321
} NVAPI_SPB_COMMAND;
typedef enum _NV_SPB_LOCALE {
  NVAPI_SPB_LOCALE_SYSTEM = 0x0000,
  NVAPI_SPB_LOCALE_CPU_0 = 0x0100,
  NVAPI_SPB_LOCALE_CPU_1,
  NVAPI_SPB_LOCALE_GPU_0 = 0x0200,
  NVAPI_SPB_LOCALE_GPU_1
} NVAPI_SPB_LOCALE;
typedef enum _NV_SPB_COMMAND_PARAM {
  NVAPI_SPB_CMD_DEF_INVALID = 0x80000000,
  NVAPI_SPB_CMD_DEF_INIT_NO = 0,
  NVAPI_SPB_CMD_DEF_INIT_YES,
  NVAPI_SPB_CMD_DEF_EXEC_STOP = 0,
  NVAPI_SPB_CMD_DEF_EXEC_START,
  NVAPI_SPB_CMD_DEF_ACTIONS_OFF = 0,
  NVAPI_SPB_CMD_DEF_ACTIONS_ON,
  NVAPI_SPB_CMD_DEF_LOGIC_OFF = 0,
  NVAPI_SPB_CMD_DEF_LOGIC_FUZZY,
  NVAPI_SPB_CMD_DEF_LOGIC_DETERMINISTIC,
  NVAPI_SPB_CMD_DEF_PREFERENCE_CPU = 0,
  NVAPI_SPB_CMD_DEF_PREFERENCE_GPU,
  NVAPI_SPB_CMD_DEF_PREFERENCE_BOTH,
  NVAPI_SPB_CMD_DEF_PMU_SPB_STATE_OFF = 0,
  NVAPI_SPB_CMD_DEF_PMU_SPB_STATE_ON,
  NVAPI_SPB_CMD_DEF_PWR_SUPPLY_REAL = 0,
  NVAPI_SPB_CMD_DEF_PWR_SUPPLY_FAKE_AC,
  NVAPI_SPB_CMD_DEF_PWR_SUPPLY_FAKE_BATT,
  NVAPI_SPB_SYS_DEF_FUNC_SUPPORT = 0x00000001,
  NVAPI_SPB_SYS_DEF_FUNC_VENTURASTATUS = 0x00000002,
  NVAPI_SPB_SYS_DEF_FUNC_GETPSS = 0x00000004,
  NVAPI_SPB_SYS_DEF_FUNC_SETPPC = 0x00000008,
  NVAPI_SPB_SYS_DEF_FUNC_GETPPC = 0x00000010,
  NVAPI_SPB_SYS_DEF_FUNC_VENTURACB = 0x00000020,
  NVAPI_SPB_SYS_DEF_FUNC_SYSPARAMS = 0x00000040,
  NVAPI_SPB_DATA_DEF_ACTION_DEC_TO_P0 = 0,
  NVAPI_SPB_DATA_DEF_ACTION_DEC_BY_1,
  NVAPI_SPB_DATA_DEF_ACTION_DO_NOTHING,
  NVAPI_SPB_DATA_DEF_ACTION_SET_CURRENT,
  NVAPI_SPB_DATA_DEF_ACTION_INC_BY_1,
  NVAPI_SPB_DATA_DEF_ACTION_INC_BY_2,
  NVAPI_SPB_DATA_DEF_ACTION_INC_TO_LFM,
  NVAPI_SPB_DATA_DEF_ACTION_INC_TO_SLFM,
  NVAPI_SPB_DATA_DEF_SLFM_PRESENT_NO = 0,
  NVAPI_SPB_DATA_DEF_SLFM_PRESENT_YES,
  NVAPI_SPB_DATA_DEF_POWER_SIM_STATE_OFF = 0,
  NVAPI_SPB_DATA_DEF_POWER_SIM_STATE_ON
} NVAPI_SPB_COMMAND_PARAM;
NVAPI_INTERFACE NvAPI_SYS_SpbControl(NVAPI_SPB_COMMAND command, NVAPI_SPB_LOCALE locale, NvU32 *pParam);
#define NVAPI_SPB_BATCH_COMMANDS_MAX 16
typedef struct {
  NvU32 version;
  NvU32 cmdCount;
  NvU32 succeeded;
  struct {
    NVAPI_SPB_COMMAND command;
    NVAPI_SPB_LOCALE locale;
    NvU32 param;
  } commands[NVAPI_SPB_BATCH_COMMANDS_MAX];
} NV_SPB_BATCH_COMMAND_STRUCT;
#define NV_SPB_BATCH_COMMAND_STRUCT_VER MAKE_NVAPI_VERSION(NV_SPB_BATCH_COMMAND_STRUCT, 1)
NVAPI_INTERFACE NvAPI_SYS_SpbBatchControl(NV_SPB_BATCH_COMMAND_STRUCT *pCmdStruct);
#define NVAPI_MAX_SPB_CPU_PSTATE 15
typedef struct {
  NvU32 version;
  NvU32 numOfCpuPstates;
  struct {
    NvU32 coreFreq;
    NvU32 power;
    NvU32 transitionLatency;
    NvU32 busMasterLatency;
    NvU32 control;
    NvU32 status;
  } cpuPstateTable[NVAPI_MAX_SPB_CPU_PSTATE];
} NV_SPB_GET_CPU_PSTATE_TABLE_V1;
typedef NV_SPB_GET_CPU_PSTATE_TABLE_V1 NV_SPB_GET_CPU_PSTATE_TABLE;
#define NV_SPB_GET_CPU_PSTATE_TABLE_VER_1 MAKE_NVAPI_VERSION(NV_SPB_GET_CPU_PSTATE_TABLE_V1, 1)
#define NV_SPB_GET_CPU_PSTATE_TABLE_VER NV_SPB_GET_CPU_PSTATE_TABLE_VER_1
NVAPI_INTERFACE NvAPI_SYS_SpbGetPstateTable(NV_SPB_GET_CPU_PSTATE_TABLE *pPstateTable);
#define NVAPI_SPB_MAX_SENSORS 8
typedef struct {
  NvU32 version;
  NvU32 sensorCount;
  struct {
    NvU32 target;
    NvU32 type;
    NvU32 i2cPort;
    NvU32 i2cAddress;
    NvU32 configIndex;
    NvU32 configValue;
    NvU32 calibIndex;
    NvU32 calibValue;
    NvU32 powerIndex;
    NvU32 pollFreq;
    NvU32 resistor;
  } sensorConfig[NVAPI_SPB_MAX_SENSORS];
} NV_SPB_GET_SENSOR_CONFIG_V1;
typedef NV_SPB_GET_SENSOR_CONFIG_V1 NV_SPB_GET_SENSOR_CONFIG;
#define NV_SPB_GET_SENSOR_CONFIG_VER_1 MAKE_NVAPI_VERSION(NV_SPB_GET_SENSOR_CONFIG_V1, 1)
#define NV_SPB_GET_SENSOR_CONFIG_VER NV_SPB_GET_SENSOR_CONFIG_VER_1
NVAPI_INTERFACE NvAPI_SYS_SpbGetSensorConfig(NV_SPB_GET_SENSOR_CONFIG *pSensorConfig);
NVAPI_INTERFACE NvAPI_SYS_GetDisplayIdFromGpuAndOutputId(NvPhysicalGpuHandle hPhysicalGpu, NvU32 outputId,
                                                         NvU32 *displayId);
NVAPI_INTERFACE NvAPI_SYS_GetGpuAndOutputIdFromDisplayId(NvU32 displayId, NvPhysicalGpuHandle *hPhysicalGpu,
                                                         NvU32 *outputId);
NVAPI_INTERFACE NvAPI_SYS_GetPhysicalGpuFromDisplayId(NvU32 displayId, NvPhysicalGpuHandle *hPhysicalGpu);
#define NV_LUID_CONTAINS_EDID NV_BIT(0)
NVAPI_INTERFACE NvAPI_SYS_GetLUIDFromDisplayID(NvU32 displayId, NvU32 flags, NvLUID *luId);
NVAPI_INTERFACE NvAPI_SYS_GetDisplayIdFromLUID(NvLUID luId, NvU32 *displayId);
#define NV_MAX_MDTL_COMBINATIONS 30
typedef struct _NV_MDTL_COMBINATION_V1 {
  NvU32 ulACPIId1;
  NvU32 ulACPIId2;
} NV_MDTL_COMBINATION_V1;
typedef struct _NV_MDTL_COMBINATION_V2 {
  NvU32 ulACPIId1;
  NvU32 ulACPIId2;
  NV_TARGET_VIEW_MODE viewMode;
} NV_MDTL_COMBINATION_V2;
typedef NV_MDTL_COMBINATION_V2 NV_MDTL_COMBINATION;
typedef struct _NV_MDTL_LIST_DATA_V1 {
  NvU32 version;
  NvU32 ulValidMdtlCombinations;
  NV_MDTL_COMBINATION_V1 mdtlList[NV_MAX_MDTL_COMBINATIONS];
} NV_MDTL_LIST_DATA_V1;
typedef struct _NV_MDTL_LIST_DATA_V2 {
  NvU32 version;
  NvU32 ulValidMdtlCombinations;
  NV_MDTL_COMBINATION mdtlList[NV_MAX_MDTL_COMBINATIONS];
} NV_MDTL_LIST_DATA_V2;
#define NV_MDTL_LIST_DATA_VER1 MAKE_NVAPI_VERSION(NV_MDTL_LIST_DATA_V1, 1)
#define NV_MDTL_LIST_DATA_VER2 MAKE_NVAPI_VERSION(NV_MDTL_LIST_DATA_V2, 2)
#define NV_MDTL_LIST_DATA_VER NV_MDTL_LIST_DATA_VER2
typedef NV_MDTL_LIST_DATA_V2 NV_MDTL_LIST_DATA;
typedef struct _NV_MDTL_VALID_INDEX_V1 {
  NvU32 version;
  NvU32 ulValidMdtlIndex;
} NV_MDTL_VALID_INDEX_V1;
#define NV_MDTL_VALID_INDEX_VER1 MAKE_NVAPI_VERSION(NV_MDTL_VALID_INDEX_V1, 1)
#define NV_MDTL_VALID_INDEX_VER NV_MDTL_VALID_INDEX_VER1
typedef NV_MDTL_VALID_INDEX_V1 NV_MDTL_VALID_INDEX;
NVAPI_INTERFACE NvAPI_SYS_GetMDTLData(NV_MDTL_LIST_DATA *pMdtlData);
NVAPI_INTERFACE NvAPI_SYS_SetValidMDTLIndex(NV_MDTL_VALID_INDEX *pMdtlIndexData);
typedef enum _NVAPI_VENTURA_STATE {
  NVAPI_VENTURA_STATE_UNSUPPORTED,
  NVAPI_VENTURA_STATE_DISABLED,
  NVAPI_VENTURA_STATE_ENABLED
} NVAPI_VENTURA_STATE;
NVAPI_INTERFACE NvAPI_SYS_VenturaGetState(NVAPI_VENTURA_STATE *state);
NVAPI_INTERFACE NvAPI_SYS_VenturaSetState(NVAPI_VENTURA_STATE state);
NVAPI_INTERFACE NvAPI_SYS_VenturaGetCoolingBudget(NvU32 *budget);
NVAPI_INTERFACE NvAPI_SYS_VenturaSetCoolingBudget(NvU32 budget);
typedef enum _NVAPI_VENTURA_DEVICE {
  NVAPI_VENTURA_DEVICE_SYSTEM,
  NVAPI_VENTURA_DEVICE_CPU_0,
  NVAPI_VENTURA_DEVICE_GPU_0
} NVAPI_VENTURA_DEVICE;
NVAPI_INTERFACE NvAPI_SYS_VenturaGetPowerReading(NVAPI_VENTURA_DEVICE device, NvU32 *power);
typedef enum {
  NV_SS_FEATURE_LICENSE_MODE_UNKNOWN = 0,
  NV_SS_FEATURE_LICENSE_MODE_3DVISION_PANEL = 1,
  NV_SS_FEATURE_LICENSE_MODE_3DTV_OEM_BULK = 2,
  NV_SS_FEATURE_LICENSE_MODE_3DTV_END_USER = 3,
  NV_SS_FEATURE_LICENSE_MODE_3DV_ANY = 4,
  NV_SS_FEATURE_LICENSE_MODE_3DTV_PLAYPLUS_END_USER = 5,
  NV_SS_FEATURE_LICENSE_MODE_CSC_OEM_BULK = 0x100,
  NV_SS_FEATURE_LICENSE_MODE_CSC_END_USER = 0x200,
  NV_SS_FEATURE_LICENSE_MODE_CSC_ANY = 0xF00,
} NV_SS_FEATURE_LICENSE_MODE;
NVAPI_INTERFACE NvAPI_SYS_CheckLicense(NV_SS_FEATURE_LICENSE_MODE mode,
                                       NV_SS_FEATURE_LICENSE_MODE *pEffectiveLicenseMode);
NVAPI_INTERFACE NvAPI_SYS_IdentifyLicense(NV_SS_FEATURE_LICENSE_MODE mode, NvU8 sessionKey[16], NvU8 random[32],
                                          NvU8 serialNumber4PID[32]);
NVAPI_INTERFACE NvAPI_SYS_ValidateLicense(NV_SS_FEATURE_LICENSE_MODE mode);
NVAPI_INTERFACE NvAPI_SYS_GenerateLicense(NV_SS_FEATURE_LICENSE_MODE mode, NvU8 sessionKey[16], NvU8 serialNumber[16]);
NVAPI_INTERFACE NvAPI_SYS_RemoveLicense(NV_SS_FEATURE_LICENSE_MODE mode);
NVAPI_INTERFACE NvAPI_SYS_SetMiscLicenseInfo(NV_SS_FEATURE_LICENSE_MODE mode, NvU8 licenseInfo[256]);
NVAPI_INTERFACE NvAPI_SYS_ClearMiscLicenseInfo(NV_SS_FEATURE_LICENSE_MODE mode);
typedef struct _NV_SS_MISC_LICENSE_INFO_V1 {
  NvU32 version;
  NvU8 isLicensed;
  char szSerialNumber[128];
  NvU8 isTrialExpired;
  NvU8 trialDaysLeft;
} NV_SS_MISC_LICENSE_INFO_V1;
typedef NV_SS_MISC_LICENSE_INFO_V1 NV_SS_MISC_LICENSE_INFO;
#define NV_SS_MISC_LICENSE_INFO_VER1 MAKE_NVAPI_VERSION(NV_SS_MISC_LICENSE_INFO_V1, 1)
#define NV_SS_MISC_LICENSE_INFO_VER NV_SS_MISC_LICENSE_INFO_VER1
NVAPI_INTERFACE NvAPI_SYS_GetMiscLicenseInfo(NV_SS_FEATURE_LICENSE_MODE mode,
                                             NV_SS_MISC_LICENSE_INFO *pMiscLicenseInfo);
typedef struct _NVAPI_SYS_NBCI_PLATCAPS_PARAMS {
  NvU32 version;
  NvU32 is3DEnableHotKeySupported : 1;
  NvU32 is3DSeparationHotKeySupported : 1;
  NvU32 is3DActivateHotKeySupported : 1;
  NvU32 reserved : 29;
} NVAPI_SYS_NBCI_PLATCAPS_PARAMS_V1;
typedef NVAPI_SYS_NBCI_PLATCAPS_PARAMS_V1 NVAPI_SYS_NBCI_PLATCAPS_PARAMS;
#define NVAPI_SYS_NBCI_PLATCAPS_PARAMS_VER1 MAKE_NVAPI_VERSION(NVAPI_SYS_NBCI_PLATCAPS_PARAMS_V1, 1)
#define NVAPI_SYS_NBCI_PLATCAPS_PARAMS_VER NVAPI_SYS_NBCI_PLATCAPS_PARAMS_VER1
NVAPI_INTERFACE NvAPI_SYS_GetNBCIPlatCaps(NVAPI_SYS_NBCI_PLATCAPS_PARAMS *pParams);
#define NVAPI_OCA_FINGERPRINT_MAX_BUFFER_SIZE 128
NVAPI_INTERFACE NvAPI_SYS_SaveOCAFingerprint(__in_bcount(sizeOfBuffer) const NvU8 *pFingerprintBuffer,
                                             __in NvU32 sizeOfBuffer);
NVAPI_INTERFACE NvAPI_SYS_GetPipeServerInformation(__out_bcount_full(sizeof(NvAPI_UnicodeString))
                                                       NvAPI_UnicodeString pipeServerName,
                                                   __out NvU32 *pipeServerVersion);
NVAPI_INTERFACE NvAPI_SYS_SetScreenSaverState(__in NvU8 bRunning);
typedef struct _NVAPI_SYS_ACPIID_MAP {
  NvU32 version;
  NvU32 count;
  NvU32 acpiIds[NVAPI_MAX_ACPI_IDS];
  NvU32 displayIds[NVAPI_MAX_ACPI_IDS];
} NVAPI_SYS_ACPIID_MAP_V1;
typedef NVAPI_SYS_ACPIID_MAP_V1 NVAPI_SYS_ACPIID_MAP;
#define NVAPI_SYS_ACPIID_MAP_VER1 MAKE_NVAPI_VERSION(NVAPI_SYS_ACPIID_MAP_V1, 1)
#define NVAPI_SYS_ACPIID_MAP_VER NVAPI_SYS_ACPIID_MAP_VER1
NVAPI_INTERFACE NvAPI_SYS_GetACPIIdMappings(__inout NVAPI_SYS_ACPIID_MAP *pACPIIdMap);
typedef struct _NV_VGX_SYS_INFO {
  NvU32 version;
  NvAPI_LongString hostDriverVersion;
  NvAPI_LongString hostDriverBranchVersion;
  NvAPI_LongString hostDriverTitle;
  NvAPI_LongString hostOSVersion;
  NvAPI_LongString pluginDriverTitle;
  NvU32 pluginChangelistNumber;
  NvU32 hostOSChangelistNumber;
} NV_VGX_SYS_INFO_V1;
typedef NV_VGX_SYS_INFO_V1 NV_VGX_SYS_INFO;
#define NV_VGX_SYS_INFO_VER1 MAKE_NVAPI_VERSION(NV_VGX_SYS_INFO_V1, 1)
#define NV_VGX_SYS_INFO_VER NV_VGX_SYS_INFO_VER1
NVAPI_INTERFACE NvAPI_SYS_GetVGXInfo(__inout NV_VGX_SYS_INFO *pVGXSysInfo);
typedef enum _NVAPI_SYS_POWER_STATUS {
  NVAPI_SYS_EXTERNAL_POWER_STATUS_CONNECTED = 0x00,
  NVAPI_SYS_EXTERNAL_POWER_STATUS_NOT_CONNECTED = 0x01,
} NVAPI_SYS_EXTERNAL_POWER_STATUS;
typedef struct _NV_SYS_GPU_POWER_STATUS_V1 {
  NvU32 version;
  NvU8 busNumber;
  NVAPI_SYS_EXTERNAL_POWER_STATUS externalPowerStatus;
} NV_SYS_GPU_POWER_STATUS_V1;
typedef NV_SYS_GPU_POWER_STATUS_V1 NV_SYS_GPU_POWER_STATUS;
#define NV_SYS_GPU_POWER_STATUS_VER1 MAKE_NVAPI_VERSION(NV_SYS_GPU_POWER_STATUS_V1, 1)
#define NV_SYS_GPU_POWER_STATUS_VER NV_SYS_GPU_POWER_STATUS_VER1
typedef struct _NV_SYS_POWER_STATUS_V1 {
  NvU32 version;
  NV_SYS_GPU_POWER_STATUS *pGpuPowerStatus;
  NvU32 gpuCount;
} NV_SYS_POWER_STATUS_V1;
typedef NV_SYS_POWER_STATUS_V1 NV_SYS_POWER_STATUS;
#define NV_SYS_POWER_STATUS_VER1 MAKE_NVAPI_VERSION(NV_SYS_POWER_STATUS_V1, 1)
#define NV_SYS_POWER_STATUS_VER NV_SYS_POWER_STATUS_VER1
NVAPI_INTERFACE NvAPI_SYS_GetPowerStatus(__inout NV_SYS_POWER_STATUS *pPowerStatus);
typedef struct _NV_SYS_JT_CAPS {
  NvU32 version;
  NvU32 isJTEnabled : 1;
  NvU32 NVSREnabled : 2;
  NvU32 PanelPowerRail : 2;
  NvU32 SelfRefreshControllerPowerRail : 1;
  NvU32 FBPowerRail : 2;
  NvU32 GPUPowerRail : 2;
  NvU32 GC6ROM : 1;
  NvU32 PanicTrapHandler : 1;
  NvU32 reserved : 20;
} NV_SYS_JT_CAPS_V1;
typedef NV_SYS_JT_CAPS_V1 NV_SYS_JT_CAPS;
#define NV_SYS_JT_CAPS_VER1 MAKE_NVAPI_VERSION(NV_SYS_JT_CAPS_V1, 1)
#define NV_SYS_JT_CAPS_VER NV_SYS_JT_CAPS_VER1
NVAPI_INTERFACE NvAPI_SYS_GetJTCaps(__inout NV_SYS_JT_CAPS *jtCaps);
typedef struct _NV_SYS_FRL20_VBLANK_DATA_V1 {
  NvU32 version;
  NvU32 refreshIntervalUs;
  NvU64 estimatedVblankTime;
  NvU32 bActiveSinceLastCall : 1;
  NvU32 reserved : 31;
} NV_SYS_FRL20_VBLANK_DATA_V1;
typedef NV_SYS_FRL20_VBLANK_DATA_V1 NV_SYS_FRL20_VBLANK_DATA;
#define NV_SYS_FRL20_VBLANK_DATA_VER_1 MAKE_NVAPI_VERSION(NV_SYS_FRL20_VBLANK_DATA_V1, 1)
#define NV_SYS_FRL20_VBLANK_DATA_VER NV_SYS_FRL20_VBLANK_DATA_VER_1
__nvapi_deprecated_function("Do not use this function - it is deprecated in release 495.") NVAPI_INTERFACE
    NvAPI_SYS_Frl20AlignVblank(__inout NV_SYS_FRL20_VBLANK_DATA *pData);
typedef enum _NV_CURSOR_COLOR_FORMAT_FLAGS {
  NV_CURSOR_COLOR_FORMAT_NONE = 0,
  NV_CURSOR_COLOR_FORMAT_MONOCHROME = 1,
  NV_CURSOR_COLOR_FORMAT_COLOR = 2,
  NV_CURSOR_COLOR_FORMAT_MASKED_COLOR = 3,
} NV_CURSOR_COLOR_FORMAT_FLAGS;
typedef struct _NV_CURSOR_INFO_V1 {
  NvU32 version;
  NvU8 bIsVisible;
  NvU32 xHot;
  NvU32 yHot;
  NV_CURSOR_COLOR_FORMAT_FLAGS formatFlag;
  NvU32 bmpBufferSize;
  NvU8 *pBmpData;
} NV_CURSOR_INFO_V1;
typedef struct _NV_CURSOR_INFO_V2 {
  NvU32 version;
  NvU8 bIsVisible;
  NvU32 xHot;
  NvU32 yHot;
  NV_CURSOR_COLOR_FORMAT_FLAGS formatFlag;
  NvU32 bmpBufferSize;
  NvU8 *pBmpData;
  NvU64 ulWidth;
  NvU64 ulHeight;
  NvU64 ulPitch;
  NvU64 ulPlanes;
  NvU64 ulDepth;
} NV_CURSOR_INFO_V2;
typedef NV_CURSOR_INFO_V2 NV_CURSOR_INFO;
#define NV_CURSOR_INFO_VER1 MAKE_NVAPI_VERSION(NV_CURSOR_INFO_V1, 1)
#define NV_CURSOR_INFO_VER2 MAKE_NVAPI_VERSION(NV_CURSOR_INFO_V2, 2)
#define NV_CURSOR_INFO_VER NV_CURSOR_INFO_VER2
NVAPI_INTERFACE NvAPI_SYS_GetCursorInfo(NV_CURSOR_INFO *cursorBitMapInfo);
NVAPI_INTERFACE NvAPI_SYS_CheckIfDriverHackedForSLI(NvBool *pBIsDriverHacked);
typedef struct _NV_SMP_INFO_V1 {
  NvU32 version;
  float tilt;
  float verticalFOV;
  NvU32 cameraMode;
  NvU32 bDefault : 1;
  NvU32 reserved : 31;
} NV_SMP_INFO_V1;
#define NV_SMP_INFO_VER1 MAKE_NVAPI_VERSION(NV_SMP_INFO_V1, 1)
typedef NV_SMP_INFO_V1 NV_SMP_INFO;
#define NV_SMP_INFO_VER NV_SMP_INFO_VER1
NVAPI_INTERFACE NvAPI_SYS_GetSMPInfo(__inout NV_SMP_INFO *pSMPInfo);
NVAPI_INTERFACE NvAPI_SYS_SetSMPInfo(__in NV_SMP_INFO *pSMPInfo);
typedef struct _NV_DISPLAY_DRIVER_INFO {
  NvU32 version;
  NvU32 driverVersion;
  NvAPI_ShortString szBuildBranch;
  NvU32 bIsDCHDriver : 1;
  NvU32 bIsNVIDIAStudioPackage : 1;
  NvU32 bIsNVIDIAGameReadyPackage : 1;
  NvU32 bIsNVIDIARTXProductionBranchPackage : 1;
  NvU32 bIsNVIDIARTXNewFeatureBranchPackage : 1;
  NvU32 reserved : 27;
} NV_DISPLAY_DRIVER_INFO_V1;
#define NV_DISPLAY_DRIVER_INFO_VER1 MAKE_NVAPI_VERSION(NV_DISPLAY_DRIVER_INFO_V1, 1)
typedef NV_DISPLAY_DRIVER_INFO_V1 NV_DISPLAY_DRIVER_INFO;
#define NV_DISPLAY_DRIVER_INFO_VER NV_DISPLAY_DRIVER_INFO_VER1
NVAPI_INTERFACE NvAPI_SYS_GetDisplayDriverInfo(__inout NV_DISPLAY_DRIVER_INFO *pDriverInfo);
NVAPI_INTERFACE NvAPI_SYS_VRRIndicatorState(__in NvU8 bEnable);
typedef struct _NV_GPU_COUNT_DATA_V1 {
  NvU32 version;
  NvU32 gpuCountFromBus;
  NvU32 activeGpuCount;
  NvU32 reserved[2];
} NV_GPU_COUNT_DATA_V1;
#define NV_GPU_COUNT_DATA_VER1 MAKE_NVAPI_VERSION(NV_GPU_COUNT_DATA_V1, 1)
typedef NV_GPU_COUNT_DATA_V1 NV_GPU_COUNT_DATA;
#define NV_GPU_COUNT_DATA_VER NV_GPU_COUNT_DATA_VER1
NVAPI_INTERFACE NvAPI_SYS_GetGpuCount(__inout NV_GPU_COUNT_DATA *pGpuCountData);
#define NVAPI_INVALID_TARGET_ID 0x0
typedef struct _NV_DISPLAY_TARGET_INFO_V1 {
  void *pOSAdapterId;
  NvU32 targetId;
  NvU32 outputTechnology;
  NvU32 bIsActive : 1;
  NvU32 reserved : 31;
  NvU8 reservedEx[8];
} NV_DISPLAY_TARGET_INFO_V1;
typedef struct _NV_DDS_SHARED_DISPLAY_INFO_V1 {
  NV_DISPLAY_TARGET_INFO_V1 iGpuDisplay;
  NV_DISPLAY_TARGET_INFO_V1 dGpuDisplay;
} NV_DDS_SHARED_DISPLAY_INFO_V1;
typedef struct _NV_DDS_INFO_V1 {
  NvU32 version;
  NvU32 numValidEntries;
  NV_DDS_SHARED_DISPLAY_INFO_V1 sharedDisplays[NVAPI_MAX_DISPLAYS];
  NvU32 resreved[8];
} NV_DDS_INFO_V1;
#define NV_DDS_INFO_VER1 MAKE_NVAPI_VERSION(NV_DDS_INFO_V1, 1)
typedef NV_DDS_INFO_V1 NV_DDS_INFO;
typedef NV_DDS_SHARED_DISPLAY_INFO_V1 NV_DDS_SHARED_DISPLAY_INFO;
#define NV_DDS_INFO_VER NV_DDS_INFO_VER1
NVAPI_INTERFACE NvAPI_SYS_GetDDSInfo(__inout NV_DDS_INFO *pDDSInfo);
#define ACE_ICON_WINDOW_CLASS "ACEIconWindowClass-5A341C11-B33D-4913-8FFC-863690D2AD11"
#define ACE_ICON_WINDOW "ACEIconWindow-5A341C11-B33D-4913-8FFC-863690D2AD11"
#define ACE_REGISTERED_MESSAGE_ID "ACEIconWindowMessage-5A341C11-B33D-4913-8FFC-863690D2AD11"
typedef enum _NV_UI_CONTROL_DATA_TYPE {
  NV_UI_CONTROL_DATA_TYPE_INVALID = 0,
  NV_UI_CONTROL_DATA_TYPE_MUX_TRAY_DATA = 1,
  NV_UI_CONTROL_DATA_TYPE_MAX = 0xFFFF
} NV_UI_CONTROL_DATA_TYPE;
typedef enum _NV_MUX_UI_TRAY_STATE { NV_MUX_UI_TRAY_STATE_OPEN = 0, NV_MUX_UI_TRAY_STATE_CLOSE } NV_MUX_UI_TRAY_STATE;
typedef enum _NV_MUX_UI_TRAY_CMD {
  NV_MUX_UI_TRAY_CMD_INVALID = 0,
  NV_MUX_UI_TRAY_CMD_SET = 1,
} NV_MUX_UI_TRAY_CMD;
typedef struct _NV_UI_TRAY_DATA_V1 {
  NvU32 version;
  NV_MUX_UI_TRAY_STATE trayState;
  NV_MUX_UI_TRAY_CMD cmd;
  NvU32 reserved[8];
} NV_MUX_UI_TRAY_DATA_V1;
#define NV_MUX_UI_TRAY_DATA_VER1 MAKE_NVAPI_VERSION(NV_MUX_UI_TRAY_DATA_V1, 1)
#define NV_MUX_UI_TRAY_DATA_VER NV_MUX_UI_TRAY_DATA_VER1
typedef NV_MUX_UI_TRAY_DATA_V1 NV_MUX_UI_TRAY_DATA;
typedef struct _NV_UI_CONTROL_PARAMS_V1 {
  NvU32 version;
  void *controlData;
  NvU32 dataSize;
  NV_UI_CONTROL_DATA_TYPE dataType;
  NvU32 reserved[8];
} NV_UI_CONTROL_PARAMS_V1;
#define NV_UI_CONTROL_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_UI_CONTROL_PARAMS_V1, 1)
typedef NV_UI_CONTROL_PARAMS_V1 NV_UI_CONTROL_PARAMS;
#define NV_UI_CONTROL_PARAMS_VER NV_UI_CONTROL_PARAMS_VER1
NVAPI_INTERFACE NvAPI_SYS_UIControl(__inout NV_UI_CONTROL_PARAMS *controlParams);
typedef struct _NV_MUX_CONTROL_DATA_V1 {
  NvU32 version;
  NvU32 status;
  NV_MUX_STATE muxState;
  NvU32 isInternal : 1;
  NvU32 isAutomatic : 1;
  NvU32 reserved : 30;
} NV_MUX_CONTROL_DATA_V1;
#define NV_MUX_CONTROL_DATA_VER1 MAKE_NVAPI_VERSION(NV_MUX_CONTROL_DATA_V1, 1)
#define NV_MUX_CONTROL_DATA_VER NV_MUX_CONTROL_DATA_VER1
typedef NV_MUX_CONTROL_DATA_V1 NV_MUX_CONTROL_DATA;
typedef enum _NV_UI_CONTROL_INTERNAL_DATA_TYPE {
  NV_UI_CONTROL_INTERNAL_DATA_TYPE_INVALID = 0,
  NV_UI_CONTROL_INTERNAL_DATA_TYPE_MUX_CONTROL = 1,
  NV_UI_CONTROL_INTERNAL_DATA_TYPE_MAX = 0xFFFF
} NV_UI_CONTROL_INTERNAL_DATA_TYPE;
typedef struct _NV_UI_CONTROL_INTERNAL_PARAMS_V1 {
  NvU32 version;
  void *controlData;
  NvU32 dataSize;
  NV_UI_CONTROL_INTERNAL_DATA_TYPE dataType;
  NvU32 reserved[8];
} NV_UI_CONTROL_INTERNAL_PARAMS_V1;
#define NV_UI_CONTROL_INTERNAL_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_UI_CONTROL_INTERNAL_PARAMS_V1, 1)
typedef NV_UI_CONTROL_INTERNAL_PARAMS_V1 NV_UI_CONTROL_INTERNAL_PARAMS;
#define NV_UI_CONTROL_INTERNAL_PARAMS_VER NV_UI_CONTROL_INTERNAL_PARAMS_VER1
NVAPI_INTERFACE NvAPI_SYS_UIControl_Internal(__inout NV_UI_CONTROL_INTERNAL_PARAMS *controlParams);
#define NV_SYS_INTERNAL_NOCAT_JOURNAL_MAX_DIAG_BUFFER 1024
#define NV_SYS_INTERNAL_NOCAT_JOURNAL_MAX_ERRORS 10
typedef struct {
  NvU32 userMinOffset;
  NvU32 userMaxOffset;
  NvU32 factoryMinOffset;
  NvU32 factoryMaxOffset;
  NvU32 lastActiveClock;
  NvU32 lastActiveVolt;
  NvU32 lastActivePoint;
  NvU32 kappa;
  NvU8 reserved[128];
} NV_SYS_INTERNAL_NOCAT_JOURNAL_OVERCLOCK_DETAILS_V1;
typedef struct {
  NV_SYS_INTERNAL_NOCAT_JOURNAL_OVERCLOCK_DETAILS_V1 gpcOverclock;
  NV_SYS_INTERNAL_NOCAT_JOURNAL_OVERCLOCK_DETAILS_V1 mclkOverclock;
  NvBool bUserOverclocked;
  NvBool bFactoryOverclocked;
  NvU8 reserved[128];
} NV_SYS_INTERNAL_NOCAT_JOURNAL_OVERCLOCK_CFG_V1;
typedef struct {
  NvBool bValid;
  NvU32 strap;
  NvU16 deviceId;
  NvU16 vendorId;
  NvU16 subsystemId;
  NvU16 revision;
  NvU16 type;
  NvU32 vbiosVersion;
  NvU32 vbiosOemVersion;
  NvAPI_ShortString vbiosProject;
  NvBool bOptimus;
  NvBool bMsHybrid;
  NvBool bFullPower;
  NvBool bInFullchipReset;
  NvBool bInSecBusReset;
  NvBool bInGc6Reset;
  NV_SYS_INTERNAL_NOCAT_JOURNAL_OVERCLOCK_CFG_V1 overclockCfg;
  NvAPI_ShortString tag;
  NvU16 subsystemVendor;
  NvU16 memoryType;
  NvU8 reserved[60];
} NV_SYS_INTERNAL_NOCAT_JOURNAL_GPU_STATE_V1;
typedef enum {
  nocatJournalRecTypeUnknown = 0,
  nocatJournalRecTypeBugcheck,
  nocatJournalRecTypeEngine,
  nocatJournalRecTypeTdr,
  nocatJournalRecTypeRcError,
  nocatJournalRecTypeAssert
} NV_SYS_INTERNAL_NOCAT_JOURNAL_REC_TYPE;
typedef struct {
  NV_SYS_INTERNAL_NOCAT_JOURNAL_REC_TYPE recType;
  NvU32 bugcheck;
  NvAPI_ShortString source;
  NvU32 subsystem;
  NvU64 errorCode;
  NvU32 diagBufferLen;
  NvU8 diagBuffer[NV_SYS_INTERNAL_NOCAT_JOURNAL_MAX_DIAG_BUFFER];
  NvAPI_ShortString faultingEngine;
  NvU32 mmuFaultType;
  NvU32 mmuErrorSrc;
  NvAPI_ShortString tdrReason;
  NvU8 reserved[128];
} NV_SYS_INTERNAL_NOCAT_JOURNAL_ENTRY_V1;
typedef struct {
  NvU32 GPUTag;
  NvU64 loadAddress;
  NvU64 timeStamp;
  NvU64 stateMask;
  NV_SYS_INTERNAL_NOCAT_JOURNAL_GPU_STATE_V1 nocatGpuState;
  NV_SYS_INTERNAL_NOCAT_JOURNAL_ENTRY_V1 nocatJournalEntry;
  NvU32 reserved[32];
} NV_SYS_INTERNAL_NOCAT_JOURNAL_RECORD_V1;
#define NV_SYS_INTERNAL_NOCAT_JOURNAL_CLEAR_REPORTED 0x0001
#define NV_SYS_INTERNAL_NOCAT_JOURNAL_TEST_REPORT 0x8000
typedef struct {
  NvU32 version;
  NvU32 flags;
  NvU32 nocatRecordCount;
  NvU32 nocatOutstandingRecordCount;
  NV_SYS_INTERNAL_NOCAT_JOURNAL_RECORD_V1 journalRecords[NV_SYS_INTERNAL_NOCAT_JOURNAL_MAX_ERRORS];
  NvU8 reserved[256];
} NV_SYS_INTERNAL_CTRL_GET_NOCAT_JOURNAL_V1;
#define NV_SYS_INTERNAL_CTRL_GET_NOCAT_JOURNAL_VER1 MAKE_NVAPI_VERSION(NV_SYS_INTERNAL_CTRL_GET_NOCAT_JOURNAL_V1, 1)
typedef NV_SYS_INTERNAL_CTRL_GET_NOCAT_JOURNAL_V1 NV_SYS_INTERNAL_CTRL_GET_NOCAT_JOURNAL;
#define NV_SYS_INTERNAL_CTRL_GET_NOCAT_JOURNAL_VER NV_SYS_INTERNAL_CTRL_GET_NOCAT_JOURNAL_VER1
NVAPI_INTERFACE NvAPI_SYS_InternalGetNocatJournal(__inout NV_SYS_INTERNAL_CTRL_GET_NOCAT_JOURNAL *pNocatJournalRequest);
#define NV_SYS_INTERNAL_NOCAT_TAG_CLEAR 0 : 0
#define NV_SYS_INTERNAL_NOCAT_TAG_CLEAR_YES 1
#define NV_SYS_INTERNAL_NOCAT_TAG_CLEAR_NO 0
#define NV_SYS_INTERNAL_NOCAT_TAG_RESERVED 31 : 1
typedef struct _NocatJournalSetTag {
  NvU32 version;
  NvU32 flags;
  NvAPI_ShortString tag;
} NV_SYS_INTERNAL_CTRL_NOCAT_SET_TAG_V1;
#define NV_SYS_INTERNAL_CTRL_NOCAT_SET_TAG_VER1 MAKE_NVAPI_VERSION(NV_SYS_INTERNAL_CTRL_NOCAT_SET_TAG_V1, 1)
typedef NV_SYS_INTERNAL_CTRL_NOCAT_SET_TAG_V1 NV_SYS_INTERNAL_CTRL_NOCAT_SET_TAG;
#define NV_SYS_INTERNAL_CTRL_NOCAT_SET_TAG_VER NV_SYS_INTERNAL_CTRL_NOCAT_SET_TAG_VER1
NVAPI_INTERFACE NvAPI_SYS_InternalNvtoppsSetNocatTag(__inout NV_SYS_INTERNAL_CTRL_NOCAT_SET_TAG *pNocatJournalData);
typedef struct _NV_REFLEX_FLASH_INDICATOR_PARAMS {
  NvU32 version;
  NvBool bShow;
  NvU8 width;
  NvU8 height;
  NvU8 posX;
  NvU8 posY;
  NvBool bDrawNegative;
  NvU32 durationMs;
  NvU8 rsvd[123];
} NV_REFLEX_FLASH_INDICATOR_PARAMS_V1;
typedef NV_REFLEX_FLASH_INDICATOR_PARAMS_V1 NV_REFLEX_FLASH_INDICATOR_PARAMS;
#define NV_REFLEX_FLASH_INDICATOR_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_REFLEX_FLASH_INDICATOR_PARAMS_V1, 1)
#define NV_REFLEX_FLASH_INDICATOR_PARAMS_VER NV_REFLEX_FLASH_INDICATOR_PARAMS_VER1
NVAPI_INTERFACE NvAPI_Reflex_FlashIndicatorSet(__in NV_REFLEX_FLASH_INDICATOR_PARAMS *pReflexFlashIndicatorParams);
typedef struct _NV_NIS2_PARAMS {
  NvU32 version;
  NvU8 sharpness;
} NV_NIS2_PARAMS_V1;
typedef NV_NIS2_PARAMS_V1 NV_NIS2_PARAMS;
#define NV_NIS2_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_NIS2_PARAMS_V1, 1)
#define NV_NIS2_PARAMS_VER NV_NIS2_PARAMS_VER1
NVAPI_INTERFACE NvAPI_Set_NIS2_Sharpness(__in NV_NIS2_PARAMS *pParams);
typedef struct _NV_PCF_BOARDOBJ {
  NvU8 type;
} NV_PCF_BOARDOBJ;
#define NV_PCF_BOARDOBJGRP_TYPE_INVALID (0x00)
#define NV_PCF_BOARDOBJGRP_TYPE_E32 (0x01)
#define NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS (32)
#define NV_PCF_BOARDOBJ_IDX_INVALID NV_U8_MAX
#define NV_PCF_BOARDOBJGRP_MASK_MASK_ELEMENT_BIT_SIZE (32)
#define NV_PCF_BOARDOBJGRP_MASK_MASK_ELEMENT_INDEX(_bit) ((_bit) / NV_PCF_BOARDOBJGRP_MASK_MASK_ELEMENT_BIT_SIZE)
#define NV_PCF_BOARDOBJGRP_MASK_MASK_ELEMENT_OFFSET(_bit) ((_bit) % NV_PCF_BOARDOBJGRP_MASK_MASK_ELEMENT_BIT_SIZE)
#define NV_PCF_BOARDOBJGRP_MASK_DATA_SIZE(_bits) (NV_PCF_BOARDOBJGRP_MASK_MASK_ELEMENT_INDEX((_bits) - 1) + 1)
#define NV_PCF_BOARDOBJGRP_MASK_ARRAY_START_SIZE (1)
#define NV_PCF_BOARDOBJGRP_MASK_ARRAY_EXTENSION_SIZE(_bits)                                                            \
  (NV_PCF_BOARDOBJGRP_MASK_DATA_SIZE(_bits) - NV_PCF_BOARDOBJGRP_MASK_ARRAY_START_SIZE)
#define NV_PCF_BOARDOBJGRP_MASK_FOR_EACH_INDEX(_maxObjects, _index, _pMask)                                            \
  {                                                                                                                    \
    for (_index = 0; _index < _maxObjects; _index++) {                                                                 \
      if (0 == (NV_BIT(NV_PCF_BOARDOBJGRP_MASK_MASK_ELEMENT_OFFSET(_index)) &                                          \
                (_pMask)->pData[NV_PCF_BOARDOBJGRP_MASK_MASK_ELEMENT_INDEX(_index)])) {                                \
        continue;                                                                                                      \
      }
#define NV_PCF_BOARDOBJGRP_MASK_FOR_EACH_INDEX_END                                                                     \
  }                                                                                                                    \
  }
#define NV_PCF_BOARDOBJGRP_MASK_E32_FOR_EACH_INDEX(_index, _pMask)                                                     \
  NV_PCF_BOARDOBJGRP_MASK_FOR_EACH_INDEX(NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS, _index, _pMask)
#define NV_PCF_BOARDOBJGRP_MASK_INIT(_pMask, _bitSize)                                                                 \
  do {                                                                                                                 \
    NvU8 _dataCount = NV_PCF_BOARDOBJGRP_MASK_DATA_SIZE(_bitSize);                                                     \
    NvU8 _dataIndex;                                                                                                   \
    for (_dataIndex = 0; _dataIndex < _dataCount; _dataIndex++) { (_pMask)->pData[_dataIndex] = NV_U32_MIN; }          \
  } while (0)
#define NV_PCF_BOARDOBJGRP_MASK_E32_INIT(_pMask)                                                                       \
  NV_PCF_BOARDOBJGRP_MASK_INIT(_pMask, NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS)
typedef struct _NV_PCF_BOARDOBJGRP_MASK {
  NvU32 pData[NV_PCF_BOARDOBJGRP_MASK_ARRAY_START_SIZE];
} NV_PCF_BOARDOBJGRP_MASK, *PNV_PCF_BOARDOBJGRP_MASK;
typedef const NV_PCF_BOARDOBJGRP_MASK CNV_PCF_BOARDOBJGRP_MASK, *PCNV_PCF_BOARDOBJGRP_MASK;
typedef struct _NV_PCF_BOARDOBJGRP_MASK_E32 {
  NV_PCF_BOARDOBJGRP_MASK super;
} NV_PCF_BOARDOBJGRP_MASK_E32, *PNV_PCF_BOARDOBJGRP_MASK_E32;
typedef const NV_PCF_BOARDOBJGRP_MASK_E32 CNV_PCF_BOARDOBJGRP_MASK_E32, *PCNV_PCF_BOARDOBJGRP_MASK_E32;
typedef struct _NV_PCF_BOARDOBJGRP_SUPER {
  NV_PCF_BOARDOBJGRP_MASK objMask;
} NV_PCF_BOARDOBJGRP_SUPER, *PNV_PCF_BOARDOBJGRP_SUPER;
typedef const NV_PCF_BOARDOBJGRP_SUPER CNV_PCF_BOARDOBJGRP_SUPER, *PCNV_PCF_BOARDOBJGRP_SUPER;
typedef struct _NV_PCF_BOARDOBJGRP_E32 {
  NV_PCF_BOARDOBJGRP_MASK_E32 objMask;
} NV_PCF_BOARDOBJGRP_E32, *PNV_PCF_BOARDOBJGRP_E32;
typedef const NV_PCF_BOARDOBJGRP_E32 CNV_PCF_BOARDOBJGRP_E32, *PCNV_PCF_BOARDOBJGRP_E32;
#define NV_PCF_TRISTATE_IGNORE (0x00)
#define NV_PCF_TRISTATE_TRUE (0x01)
#define NV_PCF_TRISTATE_FALSE (0x02)
#define NV_PCF_TRISTATE_OUTPUT_IGNORED (0x00)
#define NV_PCF_TRISTATE_OUTPUT_ENABLED (0x01)
#define NV_PCF_TRISTATE_OUTPUT_DISABLED (0x02)
typedef NvU8 NV_PCF_TRISTATE;
#define NV_PCF_CONFIG_1X_TYPE_SUBFUNC (0x00)
#define NV_PCF_CONFIG_1X_TYPE_STATIC (0x01)
#define NV_PCF_CONFIG_1X_TYPE_DYNAMIC (0x02)
#define NV_PCF_CONFIG_1X_TYPE_CPU_CONTROL (0x03)
#define NV_PCF_CONFIG_1X_BUFF_SIZE_MAX (255)
typedef struct _NV_PCF_CONFIG_INFO_V1 {
  NV_PCF_BOARDOBJ super;
  NvU8 buffSize;
  NvU8 buffer[NV_PCF_CONFIG_1X_BUFF_SIZE_MAX];
} NV_PCF_CONFIG_INFO_V1, *PNV_PCF_CONFIG_INFO_V1;
typedef struct _NV_PCF_CONFIG_GET_INFO_PARAMS_V1 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_CONFIG_INFO_V1 infos[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_CONFIG_GET_INFO_PARAMS_V1, *PNV_PCF_CONFIG_GET_INFO_PARAMS_V1;
typedef NV_PCF_CONFIG_GET_INFO_PARAMS_V1 NV_PCF_CONFIG_GET_INFO_PARAMS, *PNV_PCF_CONFIG_GET_INFO_PARAMS;
#define NV_PCF_CONFIG_GET_INFO_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_PCF_CONFIG_GET_INFO_PARAMS_V1, 1)
#define NV_PCF_CONFIG_GET_INFO_PARAMS_VER NV_PCF_CONFIG_GET_INFO_PARAMS_VER1
NVAPI_INTERFACE NvAPI_PCF_ConfigGetInfo(__inout PNV_PCF_CONFIG_GET_INFO_PARAMS pParams);
#define NV_PCF_CONTROLLER_QBOOST (1)
typedef enum _NV_PCF_CONTROLLER_FILTER_TYPE {
  NV_PCF_CONTROLLER_FILTER_TYPE_UNKNOWN = 0x00000000,
  NV_PCF_CONTROLLER_FILTER_TYPE_EWMA = 0x00000001,
  NV_PCF_CONTROLLER_FILTER_TYPE_MOVING_MAX = 0x00000002,
} NV_PCF_CONTROLLER_FILTER_TYPE;
typedef struct _NV_PCF_CONTROLLER_CONFIG_SUPER_V1 {
  NV_PCF_CONTROLLER_FILTER_TYPE filterType;
  NvU16 samplingMulti;
  union {
    NvU8 weight;
    NvU8 windowSize;
  } filterParam;
  NvU16 filterReserved;
} NV_PCF_CONTROLLER_CONFIG_SUPER_V1, *PNV_PCF_CONTROLLER_CONFIG_SUPER_V1;
#define NV_PCF_CONTROLLER_QBOOST_MAP_TO_DYNAMIC_ENABLE_BOOST (0)
#define NV_PCF_CONTROLLER_QBOOST_MAP_TO_DYNAMIC_MAX (8)
typedef struct _NV_PCF_CONTROLLER_CONFIG_QBOOST_V1 {
  NvU8 gpuMinPwrLimitTopoIdx;
  NvU8 gpuMaxPwrLimitTopoIdx;
  NvU8 gpuRatedPwrLimitTopoIdx;
  NvU8 gpuCurrentPwrLimitTopoIdx;
  NvU8 cpuPowerStatusTopoIdx;
  NvU16 cpuAcLimitW;
  NvU16 cpuAcousticLimitW;
  NvU8 mapToDynamic[NV_PCF_CONTROLLER_QBOOST_MAP_TO_DYNAMIC_MAX];
  NvU16 tspRatedIdx;
  NvU16 tspBatteryIdx;
  NvU16 incRatio;
  NvU16 decRatio;
  NvBool bAllowQboostMinBelowRated;
  NvBool bIsBoostController;
} NV_PCF_CONTROLLER_CONFIG_QBOOST_V1, *PNV_PCF_CONTROLLER_CONFIG_QBOOST_V1;
typedef union _NV_PCF_CONTROLLER_CONFIG_V1 {
  NV_PCF_CONTROLLER_CONFIG_QBOOST_V1 qboost;
} NV_PCF_CONTROLLER_CONFIG_V1, *PNV_PCF_CONTROLLER_CONFIG_V1;
#define NV_PCF_CONTROLLER_CONFIG_V1_MAX_SIZE (128)
#define NV_PCF_CONTROLLER_CONFIG_SUPER_V1_MAX_SIZE (64)
#define NV_PCF_CONTROLLER_CONFIG_V1_RESERVED_SIZE                                                                      \
  (NV_PCF_CONTROLLER_CONFIG_V1_MAX_SIZE - sizeof(NV_PCF_CONTROLLER_CONFIG_V1))
#define NV_PCF_CONTROLLER_CONFIG_V1_SUPER_RESERVED_SIZE                                                                \
  (NV_PCF_CONTROLLER_CONFIG_SUPER_V1_MAX_SIZE - sizeof(NV_PCF_CONTROLLER_CONFIG_SUPER_V1))
typedef struct _NV_PCF_CONTROLLER_INFO_V1 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_CONTROLLER_CONFIG_SUPER_V1 superConfig;
  NvU8 superReserved[NV_PCF_CONTROLLER_CONFIG_V1_SUPER_RESERVED_SIZE];
  NV_PCF_CONTROLLER_CONFIG_V1 config;
  NvU8 configReserved[NV_PCF_CONTROLLER_CONFIG_V1_RESERVED_SIZE];
} NV_PCF_CONTROLLER_INFO_V1, *PNV_PCF_CONTROLLER_INFO_V1;
typedef struct _NV_PCF_CONTROLLER_GET_INFO_PARAMS_V1 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NvU16 samplingPeriodms;
  NvU8 reserved[18];
  NV_PCF_CONTROLLER_INFO_V1 infos[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_CONTROLLER_GET_INFO_PARAMS_V1, *PNV_PCF_CONTROLLER_GET_INFO_PARAMS_V1;
typedef NV_PCF_CONTROLLER_GET_INFO_PARAMS_V1 NV_PCF_CONTROLLER_GET_INFO_PARAMS, *PNV_PCF_CONTROLLER_GET_INFO_PARAMS;
#define NV_PCF_CONTROLLER_GET_INFO_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_PCF_CONTROLLER_GET_INFO_PARAMS_V1, 1)
#define NV_PCF_CONTROLLER_GET_INFO_PARAMS_VER NV_PCF_CONTROLLER_GET_INFO_PARAMS_VER1
NVAPI_INTERFACE NvAPI_PCF_ControllerGetInfo(__inout PNV_PCF_CONTROLLER_GET_INFO_PARAMS pParams);
typedef struct _NV_PCF_CONTROLLER_QBOOST_STATUS_ENTRY_V1 {
  NvU32 time_mS;
  NvU32 ch0_cpuIn_mW;
  NvU32 ch1_gpuIn_mW;
  NvU32 ch2_cpuOut_mW;
  NvU32 ch3_gpuOut_mW;
  NvU32 cpuInTopology_mW;
  NvU32 cpuSampled_mW;
  NvU32 cpuShareOfPower_mW;
  NvU32 gpuShareOfPower_mW;
  NvU32 cpuNextSampleMin_mW;
  NvBool bBoostAllowed;
} NV_PCF_CONTROLLER_QBOOST_STATUS_ENTRY_V1, *PNV_PCF_CONTROLLER_QBOOST_STATUS_ENTRY_V1;
#define NV_PCF_CONTROLLER_BUFFER_IDX_INVALID (0xFFFFFFFF)
#define NV_PCF_CONTROLLER_QBOOST_ENTRY_CNT_MAX (64)
typedef struct _NV_PCF_CONTROLLER_QBOOST_STATUS_V1 {
  NvU32 circularIdx;
  NvU32 entryCnt;
  NV_PCF_CONTROLLER_QBOOST_STATUS_ENTRY_V1 entries[NV_PCF_CONTROLLER_QBOOST_ENTRY_CNT_MAX];
} NV_PCF_CONTROLLER_QBOOST_STATUS_V1, *PNV_PCF_CONTROLLER_QBOOST_STATUS_V1;
typedef union _NV_PCF_CONTROLLER_STATUS_DATA_V1 {
  NV_PCF_CONTROLLER_QBOOST_STATUS_V1 qboost;
} NV_PCF_CONTROLLER_STATUS_DATA_V1, *PNV_PCF_CONTROLLER_STATUS_DATA_V1;
#define NV_PCF_CONTROLLER_STATUS_DATA_V1_MAX_SIZE (4096)
#define NV_PCF_CONTROLLER_STATUS_V1_RESERVED                                                                           \
  (NV_PCF_CONTROLLER_STATUS_DATA_V1_MAX_SIZE - sizeof(NV_PCF_CONTROLLER_STATUS_DATA_V1))
typedef struct _NV_PCF_CONTROLLER_STATUS_V1 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_CONTROLLER_STATUS_DATA_V1 data;
  NvU8 reserved[NV_PCF_CONTROLLER_STATUS_V1_RESERVED];
} NV_PCF_CONTROLLER_STATUS_V1, *PNV_PCF_CONTROLLER_STATUS_V1;
typedef struct _NV_PCF_CONTROLLER_GET_STATUS_PARAMS_V1 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_CONTROLLER_STATUS_V1 status[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_CONTROLLER_GET_STATUS_PARAMS_V1, *PNV_PCF_CONTROLLER_GET_STATUS_PARAMS_V1;
typedef NV_PCF_CONTROLLER_GET_STATUS_PARAMS_V1 NV_PCF_CONTROLLER_GET_STATUS_PARAMS,
    *PNV_PCF_CONTROLLER_GET_STATUS_PARAMS;
#define NV_PCF_CONTROLLER_GET_STATUS_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_PCF_CONTROLLER_GET_STATUS_PARAMS_V1, 1)
#define NV_PCF_CONTROLLER_GET_STATUS_PARAMS_VER NV_PCF_CONTROLLER_GET_STATUS_PARAMS_VER1
NVAPI_INTERFACE NvAPI_PCF_ControllerGetStatus(__inout PNV_PCF_CONTROLLER_GET_STATUS_PARAMS pParams);
#define NV_PCF_CPU_SYSTEM_MAX_SOCKETS (8)
#define NV_PCF_CPU_SOCKET_MAX_CORES (32)
typedef struct {
  NvU8 supportedCoreCnt;
  NvBool writeable;
  NvU32 reserved[7];
  NvU8 limits[NV_PCF_CPU_SOCKET_MAX_CORES];
} NV_PCF_CPU_INTEL_TURBO_RATIO_SOCKET_DATA_V1, *PNV_PCF_CPU_INTEL_TURBO_RATIO_SOCKET_DATA_V1;
typedef struct {
  NvU32 version;
  NvU8 socketMask;
  NvU32 reserved[30];
  NV_PCF_CPU_INTEL_TURBO_RATIO_SOCKET_DATA_V1 sockets[NV_PCF_CPU_SYSTEM_MAX_SOCKETS];
} NV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS_V1, *PNV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS_V1;
typedef NV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS_V1 NV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS,
    *PNV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS;
#define NV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS_VER1                                                               \
  MAKE_NVAPI_VERSION(NV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS_V1, 1)
#define NV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS_VER NV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS_VER1
NVAPI_INTERFACE NvAPI_PCF_CpuIntelTurboRatioGetControl(__inout PNV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS pParams);
NVAPI_INTERFACE NvAPI_PCF_CpuIntelTurboRatioSetControl(__inout PNV_PCF_CPU_INTEL_TURBO_RATIO_CONTROL_PARAMS pParams);
#define NV_PCF_MASTER_CPU_FREQUENCY_CONTROL_TYPE_ACPI_ECIO (1)
#define NV_PCF_MASTER_CPU_DATA_COLLECTOR (4)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS (5)
#define NV_PCF_MASTER_CPU_TDP_LIMIT_CONTROL (6)
#define NV_PCF_MASTER_CPU_MAX_MSRS (30)
#define NV_PCF_MASTER_CPU_MAX_COMMANDS (24)
#define NV_PCF_MASTER_CPU_MAX_PM_EVENTS (10)
typedef struct _NV_PCF_MASTER_INFO_CPU_FREQUENCY_CONTROL_V1 {
  NvU8 busRatioHigh;
  NvU8 busRatioNominal;
  NvU16 offSet;
  NvU8 reserved[128];
} NV_PCF_MASTER_INFO_CPU_FREQUENCY_CONTROL_V1, *PNV_PCF_MASTER_INFO_CPU_FREQUENCY_CONTROL_V1;
typedef union _NV_PCF_MASTER_INFO_DATA_V1 {
  NV_PCF_MASTER_INFO_CPU_FREQUENCY_CONTROL_V1 infoData;
} NV_PCF_MASTER_INFO_DATA_V1, *PNV_PCF_MASTER_INFO_DATA_V1;
typedef struct _NV_PCF_MASTER_INFO_V1 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_MASTER_INFO_DATA_V1 info;
} NV_PCF_MASTER_INFO_V1, *PNV_PCF_MASTER_INFO_V1;
typedef struct _NV_PCF_MASTER_INFO_PARAMS_V1 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_MASTER_INFO_V1 infoParams[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_MASTER_INFO_PARAMS_V1, *PNV_PCF_MASTER_INFO_PARAMS_V1;
typedef struct _NV_PCF_MASTER_INFO_CPU_FREQUENCY_CONTROL_V2 {
  NvU8 busRatioHigh;
  NvU8 busRatioNominal;
  NvU16 offSet;
  NvU64 reserved[16];
} NV_PCF_MASTER_INFO_CPU_FREQUENCY_CONTROL_V2, *PNV_PCF_MASTER_INFO_CPU_FREQUENCY_CONTROL_V2;
typedef struct _NV_PCF_MASTER_INFO_CPU_DATA_COLLECTOR_V2 {
  NvU64 activeLogicalCpus;
  NvU32 version;
} NV_PCF_MASTER_INFO_CPU_DATA_COLLECTOR_V2, *PNV_PCF_MASTER_INFO_CPU_DATA_COLLECTOR_V2;
typedef union _NV_PCF_MASTER_INFO_DATA_V2 {
  NV_PCF_MASTER_INFO_CPU_FREQUENCY_CONTROL_V2 infoData;
  NV_PCF_MASTER_INFO_CPU_DATA_COLLECTOR_V2 collectorData;
} NV_PCF_MASTER_INFO_DATA_V2, *PNV_PCF_MASTER_INFO_DATA_V2;
typedef struct _NV_PCF_MASTER_INFO_V2 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_MASTER_INFO_DATA_V2 info;
} NV_PCF_MASTER_INFO_V2, *PNV_PCF_MASTER_INFO_V2;
typedef struct _NV_PCF_MASTER_INFO_PARAMS_V2 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_MASTER_INFO_V2 infoParams[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_MASTER_INFO_PARAMS_V2, *PNV_PCF_MASTER_INFO_PARAMS_V2;
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_TYPE_CPU (0)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_TYPE_GPU (1)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_TYPE_DEPRECATED (255)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_SRC_CPU (0)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_SRC_GPU (1)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_SRC_ALT (2)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_SRC_UNUSED (255)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_FAN_GRP_CTL_CPU (0)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_FAN_GRP_CTL_GPU (1)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_FLAG_FAN_GRP_CTL_UNUSED (255)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_COUNT_MAX (8)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_PAIR_COUNT_MAX (12)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_SL_COUNT_MAX (8)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MAP_ENTRIES_MAX                                                           \
  (NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_PAIR_COUNT_MAX * NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_PAIR_COUNT_MAX)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_FAN_INDEX_CPU BIT(0)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_FAN_INDEX_CPU_DISABLED (0x00)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_FAN_INDEX_CPU_DEPRECATED (0x00)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_FAN_INDEX_CPU_ENABLED (0x01)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_FAN_INDEX_GPU BIT(1)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_FAN_INDEX_GPU_DISABLED (0x00)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_FAN_INDEX_GPU_DEPRECATED (0x00)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_FAN_INDEX_GPU_ENABLED (0x01)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_CPU_TJ 2 : 2
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_CPU_TJ_DISABLED (0x00)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_CPU_TJ_ENABLED (0x01)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_GPU_TJ 3 : 3
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_GPU_TJ_DISABLED (0x00)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_GPU_TJ_ENABLED (0x01)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_TOTAL_SYSTEM_POWER 4 : 4
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_TOTAL_SYSTEM_POWER_DISABLED (0x00)
#define NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_FIELDS_TOTAL_SYSTEM_POWER_ENABLED (0x01)
typedef struct _NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_PAIRS {
  NvU8 tjDown;
  NvU8 tjUp;
} NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_PAIRS, *PNV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_PAIRS;
typedef struct _NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND {
  NvU8 flagType;
  NvU8 tPairsCount;
  NvU8 flagTempSrc;
  NvU8 flagFanGrpCtl;
  NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_PAIRS
  tPairs[NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_PAIR_COUNT_MAX];
} NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND, *PNV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND;
typedef struct _NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MODE {
  NvU8 balanced;
  NvU8 quiet;
  NvU8 silent;
  NvU8 quieter;
  NvU8 rsvd[4];
} NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MODE, *PNV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MODE;
typedef struct _NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MAP {
  NvU8 entries[NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MAP_ENTRIES_MAX];
} NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MAP, *PNV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MAP;
typedef struct _NV_PCF_MASTER_INFO_WM2_PLATFORM_PARAMS_V1 {
  NvU8 supportedSlsMask;
  NvU8 tableTbandMask;
  NvU8 supportedSls[NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SUPPORTED_SL_COUNT_MAX];
  NvU32 supportedFieldsMask;
  NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND
  tbandTables[NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_COUNT_MAX];
  NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MODE slModes;
  NV_PCF_MASTER_WM2_PLATFORM_PARAMS_SL_MAP slMapTable;
} NV_PCF_MASTER_INFO_WM2_PLATFORM_PARAMS_V1, *PNV_PCF_MASTER_INFO_WM2_PLATFORM_PARAMS_V1;
typedef struct _NV_PCF_MASTER_INFO_CPU_TDP_LIMIT_CONTROL_V1 {
  NvU32 rsvd;
} NV_PCF_MASTER_INFO_CPU_TDP_LIMIT_CONTROL_V1, *PNV_PCF_MASTER_INFO_CPU_TDP_LIMIT_CONTROL_V1;
typedef union _NV_PCF_MASTER_INFO_DATA_V3 {
  NV_PCF_MASTER_INFO_CPU_FREQUENCY_CONTROL_V2 infoData;
  NV_PCF_MASTER_INFO_CPU_DATA_COLLECTOR_V2 collectorData;
  NV_PCF_MASTER_INFO_WM2_PLATFORM_PARAMS_V1 infoWm2;
  NV_PCF_MASTER_INFO_CPU_TDP_LIMIT_CONTROL_V1 infoCpuTdpLimitControl;
} NV_PCF_MASTER_INFO_DATA_V3, *PNV_PCF_MASTER_INFO_DATA_V3;
typedef struct _NV_PCF_MASTER_INFO_V3 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_MASTER_INFO_DATA_V3 info;
} NV_PCF_MASTER_INFO_V3, *PNV_PCF_MASTER_INFO_V3;
typedef struct _NV_PCF_MASTER_INFO_PARAMS_V3 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_MASTER_INFO_V3 infoParams[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_MASTER_INFO_PARAMS_V3, *PNV_PCF_MASTER_INFO_PARAMS_V3;
typedef NV_PCF_MASTER_INFO_PARAMS_V3 NV_PCF_MASTER_INFO_PARAMS, *PNV_PCF_MASTER_INFO_PARAMS;
#define NV_PCF_MASTER_INFO_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_PCF_MASTER_INFO_PARAMS_V1, 1)
#define NV_PCF_MASTER_INFO_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_PCF_MASTER_INFO_PARAMS_V2, 2)
#define NV_PCF_MASTER_INFO_PARAMS_VER3 MAKE_NVAPI_VERSION(NV_PCF_MASTER_INFO_PARAMS_V3, 3)
#define NV_PCF_MASTER_INFO_PARAMS_VER NV_PCF_MASTER_INFO_PARAMS_VER3
NVAPI_INTERFACE NvAPI_PCF_MasterGetInfo(__inout PNV_PCF_MASTER_INFO_PARAMS pParams);
typedef struct _NV_PCF_MASTER_CONTROL_CPU_FREQUENCY_CONTROL_V1 {
  NvU8 busRatioHigh;
  NvU8 busRatioNominal;
  NvU8 reserved[128];
} NV_PCF_MASTER_CONTROL_CPU_FREQUENCY_CONTROL_V1, *PNV_PCF_MASTER_CONTROL_CPU_FREQUENCY_CONTROL_V1;
typedef union _NV_PCF_MASTER_CONTROL_DATA_V1 {
  NV_PCF_MASTER_CONTROL_CPU_FREQUENCY_CONTROL_V1 controlData;
} NV_PCF_MASTER_CONTROL_DATA_V1, *PNV_PCF_MASTER_CONTROL_DATA_V1;
typedef struct _NV_PCF_MASTER_CONTROL_V1 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_MASTER_CONTROL_DATA_V1 control;
} NV_PCF_MASTER_CONTROL_V1, *PNV_PCF_MASTER_CONTROL_V1;
typedef struct _NV_PCF_MASTER_CONTROL_PARAMS_V1 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_MASTER_CONTROL_V1 ctrlParams[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_MASTER_CONTROL_PARAMS_V1, *PNV_PCF_MASTER_CONTROL_PARAMS_V1;
typedef struct _NV_PCF_MASTER_CONTROL_CPU_FREQUENCY_CONTROL_V2 {
  NvU8 busRatioHigh;
  NvU8 busRatioNominal;
  NvU64 reserved[16];
} NV_PCF_MASTER_CONTROL_CPU_FREQUENCY_CONTROL_V2, *PNV_PCF_MASTER_CONTROL_CPU_FREQUENCY_CONTROL_V2;
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_NOP (0U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_OPEN_SESSION (1U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_CLOSE_SESSION (2U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_CONFIG_SESSION (3U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_CONFIG_EVENT_BUFFER (4U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_CONFIG_MSR (5U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_READ_FIXED_MSR (6U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_GET_SESSION_INFO (7U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_GET_MSRS (8U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_READ_ENERGY_MSR (9U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_CONFIG_PMU (10U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_CONFIG_HWP (11U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_READ_PLATFORM_INFO (12U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_INIT_PERF_COUNTERS (13U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_UPDATE_EVENT_BUFFER (14U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SUBFUNCTION_CONFIG_COMMANDS (15U)
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_HEADER_V2 {
  NvU32 recordGet;
  NvU32 recordPut;
  NvU64 recordCount;
  NvU64 recordDropcount;
  NvU64 vardataDropcount;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_HEADER_V2,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_HEADER_V2;
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_RECORD_HEADER_V2 {
  NvU16 type;
  NvU16 subtype;
  NvU32 varData;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_RECORD_HEADER_V2,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_RECORD_HEADER_V2;
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_MSR_RECORD_V2 {
  NvU64 cpuId;
  NvU64 value[NV_PCF_MASTER_CPU_MAX_MSRS];
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_MSR_EVENT_BUFFER_RECORD_V2,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_MSR_EVENT_BUFFER_RECORD_V2;
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_REGISTER_TYPE_MSR (0U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_REGISTER_TYPE_PMC (1U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_REGISTER_TYPE_IMC (2U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_REGISTER_TYPE_QPC (3U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_REGISTER_TYPE_PCI_CONFIG (4U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_REGISTER_ADDRESS_IMC_READ (0U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_REGISTER_ADDRESS_IMC_WRITE (1U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_REGISTER_ADDRESS_QPC_COUNTER (0U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_REGISTER_ADDRESS_QPC_FREQ (1U)
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_MSR_V2 {
  NvU8 type;
  NvU32 address;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_MSR_V2, *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_MSR_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_RECORD_V2 {
  NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_RECORD_HEADER_V2 recordHeader;
  NvU64 recordNum;
  NvU32 numMsrRecord;
  NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_MSR_EVENT_BUFFER_RECORD_V2 msrRecord[1];
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_RECORD_V2,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_EVENT_BUFFER_RECORD_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_OPEN_SESSION_V2 {
  NvU32 session;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_OPEN_SESSION_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CLOSE_SESSION_V2 {
  NvU32 session;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CLOSE_SESSION_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_SESSION_V2 {
  NvU32 session;
  NvBool startCapture;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_SESSION_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_EVENT_BUFFER_V2 {
  NvU32 session;
  NvU32 recordsFreeThreshold;
  NvU32 vardataBufferSize;
  NvU32 recordCount;
  NvU32 flags;
  NvU64 notificationHandle;
  NvU64 bufferHeader;
  NvU64 recordBuffer;
  NvU64 vardataBuffer;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_EVENT_BUFFER_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SESSION_INFO_V2 {
  NvU32 session;
  struct {
    NvU64 bufferHeader;
    NvU64 recordBuffer;
    NvU64 vardataBuffer;
    NvU32 recordSize;
  } eventBuffer;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SESSION_INFO_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_MSR_V2 {
  NvU32 session;
  NvU32 samplingFrequencyMsec;
  NvU32 numMsr;
  NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_MSR_V2
  msr[NV_PCF_MASTER_CPU_MAX_MSRS];
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_MSR_V2;
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_PMU_EVENT_V2 {
  NvU32 msrAddress;
  NvU32 value;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_PMU_EVENT_V2;
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_PMU_V2 {
  NvU32 session;
  NvU32 numEvents;
  NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_PMU_EVENT_V2
  event[NV_PCF_MASTER_CPU_MAX_PM_EVENTS];
  NvS64 qpc;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_PMU_V2;
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_INIT_PERF_COUNTERS_V2 {
  NvU32 session;
  NvU64 firstQpc;
  NvU64 enableBits;
  NvU64 hwpParams;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_INIT_PERF_COUNTERS_V2;
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_ENABLE 0x0001
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_ENABLE_MIN_PERF 0x0002
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_ENABLE_MAX_PERF 0x0004
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_ENABLE_DES_PERF 0x0008
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_ENABLE_ENERGY_PERF 0x0010
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_ENABLE_ACTIVITY_WINDOW 0x0020
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_ENABLE_PACKAGE_CONTROL 0x0040
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_V2 {
  NvU32 session;
  NvU64 hwpParams;
  NvU64 enableBits;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_V2;
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_UPDATE_EVENT_BUFFER_V2 {
  NvU32 session;
  NvU32 recordGet;
  NvU32 varDataBufferGet;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_UPDATE_EVENT_BUFFER_V2,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_UPDATE_EVENT_BUFFER_V2;
#define NV_PCF_CTRL_MASTER_CPU_MAX_PMC (4)
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_FIXED_MSR_V2 {
  NvU32 session;
  NvU32 cpuId;
  NvS64 qpc;
  NvU64 freq;
  NvU64 tsc;
  NvU64 instRetiredAny;
  NvU64 unhalted;
  NvU64 unhaltedRef;
  NvU64 pmc[NV_PCF_CTRL_MASTER_CPU_MAX_PMC];
  NvU64 aperf;
  NvU64 mperf;
  NvU64 pperf;
  NvU64 perfStatus;
  NvU64 thermStatus;
  NvU64 dramReads;
  NvU64 dramWrites;
  NvU64 corePerfLimitReasons;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_FIXED_MSR_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_READ_ENERGY_MSR_V2 {
  NvU32 session;
  NvS64 qpc;
  NvU64 pkgEnergyStatus;
  NvU64 pp0EnergyStatus;
  NvU64 pp1EnergyStatus;
  NvU64 dramEnergyStatus;
  NvU64 pkgThermStatus;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_ENERGY_MSR_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_PLATFORM_INFO_V2 {
  NvU32 session;
  NvS64 qpc;
  NvU64 platformInfo;
  NvU64 powerLimit;
  NvU64 powerInfo;
  NvU8 powerExp;
  NvU8 energyExp;
  NvU8 timeExp;
  NvU32 thermTarget;
  NvU8 tccOffset;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_PLATFORM_INFO_V2;
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_GET_MSR_V2 {
  NvU32 session;
  NvBool bApplyPmuConfig;
  NvU64 cpuId;
  NvU32 numMsrs;
  NvU64 value[NV_PCF_MASTER_CPU_MAX_MSRS];
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_GET_MSR_V2;
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_ADDRESS_PCI_CONFIG 27 : 0
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_ADDRESS_PCI_CONFIG_OFFSET 11 : 0
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_ADDRESS_PCI_CONFIG_FUNCTION 14 : 12
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_ADDRESS_PCI_CONFIG_DEVICE 19 : 15
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_ADDRESS_PCI_CONFIG_BUS 27 : 20
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_PAYLOAD_TYPE 1 : 0
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_PAYLOAD_TYPE_ADDRESS (0U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_PAYLOAD_TYPE_DATA (1U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_REGISTER_TYPE 5 : 2
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_REGISTER_SIZE 9 : 6
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_ACTION 12 : 10
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_ACTION_READ (0U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_ACTION_READ_CLEAR (1U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_ACTION_WRITE (2U)
#define NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_COMMAND_RESERVED 15 : 13
typedef struct NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_COMMANDS_V2 {
  NvU32 session;
  NvU32 samplingFrequencyMsec;
  NvU32 numRegisters;
  NvU32 numCommands;
  NvU64 payload[NV_PCF_MASTER_CPU_MAX_COMMANDS];
  NvU16 metadata[NV_PCF_MASTER_CPU_MAX_COMMANDS];
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_COMMANDS_V2;
typedef struct _NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_V2 {
  NvU32 subFunction;
  union {
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_OPEN_SESSION_V2 openSession;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CLOSE_SESSION_V2 closeSession;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_SESSION_V2 configSession;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_EVENT_BUFFER_V2 configEventBuffer;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_MSR_V2 configMsr;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_FIXED_MSR_V2 fixedMsr;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SESSION_INFO_V2 sessionInfo;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_MSR_V2 msrInfo;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_ENERGY_MSR_V2 energyMsr;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_PMU_V2 configPmu;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_V2 configHwp;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_PLATFORM_INFO_V2 platformInfo;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_INIT_PERF_COUNTERS_V2 initPerfCounters;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_UPDATE_EVENT_BUFFER_V2 updateEventBuffer;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_GET_MSR_V2 getMsr;
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_COMMANDS_V2 configCommands;
  } params;
} NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_V2, *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_V2;
typedef union _NV_PCF_MASTER_CONTROL_DATA_V2 {
  NV_PCF_MASTER_CONTROL_CPU_FREQUENCY_CONTROL_V2 controlData;
  NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_V2 collectorData;
} NV_PCF_MASTER_CONTROL_DATA_V2, *PNV_PCF_MASTER_CONTROL_DATA_V2;
typedef struct _NV_PCF_MASTER_CONTROL_V2 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_MASTER_CONTROL_DATA_V2 control;
} NV_PCF_MASTER_CONTROL_V2, *PNV_PCF_MASTER_CONTROL_V2;
typedef struct _NV_PCF_MASTER_CONTROL_PARAMS_V2 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_MASTER_CONTROL_V2 ctrlParams[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_MASTER_CONTROL_PARAMS_V2, *PNV_PCF_MASTER_CONTROL_PARAMS_V2;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_OPEN_SESSION_V2 NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_OPEN_SESSION,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_OPEN_SESSION;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CLOSE_SESSION_V2
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CLOSE_SESSION,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CLOSE_SESSION;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_SESSION_V2
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_SESSION,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_SESSION;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_EVENT_BUFFER_V2
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_EVENT_BUFFER,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_EVENT_BUFFER;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_MSR_V2 NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_MSR,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_MSR;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SESSION_INFO_V2 NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SESSION_INFO,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_SESSION_INFO;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_ENERGY_MSR_V2
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_ENERGY_MSR,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_READ_ENERGY_MSR;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP_V2 NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_HWP;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_PMU_V2 NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_PMU,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_PMU;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_COMMANDS_V2
    NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_COMMANDS,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_CONFIG_COMMANDS;
typedef NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_V2 NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR,
    *PNV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR;
typedef struct _NV_PCF_MASTER_CONTROL_WM2_PLATFORM_PARAMS_V1 {
  NvU8 slModeCurr;
  NvU32 cpuTjLimitCurr;
} NV_PCF_MASTER_CONTROL_WM2_PLATFORM_PARAMS_V1, *PNV_PCF_MASTER_CONTROL_WM2_PLATFORM_PARAMS_V1;
typedef struct _NV_PCF_MASTER_CONTROL_CPU_TDP_LIMIT_CONTROL_V1 {
  NvU32 rsvd;
} NV_PCF_MASTER_CONTROL_CPU_TDP_LIMIT_CONTROL_V1, *PNV_PCF_MASTER_CONTROL_CPU_TDP_LIMIT_CONTROL_V1;
typedef union _NV_PCF_MASTER_CONTROL_DATA_V3 {
  NV_PCF_MASTER_CONTROL_CPU_FREQUENCY_CONTROL_V2 controlData;
  NV_PCF_MASTER_CONTROL_CPU_DATA_COLLECTOR_V2 collectorData;
  NV_PCF_MASTER_CONTROL_WM2_PLATFORM_PARAMS_V1 controlWm2;
  NV_PCF_MASTER_CONTROL_CPU_TDP_LIMIT_CONTROL_V1 controlCpuTdpLimitControl;
} NV_PCF_MASTER_CONTROL_DATA_V3, *PNV_PCF_MASTER_CONTROL_DATA_V3;
typedef struct _NV_PCF_MASTER_CONTROL_V3 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_MASTER_CONTROL_DATA_V3 control;
} NV_PCF_MASTER_CONTROL_V3, *PNV_PCF_MASTER_CONTROL_V3;
typedef struct _NV_PCF_MASTER_CONTROL_PARAMS_V3 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_MASTER_CONTROL_V3 ctrlParams[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_MASTER_CONTROL_PARAMS_V3, *PNV_PCF_MASTER_CONTROL_PARAMS_V3;
typedef NV_PCF_MASTER_CONTROL_PARAMS_V3 NV_PCF_MASTER_CONTROL_PARAMS, *PNV_PCF_MASTER_CONTROL_PARAMS;
#define NV_PCF_MASTER_CONTROL_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_PCF_MASTER_CONTROL_PARAMS_V1, 1)
#define NV_PCF_MASTER_CONTROL_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_PCF_MASTER_CONTROL_PARAMS_V2, 2)
#define NV_PCF_MASTER_CONTROL_PARAMS_VER3 MAKE_NVAPI_VERSION(NV_PCF_MASTER_CONTROL_PARAMS_V3, 3)
#define NV_PCF_MASTER_CONTROL_PARAMS_VER NV_PCF_MASTER_CONTROL_PARAMS_VER3
NVAPI_INTERFACE NvAPI_PCF_MasterGetControl(__inout PNV_PCF_MASTER_CONTROL_PARAMS pParams);
NVAPI_INTERFACE NvAPI_PCF_MasterSetControl(__inout PNV_PCF_MASTER_CONTROL_PARAMS pParams);
typedef struct _NV_PCF_MASTER_STATUS_WM2_PLATFORM_PARAMS_TBAND {
  NvU8 tBandIdxCurr;
  NvU32 tBandTempCurr;
} NV_PCF_MASTER_STATUS_WM2_PLATFORM_PARAMS_TBAND, *PNV_PCF_MASTER_STATUS_WM2_PLATFORM_PARAMS_TBAND;
typedef struct _NV_PCF_MASTER_STATUS_WM2_PLATFORM_PARAMS_V1 {
  NvU8 bPlatformEnabled;
  NvU8 updateEventCount;
  NvU8 cpuFanIdx;
  NvU8 gpuFanIdx;
  NvU32 cpuTj;
  NvU32 gpuTj;
  NvU32 sysTspW;
  NV_PCF_MASTER_STATUS_WM2_PLATFORM_PARAMS_TBAND
  tBandStatus[NV_PCF_MASTER_WM2_PLATFORM_PARAMS_TBAND_COUNT_MAX];
  NvU64 rsvd[6];
} NV_PCF_MASTER_STATUS_WM2_PLATFORM_PARAMS_V1, *PNV_PCF_MASTER_STATUS_WM2_PLATFORM_PARAMS_V1;
typedef union _NV_PCF_MASTER_STATUS_DATA_V1 {
  NV_PCF_MASTER_STATUS_WM2_PLATFORM_PARAMS_V1 statusWm2;
} NV_PCF_MASTER_STATUS_DATA_V1, *PNV_PCF_MASTER_STATUS_DATA_V1;
typedef struct _NV_PCF_MASTER_STATUS_V1 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_MASTER_STATUS_DATA_V1 status;
} NV_PCF_MASTER_STATUS_V1, *PNV_PCF_MASTER_STATUS_V1;
typedef struct _NV_PCF_MASTER_STATUS_PARAMS_V1 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_MASTER_STATUS_V1 statusParams[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_MASTER_STATUS_PARAMS_V1, *PNV_PCF_MASTER_STATUS_PARAMS_V1;
typedef NV_PCF_MASTER_STATUS_PARAMS_V1 NV_PCF_MASTER_STATUS_PARAMS, *PNV_PCF_MASTER_STATUS_PARAMS;
#define NV_PCF_MASTER_STATUS_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_PCF_MASTER_STATUS_PARAMS_V1, 1)
#define NV_PCF_MASTER_STATUS_PARAMS_VER NV_PCF_MASTER_STATUS_PARAMS_VER1
NVAPI_INTERFACE NvAPI_PCF_MasterGetStatus(__inout PNV_PCF_MASTER_STATUS_PARAMS pParams);
typedef struct _NV_PCF_CONTROLLER_QBOOST_CONTROL_V1 {
  NvU32 targetTppmW;
  NvU32 defaultOutputmW;
  NvU32 minOutputmW;
  NvU32 maxOutputmW;
  NvU16 incRatio;
  NvU16 decRatio;
  NvU32 thresholdmW;
  NV_PCF_TRISTATE swEnable;
  NV_PCF_TRISTATE sbiosEnable;
} NV_PCF_CONTROLLER_QBOOST_CONTROL_V1, *PNV_PCF_CONTROLLER_QBOOST_CONTROL_V1;
typedef union _NV_PCF_CONTROLLER_CONTROL_DATA_V1 {
  NV_PCF_CONTROLLER_QBOOST_CONTROL_V1 qboost;
} NV_PCF_CONTROLLER_CONTROL_DATA_V1, *PNV_PCF_CONTROLLER_CONTROL_DATA_V1;
#define NV_PCF_CONTROLLER_CONTROL_DATA_V1_MAX_SIZE (64)
#define NV_PCF_CONTROLLER_CONTROL_V1_SUPER_RESERVED (32)
#define NV_PCF_CONTROLLER_CONTROL_V1_RESERVED                                                                          \
  (NV_PCF_CONTROLLER_CONTROL_DATA_V1_MAX_SIZE - sizeof(NV_PCF_CONTROLLER_CONTROL_DATA_V1))
typedef struct _NV_PCF_CONTROLLER_CONTROL_V1 {
  NV_PCF_BOARDOBJ super;
  NvU8 superReserved[NV_PCF_CONTROLLER_CONTROL_V1_SUPER_RESERVED];
  NV_PCF_CONTROLLER_CONTROL_DATA_V1 control;
  NvU8 controllerReserved[NV_PCF_CONTROLLER_CONTROL_V1_RESERVED];
} NV_PCF_CONTROLLER_CONTROL_V1, *PNV_PCF_CONTROLLER_CONTROL_V1;
typedef struct _NV_PCF_CONTROLLER_CONTROL_PARAMS_V1 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_CONTROLLER_CONTROL_V1 ctrlParams[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_CONTROLLER_CONTROL_PARAMS_V1, *PNV_PCF_CONTROLLER_CONTROL_PARAMS_V1;
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_LEGACY (0)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_DRIVER (1)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_STATIC (2)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_SBIOS (3)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_NVAPI (4)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_NVAPI_N(i) (NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_NVAPI + i)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_NVAPI_END (7)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_RUNTIME (7)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_VIRTUAL_NVPCF (8)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_VIRTUAL_NON_TOOL (9)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CLIENT_END (10)
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_ACDC 1 : 0
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_ACDC_IGNORE 0
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_ACDC_TRUE 1
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_ACDC_FALSE 2
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_AC 3 : 2
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_AC_IGNORE 0
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_AC_TRUE 1
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_AC_FALSE 2
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_DC 5 : 4
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_DC_IGNORE 0
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_DC_TRUE 1
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_ENABLE_DC_FALSE 2
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_TGP_CAP 1 : 0
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_TGP_CAP_IGNORE 0
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_TGP_CAP_UNCAP 1
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_TGP_CAP_BASELINE 2
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_TGP_CAP_RATED 3
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_CPU_TDP_CAP 3 : 2
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_CPU_TDP_CAP_IGNORE 0
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_CPU_TDP_CAP_MIN 1
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_CPU_TDP_CAP_BOOSTED 2
#define NV_PCF_CONTROLLER_QBOOST_CONTROL_CMD_DC_CPU_TDP_CAP_MAX 3
#define NV_PCF_CONTROLLER_SET_CONTROL_SAMPLING_PERIOD_CLEAR (65535)
#define NV_PCF_CONTROLLER_SET_CONTROL_FILTER_CMD_IGNORE (0)
#define NV_PCF_CONTROLLER_SET_CONTROL_FILTER_CMD_MODIFY (1)
#define NV_PCF_CONTROLLER_SET_CONTROL_FILTER_CMD_CLEAR (2)
#define NV_PCF_CONTROLLER_GET_CONTROL_FILTER_CMD_CLEARED (0)
#define NV_PCF_CONTROLLER_GET_CONTROL_FILTER_CMD_MODIFIED (1)
#define NV_PCF_CONTROLLER_CONTROL_FILTER_TYPE_EMWA (0)
#define NV_PCF_CONTROLLER_CONTROL_FILTER_TYPE_MOVING_MAX (1)
typedef struct _NV_PCF_QBOOST_FILTER_CONFIG {
  NvU8 cmd;
  NvU8 filterType;
  union {
    NvU8 weight;
    NvU8 windowSize;
  } filterParam;
  NvU8 filterReserved;
} NV_PCF_QBOOST_FILTER_CONFIG;
typedef struct _NV_PCF_CONTROLLER_QBOOST_CONTROL_V2 {
  NvU32 targetTppmW;
  NvU32 defaultOutputmW;
  NvU32 minOutputmW;
  NvU32 maxOutputmW;
  NvU16 incRatio;
  NvU16 decRatio;
  NvU32 thresholdmW;
  NvU8 enable;
  NvU8 clientCount;
  NvU8 client;
  NvBool bHasData;
  NvBool bClear;
  NvU8 offsetMode;
  NvU32 maxPossibleOutputmW;
  NvU32 minPossibleOutputmW;
  NvS32 ctgpOffsetmW;
  NvS32 targetTppOffsetmW;
  NvS32 maxOutputOffsetmW;
  NvS32 minOutputOffsetmW;
  NvU32 targetTppBattmW;
  NvU32 defaultOutputBattmW;
  NvU32 maxOutputBattmW;
  NvU32 minOutputBattmW;
  NvS32 targetTppBattOffsetmW;
  NvS32 maxOutputBattOffsetmW;
  NvS32 minOutputBattOffsetmW;
  NvU32 cmd;
  NvS32 ctgpBattOffsetmW;
  NvU16 samplingPeriodmS;
  NV_PCF_QBOOST_FILTER_CONFIG filterConfig;
  NvBool bIgnoreRuntimeClient;
  NV_PCF_TRISTATE dcCpuTdpLimitEnable;
  NvU32 dcCpuTdpLimitmW;
} NV_PCF_CONTROLLER_QBOOST_CONTROL_V2, *PNV_PCF_CONTROLLER_QBOOST_CONTROL_V2;
typedef struct _NV_PCF_CONTROLLER_RESERVED_CONTROL_V2 {
  NvU64 reserved[21];
} NV_PCF_CONTROLLER_RESERVED_CONTROL_V2, *PNV_PCF_CONTROLLER_RESERVED_CONTROL_V2;
typedef union _NV_PCF_CONTROLLER_CONTROL_DATA_V2 {
  NV_PCF_CONTROLLER_RESERVED_CONTROL_V2 reserved;
  NV_PCF_CONTROLLER_QBOOST_CONTROL_V2 qboost;
} NV_PCF_CONTROLLER_CONTROL_DATA_V2, *PNV_PCF_CONTROLLER_CONTROL_DATA_V2;
typedef struct _NV_PCF_CONTROLLER_CONTROL_V2 {
  NV_PCF_BOARDOBJ super;
  NV_PCF_CONTROLLER_CONTROL_DATA_V2 control;
} NV_PCF_CONTROLLER_CONTROL_V2, *PNV_PCF_CONTROLLER_CONTROL_V2;
typedef struct _NV_PCF_CONTROLLER_CONTROL_GROUP_V2 {
  NvU64 reserved[7];
} NV_PCF_CONTROLLER_CONTROL_GROUP_V2, *PNV_PCF_CONTROLLER_CONTROL_GROUP_V2;
typedef struct _NV_PCF_CONTROLLER_CONTROL_PARAMS_V2 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NV_PCF_CONTROLLER_CONTROL_GROUP_V2 group;
  NV_PCF_CONTROLLER_CONTROL_V2 ctrlParams[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_CONTROLLER_CONTROL_PARAMS_V2, *PNV_PCF_CONTROLLER_CONTROL_PARAMS_V2;
typedef NV_PCF_CONTROLLER_CONTROL_PARAMS_V2 NV_PCF_CONTROLLER_CONTROL_PARAMS, *PNV_PCF_CONTROLLER_CONTROL_PARAMS;
#define NV_PCF_CONTROLLER_CONTROL_PARAMS_VER2 MAKE_NVAPI_VERSION(NV_PCF_CONTROLLER_CONTROL_PARAMS_V2, 2)
#define NV_PCF_CONTROLLER_CONTROL_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_PCF_CONTROLLER_CONTROL_PARAMS_V1, 1)
#define NV_PCF_CONTROLLER_CONTROL_PARAMS_VER NV_PCF_CONTROLLER_CONTROL_PARAMS_VER2
NVAPI_INTERFACE NvAPI_PCF_ControllerGetControl(__inout PNV_PCF_CONTROLLER_CONTROL_PARAMS pParams);
NVAPI_INTERFACE NvAPI_PCF_ControllerSetControl(__inout PNV_PCF_CONTROLLER_CONTROL_PARAMS pParams);
NVAPI_INTERFACE NvAPI_PCF_DynamicBoostGetStatus(__out NvU8 *pIsEnabled);
NVAPI_INTERFACE NvAPI_PCF_DynamicBoostSetStatus(__in NvU8 bEnable);
#define NV_PCF_SYSPWRLIMIT_TYPE_BASE (1)
typedef struct _NV_PCF_SYSPWRLIMIT_INFO_V1 {
  NV_PCF_BOARDOBJ super;
  NvU8 batteryStateOfChargePercent;
  NvU32 batteryCurrentLimitmA;
  NvU32 restOfSytemReservedPowermW;
  NvU32 minCpuTdpmW;
  NvU32 maxCpuTdpmW;
  NvU8 rsvd[256];
} NV_PCF_SYSPWRLIMIT_INFO_V1, *PNV_PCF_SYSPWRLIMIT_INFO_V1;
typedef struct _NV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS_V1 {
  NV_PCF_BOARDOBJGRP_E32 super;
  NvU32 ver;
  NvU8 rsvd[256];
  NV_PCF_SYSPWRLIMIT_INFO_V1 infos[NV_PCF_BOARDOBJGRP_E32_MAX_OBJECTS];
} NV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS_V1, *PNV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS_V1;
typedef NV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS_V1 NV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS, *PNV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS;
#define NV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS_V1, 1)
#define NV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS_VER NV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS_VER1
NVAPI_INTERFACE NvAPI_PCF_SysPwrLimitGetInfo(__inout PNV_PCF_SYSPWRLIMIT_GET_INFO_PARAMS pParams);
typedef struct _NV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS_V1 {
  NvU32 ver;
  NvBool bInterfaceAvailable;
  NvU8 capacityPercent;
  NvU32 voltagemV;
  NvU32 drainRatemW;
  NvU8 rsvd[64];
} NV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS_V1, *PNV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS_V1;
typedef NV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS_V1 NV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS,
    *PNV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS;
#define NV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS_VER1 MAKE_NVAPI_VERSION(NV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS_V1, 1)
#define NV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS_VER NV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS_VER1
NVAPI_INTERFACE NvAPI_PCF_SystemBatteryGetStatus(__inout PNV_PCF_SYSTEM_BATTERY_GET_STATUS_PARAMS pParams);
typedef struct _NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 {
  void *pCallbackParam;
  NvU8 rsvd[64];
} NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1;
typedef NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1;
typedef struct _NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 {
  NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 super;
  NvU32 callbackPeriodms;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1;
typedef struct _NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 {
  void *pCallbackParam;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1;
typedef struct _NV_GPU_CLIENT_CLOCK_DATA_V1 {
  NV_GPU_PUBLIC_CLOCK_ID clockId;
  NvU32 freqkHz;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_CLOCK_DATA_V1;
typedef struct _NV_GPU_CLIENT_CALLBACK_CLOCK_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 super;
  NvU32 numClocks;
  NvU64 timestamp;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_CLOCK_DATA_V1 clocks[NVAPI_MAX_GPU_PUBLIC_CLOCKS];
} NV_GPU_CLIENT_CALLBACK_CLOCK_DATA_V1;
typedef void(__cdecl *NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_V1)(NvPhysicalGpuHandle hPhysicalGpu,
                                                                NV_GPU_CLIENT_CALLBACK_CLOCK_DATA_V1 *pData);
typedef struct _NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_SETTINGS_V1;
#define NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_SETTINGS_VER1                                                            \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_SETTINGS_V1 NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_SETTINGS;
#define NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_SETTINGS_VER NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRegisterForClockSampleUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_CLOCK_PERIODIC_CALLBACK_SETTINGS *pCallbackSettings);
typedef struct _NV_GPU_CLIENT_VOLTAGE_DATA_V1 {
  NV_GPU_CLIENT_VOLT_DOMAIN_ID railId;
  NvU32 voltageuV;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_VOLTAGE_DATA_V1;
typedef struct _NV_GPU_CLIENT_CALLBACK_VOLTAGE_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 super;
  NvU32 numRails;
  NvU64 timestamp;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_VOLTAGE_DATA_V1 rails[NV_GPU_CLIENT_VOLT_DOMAIN_MAX_ENTRIES];
} NV_GPU_CLIENT_CALLBACK_VOLTAGE_DATA_V1;
typedef void(__cdecl *NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_V1)(NvPhysicalGpuHandle hPhysicalGpu,
                                                                  NV_GPU_CLIENT_CALLBACK_VOLTAGE_DATA_V1 *pData);
typedef struct _NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_SETTINGS_V1;
#define NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_SETTINGS_VER1                                                          \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_SETTINGS_V1 NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_SETTINGS;
#define NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_SETTINGS_VER NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRegisterForVoltageSampleUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_VOLTAGE_PERIODIC_CALLBACK_SETTINGS *pCallbackSettings);
typedef enum _NV_GPU_CLIENT_UTIL_DOMAIN_ID {
  NV_GPU_CLIENT_UTIL_DOMAIN_GRAPHICS = 0,
  NV_GPU_CLIENT_UTIL_DOMAIN_FRAME_BUFFER = 1,
  NV_GPU_CLIENT_UTIL_DOMAIN_VIDEO = 2,
  NV_GPU_CLIENT_UTIL_DOMAIN_RSVD = 3,
} NV_GPU_CLIENT_UTIL_DOMAIN_ID;
#define NV_GPU_CLIENT_UTIL_DOMAINS_MAX_V1 (4)
typedef struct _NV_GPU_CLIENT_UTILIZATION_DATA_V1 {
  NV_GPU_CLIENT_UTIL_DOMAIN_ID utilId;
  NvU32 utilizationPercent;
  NvU8 rsvd[61];
} NV_GPU_CLIENT_UTILIZATION_DATA_V1;
typedef struct _NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 super;
  NvU32 numUtils;
  NvU64 timestamp;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_UTILIZATION_DATA_V1 utils[NV_GPU_CLIENT_UTIL_DOMAINS_MAX_V1];
} NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1;
typedef void(__cdecl *NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_V1)(
    NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_CLIENT_CALLBACK_UTILIZATION_DATA_V1 *pData);
typedef struct _NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1;
#define NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_VER1                                                      \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_V1 NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS;
#define NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_VER                                                       \
  NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRegisterForUtilizationSampleUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu,
    __in NV_GPU_CLIENT_UTILIZATION_PERIODIC_CALLBACK_SETTINGS *pCallbackSettings);
typedef enum _NV_GPU_CLIENT_THERMAL_DOMAIN_ID {
  NV_GPU_CLIENT_THERMAL_DOMAIN_GPU = 0,
  NV_GPU_CLIENT_THERMAL_DOMAIN_MEMORY = 1,
  NV_GPU_CLIENT_THERMAL_DOMAIN_POWER_SUPPLY = 2,
  NV_GPU_CLIENT_THERMAL_DOMAIN_BOARD = 3,
} NV_GPU_CLIENT_THERMAL_DOMAIN_ID;
#define NV_GPU_CLIENT_THERMAL_DOMAINS_MAX_V1 (4)
typedef struct _NV_GPU_CLIENT_THERMAL_DATA_V1 {
  NV_GPU_CLIENT_THERMAL_DOMAIN_ID thermalId;
  NvS32 temperature;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_THERMAL_DATA_V1;
typedef struct _NV_GPU_CLIENT_CALLBACK_THERMAL_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 super;
  NvU32 numThermals;
  NvU64 timestamp;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_THERMAL_DATA_V1 thermals[NV_GPU_CLIENT_THERMAL_DOMAINS_MAX_V1];
} NV_GPU_CLIENT_CALLBACK_THERMAL_DATA_V1;
typedef void(__cdecl *NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_V1)(NvPhysicalGpuHandle hPhysicalGpu,
                                                                  NV_GPU_CLIENT_CALLBACK_THERMAL_DATA_V1 *pData);
typedef struct _NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_SETTINGS_V1;
#define NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_SETTINGS_VER1                                                          \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_SETTINGS_V1 NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_SETTINGS;
#define NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_SETTINGS_VER NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRegisterForThermalSampleUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_THERMAL_PERIODIC_CALLBACK_SETTINGS *pCallbackSettings);
typedef struct _NV_GPU_CLIENT_FAN_COOLER_DATA_V1 {
  NV_GPU_CLIENT_FAN_COOLERS_COOLER_ID coolerId;
  NvU32 rpm;
  NvU32 level;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_FAN_COOLER_DATA_V1;
typedef struct _NV_GPU_CLIENT_CALLBACK_FAN_COOLER_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 super;
  NvU32 numFanCoolers;
  NvU64 timestamp;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_FAN_COOLER_DATA_V1 fanCoolers[NV_GPU_CLIENT_FAN_COOLERS_NUM_COOLERS_MAX];
} NV_GPU_CLIENT_CALLBACK_FAN_COOLER_DATA_V1;
typedef void(__cdecl *NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_V1)(NvPhysicalGpuHandle hPhysicalGpu,
                                                                     NV_GPU_CLIENT_CALLBACK_FAN_COOLER_DATA_V1 *pData);
typedef struct _NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_SETTINGS_V1;
#define NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_SETTINGS_VER1                                                       \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_SETTINGS_V1 NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_SETTINGS;
#define NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_SETTINGS_VER NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRegisterForFanCoolerSampleUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_FAN_COOLER_PERIODIC_CALLBACK_SETTINGS *pCallbackSettings);
typedef struct _NV_GPU_CLIENT_PERF_POLICY_PERF_POINT_DATA_V1 {
  NV_GPU_PERF_POINT_ID perfPointId;
  NvU64 violationTimeNs;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_PERF_POLICY_PERF_POINT_DATA_V1;
typedef struct _NV_GPU_CLIENT_PERF_POLICY_DATA_V1 {
  NV_GPU_PERF_POLICY_ID_SW perfPolicyId;
  NvU32 numPerfPoints;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_PERF_POLICY_PERF_POINT_DATA_V1 perfPoints[NV_GPU_PERF_POINT_ID_NUM_V1];
} NV_GPU_CLIENT_PERF_POLICY_DATA_V1;
typedef struct _NV_GPU_CLIENT_CALLBACK_PERF_POLICY_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 super;
  NvU32 numPolicies;
  NvU64 timestamp;
  NvU32 limitingPoliciesMask;
  NV_GPU_CLIENT_PERF_POLICY_DATA_V1 global;
  NvU8 rsvd[64];
  NV_GPU_CLIENT_PERF_POLICY_DATA_V1 policies[NV_GPU_PERF_POLICY_ID_SW_NUM_V1];
} NV_GPU_CLIENT_CALLBACK_PERF_POLICY_DATA_V1;
typedef void(__cdecl *NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_V1)(
    NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_CLIENT_CALLBACK_PERF_POLICY_DATA_V1 *pData);
typedef struct _NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_SETTINGS_V1;
#define NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_SETTINGS_VER1                                                      \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_SETTINGS_V1 NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_SETTINGS;
#define NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_SETTINGS_VER                                                       \
  NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRegisterForPerfPolicySampleUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu,
    __in NV_GPU_CLIENT_PERF_POLICY_PERIODIC_CALLBACK_SETTINGS *pCallbackSettings);
typedef struct _NV_GPU_CLIENT_CALLBACK_POWER_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 super;
  NvU64 timestamp;
  NvU32 totalGpuPowermw;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_CALLBACK_POWER_DATA_V1;
typedef void(__cdecl *NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_V1)(NvPhysicalGpuHandle hPhysicalGpu,
                                                                NV_GPU_CLIENT_CALLBACK_POWER_DATA_V1 *pData);
typedef struct _NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_SETTINGS_V1;
#define NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_SETTINGS_VER1                                                            \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_SETTINGS_V1 NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_SETTINGS;
#define NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_SETTINGS_VER NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRegisterForPowerSampleUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_POWER_PERIODIC_CALLBACK_SETTINGS *pCallbackSettings);
typedef struct _NV_GPU_INTERNAL_CALLBACK_POWER_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_DATA_SUPER_V1 super;
  NvU64 timestamp;
  NvU32 totalGpuPowermw;
  NvU32 coreGpuPowermw;
  NvU8 rsvd[64];
} NV_GPU_INTERNAL_CALLBACK_POWER_DATA_V1;
typedef void(__cdecl *NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_V1)(NvPhysicalGpuHandle hPhysicalGpu,
                                                                  NV_GPU_INTERNAL_CALLBACK_POWER_DATA_V1 *pData);
typedef struct _NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_PERIODIC_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_SETTINGS_V1;
#define NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_SETTINGS_VER1                                                          \
  MAKE_NVAPI_VERSION(NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_SETTINGS_V1 NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_SETTINGS;
#define NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_SETTINGS_VER NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_InternalRegisterForPowerSampleUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_INTERNAL_POWER_PERIODIC_CALLBACK_SETTINGS *pCallbackSettings);
typedef struct _NV_GPU_CLIENT_ENABLE_BACKGROUND_OC_SCANNER_SETTINGS_V1 {
  NvU32 version;
  NvBool bEnable;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ENABLE_BACKGROUND_OC_SCANNER_SETTINGS_V1;
#define NV_GPU_CLIENT_ENABLE_BACKGROUND_OC_SCANNER_SETTINGS_VER1                                                       \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_ENABLE_BACKGROUND_OC_SCANNER_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_ENABLE_BACKGROUND_OC_SCANNER_SETTINGS_V1 NV_GPU_CLIENT_ENABLE_BACKGROUND_OC_SCANNER_SETTINGS;
#define NV_GPU_CLIENT_ENABLE_BACKGROUND_OC_SCANNER_SETTINGS_VER NV_GPU_CLIENT_ENABLE_BACKGROUND_OC_SCANNER_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientEnableBackgroundOcScanner(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_ENABLE_BACKGROUND_OC_SCANNER_SETTINGS *pSettings);
typedef struct _NV_GPU_CLIENT_ENABLE_GRD_OC_SETTINGS_V1 {
  NvU32 version;
  NvBool bEnable;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_ENABLE_GRD_OC_SETTINGS_V1;
#define NV_GPU_CLIENT_ENABLE_GRD_OC_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_ENABLE_GRD_OC_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_ENABLE_GRD_OC_SETTINGS_V1 NV_GPU_CLIENT_ENABLE_GRD_OC_SETTINGS;
#define NV_GPU_CLIENT_ENABLE_GRD_OC_SETTINGS_VER NV_GPU_CLIENT_ENABLE_GRD_OC_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientEnableGrdOc(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __in NV_GPU_CLIENT_ENABLE_GRD_OC_SETTINGS *pSettings);
typedef struct _NV_GPU_CLIENT_START_OC_SCANNER_SETTINGS_V1 {
  NvU32 version;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_START_OC_SCANNER_SETTINGS_V1;
#define NV_GPU_CLIENT_START_OC_SCANNER_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_START_OC_SCANNER_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_START_OC_SCANNER_SETTINGS_V1 NV_GPU_CLIENT_START_OC_SCANNER_SETTINGS;
#define NV_GPU_CLIENT_START_OC_SCANNER_SETTINGS_VER NV_GPU_CLIENT_START_OC_SCANNER_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientStartOcScanner(__in NvPhysicalGpuHandle hPhysicalGpu,
                                               __in NV_GPU_CLIENT_START_OC_SCANNER_SETTINGS *pSettings);
typedef struct _NV_GPU_CLIENT_STOP_OC_SCANNER_SETTINGS_V1 {
  NvU32 version;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_STOP_OC_SCANNER_SETTINGS_V1;
#define NV_GPU_CLIENT_STOP_OC_SCANNER_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_STOP_OC_SCANNER_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_STOP_OC_SCANNER_SETTINGS_V1 NV_GPU_CLIENT_STOP_OC_SCANNER_SETTINGS;
#define NV_GPU_CLIENT_STOP_OC_SCANNER_SETTINGS_VER NV_GPU_CLIENT_STOP_OC_SCANNER_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientStopOcScanner(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __in NV_GPU_CLIENT_STOP_OC_SCANNER_SETTINGS *pSettings);
typedef enum _NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_TYPE {
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_TYPE_PROGRESS_UPDATE = 0,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_TYPE_COMPLETION_EVENT = 1,
} NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_TYPE;
typedef enum _NV_GPU_CLIENT_OC_SCANNER_STATUS {
  NV_GPU_CLIENT_OC_SCANNER_STATUS_SCAN_IN_PROGRESS = 0x0001,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_NO_SCAN_IN_PROGRESS = 0x0002,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_COMPLETED_SUCCESSFULLY = 0x0004,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CANCELLED = 0x0008,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_INTERNAL_ERROR = 0x0010,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_NO_RESULTS_AVAILABLE = 0x0020,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CANCELLED_USER_REQUESTED = 0x0040,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CANCELLED_GPU_BUSY = 0x0080,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CANCELLED_USER_INPUT_DETECTED = 0x0100,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CANCELLED_POWER_SWITCH_TO_DC = 0x0200,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CANCELLED_SERVICE_SUSPENDED = 0x0400,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CANCELLED_SERVICE_STOPPED = 0x0800,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CANCELLED_BACKGROUND_SCAN_DISABLED = 0x1000,
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CANCELLED_CONFIGURATION_NOT_SUPPORTED = 0x2000,
} NV_GPU_CLIENT_OC_SCANNER_STATUS;
typedef struct _NV_GPU_CLIENT_OC_SCANNER_RESULTS {
  NV_GPU_CLIENT_OC_SCANNER_STATUS scannerStatus;
  NvU64 completionTime;
  NvU32 memoryOcOffsetMhz;
  NvU32 averageGraphicsClockOffsetMhz;
  NV_GPU_PERF_POLICY_ID_SW dominantPerfPolicy;
  NV_GPU_CLOCK_CLIENT_CLK_VF_POINTS_CONTROL_V2 offsets;
  NvBool bStable;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_OC_SCANNER_RESULTS;
typedef struct _NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_PROGRESS_UPDATE {
  NvU8 percentComplete;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_PROGRESS_UPDATE;
typedef struct _NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_COMPLETION {
  NV_GPU_CLIENT_OC_SCANNER_RESULTS scannerResults;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_COMPLETION;
typedef union _NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_UNION {
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_PROGRESS_UPDATE progressUpdate;
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_COMPLETION completion;
} NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_UNION;
typedef struct _NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_TYPE type;
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_UNION data;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_V1;
typedef void(__cdecl *NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_V1)(
    NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_DATA_V1 *pData);
typedef struct _NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_SETTINGS_V1;
#define NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_SETTINGS_VER1                                                         \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_SETTINGS_V1 NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_SETTINGS;
#define NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_SETTINGS_VER NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRegisterForOcScannerStatusUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_OC_SCANNER_STATUS_CALLBACK_SETTINGS *pCallbackSettings);
typedef struct _NV_GPU_CLIENT_GET_LAST_OC_SCANNER_RESULTS_V1 {
  NvU32 version;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_GET_LAST_OC_SCANNER_RESULTS_V1;
#define NV_GPU_CLIENT_GET_LAST_OC_SCANNER_RESULTS_VER1                                                                 \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_GET_LAST_OC_SCANNER_RESULTS_V1, 1)
typedef NV_GPU_CLIENT_GET_LAST_OC_SCANNER_RESULTS_V1 NV_GPU_CLIENT_GET_LAST_OC_SCANNER_RESULTS;
#define NV_GPU_CLIENT_GET_LAST_OC_SCANNER_RESULTS_VER NV_GPU_CLIENT_GET_LAST_OC_SCANNER_RESULTS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientGetLastOcScannerResults(__in NvPhysicalGpuHandle hPhysicalGpu,
                                                        __in NV_GPU_CLIENT_GET_LAST_OC_SCANNER_RESULTS *pResults);
typedef struct _NV_GPU_GET_LAST_INCOMPLETE_OC_SCANNER_RESULTS_V1 {
  NvU32 version;
  NvU8 rsvd[64];
} NV_GPU_GET_LAST_INCOMPLETE_OC_SCANNER_RESULTS_V1;
#define NV_GPU_GET_LAST_INCOMPLETE_OC_SCANNER_RESULTS_VER1                                                             \
  MAKE_NVAPI_VERSION(NV_GPU_GET_LAST_INCOMPLETE_OC_SCANNER_RESULTS_V1, 1)
typedef NV_GPU_GET_LAST_INCOMPLETE_OC_SCANNER_RESULTS_V1 NV_GPU_GET_LAST_INCOMPLETE_OC_SCANNER_RESULTS;
#define NV_GPU_GET_LAST_INCOMPLETE_OC_SCANNER_RESULTS_VER NV_GPU_GET_LAST_INCOMPLETE_OC_SCANNER_RESULTS_VER1
NVAPI_INTERFACE NvAPI_GPU_GetLastIncompleteOcScannerResults(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_GET_LAST_INCOMPLETE_OC_SCANNER_RESULTS *pResults);
typedef struct _NV_GPU_CLIENT_REVERT_OC_SETTINGS_V1 {
  NvU32 version;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_REVERT_OC_SETTINGS_V1;
#define NV_GPU_CLIENT_REVERT_OC_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_REVERT_OC_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_REVERT_OC_SETTINGS_V1 NV_GPU_CLIENT_REVERT_OC_SETTINGS;
#define NV_GPU_CLIENT_REVERT_OC_SETTINGS_VER NV_GPU_CLIENT_REVERT_OC_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRevertOc(__in NvPhysicalGpuHandle hPhysicalGpu,
                                         __in NV_GPU_CLIENT_REVERT_OC_SETTINGS *pSettings);
#define NV_GPU_CLIENT_GRAPHICS_OC_INVALID_VALUE 0x7FFFFFFF
#define NV_GPU_CLIENT_MEMORY_OC_INVALID_VALUE 0x7FFFFFFF
#define NV_GPU_CLIENT_VOLTAGE_LIMIT_INVALID_VALUE 0xFF
#define NV_GPU_CLIENT_THERMAL_LIMIT_INVALID_VALUE 0x7FFFFFFF
#define NV_GPU_CLIENT_POWER_LIMIT_INVALID_VALUE 0xFFFFFFFF
typedef enum _NV_GPU_CLIENT_OC_PERSISTENCE_TYPE {
  NV_GPU_CLIENT_OC_PERSISTENCE_NONE = 0,
  NV_GPU_CLIENT_OC_PERSISTENCE_MANUAL_OC = 1,
  NV_GPU_CLIENT_OC_PERSISTENCE_AUTOMATIC_OC = 2,
} NV_GPU_CLIENT_OC_PERSISTENCE_TYPE;
typedef struct _NV_GPU_CLIENT_OC_CONFIG_V1 {
  NvBool bManualOcSupported;
  NvS32 graphicsOcOffsetKhz;
  NvS32 memoryOcOffsetKhz;
  NvU8 voltageLimitPercentage;
  NvS32 thermalLimitCelcius;
  NvU32 powerLimitPercentage;
  NV_GPU_CLIENT_OC_PERSISTENCE_TYPE ocPersistanceType;
  NvBool bManualOcScannerSupported;
  NvU8 rsvd[10240];
} NV_GPU_CLIENT_OC_CONFIG_V1;
typedef struct _NV_GPU_CLIENT_GET_OC_CONFIG_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_OC_CONFIG_V1 ocConfig;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_GET_OC_CONFIG_SETTINGS_V1;
#define NV_GPU_CLIENT_GET_OC_CONFIG_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_GPU_CLIENT_GET_OC_CONFIG_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_GET_OC_CONFIG_SETTINGS_V1 NV_GPU_CLIENT_GET_OC_CONFIG_SETTINGS;
#define NV_GPU_CLIENT_GET_OC_CONFIG_SETTINGS_VER NV_GPU_CLIENT_GET_OC_CONFIG_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientGetOcConfig(__in NvPhysicalGpuHandle hPhysicalGpu,
                                            __in NV_GPU_CLIENT_GET_OC_CONFIG_SETTINGS *pSettings);
typedef struct _NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_OC_CONFIG_V1 ocConfig;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_DATA_V1;
typedef void(__cdecl *NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_V1)(
    NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_DATA_V1 *pData);
typedef struct _NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_V1;
#define NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_VER1                                                         \
  MAKE_NVAPI_VERSION(NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_V1 NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_SETTINGS;
#define NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_VER NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_ClientRegisterForOcConfigChangedUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_CLIENT_OC_CONFIG_CHANGED_CALLBACK_SETTINGS *pCallbackSettings);
typedef struct _NV_GPU_INTERNAL_OC_CONFIG_V1 {
  NV_GPU_CLIENT_OC_CONFIG_V1 clientOcConfiguration;
  NvBool bGrdOcSupported;
  NvBool bGrdOcEnabled;
  NvBool bBackgroundOcScannerSupported;
  NvBool bBackgroundOcScannerEnabled;
  NvU8 rsvd[64];
} NV_GPU_INTERNAL_OC_CONFIG_V1;
typedef struct _NV_GPU_INTERNAL_GET_OC_CONFIG_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_INTERNAL_OC_CONFIG_V1 ocConfig;
  NvU8 rsvd[64];
} NV_GPU_INTERNAL_GET_OC_CONFIG_SETTINGS_V1;
#define NV_GPU_INTERNAL_GET_OC_CONFIG_SETTINGS_VER1 MAKE_NVAPI_VERSION(NV_GPU_INTERNAL_GET_OC_CONFIG_SETTINGS_V1, 1)
typedef NV_GPU_INTERNAL_GET_OC_CONFIG_SETTINGS_V1 NV_GPU_INTERNAL_GET_OC_CONFIG_SETTINGS;
#define NV_GPU_INTERNAL_GET_OC_CONFIG_SETTINGS_VER NV_GPU_INTERNAL_GET_OC_CONFIG_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_InternalGetOcConfig(__in NvPhysicalGpuHandle hPhysicalGpu,
                                              __in NV_GPU_INTERNAL_GET_OC_CONFIG_SETTINGS *pSettings);
typedef struct _NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_DATA_V1 {
  NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_INTERNAL_OC_CONFIG_V1 ocConfig;
  NvU8 rsvd[64];
} NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_DATA_V1;
typedef void(__cdecl *NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_V1)(
    NvPhysicalGpuHandle hPhysicalGpu, NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_DATA_V1 *pData);
typedef struct _NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_GPU_CLIENT_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_V1;
#define NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_VER1                                                       \
  MAKE_NVAPI_VERSION(NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_V1, 1)
typedef NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_V1 NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_SETTINGS;
#define NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_VER NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_GPU_InternalRegisterForOcConfigChangedUpdates(
    __in NvPhysicalGpuHandle hPhysicalGpu, __in NV_GPU_INTERNAL_OC_CONFIG_CHANGED_CALLBACK_SETTINGS *pCallbackSettings);
#define NV_SYS_CLIENT_JPAC_CONTROL_SETTING_MAX_V1 32
typedef enum {
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_SPL_ENABLE = 0x0,
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_SPL_LIMIT = 0x1,
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_MIN_FPS = 0x2,
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_JPP_ENABLE = 0x3,
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_JPP_LIMIT = 0x4,
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_SPL_ENABLE_PLATFORM = 0x5,
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_JPP_MIN_FPS = 0x6,
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_DBDC_TPP_MW = 0x7,
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_BB2_TPP_MW = 0x8,
  NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID_UNKNOWN = 0xFFFFFFFF,
} NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID,
    *PNV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID;
typedef struct {
  NvU32 version;
  NvU32 numSettings;
  NvU8 rsvd[64];
  struct {
    NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID id;
    union {
      NvBool splEnable;
      NvU32 splLimit;
      NvU32 minFps;
      NvBool jppEnable;
      NvU32 jppLimit;
      NvU32 jppMinFps;
      NvU8 rsvd[32];
    } data;
  } setting[NV_SYS_CLIENT_JPAC_CONTROL_SETTING_MAX_V1];
} NV_SYS_CLIENT_JPAC_CONTROL_V1, *PNV_SYS_CLIENT_JPAC_CONTROL_V1;
#define NV_SYS_CLIENT_JPAC_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_SYS_CLIENT_JPAC_CONTROL_V1, 1)
typedef NV_SYS_CLIENT_JPAC_CONTROL_V1 NV_SYS_CLIENT_JPAC_CONTROL;
#define NV_SYS_CLIENT_JPAC_CONTROL_VER NV_SYS_CLIENT_JPAC_CONTROL_VER1
NVAPI_INTERFACE NvAPI_SYS_ClientJpacSetControl(__in NV_SYS_CLIENT_JPAC_CONTROL *pControl);
typedef struct _NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_DATA_V1 {
  NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 super;
  NvU32 numSettings;
  NvU8 rsvd[64];
  struct {
    NV_SYS_CLIENT_JPAC_CONTROL_SETTING_ID id;
    union {
      NvBool splEnable;
      NvU32 splLimit;
      NvU32 minFps;
      NvBool jppEnable;
      NvU32 jppLimit;
      NvU32 jppMinFps;
      NvBool splEnablePlatform;
      NvU32 dbdcTppmW;
      NvU32 bb2TppmW;
      NvU8 rsvd[32];
    } data;
  } setting[NV_SYS_CLIENT_JPAC_CONTROL_SETTING_MAX_V1];
} NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_DATA_V1;
typedef void(__cdecl *NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_V1)(NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_DATA_V1 *pData);
typedef struct _NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_SETTINGS_V1 {
  NvU32 version;
  NV_CLIENT_CALLBACK_SETTINGS_SUPER_V1 super;
  NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_V1 callback;
  NvBool bAllowWithoutWm2;
  NvU8 rsvd[63];
} NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_SETTINGS_V1;
#define NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_SETTINGS_VER1                                                              \
  MAKE_NVAPI_VERSION(NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_SETTINGS_V1, 1)
typedef NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_SETTINGS_V1 NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_SETTINGS;
#define NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_SETTINGS_VER NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_SETTINGS_VER1
NVAPI_INTERFACE NvAPI_SYS_ClientRegisterForJpacControlUpdates(
    __in NV_SYS_CLIENT_JPAC_CONTROL_CALLBACK_SETTINGS *pCallbackSettings);
#define NV_SYS_CLIENT_JPAC_INFO_MAX_V1 128
typedef enum {
  NV_SYS_CLIENT_JPAC_INFO_ID_WM2_VERSION = 0x0,
  NV_SYS_CLIENT_JPAC_INFO_ID_BB2_VERSION = 0x1,
  NV_SYS_CLIENT_JPAC_INFO_ID_AMPERE_REFRESH = 0x2,
  NV_SYS_CLIENT_JPAC_INFO_ID_BOPS_LEVEL = 0x3,
  NV_SYS_CLIENT_JPAC_INFO_ID_UNKNOWN = 0xFFFFFFFF,
} NV_SYS_CLIENT_JPAC_INFO_ID,
    *PNV_SYS_CLIENT_JPAC_INFO_ID;
typedef enum {
  NV_SYS_CLIENT_JPAC_BOPS_LEVEL_INVALID = 0x0,
  NV_SYS_CLIENT_JPAC_BOPS_LEVEL_LOW = 0x1,
  NV_SYS_CLIENT_JPAC_BOPS_LEVEL_HIGH = 0x2,
  NV_SYS_CLIENT_JPAC_BOPS_LEVEL_UNKNOWN = 0xFFFFFFFF,
} NV_SYS_CLIENT_JPAC_BOPS_LEVEL,
    *PNV_SYS_CLIENT_JPAC_BOPS_LEVEL;
typedef struct {
  NvU32 version;
  NvU32 numInfo;
  NvU8 rsvd[64];
  struct {
    NV_SYS_CLIENT_JPAC_INFO_ID id;
    union {
      NvU32 wm2Version;
      NvU32 bb2Version;
      NvBool bAmpereRefresh;
      NV_SYS_CLIENT_JPAC_BOPS_LEVEL bopsLevel;
      NvU8 rsvd[32];
    } data;
  } info[NV_SYS_CLIENT_JPAC_INFO_MAX_V1];
} NV_SYS_CLIENT_JPAC_INFO_V1, *PNV_SYS_CLIENT_JPAC_INFO_V1;
#define NV_SYS_CLIENT_JPAC_INFO_VER1 MAKE_NVAPI_VERSION(NV_SYS_CLIENT_JPAC_INFO_V1, 1)
typedef NV_SYS_CLIENT_JPAC_INFO_V1 NV_SYS_CLIENT_JPAC_INFO;
#define NV_SYS_CLIENT_JPAC_INFO_VER NV_SYS_CLIENT_JPAC_INFO_VER1
NVAPI_INTERFACE NvAPI_SYS_ClientJpacGetInfo(__in NV_SYS_CLIENT_JPAC_INFO *pInfo);
typedef struct _NV_GPU_CLIENT_NVTOPPS_CLIENT_DISPLAY_DATA_V1 {
  NvU64 timeStamp;
  NvAPI_ShortString edidManufacturerId;
  NvAPI_ShortString edidDisplayId;
  NvU32 displayId;
  NvU32 activeWidth;
  NvU32 activeHeight;
  NvU32 depth;
  NvU32 frequency;
  NvBool gsyncCapable;
  NvU32 edidSize;
  NvU8 edidData[NV_EDID_DATA_SIZE_MAX];
  NvU8 rsvd[32];
} NV_GPU_CLIENT_NVTOPPS_DISPLAY_DATA_V1;
typedef struct _NV_GPU_CLIENT_NVTOPPS_CONNECTOR_DATA {
  NvU64 timeStamp;
  NV_MONITOR_CONN_TYPE connectorType;
  NvBool displayAttached;
  NV_GPU_CLIENT_NVTOPPS_DISPLAY_DATA_V1 attachedDisplay;
  NvU8 rsvd[32];
} NV_GPU_CLIENT_NVTOPPS_CONNECTOR_DATA_V1;
typedef struct _NV_GPU_CLIENT_NVTOPPS_DWELL_TIME_VALUE {
  NvU64 timeStamp;
  NvAPI_ShortString valueName;
  NvU64 value;
  NvU8 rsvd[16];
} NV_GPU_CLIENT_NVTOPPS_DWELL_TIME_VALUE_V1;
#define NV_GPU_CLIENT_NVTOPPS_MAX_DWELL_TIME_VALUES 32
typedef struct _NV_GPU_CLIENT_NVTOPPS_DWELL_TIME_GROUP {
  NvAPI_ShortString measuementName;
  NvU64 start;
  NvU64 end;
  NvU32 valueCount;
  NV_GPU_CLIENT_NVTOPPS_DWELL_TIME_VALUE_V1 values[NV_GPU_CLIENT_NVTOPPS_MAX_DWELL_TIME_VALUES];
  NvU8 rsvd[32];
} NV_GPU_CLIENT_NVTOPPS_DWELL_TIME_GROUP_V1;
typedef struct _NV_GPU_CLIENT_NVTOPPS_TGP_SLIDER_V1 {
  NvU64 timeStamp;
  NvU32 defaultc;
  NvU32 selectedValue;
  NvU32 maxValue;
  NvU8 rsvd[32];
} NV_GPU_CLIENT_NVTOPPS_TGP_SLIDER_V1;
typedef struct _NV_GPU_CLIENT_NVTOPPS_OC_STATUS_V1 {
  NvU64 timeStamp;
  NvU32 speedo;
  NvU32 kappaFuse;
  NvU32 factoryOc;
  NvU32 oc;
  NvU8 rsvd[32];
} NV_GPU_CLIENT_NVTOPPS_OC_STATUS_V1;
typedef struct _NV_GPU_CLIENT_NVTOPPS_RESIDENCY_V1 {
  NvU64 timeStamp;
  NvAPI_ShortString measurementName;
  NvU32 residency;
  NvU32 idleTreshold;
  NvU32 entryLatancy;
  NvU32 exitLatancy;
  NvU8 rsvd[32];
} NV_GPU_CLIENT_NVTOPPS_RESIDENCY_V1;
#define NV_GPU_CLIENT_NVTOPPS_DWELL_TIME_MONTHLY_REPORT 0
#define NV_GPU_CLIENT_NVTOPPS_DWELL_TIME_ALL_TIME_REPORT 1
#define NV_GPU_CLIENT_NVTOPPS_MAX_DWELL_TIME_REPORTS 2
#define NV_GPU_CLIENT_NVTOPPS_MAX_RESIDENCY_REPORTS 2
typedef struct _NV_GPU_CLIENT_NVTOPPS_SCANNER_OFFSETS_DATA_V1 {
  NvS32 millivoltage;
  NvS32 offsetFrequencyKhz;
} NV_GPU_CLIENT_NVTOPPS_SCANNER_OFFSETS_DATA_V1;
#define NV_GPU_CLIENT_NVTOPPS_MAX_SCANNER_OFFSETS_COUNT 255
typedef enum {
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS_SCAN_IN_NONE = 0x000,
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS_SCAN_IN_PROGRESS = 0x001,
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS_SCAN_NOT_IN_PROGRESS = 0x002,
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS_COMPLETED_SUCCESSFULLY = 0x004,
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS_CANCELLED = 0x008,
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS_INTERNAL_ERROR = 0x010,
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS_NO_RESULTS_AVAILABLE = 0x020,
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS_UNKNOWN = 0xFFFFFFFF,
} NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS;
typedef enum {
  NV_GPU_CLIENT_NVTOPPS_SCANNER_OC_PERSISTENCE_NONE = 0,
  NV_GPU_CLIENT_NVTOPPS_SCANNER_OC_PERSISTENCE_MANUAL_OC = 1,
  NV_GPU_CLIENT_NVTOPPS_SCANNER_OC_PERSISTENCE_AUTOMATIC_OC = 2,
} NV_GPU_CLIENT_NVTOPPS_SCANNER_OC_PERSISTENCE_TYPE;
typedef struct _NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_DATA_V1 {
  NvS32 scannerResultsId;
  NvU64 timeStamp;
  NV_GPU_CLIENT_NVTOPPS_SCANNER_OC_PERSISTENCE_TYPE persistenceType;
  NvBool bStable;
  NvBool bAutoPersist;
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_STATUS completionStatus;
  NV_GPU_PERF_POLICY_ID_SW dominantLimiters;
  NvU32 averageOverlockMhz;
  NvU32 memoryOffsetMhz;
  NvU32 offsetsCount;
  NV_GPU_CLIENT_NVTOPPS_SCANNER_OFFSETS_DATA_V1 offsets[NV_GPU_CLIENT_NVTOPPS_MAX_SCANNER_OFFSETS_COUNT];
} NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_DATA_V1;
#define NV_GPU_CLIENT_NVTOPPS_MAX_ERROR_COUNT 8
typedef struct _NV_GPU_CLIENT_NVTOPPS_GPU_ERROR_DATA_V1 {
  NvS32 scannerResultsId;
  NvU64 timeStamp;
} NV_GPU_CLIENT_NVTOPPS_GPU_ERROR_DATA_V1;
typedef struct _NV_GPU_CLIENT_NVTOPPS_GPU_ERROR_LIST_V1 {
  NvU32 errorCount;
  NvU32 errorReportCount;
  NV_GPU_CLIENT_NVTOPPS_GPU_ERROR_DATA_V1 errors[NV_GPU_CLIENT_NVTOPPS_MAX_ERROR_COUNT];
} NV_GPU_CLIENT_NVTOPPS_GPU_ERROR_LIST_V1;
typedef struct _NV_GPU_CLIENT_NVTOPPS_GPU_DATA_V1 {
  NvU64 timeStamp;
  NvAPI_ShortString shortName;
  NvU32 deviceId;
  NvU32 subsystemId;
  NvU32 revision;
  NvU32 extDeviceId;
  NvAPI_ShortString projectId;
  NvAPI_ShortString partner;
  NvAPI_ShortString sessionId;
  NvBool msiActive;
  NvU32 pciGen;
  NvU32 pciLaneCnt;
  NvU32 fanCnt;
  NV_GPU_CLIENT_OC_SCANNER_RESULTS scanResults;
  NV_GPU_CLIENT_NVTOPPS_SCANNER_RESULTS_DATA_V1 lastScanResults;
  NV_GPU_CLIENT_NVTOPPS_GPU_ERROR_LIST_V1 gpuErrors;
  NvU8 rsvd[32];
} NV_GPU_CLIENT_NVTOPPS_GPU_DATA_V1;
typedef struct _NV_SYS_CLIENT_NVTOPPS_SYSTEM_DATA_V1 {
  NvU64 timeStamp;
  NvAPI_ShortString driverVersion;
  NvAPI_ShortString cpuName;
  NvAPI_ShortString mbVendor;
  NvAPI_ShortString mbModel;
  NvAPI_ShortString biosVer;
  NvAPI_ShortString biosInstallDate;
  NvU64 systemMemorySize;
  NvBool msiCapable;
  NvBool ddsCapable;
  NvU32 gpuCount;
  NV_GPU_CLIENT_NVTOPPS_GPU_DATA_V1 gpus[NVAPI_MAX_GPU_PER_TOPOLOGY];
  NvU8 rsvd[32];
} NV_SYS_CLIENT_NVTOPPS_SYSTEM_DATA_V1;
typedef struct _NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_V1 {
  NvU32 version;
  NvU32 valid;
  NV_SYS_CLIENT_NVTOPPS_SYSTEM_DATA_V1 systemData;
  NvU8 rsvd[32];
} NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_V1;
#define NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_VER1 MAKE_NVAPI_VERSION(NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_V1, 1)
typedef NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_V1 NV_SYS_CLIENT_NVTOPPS_DATA_REPORT;
#define NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_VER NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_VER1
typedef void(__cdecl *NV_GPU_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_V1)(NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_V1 *pData);
typedef struct _NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST_V1 {
  NvU32 version;
  NV_GPU_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_V1 callback;
  NvU8 rsvd[64];
} NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST_V1;
#define NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST_VER1                                                        \
  MAKE_NVAPI_VERSION(NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST_V1, 1)
typedef NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST_V1 NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST;
#define NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST_VER NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST_VER1
NVAPI_INTERFACE NvAPI_SYS_InternalGetNvToppsDataReport(
    __in NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST *pCallbackSettings);
typedef struct _NV_SYS_NOTIFY_NVTOPPS_DATA_REPORT_READY_V1 {
  NvU32 version;
  NvU8 rsvd[64];
} NV_SYS_NOTIFY_NVTOPPS_DATA_REPORT_READY_V1;
#define NV_SYS_NOTIFY_NVTOPPS_DATA_REPORT_READY_VER1                                                                   \
  MAKE_NVAPI_VERSION(NV_SYS_CLIENT_NVTOPPS_DATA_REPORT_CALLBACK_REQUEST_V1, 1)
typedef NV_SYS_NOTIFY_NVTOPPS_DATA_REPORT_READY_V1 NV_SYS_NOTIFY_NVTOPPS_DATA_REPORT_READY;
#define NV_SYS_NOTIFY_NVTOPPS_DATA_REPORT_READY_VER NV_SYS_NOTIFY_NVTOPPS_DATA_REPORT_READY_VER1
NVAPI_INTERFACE NvAPI_SYS_InternalNotifyNvToppsDataReportReady(
    NV_SYS_NOTIFY_NVTOPPS_DATA_REPORT_READY *reportReadyParams);
#define NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_SETTING_MAX_V1 32
typedef enum {
  NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_SETTING_ID_LOG_CONDITIONAL = 0x0,
  NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_SETTING_ID_UNKNOWN = 0xFFFFFFFF,
} NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_SETTING_ID,
    *PNV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_SETTING_ID;
typedef struct {
  NvU32 version;
  NvU32 numSettings;
  NvU8 rsvd[64];
  struct {
    NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_SETTING_ID id;
    union {
      NvBool bLogConditional;
      NvU8 rsvd[128];
    } data;
  } setting[NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_SETTING_MAX_V1];
} NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_V1, *PNV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_V1;
#define NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_VER1 MAKE_NVAPI_VERSION(NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_V1, 1)
typedef NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_V1 NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL;
#define NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_VER NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL_VER1
NVAPI_INTERFACE NvAPI_SYS_InternalNvtoppsGlobalSetControl(__in NV_SYS_INTERNAL_NVTOPPS_GLOBAL_CONTROL *pControl);
typedef enum _NV_SYS__MODULE {
  NV_SYS_MODULE_Cache = 1,
  NV_SYS_MODULE_Vcp,
  NV_SYS_MODULE_Host1x,
  NV_SYS_MODULE_Display,
  NV_SYS_MODULE_Ide,
  NV_SYS_MODULE_3d,
  NV_SYS_MODULE_Isp,
  NV_SYS_MODULE_Usb,
  NV_SYS_MODULE_2d,
  NV_SYS_MODULE_Vi,
  NV_SYS_MODULE_Epp,
  NV_SYS_MODULE_I2s,
  NV_SYS_MODULE_Pwm,
  NV_SYS_MODULE_Twc,
  NV_SYS_MODULE_Hsmmc,
  NV_SYS_MODULE_Sdio,
  NV_SYS_MODULE_NandFlash,
  NV_SYS_MODULE_NandSpeed,
  NV_SYS_MODULE_I2c,
  NV_SYS_MODULE_Spdif,
  NV_SYS_MODULE_Gpio,
  NV_SYS_MODULE_Uart,
  NV_SYS_MODULE_Timer,
  NV_SYS_MODULE_Rtc,
  NV_SYS_MODULE_Ac97,
  NV_SYS_MODULE_Coprocessor,
  NV_SYS_MODULE_Cpu,
  NV_SYS_MODULE_Bsev,
  NV_SYS_MODULE_Bsea,
  NV_SYS_MODULE_Vde,
  NV_SYS_MODULE_Mpe,
  NV_SYS_MODULE_Emc,
  NV_SYS_MODULE_Sprom,
  NV_SYS_MODULE_Tvdac,
  NV_SYS_MODULE_Csi,
  NV_SYS_MODULE_Hdmi,
  NV_SYS_MODULE_MipiBaseband,
  NV_SYS_MODULE_Tvo,
  NV_SYS_MODULE_Dsi,
  NV_SYS_MODULE_Dvc,
  NV_SYS_MODULE_Sbc,
  NV_SYS_MODULE_Xio,
  NV_SYS_MODULE_Spi,
  NV_SYS_MODULE_NorFlash,
  NV_SYS_MODULE_Slc,
  NV_SYS_MODULE_Fuse,
  NV_SYS_MODULE_Pmc,
  NV_SYS_MODULE_StatMon,
  NV_SYS_MODULE_Kbc,
  NV_SYS_MODULE_Vg,
  NV_SYS_MODULE_ApbDma,
  NV_SYS_MODULE_Mc,
  NV_SYS_MODULE_SpdifIn,
  NV_SYS_MODULE_Vfir,
  NV_SYS_MODULE_Cve,
  NV_SYS_MODULE_ViSensor,
  NV_SYS_MODULE_SystemReset,
  NV_SYS_MODULE_AvpUcq,
  NV_SYS_MODULE_KFuse,
  NV_SYS_MODULE_OneWire,
  NV_SYS_MODULE_SyncNor,
  NV_SYS_MODULE_Pcie,
  NV_SYS_MODULE_Mselect,
  NV_SYS_MODULE_Sata,
  NV_SYS_MODULE_SataOob,
  NV_SYS_MODULE_HDA,
  NV_SYS_MODULE_HDA2CODEC,
  NV_SYS_MODULE_Apbif,
  NV_SYS_MODULE_MSENC,
  NV_SYS_MODULE_DTV,
  NV_SYS_MODULE_Tsensor,
  NV_SYS_MODULE_Atomics,
  NV_SYS_MODULE_Actmon,
  NV_SYS_MODULE_Se,
  NV_SYS_MODULE_DAM,
  NV_SYS_MODULE_Audio,
  NV_SYS_MODULE_Num,
  NV_SYS_MODULE_UNDEFINED = 0xffffffff,
} NV_SYS_MODULE;
typedef struct {
  NvU32 version;
  NV_SYS_MODULE clkModule;
  NvU32 instance;
  NvU32 frequency;
  NvU32 reserved;
} NV_SYS_CLOCK_INFO_V1;
typedef NV_SYS_CLOCK_INFO_V1 NV_SYS_CLOCK_INFO;
#define NV_SYS_CLOCK_INFO_VER1 MAKE_NVAPI_VERSION(NV_SYS_CLOCK_INFO_V1, 1)
#define NV_SYS_CLOCK_INFO_VER NV_SYS_CLOCK_INFO_VER1
NVAPI_INTERFACE NvAPI_SYS_GetClockInfo(__out_ecount_full_opt(*numSupportedDomain) NV_SYS_CLOCK_INFO *clockInfo,
                                       __inout NvU32 *numSupportedDomain, __in NvU32 flags);
NVAPI_INTERFACE NvAPI_SYS_EnableDVFS(__in NvU8 bEnable);
NVAPI_INTERFACE NvAPI_SYS_SetLowestPowerState(__in NvU32 lowestPowerState);
NVAPI_INTERFACE NvAPI_Power_Unload();
#if (!defined(NVAPI_INTERNAL) && (((defined(WIN32) || defined(_WIN32)) && defined(_MSC_VER) && (_MSC_VER <= 1399)) ||  \
                                  defined(NVAPI_DEPRECATED_OLD)))
#pragma deprecated(                                                                                                    \
    NvAPI_SetView, NvAPI_SetViewEx, NvAPI_GetDisplayDriverVersion, NvAPI_GetDisplayDriverMemoryInfo,                   \
    NvAPI_GetDriverMemoryInfo, NvAPI_EnumAppStatistics, NvAPI_GPU_PowerCappingGetInfo,                                 \
    NvAPI_GPU_PowerCappingSlowdownGetStatus, NvAPI_GPU_PowerLeakageGetStatus, NvAPI_GPU_GetLpwrStatistics,             \
    NvAPI_GetPhysicalGPUsFromLogicalGPUInEngineOrder, NvAPI_GPU_GetRawFuseData, NvAPI_GPU_GetFoundry,                  \
    NvAPI_GPU_GetAllOutputs, NvAPI_GPU_GetConnectedOutputs, NvAPI_GPU_GetConnectedSLIOutputs,                          \
    NvAPI_GPU_GetConnectedOutputsEx, NvAPI_GPU_GetConnectedOutputsWithLidState,                                        \
    NvAPI_GPU_GetConnectedSLIOutputsWithLidState, NvAPI_GPU_GetConnectedOutputsWithLidStateEx,                         \
    NvAPI_GPU_GetConnectedSLIOutputsWithLidStateEx, NvAPI_GPU_GetAGPAperture, NvAPI_GPU_GetCurrentAGPRate,             \
    NvAPI_GPU_GetQuadroStatus, NvAPI_GPU_GetFasTelemetryInfo, NvAPI_GPU_HandleAELPG, NvAPI_GPU_QueryActiveApps,        \
    NvAPI_GPU_CudaEnumComputeCapableGpus, NvAPI_GPU_GetDeepIdleState, NvAPI_GPU_SetDeepIdleState,                      \
    NvAPI_GPU_AccessRefCount, NvAPI_GPU_GetActivationState, NvAPI_GPU_SetActivationState, NvAPI_GPU_SetPerfHybridMode, \
    NvAPI_GPU_GetPerfHybridMode, NvAPI_GPU_GetPerfPwmInfo, NvAPI_GPU_GetPstatesInfoEx, NvAPI_GetImageSharpeningInfo,   \
    NvAPI_SetImageSharpeningLevel, NvAPI_GetTVEncoderControls, NvAPI_SetTVEncoderControls, NvAPI_GetGFAHandle,         \
    NvAPI_GetTiming, NvAPI_EnumCustomDisplay, NvAPI_TryCustomDisplay, NvAPI_RevertCustomDisplayTrial,                  \
    NvAPI_DeleteCustomDisplay, NvAPI_SaveCustomDisplay, NvAPI_GetView, NvAPI_GetViewEx, NvAPI_SetViewExInternal,       \
    NvAPI_Diag_DPCD, NvAPI_Diag_DP_TestPattern, NvAPI_Diag_DP_VideoInfo, NvAPI_Diag_DP_LaneData,                       \
    NvAPI_GetHybridConnectedOutputs, NvAPI_GetHybridEDID, NvAPI_SendHybridMessage, NvAPI_SetHybridMode,                \
    NvAPI_GetHybridMode, NvAPI_GetHybridSwitchStatus, NvAPI_GetHybridInfo, NvAPI_GetHybridModesString,                 \
    NvAPI_LightWeightDGPU, NvAPI_HybridIGPUHeadsControl, NvAPI_QueryHybridIGPUHeadsControl, NvAPI_IsIntelHybrid,       \
    NvAPI_Hybrid_SetDGPUPowerState, NvAPI_Hybrid_GetDGPUPowerState, NvAPI_Hybrid_StartTransition,                      \
    NvAPI_Hybrid_StopTransition, NvAPI_Hybrid_SetDGPUDriverState, NvAPI_Hybrid_GetDGPUDriverState,                     \
    NvAPI_Hybrid_StartDisplaySwitch, NvAPI_Hybrid_StopDisplaySwitch, NvAPI_Hybrid_GetMirroredDisplays,                 \
    NvAPI_Hybrid_SwapDisplays, NvAPI_Hybrid_SetDisplayMUX, NvAPI_Hybrid_GetIntelDeviceMap,                             \
    NvAPI_Hybrid_QueryUnblockedNonMigratableApps, NvAPI_Hybrid_QueryBlockedMigratableApps,                             \
    NvAPI_Hybrid_SetAppMigrationState, NvAPI_Hybrid_IsAppMigrationStateChangeable, NvAPI_SetHybridModeEx,              \
    NvAPI_InitHybridMicroController, NvAPI_Hybrid_SetHybridModeAndDisplayConfig, NvAPI_DISP_SetHCloneTopology,         \
    NvAPI_DISP_GetHCloneTopology, NvAPI_DISP_GetHCloneDisplayCaps, NvAPI_DISP_ValidateHCloneTopology,                  \
    NvAPI_DISP_GetHCloneIGPUDisplayEdid, NvAPI_DISP_SetHyperSamplingSettings, NvAPI_DISP_GetHyperSamplingSettings,     \
    NvAPI_DISP_SetOculusZoomFactor, NvAPI_EnumVisualComputingDevices, NvAPI_VCD_GetDeviceInfo,                         \
    NvAPI_HIC_QueryTopology, NvAPI_VCD_UpdatePerformanceMode, NvAPI_VCD_GetPowerSupplyInfo,                            \
    NvAPI_VCD_GetAssociatedGSyncs, NvAPI_VCD_GetThermalInfo, NvAPI_VCD_GetCoolerSettings, NvAPI_GSync_QueryTopology,   \
    NvAPI_GSync_EnableSync, NvAPI_GSync_DisableSync, NvAPI_GSync_SetSyncState, NvAPI_GSync_UpdateSyncPolarity,         \
    NvAPI_GSync_UpdateVideoMode, NvAPI_GSync_UpdateSyncInterval, NvAPI_GSync_UpdateSyncSkew,                           \
    NvAPI_GSync_UpdateSyncStartDelay, NvAPI_GSync_UpdateSyncSource, NvAPI_GSync_QuerySyncParameters,                   \
    NvAPI_GSync_QuerySyncStatus, NvAPI_GSync_UpdateInterlaceMode, NvAPI_GSync_QueryInterlaceMode,                      \
    NvAPI_D3D9_GetOverlaySurfaceHandles, NvAPI_D3D9_CreateVideoBegin, NvAPI_D3D9_CreateVideoEnd,                       \
    NvAPI_D3D9_CreateVideo, NvAPI_D3D9_FreeVideo, NvAPI_D3D9_PresentVideo, NvAPI_D3D10_AliasPrimaryAsTexture,          \
    NvAPI_D3D10_SetPrimaryFlipChainCallbacks, NvAPI_D3D10_ProcessCallbacks, NvAPI_D3D10_GetRenderedCursorAsBitmap,     \
    NvAPI_D3D_TagFrameWithAnimationTime, NvAPI_D3D_GetSmoothAnimationTime, NvAPI_D3D_EnableSilk,                       \
    NvAPI_D3D_DisableSilk, NvAPI_D3D1x_HintCreateLowLatencyDevice, NvAPI_D3D1x_GetLowLatencySupport,                   \
    NvAPI_D3D11_InitializeSMPAssist, NvAPI_D3D11_QuerySMPAssistSupport, NvAPI_VIO_GetCapabilities, NvAPI_VIO_Open,     \
    NvAPI_VIO_Close, NvAPI_VIO_Status, NvAPI_VIO_SyncFormatDetect, NvAPI_VIO_GetConfig, NvAPI_VIO_SetConfig,           \
    NvAPI_VIO_SetCSC, NvAPI_VIO_GetCSC, NvAPI_VIO_SetGamma, NvAPI_VIO_GetGamma, NvAPI_VIO_SetSyncDelay,                \
    NvAPI_VIO_GetSyncDelay, NvAPI_VIO_GetPCIInfo, NvAPI_VIO_IsRunning, NvAPI_VIO_Start, NvAPI_VIO_Stop,                \
    NvAPI_VIO_IsFrameLockModeCompatible, NvAPI_VIO_EnumDevices, NvAPI_VIO_QueryTopology, NvAPI_VIO_EnumSignalFormats,  \
    NvAPI_VIO_EnumDataFormats, NvAPI_Video_PostProcessing_GetDefault, NvAPI_Video_PostProcessing_Get,                  \
    NvAPI_Video_PostProcessing_Set, NvAPI_Video_ColorControl_GetDefault, NvAPI_Video_ColorControl_Get,                 \
    NvAPI_Video_ColorControl_Set, NvAPI_Video_EvoOverlayLUT_Get, NvAPI_Video_EvoOverlayLUT_Set,                        \
    NvAPI_Video_PmmC_SetMode, NvAPI_Video_PmmC_GetReport, NvAPI_Video_Pmmc_SetDomainConfig,                            \
    NvAPI_Video_GetOverlayInfo, NvAPI_SecureAudio_GetSecureAudioAPIRevision, NvAPI_SecureAudio_CheckAPICompatibility,  \
    NvAPI_SecureAudio_GetCustomFormatGUID, NvAPI_SecureAudio_NegotiateDHExchange, NvAPI_SecureAudio_ComputeSessionKey, \
    NvAPI_SecureAudio_PollOOSDState, NvAPI_Diag_SetHybridDiag, NvAPI_SYS_GetSmartDimmerLevel,                          \
    NvAPI_SYS_SetSmartDimmerLevel, NvAPI_GPU_GetSmartDimmerConfig, NvAPI_GPU_SetSmartDimmerConfig,                     \
    NvAPI_SYS_Frl20AlignVblank)
#endif
#ifndef __NVAPI_EMPTY_SAL
#ifdef __nvapi_undef__ecount
#undef __ecount
#undef __nvapi_undef__ecount
#endif
#ifdef __nvapi_undef__bcount
#undef __bcount
#undef __nvapi_undef__bcount
#endif
#ifdef __nvapi_undef__in
#undef __in
#undef __nvapi_undef__in
#endif
#ifdef __nvapi_undef__in_ecount
#undef __in_ecount
#undef __nvapi_undef__in_ecount
#endif
#ifdef __nvapi_undef__in_bcount
#undef __in_bcount
#undef __nvapi_undef__in_bcount
#endif
#ifdef __nvapi_undef__in_z
#undef __in_z
#undef __nvapi_undef__in_z
#endif
#ifdef __nvapi_undef__in_ecount_z
#undef __in_ecount_z
#undef __nvapi_undef__in_ecount_z
#endif
#ifdef __nvapi_undef__in_bcount_z
#undef __in_bcount_z
#undef __nvapi_undef__in_bcount_z
#endif
#ifdef __nvapi_undef__in_nz
#undef __in_nz
#undef __nvapi_undef__in_nz
#endif
#ifdef __nvapi_undef__in_ecount_nz
#undef __in_ecount_nz
#undef __nvapi_undef__in_ecount_nz
#endif
#ifdef __nvapi_undef__in_bcount_nz
#undef __in_bcount_nz
#undef __nvapi_undef__in_bcount_nz
#endif
#ifdef __nvapi_undef__out
#undef __out
#undef __nvapi_undef__out
#endif
#ifdef __nvapi_undef__out_ecount
#undef __out_ecount
#undef __nvapi_undef__out_ecount
#endif
#ifdef __nvapi_undef__out_bcount
#undef __out_bcount
#undef __nvapi_undef__out_bcount
#endif
#ifdef __nvapi_undef__out_ecount_part
#undef __out_ecount_part
#undef __nvapi_undef__out_ecount_part
#endif
#ifdef __nvapi_undef__out_bcount_part
#undef __out_bcount_part
#undef __nvapi_undef__out_bcount_part
#endif
#ifdef __nvapi_undef__out_ecount_full
#undef __out_ecount_full
#undef __nvapi_undef__out_ecount_full
#endif
#ifdef __nvapi_undef__out_bcount_full
#undef __out_bcount_full
#undef __nvapi_undef__out_bcount_full
#endif
#ifdef __nvapi_undef__out_z
#undef __out_z
#undef __nvapi_undef__out_z
#endif
#ifdef __nvapi_undef__out_z_opt
#undef __out_z_opt
#undef __nvapi_undef__out_z_opt
#endif
#ifdef __nvapi_undef__out_ecount_z
#undef __out_ecount_z
#undef __nvapi_undef__out_ecount_z
#endif
#ifdef __nvapi_undef__out_bcount_z
#undef __out_bcount_z
#undef __nvapi_undef__out_bcount_z
#endif
#ifdef __nvapi_undef__out_ecount_part_z
#undef __out_ecount_part_z
#undef __nvapi_undef__out_ecount_part_z
#endif
#ifdef __nvapi_undef__out_bcount_part_z
#undef __out_bcount_part_z
#undef __nvapi_undef__out_bcount_part_z
#endif
#ifdef __nvapi_undef__out_ecount_full_z
#undef __out_ecount_full_z
#undef __nvapi_undef__out_ecount_full_z
#endif
#ifdef __nvapi_undef__out_bcount_full_z
#undef __out_bcount_full_z
#undef __nvapi_undef__out_bcount_full_z
#endif
#ifdef __nvapi_undef__out_nz
#undef __out_nz
#undef __nvapi_undef__out_nz
#endif
#ifdef __nvapi_undef__out_nz_opt
#undef __out_nz_opt
#undef __nvapi_undef__out_nz_opt
#endif
#ifdef __nvapi_undef__out_ecount_nz
#undef __out_ecount_nz
#undef __nvapi_undef__out_ecount_nz
#endif
#ifdef __nvapi_undef__out_bcount_nz
#undef __out_bcount_nz
#undef __nvapi_undef__out_bcount_nz
#endif
#ifdef __nvapi_undef__inout
#undef __inout
#undef __nvapi_undef__inout
#endif
#ifdef __nvapi_undef__inout_ecount
#undef __inout_ecount
#undef __nvapi_undef__inout_ecount
#endif
#ifdef __nvapi_undef__inout_bcount
#undef __inout_bcount
#undef __nvapi_undef__inout_bcount
#endif
#ifdef __nvapi_undef__inout_ecount_part
#undef __inout_ecount_part
#undef __nvapi_undef__inout_ecount_part
#endif
#ifdef __nvapi_undef__inout_bcount_part
#undef __inout_bcount_part
#undef __nvapi_undef__inout_bcount_part
#endif
#ifdef __nvapi_undef__inout_ecount_full
#undef __inout_ecount_full
#undef __nvapi_undef__inout_ecount_full
#endif
#ifdef __nvapi_undef__inout_bcount_full
#undef __inout_bcount_full
#undef __nvapi_undef__inout_bcount_full
#endif
#ifdef __nvapi_undef__inout_z
#undef __inout_z
#undef __nvapi_undef__inout_z
#endif
#ifdef __nvapi_undef__inout_ecount_z
#undef __inout_ecount_z
#undef __nvapi_undef__inout_ecount_z
#endif
#ifdef __nvapi_undef__inout_bcount_z
#undef __inout_bcount_z
#undef __nvapi_undef__inout_bcount_z
#endif
#ifdef __nvapi_undef__inout_nz
#undef __inout_nz
#undef __nvapi_undef__inout_nz
#endif
#ifdef __nvapi_undef__inout_ecount_nz
#undef __inout_ecount_nz
#undef __nvapi_undef__inout_ecount_nz
#endif
#ifdef __nvapi_undef__inout_bcount_nz
#undef __inout_bcount_nz
#undef __nvapi_undef__inout_bcount_nz
#endif
#ifdef __nvapi_undef__ecount_opt
#undef __ecount_opt
#undef __nvapi_undef__ecount_opt
#endif
#ifdef __nvapi_undef__bcount_opt
#undef __bcount_opt
#undef __nvapi_undef__bcount_opt
#endif
#ifdef __nvapi_undef__in_opt
#undef __in_opt
#undef __nvapi_undef__in_opt
#endif
#ifdef __nvapi_undef__in_ecount_opt
#undef __in_ecount_opt
#undef __nvapi_undef__in_ecount_opt
#endif
#ifdef __nvapi_undef__in_bcount_opt
#undef __in_bcount_opt
#undef __nvapi_undef__in_bcount_opt
#endif
#ifdef __nvapi_undef__in_z_opt
#undef __in_z_opt
#undef __nvapi_undef__in_z_opt
#endif
#ifdef __nvapi_undef__in_ecount_z_opt
#undef __in_ecount_z_opt
#undef __nvapi_undef__in_ecount_z_opt
#endif
#ifdef __nvapi_undef__in_bcount_z_opt
#undef __in_bcount_z_opt
#undef __nvapi_undef__in_bcount_z_opt
#endif
#ifdef __nvapi_undef__in_nz_opt
#undef __in_nz_opt
#undef __nvapi_undef__in_nz_opt
#endif
#ifdef __nvapi_undef__in_ecount_nz_opt
#undef __in_ecount_nz_opt
#undef __nvapi_undef__in_ecount_nz_opt
#endif
#ifdef __nvapi_undef__in_bcount_nz_opt
#undef __in_bcount_nz_opt
#undef __nvapi_undef__in_bcount_nz_opt
#endif
#ifdef __nvapi_undef__out_opt
#undef __out_opt
#undef __nvapi_undef__out_opt
#endif
#ifdef __nvapi_undef__out_ecount_opt
#undef __out_ecount_opt
#undef __nvapi_undef__out_ecount_opt
#endif
#ifdef __nvapi_undef__out_bcount_opt
#undef __out_bcount_opt
#undef __nvapi_undef__out_bcount_opt
#endif
#ifdef __nvapi_undef__out_ecount_part_opt
#undef __out_ecount_part_opt
#undef __nvapi_undef__out_ecount_part_opt
#endif
#ifdef __nvapi_undef__out_bcount_part_opt
#undef __out_bcount_part_opt
#undef __nvapi_undef__out_bcount_part_opt
#endif
#ifdef __nvapi_undef__out_ecount_full_opt
#undef __out_ecount_full_opt
#undef __nvapi_undef__out_ecount_full_opt
#endif
#ifdef __nvapi_undef__out_bcount_full_opt
#undef __out_bcount_full_opt
#undef __nvapi_undef__out_bcount_full_opt
#endif
#ifdef __nvapi_undef__out_ecount_z_opt
#undef __out_ecount_z_opt
#undef __nvapi_undef__out_ecount_z_opt
#endif
#ifdef __nvapi_undef__out_bcount_z_opt
#undef __out_bcount_z_opt
#undef __nvapi_undef__out_bcount_z_opt
#endif
#ifdef __nvapi_undef__out_ecount_part_z_opt
#undef __out_ecount_part_z_opt
#undef __nvapi_undef__out_ecount_part_z_opt
#endif
#ifdef __nvapi_undef__out_bcount_part_z_opt
#undef __out_bcount_part_z_opt
#undef __nvapi_undef__out_bcount_part_z_opt
#endif
#ifdef __nvapi_undef__out_ecount_full_z_opt
#undef __out_ecount_full_z_opt
#undef __nvapi_undef__out_ecount_full_z_opt
#endif
#ifdef __nvapi_undef__out_bcount_full_z_opt
#undef __out_bcount_full_z_opt
#undef __nvapi_undef__out_bcount_full_z_opt
#endif
#ifdef __nvapi_undef__out_ecount_nz_opt
#undef __out_ecount_nz_opt
#undef __nvapi_undef__out_ecount_nz_opt
#endif
#ifdef __nvapi_undef__out_bcount_nz_opt
#undef __out_bcount_nz_opt
#undef __nvapi_undef__out_bcount_nz_opt
#endif
#ifdef __nvapi_undef__inout_opt
#undef __inout_opt
#undef __nvapi_undef__inout_opt
#endif
#ifdef __nvapi_undef__inout_ecount_opt
#undef __inout_ecount_opt
#undef __nvapi_undef__inout_ecount_opt
#endif
#ifdef __nvapi_undef__inout_bcount_opt
#undef __inout_bcount_opt
#undef __nvapi_undef__inout_bcount_opt
#endif
#ifdef __nvapi_undef__inout_ecount_part_opt
#undef __inout_ecount_part_opt
#undef __nvapi_undef__inout_ecount_part_opt
#endif
#ifdef __nvapi_undef__inout_bcount_part_opt
#undef __inout_bcount_part_opt
#undef __nvapi_undef__inout_bcount_part_opt
#endif
#ifdef __nvapi_undef__inout_ecount_full_opt
#undef __inout_ecount_full_opt
#undef __nvapi_undef__inout_ecount_full_opt
#endif
#ifdef __nvapi_undef__inout_bcount_full_opt
#undef __inout_bcount_full_opt
#undef __nvapi_undef__inout_bcount_full_opt
#endif
#ifdef __nvapi_undef__inout_z_opt
#undef __inout_z_opt
#undef __nvapi_undef__inout_z_opt
#endif
#ifdef __nvapi_undef__inout_ecount_z_opt
#undef __inout_ecount_z_opt
#undef __nvapi_undef__inout_ecount_z_opt
#endif
#ifdef __nvapi_undef__inout_ecount_z_opt
#undef __inout_ecount_z_opt
#undef __nvapi_undef__inout_ecount_z_opt
#endif
#ifdef __nvapi_undef__inout_bcount_z_opt
#undef __inout_bcount_z_opt
#undef __nvapi_undef__inout_bcount_z_opt
#endif
#ifdef __nvapi_undef__inout_nz_opt
#undef __inout_nz_opt
#undef __nvapi_undef__inout_nz_opt
#endif
#ifdef __nvapi_undef__inout_ecount_nz_opt
#undef __inout_ecount_nz_opt
#undef __nvapi_undef__inout_ecount_nz_opt
#endif
#ifdef __nvapi_undef__inout_bcount_nz_opt
#undef __inout_bcount_nz_opt
#undef __nvapi_undef__inout_bcount_nz_opt
#endif
#ifdef __nvapi_undef__deref_ecount
#undef __deref_ecount
#undef __nvapi_undef__deref_ecount
#endif
#ifdef __nvapi_undef__deref_bcount
#undef __deref_bcount
#undef __nvapi_undef__deref_bcount
#endif
#ifdef __nvapi_undef__deref_out
#undef __deref_out
#undef __nvapi_undef__deref_out
#endif
#ifdef __nvapi_undef__deref_out_ecount
#undef __deref_out_ecount
#undef __nvapi_undef__deref_out_ecount
#endif
#ifdef __nvapi_undef__deref_out_bcount
#undef __deref_out_bcount
#undef __nvapi_undef__deref_out_bcount
#endif
#ifdef __nvapi_undef__deref_out_ecount_part
#undef __deref_out_ecount_part
#undef __nvapi_undef__deref_out_ecount_part
#endif
#ifdef __nvapi_undef__deref_out_bcount_part
#undef __deref_out_bcount_part
#undef __nvapi_undef__deref_out_bcount_part
#endif
#ifdef __nvapi_undef__deref_out_ecount_full
#undef __deref_out_ecount_full
#undef __nvapi_undef__deref_out_ecount_full
#endif
#ifdef __nvapi_undef__deref_out_bcount_full
#undef __deref_out_bcount_full
#undef __nvapi_undef__deref_out_bcount_full
#endif
#ifdef __nvapi_undef__deref_out_z
#undef __deref_out_z
#undef __nvapi_undef__deref_out_z
#endif
#ifdef __nvapi_undef__deref_out_ecount_z
#undef __deref_out_ecount_z
#undef __nvapi_undef__deref_out_ecount_z
#endif
#ifdef __nvapi_undef__deref_out_bcount_z
#undef __deref_out_bcount_z
#undef __nvapi_undef__deref_out_bcount_z
#endif
#ifdef __nvapi_undef__deref_out_nz
#undef __deref_out_nz
#undef __nvapi_undef__deref_out_nz
#endif
#ifdef __nvapi_undef__deref_out_ecount_nz
#undef __deref_out_ecount_nz
#undef __nvapi_undef__deref_out_ecount_nz
#endif
#ifdef __nvapi_undef__deref_out_bcount_nz
#undef __deref_out_bcount_nz
#undef __nvapi_undef__deref_out_bcount_nz
#endif
#ifdef __nvapi_undef__deref_inout
#undef __deref_inout
#undef __nvapi_undef__deref_inout
#endif
#ifdef __nvapi_undef__deref_inout_z
#undef __deref_inout_z
#undef __nvapi_undef__deref_inout_z
#endif
#ifdef __nvapi_undef__deref_inout_ecount
#undef __deref_inout_ecount
#undef __nvapi_undef__deref_inout_ecount
#endif
#ifdef __nvapi_undef__deref_inout_bcount
#undef __deref_inout_bcount
#undef __nvapi_undef__deref_inout_bcount
#endif
#ifdef __nvapi_undef__deref_inout_ecount_part
#undef __deref_inout_ecount_part
#undef __nvapi_undef__deref_inout_ecount_part
#endif
#ifdef __nvapi_undef__deref_inout_bcount_part
#undef __deref_inout_bcount_part
#undef __nvapi_undef__deref_inout_bcount_part
#endif
#ifdef __nvapi_undef__deref_inout_ecount_full
#undef __deref_inout_ecount_full
#undef __nvapi_undef__deref_inout_ecount_full
#endif
#ifdef __nvapi_undef__deref_inout_bcount_full
#undef __deref_inout_bcount_full
#undef __nvapi_undef__deref_inout_bcount_full
#endif
#ifdef __nvapi_undef__deref_inout_z
#undef __deref_inout_z
#undef __nvapi_undef__deref_inout_z
#endif
#ifdef __nvapi_undef__deref_inout_ecount_z
#undef __deref_inout_ecount_z
#undef __nvapi_undef__deref_inout_ecount_z
#endif
#ifdef __nvapi_undef__deref_inout_bcount_z
#undef __deref_inout_bcount_z
#undef __nvapi_undef__deref_inout_bcount_z
#endif
#ifdef __nvapi_undef__deref_inout_nz
#undef __deref_inout_nz
#undef __nvapi_undef__deref_inout_nz
#endif
#ifdef __nvapi_undef__deref_inout_ecount_nz
#undef __deref_inout_ecount_nz
#undef __nvapi_undef__deref_inout_ecount_nz
#endif
#ifdef __nvapi_undef__deref_inout_bcount_nz
#undef __deref_inout_bcount_nz
#undef __nvapi_undef__deref_inout_bcount_nz
#endif
#ifdef __nvapi_undef__deref_ecount_opt
#undef __deref_ecount_opt
#undef __nvapi_undef__deref_ecount_opt
#endif
#ifdef __nvapi_undef__deref_bcount_opt
#undef __deref_bcount_opt
#undef __nvapi_undef__deref_bcount_opt
#endif
#ifdef __nvapi_undef__deref_out_opt
#undef __deref_out_opt
#undef __nvapi_undef__deref_out_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_opt
#undef __deref_out_ecount_opt
#undef __nvapi_undef__deref_out_ecount_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_opt
#undef __deref_out_bcount_opt
#undef __nvapi_undef__deref_out_bcount_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_part_opt
#undef __deref_out_ecount_part_opt
#undef __nvapi_undef__deref_out_ecount_part_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_part_opt
#undef __deref_out_bcount_part_opt
#undef __nvapi_undef__deref_out_bcount_part_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_full_opt
#undef __deref_out_ecount_full_opt
#undef __nvapi_undef__deref_out_ecount_full_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_full_opt
#undef __deref_out_bcount_full_opt
#undef __nvapi_undef__deref_out_bcount_full_opt
#endif
#ifdef __nvapi_undef__deref_out_z_opt
#undef __deref_out_z_opt
#undef __nvapi_undef__deref_out_z_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_z_opt
#undef __deref_out_ecount_z_opt
#undef __nvapi_undef__deref_out_ecount_z_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_z_opt
#undef __deref_out_bcount_z_opt
#undef __nvapi_undef__deref_out_bcount_z_opt
#endif
#ifdef __nvapi_undef__deref_out_nz_opt
#undef __deref_out_nz_opt
#undef __nvapi_undef__deref_out_nz_opt
#endif
#ifdef __nvapi_undef__deref_out_ecount_nz_opt
#undef __deref_out_ecount_nz_opt
#undef __nvapi_undef__deref_out_ecount_nz_opt
#endif
#ifdef __nvapi_undef__deref_out_bcount_nz_opt
#undef __deref_out_bcount_nz_opt
#undef __nvapi_undef__deref_out_bcount_nz_opt
#endif
#ifdef __nvapi_undef__deref_inout_opt
#undef __deref_inout_opt
#undef __nvapi_undef__deref_inout_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_opt
#undef __deref_inout_ecount_opt
#undef __nvapi_undef__deref_inout_ecount_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_opt
#undef __deref_inout_bcount_opt
#undef __nvapi_undef__deref_inout_bcount_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_part_opt
#undef __deref_inout_ecount_part_opt
#undef __nvapi_undef__deref_inout_ecount_part_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_part_opt
#undef __deref_inout_bcount_part_opt
#undef __nvapi_undef__deref_inout_bcount_part_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_full_opt
#undef __deref_inout_ecount_full_opt
#undef __nvapi_undef__deref_inout_ecount_full_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_full_opt
#undef __deref_inout_bcount_full_opt
#undef __nvapi_undef__deref_inout_bcount_full_opt
#endif
#ifdef __nvapi_undef__deref_inout_z_opt
#undef __deref_inout_z_opt
#undef __nvapi_undef__deref_inout_z_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_z_opt
#undef __deref_inout_ecount_z_opt
#undef __nvapi_undef__deref_inout_ecount_z_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_z_opt
#undef __deref_inout_bcount_z_opt
#undef __nvapi_undef__deref_inout_bcount_z_opt
#endif
#ifdef __nvapi_undef__deref_inout_nz_opt
#undef __deref_inout_nz_opt
#undef __nvapi_undef__deref_inout_nz_opt
#endif
#ifdef __nvapi_undef__deref_inout_ecount_nz_opt
#undef __deref_inout_ecount_nz_opt
#undef __nvapi_undef__deref_inout_ecount_nz_opt
#endif
#ifdef __nvapi_undef__deref_inout_bcount_nz_opt
#undef __deref_inout_bcount_nz_opt
#undef __nvapi_undef__deref_inout_bcount_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_ecount
#undef __deref_opt_ecount
#undef __nvapi_undef__deref_opt_ecount
#endif
#ifdef __nvapi_undef__deref_opt_bcount
#undef __deref_opt_bcount
#undef __nvapi_undef__deref_opt_bcount
#endif
#ifdef __nvapi_undef__deref_opt_out
#undef __deref_opt_out
#undef __nvapi_undef__deref_opt_out
#endif
#ifdef __nvapi_undef__deref_opt_out_z
#undef __deref_opt_out_z
#undef __nvapi_undef__deref_opt_out_z
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount
#undef __deref_opt_out_ecount
#undef __nvapi_undef__deref_opt_out_ecount
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount
#undef __deref_opt_out_bcount
#undef __nvapi_undef__deref_opt_out_bcount
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_part
#undef __deref_opt_out_ecount_part
#undef __nvapi_undef__deref_opt_out_ecount_part
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_part
#undef __deref_opt_out_bcount_part
#undef __nvapi_undef__deref_opt_out_bcount_part
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_full
#undef __deref_opt_out_ecount_full
#undef __nvapi_undef__deref_opt_out_ecount_full
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_full
#undef __deref_opt_out_bcount_full
#undef __nvapi_undef__deref_opt_out_bcount_full
#endif
#ifdef __nvapi_undef__deref_opt_inout
#undef __deref_opt_inout
#undef __nvapi_undef__deref_opt_inout
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount
#undef __deref_opt_inout_ecount
#undef __nvapi_undef__deref_opt_inout_ecount
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount
#undef __deref_opt_inout_bcount
#undef __nvapi_undef__deref_opt_inout_bcount
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_part
#undef __deref_opt_inout_ecount_part
#undef __nvapi_undef__deref_opt_inout_ecount_part
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_part
#undef __deref_opt_inout_bcount_part
#undef __nvapi_undef__deref_opt_inout_bcount_part
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_full
#undef __deref_opt_inout_ecount_full
#undef __nvapi_undef__deref_opt_inout_ecount_full
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_full
#undef __deref_opt_inout_bcount_full
#undef __nvapi_undef__deref_opt_inout_bcount_full
#endif
#ifdef __nvapi_undef__deref_opt_inout_z
#undef __deref_opt_inout_z
#undef __nvapi_undef__deref_opt_inout_z
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_z
#undef __deref_opt_inout_ecount_z
#undef __nvapi_undef__deref_opt_inout_ecount_z
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_z
#undef __deref_opt_inout_bcount_z
#undef __nvapi_undef__deref_opt_inout_bcount_z
#endif
#ifdef __nvapi_undef__deref_opt_inout_nz
#undef __deref_opt_inout_nz
#undef __nvapi_undef__deref_opt_inout_nz
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_nz
#undef __deref_opt_inout_ecount_nz
#undef __nvapi_undef__deref_opt_inout_ecount_nz
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_nz
#undef __deref_opt_inout_bcount_nz
#undef __nvapi_undef__deref_opt_inout_bcount_nz
#endif
#ifdef __nvapi_undef__deref_opt_ecount_opt
#undef __deref_opt_ecount_opt
#undef __nvapi_undef__deref_opt_ecount_opt
#endif
#ifdef __nvapi_undef__deref_opt_bcount_opt
#undef __deref_opt_bcount_opt
#undef __nvapi_undef__deref_opt_bcount_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_opt
#undef __deref_opt_out_opt
#undef __nvapi_undef__deref_opt_out_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_opt
#undef __deref_opt_out_ecount_opt
#undef __nvapi_undef__deref_opt_out_ecount_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_opt
#undef __deref_opt_out_bcount_opt
#undef __nvapi_undef__deref_opt_out_bcount_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_part_opt
#undef __deref_opt_out_ecount_part_opt
#undef __nvapi_undef__deref_opt_out_ecount_part_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_part_opt
#undef __deref_opt_out_bcount_part_opt
#undef __nvapi_undef__deref_opt_out_bcount_part_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_full_opt
#undef __deref_opt_out_ecount_full_opt
#undef __nvapi_undef__deref_opt_out_ecount_full_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_full_opt
#undef __deref_opt_out_bcount_full_opt
#undef __nvapi_undef__deref_opt_out_bcount_full_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_z_opt
#undef __deref_opt_out_z_opt
#undef __nvapi_undef__deref_opt_out_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_z_opt
#undef __deref_opt_out_ecount_z_opt
#undef __nvapi_undef__deref_opt_out_ecount_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_z_opt
#undef __deref_opt_out_bcount_z_opt
#undef __nvapi_undef__deref_opt_out_bcount_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_nz_opt
#undef __deref_opt_out_nz_opt
#undef __nvapi_undef__deref_opt_out_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_ecount_nz_opt
#undef __deref_opt_out_ecount_nz_opt
#undef __nvapi_undef__deref_opt_out_ecount_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_out_bcount_nz_opt
#undef __deref_opt_out_bcount_nz_opt
#undef __nvapi_undef__deref_opt_out_bcount_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_opt
#undef __deref_opt_inout_opt
#undef __nvapi_undef__deref_opt_inout_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_opt
#undef __deref_opt_inout_ecount_opt
#undef __nvapi_undef__deref_opt_inout_ecount_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_opt
#undef __deref_opt_inout_bcount_opt
#undef __nvapi_undef__deref_opt_inout_bcount_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_part_opt
#undef __deref_opt_inout_ecount_part_opt
#undef __nvapi_undef__deref_opt_inout_ecount_part_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_part_opt
#undef __deref_opt_inout_bcount_part_opt
#undef __nvapi_undef__deref_opt_inout_bcount_part_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_full_opt
#undef __deref_opt_inout_ecount_full_opt
#undef __nvapi_undef__deref_opt_inout_ecount_full_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_full_opt
#undef __deref_opt_inout_bcount_full_opt
#undef __nvapi_undef__deref_opt_inout_bcount_full_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_z_opt
#undef __deref_opt_inout_z_opt
#undef __nvapi_undef__deref_opt_inout_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_z_opt
#undef __deref_opt_inout_ecount_z_opt
#undef __nvapi_undef__deref_opt_inout_ecount_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_z_opt
#undef __deref_opt_inout_bcount_z_opt
#undef __nvapi_undef__deref_opt_inout_bcount_z_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_nz_opt
#undef __deref_opt_inout_nz_opt
#undef __nvapi_undef__deref_opt_inout_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_ecount_nz_opt
#undef __deref_opt_inout_ecount_nz_opt
#undef __nvapi_undef__deref_opt_inout_ecount_nz_opt
#endif
#ifdef __nvapi_undef__deref_opt_inout_bcount_nz_opt
#undef __deref_opt_inout_bcount_nz_opt
#undef __nvapi_undef__deref_opt_inout_bcount_nz_opt
#endif
#ifdef __nvapi_success
#undef __success
#undef __nvapi_success
#endif
#ifdef __nvapi__Ret_notnull_
#undef __nvapi__Ret_notnull_
#undef _Ret_notnull_
#endif
#ifdef __nvapi__Post_writable_byte_size_
#undef __nvapi__Post_writable_byte_size_
#undef _Post_writable_byte_size_
#endif
#ifdef __nvapi_Outptr_
#undef __nvapi_Outptr_
#undef _Outptr_
#endif
#endif
#ifdef __cplusplus
};
#endif
#pragma pack(pop)
#endif
